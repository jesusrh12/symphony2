// Copyright (c) 2004-present Facebook All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
	"github.com/facebook/ent/schema/field"
	"github.com/facebookincubator/symphony/pkg/ent/block"
	"github.com/facebookincubator/symphony/pkg/ent/entrypoint"
	"github.com/facebookincubator/symphony/pkg/ent/exitpoint"
	"github.com/facebookincubator/symphony/pkg/ent/predicate"
	"github.com/facebookincubator/symphony/pkg/flowengine/flowschema"
)

// ExitPointUpdate is the builder for updating ExitPoint entities.
type ExitPointUpdate struct {
	config
	hooks    []Hook
	mutation *ExitPointMutation
}

// Where adds a new predicate for the builder.
func (epu *ExitPointUpdate) Where(ps ...predicate.ExitPoint) *ExitPointUpdate {
	epu.mutation.predicates = append(epu.mutation.predicates, ps...)
	return epu
}

// SetRole sets the role field.
func (epu *ExitPointUpdate) SetRole(fpr flowschema.ExitPointRole) *ExitPointUpdate {
	epu.mutation.SetRole(fpr)
	return epu
}

// SetCid sets the cid field.
func (epu *ExitPointUpdate) SetCid(s string) *ExitPointUpdate {
	epu.mutation.SetCid(s)
	return epu
}

// SetNillableCid sets the cid field if the given value is not nil.
func (epu *ExitPointUpdate) SetNillableCid(s *string) *ExitPointUpdate {
	if s != nil {
		epu.SetCid(*s)
	}
	return epu
}

// ClearCid clears the value of cid.
func (epu *ExitPointUpdate) ClearCid() *ExitPointUpdate {
	epu.mutation.ClearCid()
	return epu
}

// SetCondition sets the condition field.
func (epu *ExitPointUpdate) SetCondition(fe *flowschema.VariableExpression) *ExitPointUpdate {
	epu.mutation.SetCondition(fe)
	return epu
}

// ClearCondition clears the value of condition.
func (epu *ExitPointUpdate) ClearCondition() *ExitPointUpdate {
	epu.mutation.ClearCondition()
	return epu
}

// AddNextEntryPointIDs adds the next_entry_points edge to EntryPoint by ids.
func (epu *ExitPointUpdate) AddNextEntryPointIDs(ids ...int) *ExitPointUpdate {
	epu.mutation.AddNextEntryPointIDs(ids...)
	return epu
}

// AddNextEntryPoints adds the next_entry_points edges to EntryPoint.
func (epu *ExitPointUpdate) AddNextEntryPoints(e ...*EntryPoint) *ExitPointUpdate {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epu.AddNextEntryPointIDs(ids...)
}

// SetParentBlockID sets the parent_block edge to Block by id.
func (epu *ExitPointUpdate) SetParentBlockID(id int) *ExitPointUpdate {
	epu.mutation.SetParentBlockID(id)
	return epu
}

// SetParentBlock sets the parent_block edge to Block.
func (epu *ExitPointUpdate) SetParentBlock(b *Block) *ExitPointUpdate {
	return epu.SetParentBlockID(b.ID)
}

// Mutation returns the ExitPointMutation object of the builder.
func (epu *ExitPointUpdate) Mutation() *ExitPointMutation {
	return epu.mutation
}

// ClearNextEntryPoints clears all "next_entry_points" edges to type EntryPoint.
func (epu *ExitPointUpdate) ClearNextEntryPoints() *ExitPointUpdate {
	epu.mutation.ClearNextEntryPoints()
	return epu
}

// RemoveNextEntryPointIDs removes the next_entry_points edge to EntryPoint by ids.
func (epu *ExitPointUpdate) RemoveNextEntryPointIDs(ids ...int) *ExitPointUpdate {
	epu.mutation.RemoveNextEntryPointIDs(ids...)
	return epu
}

// RemoveNextEntryPoints removes next_entry_points edges to EntryPoint.
func (epu *ExitPointUpdate) RemoveNextEntryPoints(e ...*EntryPoint) *ExitPointUpdate {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epu.RemoveNextEntryPointIDs(ids...)
}

// ClearParentBlock clears the "parent_block" edge to type Block.
func (epu *ExitPointUpdate) ClearParentBlock() *ExitPointUpdate {
	epu.mutation.ClearParentBlock()
	return epu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (epu *ExitPointUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	epu.defaults()
	if len(epu.hooks) == 0 {
		if err = epu.check(); err != nil {
			return 0, err
		}
		affected, err = epu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ExitPointMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = epu.check(); err != nil {
				return 0, err
			}
			epu.mutation = mutation
			affected, err = epu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(epu.hooks) - 1; i >= 0; i-- {
			mut = epu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, epu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (epu *ExitPointUpdate) SaveX(ctx context.Context) int {
	affected, err := epu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (epu *ExitPointUpdate) Exec(ctx context.Context) error {
	_, err := epu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (epu *ExitPointUpdate) ExecX(ctx context.Context) {
	if err := epu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (epu *ExitPointUpdate) defaults() {
	if _, ok := epu.mutation.UpdateTime(); !ok {
		v := exitpoint.UpdateDefaultUpdateTime()
		epu.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (epu *ExitPointUpdate) check() error {
	if v, ok := epu.mutation.Role(); ok {
		if err := exitpoint.RoleValidator(v); err != nil {
			return &ValidationError{Name: "role", err: fmt.Errorf("ent: validator failed for field \"role\": %w", err)}
		}
	}
	if _, ok := epu.mutation.ParentBlockID(); epu.mutation.ParentBlockCleared() && !ok {
		return errors.New("ent: clearing a required unique edge \"parent_block\"")
	}
	return nil
}

func (epu *ExitPointUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   exitpoint.Table,
			Columns: exitpoint.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: exitpoint.FieldID,
			},
		},
	}
	if ps := epu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := epu.mutation.UpdateTime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: exitpoint.FieldUpdateTime,
		})
	}
	if value, ok := epu.mutation.Role(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: exitpoint.FieldRole,
		})
	}
	if value, ok := epu.mutation.Cid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: exitpoint.FieldCid,
		})
	}
	if epu.mutation.CidCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: exitpoint.FieldCid,
		})
	}
	if value, ok := epu.mutation.Condition(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  value,
			Column: exitpoint.FieldCondition,
		})
	}
	if epu.mutation.ConditionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: exitpoint.FieldCondition,
		})
	}
	if epu.mutation.NextEntryPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   exitpoint.NextEntryPointsTable,
			Columns: exitpoint.NextEntryPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: entrypoint.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epu.mutation.RemovedNextEntryPointsIDs(); len(nodes) > 0 && !epu.mutation.NextEntryPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   exitpoint.NextEntryPointsTable,
			Columns: exitpoint.NextEntryPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: entrypoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epu.mutation.NextEntryPointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   exitpoint.NextEntryPointsTable,
			Columns: exitpoint.NextEntryPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: entrypoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if epu.mutation.ParentBlockCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   exitpoint.ParentBlockTable,
			Columns: []string{exitpoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epu.mutation.ParentBlockIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   exitpoint.ParentBlockTable,
			Columns: []string{exitpoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, epu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{exitpoint.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// ExitPointUpdateOne is the builder for updating a single ExitPoint entity.
type ExitPointUpdateOne struct {
	config
	hooks    []Hook
	mutation *ExitPointMutation
}

// SetRole sets the role field.
func (epuo *ExitPointUpdateOne) SetRole(fpr flowschema.ExitPointRole) *ExitPointUpdateOne {
	epuo.mutation.SetRole(fpr)
	return epuo
}

// SetCid sets the cid field.
func (epuo *ExitPointUpdateOne) SetCid(s string) *ExitPointUpdateOne {
	epuo.mutation.SetCid(s)
	return epuo
}

// SetNillableCid sets the cid field if the given value is not nil.
func (epuo *ExitPointUpdateOne) SetNillableCid(s *string) *ExitPointUpdateOne {
	if s != nil {
		epuo.SetCid(*s)
	}
	return epuo
}

// ClearCid clears the value of cid.
func (epuo *ExitPointUpdateOne) ClearCid() *ExitPointUpdateOne {
	epuo.mutation.ClearCid()
	return epuo
}

// SetCondition sets the condition field.
func (epuo *ExitPointUpdateOne) SetCondition(fe *flowschema.VariableExpression) *ExitPointUpdateOne {
	epuo.mutation.SetCondition(fe)
	return epuo
}

// ClearCondition clears the value of condition.
func (epuo *ExitPointUpdateOne) ClearCondition() *ExitPointUpdateOne {
	epuo.mutation.ClearCondition()
	return epuo
}

// AddNextEntryPointIDs adds the next_entry_points edge to EntryPoint by ids.
func (epuo *ExitPointUpdateOne) AddNextEntryPointIDs(ids ...int) *ExitPointUpdateOne {
	epuo.mutation.AddNextEntryPointIDs(ids...)
	return epuo
}

// AddNextEntryPoints adds the next_entry_points edges to EntryPoint.
func (epuo *ExitPointUpdateOne) AddNextEntryPoints(e ...*EntryPoint) *ExitPointUpdateOne {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epuo.AddNextEntryPointIDs(ids...)
}

// SetParentBlockID sets the parent_block edge to Block by id.
func (epuo *ExitPointUpdateOne) SetParentBlockID(id int) *ExitPointUpdateOne {
	epuo.mutation.SetParentBlockID(id)
	return epuo
}

// SetParentBlock sets the parent_block edge to Block.
func (epuo *ExitPointUpdateOne) SetParentBlock(b *Block) *ExitPointUpdateOne {
	return epuo.SetParentBlockID(b.ID)
}

// Mutation returns the ExitPointMutation object of the builder.
func (epuo *ExitPointUpdateOne) Mutation() *ExitPointMutation {
	return epuo.mutation
}

// ClearNextEntryPoints clears all "next_entry_points" edges to type EntryPoint.
func (epuo *ExitPointUpdateOne) ClearNextEntryPoints() *ExitPointUpdateOne {
	epuo.mutation.ClearNextEntryPoints()
	return epuo
}

// RemoveNextEntryPointIDs removes the next_entry_points edge to EntryPoint by ids.
func (epuo *ExitPointUpdateOne) RemoveNextEntryPointIDs(ids ...int) *ExitPointUpdateOne {
	epuo.mutation.RemoveNextEntryPointIDs(ids...)
	return epuo
}

// RemoveNextEntryPoints removes next_entry_points edges to EntryPoint.
func (epuo *ExitPointUpdateOne) RemoveNextEntryPoints(e ...*EntryPoint) *ExitPointUpdateOne {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epuo.RemoveNextEntryPointIDs(ids...)
}

// ClearParentBlock clears the "parent_block" edge to type Block.
func (epuo *ExitPointUpdateOne) ClearParentBlock() *ExitPointUpdateOne {
	epuo.mutation.ClearParentBlock()
	return epuo
}

// Save executes the query and returns the updated entity.
func (epuo *ExitPointUpdateOne) Save(ctx context.Context) (*ExitPoint, error) {
	var (
		err  error
		node *ExitPoint
	)
	epuo.defaults()
	if len(epuo.hooks) == 0 {
		if err = epuo.check(); err != nil {
			return nil, err
		}
		node, err = epuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ExitPointMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = epuo.check(); err != nil {
				return nil, err
			}
			epuo.mutation = mutation
			node, err = epuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(epuo.hooks) - 1; i >= 0; i-- {
			mut = epuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, epuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (epuo *ExitPointUpdateOne) SaveX(ctx context.Context) *ExitPoint {
	node, err := epuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (epuo *ExitPointUpdateOne) Exec(ctx context.Context) error {
	_, err := epuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (epuo *ExitPointUpdateOne) ExecX(ctx context.Context) {
	if err := epuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (epuo *ExitPointUpdateOne) defaults() {
	if _, ok := epuo.mutation.UpdateTime(); !ok {
		v := exitpoint.UpdateDefaultUpdateTime()
		epuo.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (epuo *ExitPointUpdateOne) check() error {
	if v, ok := epuo.mutation.Role(); ok {
		if err := exitpoint.RoleValidator(v); err != nil {
			return &ValidationError{Name: "role", err: fmt.Errorf("ent: validator failed for field \"role\": %w", err)}
		}
	}
	if _, ok := epuo.mutation.ParentBlockID(); epuo.mutation.ParentBlockCleared() && !ok {
		return errors.New("ent: clearing a required unique edge \"parent_block\"")
	}
	return nil
}

func (epuo *ExitPointUpdateOne) sqlSave(ctx context.Context) (_node *ExitPoint, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   exitpoint.Table,
			Columns: exitpoint.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: exitpoint.FieldID,
			},
		},
	}
	id, ok := epuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing ExitPoint.ID for update")}
	}
	_spec.Node.ID.Value = id
	if value, ok := epuo.mutation.UpdateTime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: exitpoint.FieldUpdateTime,
		})
	}
	if value, ok := epuo.mutation.Role(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: exitpoint.FieldRole,
		})
	}
	if value, ok := epuo.mutation.Cid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: exitpoint.FieldCid,
		})
	}
	if epuo.mutation.CidCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: exitpoint.FieldCid,
		})
	}
	if value, ok := epuo.mutation.Condition(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  value,
			Column: exitpoint.FieldCondition,
		})
	}
	if epuo.mutation.ConditionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: exitpoint.FieldCondition,
		})
	}
	if epuo.mutation.NextEntryPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   exitpoint.NextEntryPointsTable,
			Columns: exitpoint.NextEntryPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: entrypoint.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epuo.mutation.RemovedNextEntryPointsIDs(); len(nodes) > 0 && !epuo.mutation.NextEntryPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   exitpoint.NextEntryPointsTable,
			Columns: exitpoint.NextEntryPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: entrypoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epuo.mutation.NextEntryPointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   exitpoint.NextEntryPointsTable,
			Columns: exitpoint.NextEntryPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: entrypoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if epuo.mutation.ParentBlockCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   exitpoint.ParentBlockTable,
			Columns: []string{exitpoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epuo.mutation.ParentBlockIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   exitpoint.ParentBlockTable,
			Columns: []string{exitpoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &ExitPoint{config: epuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues()
	if err = sqlgraph.UpdateNode(ctx, epuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{exitpoint.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
