// Copyright (c) 2004-present Facebook All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by entc, DO NOT EDIT.

package ent

import "context"

func (a *Activity) Author(ctx context.Context) (*User, error) {
	result, err := a.Edges.AuthorOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryAuthor().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (a *Activity) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := a.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryWorkOrder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (af *AlarmFilter) AlarmStatusFk(ctx context.Context) (*AlarmStatus, error) {
	result, err := af.Edges.AlarmStatusFkOrErr()
	if IsNotLoaded(err) {
		result, err = af.QueryAlarmStatusFk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (as *AlarmStatus) AlarmStatusFk(ctx context.Context) ([]*AlarmFilter, error) {
	result, err := as.Edges.AlarmStatusFkOrErr()
	if IsNotLoaded(err) {
		result, err = as.QueryAlarmStatusFk().All(ctx)
	}
	return result, err
}

func (a *Appointment) Workorder(ctx context.Context) (*WorkOrder, error) {
	result, err := a.Edges.WorkorderOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryWorkorder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (a *Appointment) Assignee(ctx context.Context) (*User, error) {
	result, err := a.Edges.AssigneeOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryAssignee().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Block) Flow(ctx context.Context) (*Flow, error) {
	result, err := b.Edges.FlowOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryFlow().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Block) FlowTemplate(ctx context.Context) (*FlowExecutionTemplate, error) {
	result, err := b.Edges.FlowTemplateOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryFlowTemplate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Block) FlowDraft(ctx context.Context) (*FlowDraft, error) {
	result, err := b.Edges.FlowDraftOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryFlowDraft().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Block) SubFlow(ctx context.Context) (*Flow, error) {
	result, err := b.Edges.SubFlowOrErr()
	if IsNotLoaded(err) {
		result, err = b.QuerySubFlow().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Block) SourceBlock(ctx context.Context) ([]*Block, error) {
	result, err := b.Edges.SourceBlockOrErr()
	if IsNotLoaded(err) {
		result, err = b.QuerySourceBlock().All(ctx)
	}
	return result, err
}

func (b *Block) GotoBlock(ctx context.Context) (*Block, error) {
	result, err := b.Edges.GotoBlockOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryGotoBlock().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Block) Instances(ctx context.Context) ([]*BlockInstance, error) {
	result, err := b.Edges.InstancesOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryInstances().All(ctx)
	}
	return result, err
}

func (b *Block) EntryPoint(ctx context.Context) (*EntryPoint, error) {
	result, err := b.Edges.EntryPointOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryEntryPoint().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (b *Block) ExitPoints(ctx context.Context) ([]*ExitPoint, error) {
	result, err := b.Edges.ExitPointsOrErr()
	if IsNotLoaded(err) {
		result, err = b.QueryExitPoints().All(ctx)
	}
	return result, err
}

func (bi *BlockInstance) FlowInstance(ctx context.Context) (*FlowInstance, error) {
	result, err := bi.Edges.FlowInstanceOrErr()
	if IsNotLoaded(err) {
		result, err = bi.QueryFlowInstance().Only(ctx)
	}
	return result, err
}

func (bi *BlockInstance) Block(ctx context.Context) (*Block, error) {
	result, err := bi.Edges.BlockOrErr()
	if IsNotLoaded(err) {
		result, err = bi.QueryBlock().Only(ctx)
	}
	return result, err
}

func (bi *BlockInstance) SubflowInstance(ctx context.Context) (*FlowInstance, error) {
	result, err := bi.Edges.SubflowInstanceOrErr()
	if IsNotLoaded(err) {
		result, err = bi.QuerySubflowInstance().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (clc *CheckListCategory) CheckListItems(ctx context.Context) ([]*CheckListItem, error) {
	result, err := clc.Edges.CheckListItemsOrErr()
	if IsNotLoaded(err) {
		result, err = clc.QueryCheckListItems().All(ctx)
	}
	return result, err
}

func (clc *CheckListCategory) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := clc.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = clc.QueryWorkOrder().Only(ctx)
	}
	return result, err
}

func (clcd *CheckListCategoryDefinition) CheckListItemDefinitions(ctx context.Context) ([]*CheckListItemDefinition, error) {
	result, err := clcd.Edges.CheckListItemDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = clcd.QueryCheckListItemDefinitions().All(ctx)
	}
	return result, err
}

func (clcd *CheckListCategoryDefinition) WorkOrderType(ctx context.Context) (*WorkOrderType, error) {
	result, err := clcd.Edges.WorkOrderTypeOrErr()
	if IsNotLoaded(err) {
		result, err = clcd.QueryWorkOrderType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (clcd *CheckListCategoryDefinition) WorkOrderTemplate(ctx context.Context) (*WorkOrderTemplate, error) {
	result, err := clcd.Edges.WorkOrderTemplateOrErr()
	if IsNotLoaded(err) {
		result, err = clcd.QueryWorkOrderTemplate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (cli *CheckListItem) Files(ctx context.Context) ([]*File, error) {
	result, err := cli.Edges.FilesOrErr()
	if IsNotLoaded(err) {
		result, err = cli.QueryFiles().All(ctx)
	}
	return result, err
}

func (cli *CheckListItem) WifiScan(ctx context.Context) ([]*SurveyWiFiScan, error) {
	result, err := cli.Edges.WifiScanOrErr()
	if IsNotLoaded(err) {
		result, err = cli.QueryWifiScan().All(ctx)
	}
	return result, err
}

func (cli *CheckListItem) CellScan(ctx context.Context) ([]*SurveyCellScan, error) {
	result, err := cli.Edges.CellScanOrErr()
	if IsNotLoaded(err) {
		result, err = cli.QueryCellScan().All(ctx)
	}
	return result, err
}

func (cli *CheckListItem) CheckListCategory(ctx context.Context) (*CheckListCategory, error) {
	result, err := cli.Edges.CheckListCategoryOrErr()
	if IsNotLoaded(err) {
		result, err = cli.QueryCheckListCategory().Only(ctx)
	}
	return result, err
}

func (clid *CheckListItemDefinition) CheckListCategoryDefinition(ctx context.Context) (*CheckListCategoryDefinition, error) {
	result, err := clid.Edges.CheckListCategoryDefinitionOrErr()
	if IsNotLoaded(err) {
		result, err = clid.QueryCheckListCategoryDefinition().Only(ctx)
	}
	return result, err
}

func (c *Comment) Author(ctx context.Context) (*User, error) {
	result, err := c.Edges.AuthorOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryAuthor().Only(ctx)
	}
	return result, err
}

func (c *Comment) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := c.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryWorkOrder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *Comment) Project(ctx context.Context) (*Project, error) {
	result, err := c.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryProject().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *Comparator) Comparatorrulelimit(ctx context.Context) ([]*RuleLimit, error) {
	result, err := c.Edges.ComparatorrulelimitOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryComparatorrulelimit().All(ctx)
	}
	return result, err
}

func (c *Comparator) Comparatorkqitargetfk(ctx context.Context) ([]*KqiComparator, error) {
	result, err := c.Edges.ComparatorkqitargetfkOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryComparatorkqitargetfk().All(ctx)
	}
	return result, err
}

func (c *Counter) Counterfamily(ctx context.Context) (*CounterFamily, error) {
	result, err := c.Edges.CounterfamilyOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryCounterfamily().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *Counter) Vendor(ctx context.Context) (*Vendor, error) {
	result, err := c.Edges.VendorOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryVendor().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *Counter) CounterFk(ctx context.Context) ([]*CounterFormula, error) {
	result, err := c.Edges.CounterFkOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryCounterFk().All(ctx)
	}
	return result, err
}

func (cf *CounterFamily) Counterfamily(ctx context.Context) ([]*Counter, error) {
	result, err := cf.Edges.CounterfamilyOrErr()
	if IsNotLoaded(err) {
		result, err = cf.QueryCounterfamily().All(ctx)
	}
	return result, err
}

func (cf *CounterFormula) Formula(ctx context.Context) (*Formula, error) {
	result, err := cf.Edges.FormulaOrErr()
	if IsNotLoaded(err) {
		result, err = cf.QueryFormula().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (cf *CounterFormula) Counter(ctx context.Context) (*Counter, error) {
	result, err := cf.Edges.CounterOrErr()
	if IsNotLoaded(err) {
		result, err = cf.QueryCounter().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *Customer) Services(ctx context.Context) ([]*Service, error) {
	result, err := c.Edges.ServicesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryServices().All(ctx)
	}
	return result, err
}

func (dc *DocumentCategory) LocationType(ctx context.Context) (*LocationType, error) {
	result, err := dc.Edges.LocationTypeOrErr()
	if IsNotLoaded(err) {
		result, err = dc.QueryLocationType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (dc *DocumentCategory) Files(ctx context.Context) ([]*File, error) {
	result, err := dc.Edges.FilesOrErr()
	if IsNotLoaded(err) {
		result, err = dc.QueryFiles().All(ctx)
	}
	return result, err
}

func (dc *DocumentCategory) Hyperlinks(ctx context.Context) ([]*Hyperlink, error) {
	result, err := dc.Edges.HyperlinksOrErr()
	if IsNotLoaded(err) {
		result, err = dc.QueryHyperlinks().All(ctx)
	}
	return result, err
}

func (d *Domain) Techdomain(ctx context.Context) ([]*Tech, error) {
	result, err := d.Edges.TechdomainOrErr()
	if IsNotLoaded(err) {
		result, err = d.QueryTechdomain().All(ctx)
	}
	return result, err
}

func (d *Domain) Kpidomain(ctx context.Context) ([]*Kpi, error) {
	result, err := d.Edges.KpidomainOrErr()
	if IsNotLoaded(err) {
		result, err = d.QueryKpidomain().All(ctx)
	}
	return result, err
}

func (ep *EntryPoint) PrevExitPoints(ctx context.Context) ([]*ExitPoint, error) {
	result, err := ep.Edges.PrevExitPointsOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryPrevExitPoints().All(ctx)
	}
	return result, err
}

func (ep *EntryPoint) ParentBlock(ctx context.Context) (*Block, error) {
	result, err := ep.Edges.ParentBlockOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryParentBlock().Only(ctx)
	}
	return result, err
}

func (e *Equipment) Type(ctx context.Context) (*EquipmentType, error) {
	result, err := e.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryType().Only(ctx)
	}
	return result, err
}

func (e *Equipment) Location(ctx context.Context) (*Location, error) {
	result, err := e.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (e *Equipment) ParentPosition(ctx context.Context) (*EquipmentPosition, error) {
	result, err := e.Edges.ParentPositionOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryParentPosition().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (e *Equipment) Positions(ctx context.Context) ([]*EquipmentPosition, error) {
	result, err := e.Edges.PositionsOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryPositions().All(ctx)
	}
	return result, err
}

func (e *Equipment) Ports(ctx context.Context) ([]*EquipmentPort, error) {
	result, err := e.Edges.PortsOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryPorts().All(ctx)
	}
	return result, err
}

func (e *Equipment) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := e.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryWorkOrder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (e *Equipment) Properties(ctx context.Context) ([]*Property, error) {
	result, err := e.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryProperties().All(ctx)
	}
	return result, err
}

func (e *Equipment) Files(ctx context.Context) ([]*File, error) {
	result, err := e.Edges.FilesOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryFiles().All(ctx)
	}
	return result, err
}

func (e *Equipment) Hyperlinks(ctx context.Context) ([]*Hyperlink, error) {
	result, err := e.Edges.HyperlinksOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryHyperlinks().All(ctx)
	}
	return result, err
}

func (e *Equipment) Endpoints(ctx context.Context) ([]*ServiceEndpoint, error) {
	result, err := e.Edges.EndpointsOrErr()
	if IsNotLoaded(err) {
		result, err = e.QueryEndpoints().All(ctx)
	}
	return result, err
}

func (ec *EquipmentCategory) Types(ctx context.Context) ([]*EquipmentType, error) {
	result, err := ec.Edges.TypesOrErr()
	if IsNotLoaded(err) {
		result, err = ec.QueryTypes().All(ctx)
	}
	return result, err
}

func (ep *EquipmentPort) Definition(ctx context.Context) (*EquipmentPortDefinition, error) {
	result, err := ep.Edges.DefinitionOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryDefinition().Only(ctx)
	}
	return result, err
}

func (ep *EquipmentPort) Parent(ctx context.Context) (*Equipment, error) {
	result, err := ep.Edges.ParentOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryParent().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (ep *EquipmentPort) Link(ctx context.Context) (*Link, error) {
	result, err := ep.Edges.LinkOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryLink().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (ep *EquipmentPort) Properties(ctx context.Context) ([]*Property, error) {
	result, err := ep.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryProperties().All(ctx)
	}
	return result, err
}

func (ep *EquipmentPort) Endpoints(ctx context.Context) ([]*ServiceEndpoint, error) {
	result, err := ep.Edges.EndpointsOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryEndpoints().All(ctx)
	}
	return result, err
}

func (ep *EquipmentPort) Service(ctx context.Context) ([]*Service, error) {
	result, err := ep.Edges.ServiceOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryService().All(ctx)
	}
	return result, err
}

func (epd *EquipmentPortDefinition) EquipmentPortType(ctx context.Context) (*EquipmentPortType, error) {
	result, err := epd.Edges.EquipmentPortTypeOrErr()
	if IsNotLoaded(err) {
		result, err = epd.QueryEquipmentPortType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (epd *EquipmentPortDefinition) Ports(ctx context.Context) ([]*EquipmentPort, error) {
	result, err := epd.Edges.PortsOrErr()
	if IsNotLoaded(err) {
		result, err = epd.QueryPorts().All(ctx)
	}
	return result, err
}

func (epd *EquipmentPortDefinition) EquipmentType(ctx context.Context) (*EquipmentType, error) {
	result, err := epd.Edges.EquipmentTypeOrErr()
	if IsNotLoaded(err) {
		result, err = epd.QueryEquipmentType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (epd *EquipmentPortDefinition) ConnectedPorts(ctx context.Context) ([]*EquipmentPortDefinition, error) {
	result, err := epd.Edges.ConnectedPortsOrErr()
	if IsNotLoaded(err) {
		result, err = epd.QueryConnectedPorts().All(ctx)
	}
	return result, err
}

func (ept *EquipmentPortType) PropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := ept.Edges.PropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = ept.QueryPropertyTypes().All(ctx)
	}
	return result, err
}

func (ept *EquipmentPortType) LinkPropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := ept.Edges.LinkPropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = ept.QueryLinkPropertyTypes().All(ctx)
	}
	return result, err
}

func (ept *EquipmentPortType) PortDefinitions(ctx context.Context) ([]*EquipmentPortDefinition, error) {
	result, err := ept.Edges.PortDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = ept.QueryPortDefinitions().All(ctx)
	}
	return result, err
}

func (ep *EquipmentPosition) Definition(ctx context.Context) (*EquipmentPositionDefinition, error) {
	result, err := ep.Edges.DefinitionOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryDefinition().Only(ctx)
	}
	return result, err
}

func (ep *EquipmentPosition) Parent(ctx context.Context) (*Equipment, error) {
	result, err := ep.Edges.ParentOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryParent().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (ep *EquipmentPosition) Attachment(ctx context.Context) (*Equipment, error) {
	result, err := ep.Edges.AttachmentOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryAttachment().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (epd *EquipmentPositionDefinition) Positions(ctx context.Context) ([]*EquipmentPosition, error) {
	result, err := epd.Edges.PositionsOrErr()
	if IsNotLoaded(err) {
		result, err = epd.QueryPositions().All(ctx)
	}
	return result, err
}

func (epd *EquipmentPositionDefinition) EquipmentType(ctx context.Context) (*EquipmentType, error) {
	result, err := epd.Edges.EquipmentTypeOrErr()
	if IsNotLoaded(err) {
		result, err = epd.QueryEquipmentType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (et *EquipmentType) PortDefinitions(ctx context.Context) ([]*EquipmentPortDefinition, error) {
	result, err := et.Edges.PortDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = et.QueryPortDefinitions().All(ctx)
	}
	return result, err
}

func (et *EquipmentType) PositionDefinitions(ctx context.Context) ([]*EquipmentPositionDefinition, error) {
	result, err := et.Edges.PositionDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = et.QueryPositionDefinitions().All(ctx)
	}
	return result, err
}

func (et *EquipmentType) PropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := et.Edges.PropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = et.QueryPropertyTypes().All(ctx)
	}
	return result, err
}

func (et *EquipmentType) Equipment(ctx context.Context) ([]*Equipment, error) {
	result, err := et.Edges.EquipmentOrErr()
	if IsNotLoaded(err) {
		result, err = et.QueryEquipment().All(ctx)
	}
	return result, err
}

func (et *EquipmentType) Category(ctx context.Context) (*EquipmentCategory, error) {
	result, err := et.Edges.CategoryOrErr()
	if IsNotLoaded(err) {
		result, err = et.QueryCategory().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (et *EquipmentType) ServiceEndpointDefinitions(ctx context.Context) ([]*ServiceEndpointDefinition, error) {
	result, err := et.Edges.ServiceEndpointDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = et.QueryServiceEndpointDefinitions().All(ctx)
	}
	return result, err
}

func (es *EventSeverity) Eventseverityrule(ctx context.Context) ([]*Rule, error) {
	result, err := es.Edges.EventseverityruleOrErr()
	if IsNotLoaded(err) {
		result, err = es.QueryEventseverityrule().All(ctx)
	}
	return result, err
}

func (ep *ExitPoint) NextEntryPoints(ctx context.Context) ([]*EntryPoint, error) {
	result, err := ep.Edges.NextEntryPointsOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryNextEntryPoints().All(ctx)
	}
	return result, err
}

func (ep *ExitPoint) ParentBlock(ctx context.Context) (*Block, error) {
	result, err := ep.Edges.ParentBlockOrErr()
	if IsNotLoaded(err) {
		result, err = ep.QueryParentBlock().Only(ctx)
	}
	return result, err
}

func (f *Feature) Users(ctx context.Context) ([]*User, error) {
	result, err := f.Edges.UsersOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryUsers().All(ctx)
	}
	return result, err
}

func (f *Feature) Groups(ctx context.Context) ([]*UsersGroup, error) {
	result, err := f.Edges.GroupsOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryGroups().All(ctx)
	}
	return result, err
}

func (f *File) Location(ctx context.Context) (*Location, error) {
	result, err := f.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) Equipment(ctx context.Context) (*Equipment, error) {
	result, err := f.Edges.EquipmentOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryEquipment().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) User(ctx context.Context) (*User, error) {
	result, err := f.Edges.UserOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryUser().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := f.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryWorkOrder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) ChecklistItem(ctx context.Context) (*CheckListItem, error) {
	result, err := f.Edges.ChecklistItemOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryChecklistItem().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) Survey(ctx context.Context) (*Survey, error) {
	result, err := f.Edges.SurveyOrErr()
	if IsNotLoaded(err) {
		result, err = f.QuerySurvey().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) FloorPlan(ctx context.Context) (*FloorPlan, error) {
	result, err := f.Edges.FloorPlanOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryFloorPlan().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) PhotoSurveyQuestion(ctx context.Context) (*SurveyQuestion, error) {
	result, err := f.Edges.PhotoSurveyQuestionOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryPhotoSurveyQuestion().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) SurveyQuestion(ctx context.Context) (*SurveyQuestion, error) {
	result, err := f.Edges.SurveyQuestionOrErr()
	if IsNotLoaded(err) {
		result, err = f.QuerySurveyQuestion().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *File) DocumentCategory(ctx context.Context) (*DocumentCategory, error) {
	result, err := f.Edges.DocumentCategoryOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryDocumentCategory().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (fp *FloorPlan) Location(ctx context.Context) (*Location, error) {
	result, err := fp.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = fp.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (fp *FloorPlan) ReferencePoint(ctx context.Context) (*FloorPlanReferencePoint, error) {
	result, err := fp.Edges.ReferencePointOrErr()
	if IsNotLoaded(err) {
		result, err = fp.QueryReferencePoint().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (fp *FloorPlan) Scale(ctx context.Context) (*FloorPlanScale, error) {
	result, err := fp.Edges.ScaleOrErr()
	if IsNotLoaded(err) {
		result, err = fp.QueryScale().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (fp *FloorPlan) Image(ctx context.Context) (*File, error) {
	result, err := fp.Edges.ImageOrErr()
	if IsNotLoaded(err) {
		result, err = fp.QueryImage().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *Flow) Blocks(ctx context.Context) ([]*Block, error) {
	result, err := f.Edges.BlocksOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryBlocks().All(ctx)
	}
	return result, err
}

func (f *Flow) Draft(ctx context.Context) (*FlowDraft, error) {
	result, err := f.Edges.DraftOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryDraft().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (fd *FlowDraft) Blocks(ctx context.Context) ([]*Block, error) {
	result, err := fd.Edges.BlocksOrErr()
	if IsNotLoaded(err) {
		result, err = fd.QueryBlocks().All(ctx)
	}
	return result, err
}

func (fd *FlowDraft) Flow(ctx context.Context) (*Flow, error) {
	result, err := fd.Edges.FlowOrErr()
	if IsNotLoaded(err) {
		result, err = fd.QueryFlow().Only(ctx)
	}
	return result, err
}

func (fet *FlowExecutionTemplate) Blocks(ctx context.Context) ([]*Block, error) {
	result, err := fet.Edges.BlocksOrErr()
	if IsNotLoaded(err) {
		result, err = fet.QueryBlocks().All(ctx)
	}
	return result, err
}

func (fi *FlowInstance) Flow(ctx context.Context) (*Flow, error) {
	result, err := fi.Edges.FlowOrErr()
	if IsNotLoaded(err) {
		result, err = fi.QueryFlow().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (fi *FlowInstance) Template(ctx context.Context) (*FlowExecutionTemplate, error) {
	result, err := fi.Edges.TemplateOrErr()
	if IsNotLoaded(err) {
		result, err = fi.QueryTemplate().Only(ctx)
	}
	return result, err
}

func (fi *FlowInstance) Blocks(ctx context.Context) ([]*BlockInstance, error) {
	result, err := fi.Edges.BlocksOrErr()
	if IsNotLoaded(err) {
		result, err = fi.QueryBlocks().All(ctx)
	}
	return result, err
}

func (fi *FlowInstance) ParentSubflowBlock(ctx context.Context) (*BlockInstance, error) {
	result, err := fi.Edges.ParentSubflowBlockOrErr()
	if IsNotLoaded(err) {
		result, err = fi.QueryParentSubflowBlock().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *Formula) NetworkType(ctx context.Context) (*NetworkType, error) {
	result, err := f.Edges.NetworkTypeOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryNetworkType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *Formula) Tech(ctx context.Context) (*Tech, error) {
	result, err := f.Edges.TechOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryTech().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *Formula) Kpi(ctx context.Context) (*Kpi, error) {
	result, err := f.Edges.KpiOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryKpi().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (f *Formula) Counterformula(ctx context.Context) ([]*CounterFormula, error) {
	result, err := f.Edges.CounterformulaOrErr()
	if IsNotLoaded(err) {
		result, err = f.QueryCounterformula().All(ctx)
	}
	return result, err
}

func (h *Hyperlink) Equipment(ctx context.Context) (*Equipment, error) {
	result, err := h.Edges.EquipmentOrErr()
	if IsNotLoaded(err) {
		result, err = h.QueryEquipment().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (h *Hyperlink) Location(ctx context.Context) (*Location, error) {
	result, err := h.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = h.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (h *Hyperlink) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := h.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = h.QueryWorkOrder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (h *Hyperlink) DocumentCategory(ctx context.Context) (*DocumentCategory, error) {
	result, err := h.Edges.DocumentCategoryOrErr()
	if IsNotLoaded(err) {
		result, err = h.QueryDocumentCategory().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (k *Kpi) Domain(ctx context.Context) (*Domain, error) {
	result, err := k.Edges.DomainOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryDomain().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (k *Kpi) KpiCategory(ctx context.Context) (*KpiCategory, error) {
	result, err := k.Edges.KpiCategoryOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryKpiCategory().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (k *Kpi) Formulakpi(ctx context.Context) ([]*Formula, error) {
	result, err := k.Edges.FormulakpiOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryFormulakpi().All(ctx)
	}
	return result, err
}

func (k *Kpi) Thresholdkpi(ctx context.Context) (*Threshold, error) {
	result, err := k.Edges.ThresholdkpiOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryThresholdkpi().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (kc *KpiCategory) Kpicategory(ctx context.Context) ([]*Kpi, error) {
	result, err := kc.Edges.KpicategoryOrErr()
	if IsNotLoaded(err) {
		result, err = kc.QueryKpicategory().All(ctx)
	}
	return result, err
}

func (k *Kqi) KqiCategoryFk(ctx context.Context) (*KqiCategory, error) {
	result, err := k.Edges.KqiCategoryFkOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryKqiCategoryFk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (k *Kqi) KqiPerspectiveFk(ctx context.Context) (*KqiPerspective, error) {
	result, err := k.Edges.KqiPerspectiveFkOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryKqiPerspectiveFk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (k *Kqi) KqiSourceFk(ctx context.Context) (*KqiSource, error) {
	result, err := k.Edges.KqiSourceFkOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryKqiSourceFk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (k *Kqi) KqiTemporalFrequencyFk(ctx context.Context) (*KqiTemporalFrequency, error) {
	result, err := k.Edges.KqiTemporalFrequencyFkOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryKqiTemporalFrequencyFk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (k *Kqi) KqiTargetFk(ctx context.Context) ([]*KqiTarget, error) {
	result, err := k.Edges.KqiTargetFkOrErr()
	if IsNotLoaded(err) {
		result, err = k.QueryKqiTargetFk().All(ctx)
	}
	return result, err
}

func (kc *KqiCategory) KqiCategoryFk(ctx context.Context) ([]*Kqi, error) {
	result, err := kc.Edges.KqiCategoryFkOrErr()
	if IsNotLoaded(err) {
		result, err = kc.QueryKqiCategoryFk().All(ctx)
	}
	return result, err
}

func (kc *KqiComparator) Comparatorkqitargetfk(ctx context.Context) (*Comparator, error) {
	result, err := kc.Edges.ComparatorkqitargetfkOrErr()
	if IsNotLoaded(err) {
		result, err = kc.QueryComparatorkqitargetfk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (kc *KqiComparator) Kqitargetcomparatorfk(ctx context.Context) (*KqiTarget, error) {
	result, err := kc.Edges.KqitargetcomparatorfkOrErr()
	if IsNotLoaded(err) {
		result, err = kc.QueryKqitargetcomparatorfk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (kp *KqiPerspective) KqiPerspectiveFk(ctx context.Context) ([]*Kqi, error) {
	result, err := kp.Edges.KqiPerspectiveFkOrErr()
	if IsNotLoaded(err) {
		result, err = kp.QueryKqiPerspectiveFk().All(ctx)
	}
	return result, err
}

func (ks *KqiSource) KqiSourceFk(ctx context.Context) ([]*Kqi, error) {
	result, err := ks.Edges.KqiSourceFkOrErr()
	if IsNotLoaded(err) {
		result, err = ks.QueryKqiSourceFk().All(ctx)
	}
	return result, err
}

func (kt *KqiTarget) KqiTargetFk(ctx context.Context) (*Kqi, error) {
	result, err := kt.Edges.KqiTargetFkOrErr()
	if IsNotLoaded(err) {
		result, err = kt.QueryKqiTargetFk().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (kt *KqiTarget) Kqitargetcomparatorfk(ctx context.Context) ([]*KqiComparator, error) {
	result, err := kt.Edges.KqitargetcomparatorfkOrErr()
	if IsNotLoaded(err) {
		result, err = kt.QueryKqitargetcomparatorfk().All(ctx)
	}
	return result, err
}

func (ktf *KqiTemporalFrequency) KqiTemporalFrequencyFk(ctx context.Context) ([]*Kqi, error) {
	result, err := ktf.Edges.KqiTemporalFrequencyFkOrErr()
	if IsNotLoaded(err) {
		result, err = ktf.QueryKqiTemporalFrequencyFk().All(ctx)
	}
	return result, err
}

func (l *Link) Ports(ctx context.Context) ([]*EquipmentPort, error) {
	result, err := l.Edges.PortsOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryPorts().All(ctx)
	}
	return result, err
}

func (l *Link) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := l.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryWorkOrder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (l *Link) Properties(ctx context.Context) ([]*Property, error) {
	result, err := l.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryProperties().All(ctx)
	}
	return result, err
}

func (l *Link) Service(ctx context.Context) ([]*Service, error) {
	result, err := l.Edges.ServiceOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryService().All(ctx)
	}
	return result, err
}

func (l *Location) Type(ctx context.Context) (*LocationType, error) {
	result, err := l.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryType().Only(ctx)
	}
	return result, err
}

func (l *Location) Parent(ctx context.Context) (*Location, error) {
	result, err := l.Edges.ParentOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryParent().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (l *Location) Children(ctx context.Context) ([]*Location, error) {
	result, err := l.Edges.ChildrenOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryChildren().All(ctx)
	}
	return result, err
}

func (l *Location) Files(ctx context.Context) ([]*File, error) {
	result, err := l.Edges.FilesOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryFiles().All(ctx)
	}
	return result, err
}

func (l *Location) Hyperlinks(ctx context.Context) ([]*Hyperlink, error) {
	result, err := l.Edges.HyperlinksOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryHyperlinks().All(ctx)
	}
	return result, err
}

func (l *Location) Equipment(ctx context.Context) ([]*Equipment, error) {
	result, err := l.Edges.EquipmentOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryEquipment().All(ctx)
	}
	return result, err
}

func (l *Location) Properties(ctx context.Context) ([]*Property, error) {
	result, err := l.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryProperties().All(ctx)
	}
	return result, err
}

func (l *Location) Survey(ctx context.Context) ([]*Survey, error) {
	result, err := l.Edges.SurveyOrErr()
	if IsNotLoaded(err) {
		result, err = l.QuerySurvey().All(ctx)
	}
	return result, err
}

func (l *Location) WifiScan(ctx context.Context) ([]*SurveyWiFiScan, error) {
	result, err := l.Edges.WifiScanOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryWifiScan().All(ctx)
	}
	return result, err
}

func (l *Location) CellScan(ctx context.Context) ([]*SurveyCellScan, error) {
	result, err := l.Edges.CellScanOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryCellScan().All(ctx)
	}
	return result, err
}

func (l *Location) WorkOrders(ctx context.Context) ([]*WorkOrder, error) {
	result, err := l.Edges.WorkOrdersOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryWorkOrders().All(ctx)
	}
	return result, err
}

func (l *Location) FloorPlans(ctx context.Context) ([]*FloorPlan, error) {
	result, err := l.Edges.FloorPlansOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryFloorPlans().All(ctx)
	}
	return result, err
}

func (lt *LocationType) Locations(ctx context.Context) ([]*Location, error) {
	result, err := lt.Edges.LocationsOrErr()
	if IsNotLoaded(err) {
		result, err = lt.QueryLocations().All(ctx)
	}
	return result, err
}

func (lt *LocationType) PropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := lt.Edges.PropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = lt.QueryPropertyTypes().All(ctx)
	}
	return result, err
}

func (lt *LocationType) SurveyTemplateCategories(ctx context.Context) ([]*SurveyTemplateCategory, error) {
	result, err := lt.Edges.SurveyTemplateCategoriesOrErr()
	if IsNotLoaded(err) {
		result, err = lt.QuerySurveyTemplateCategories().All(ctx)
	}
	return result, err
}

func (lt *LocationType) DocumentCategory(ctx context.Context) ([]*DocumentCategory, error) {
	result, err := lt.Edges.DocumentCategoryOrErr()
	if IsNotLoaded(err) {
		result, err = lt.QueryDocumentCategory().All(ctx)
	}
	return result, err
}

func (nt *NetworkType) FormulaNetworkTypeFK(ctx context.Context) ([]*Formula, error) {
	result, err := nt.Edges.FormulaNetworkTypeFKOrErr()
	if IsNotLoaded(err) {
		result, err = nt.QueryFormulaNetworkTypeFK().All(ctx)
	}
	return result, err
}

func (o *Organization) UserFk(ctx context.Context) ([]*User, error) {
	result, err := o.Edges.UserFkOrErr()
	if IsNotLoaded(err) {
		result, err = o.QueryUserFk().All(ctx)
	}
	return result, err
}

func (o *Organization) WorkOrderFk(ctx context.Context) ([]*WorkOrder, error) {
	result, err := o.Edges.WorkOrderFkOrErr()
	if IsNotLoaded(err) {
		result, err = o.QueryWorkOrderFk().All(ctx)
	}
	return result, err
}

func (o *Organization) Policies(ctx context.Context) ([]*PermissionsPolicy, error) {
	result, err := o.Edges.PoliciesOrErr()
	if IsNotLoaded(err) {
		result, err = o.QueryPolicies().All(ctx)
	}
	return result, err
}

func (pc *ParameterCatalog) PropertyCategories(ctx context.Context) ([]*PropertyCategory, error) {
	result, err := pc.Edges.PropertyCategoriesOrErr()
	if IsNotLoaded(err) {
		result, err = pc.QueryPropertyCategories().All(ctx)
	}
	return result, err
}

func (pp *PermissionsPolicy) Groups(ctx context.Context) ([]*UsersGroup, error) {
	result, err := pp.Edges.GroupsOrErr()
	if IsNotLoaded(err) {
		result, err = pp.QueryGroups().All(ctx)
	}
	return result, err
}

func (pp *PermissionsPolicy) Organization(ctx context.Context) ([]*Organization, error) {
	result, err := pp.Edges.OrganizationOrErr()
	if IsNotLoaded(err) {
		result, err = pp.QueryOrganization().All(ctx)
	}
	return result, err
}

func (pr *Project) Type(ctx context.Context) (*ProjectType, error) {
	result, err := pr.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryType().Only(ctx)
	}
	return result, err
}

func (pr *Project) Template(ctx context.Context) (*ProjectTemplate, error) {
	result, err := pr.Edges.TemplateOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryTemplate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Project) Location(ctx context.Context) (*Location, error) {
	result, err := pr.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Project) Comments(ctx context.Context) ([]*Comment, error) {
	result, err := pr.Edges.CommentsOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryComments().All(ctx)
	}
	return result, err
}

func (pr *Project) WorkOrders(ctx context.Context) ([]*WorkOrder, error) {
	result, err := pr.Edges.WorkOrdersOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryWorkOrders().All(ctx)
	}
	return result, err
}

func (pr *Project) Properties(ctx context.Context) ([]*Property, error) {
	result, err := pr.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryProperties().All(ctx)
	}
	return result, err
}

func (pr *Project) Creator(ctx context.Context) (*User, error) {
	result, err := pr.Edges.CreatorOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryCreator().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *ProjectTemplate) Properties(ctx context.Context) ([]*PropertyType, error) {
	result, err := pt.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryProperties().All(ctx)
	}
	return result, err
}

func (pt *ProjectTemplate) WorkOrders(ctx context.Context) ([]*WorkOrderDefinition, error) {
	result, err := pt.Edges.WorkOrdersOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryWorkOrders().All(ctx)
	}
	return result, err
}

func (pt *ProjectTemplate) Type(ctx context.Context) (*ProjectType, error) {
	result, err := pt.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *ProjectType) Properties(ctx context.Context) ([]*PropertyType, error) {
	result, err := pt.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryProperties().All(ctx)
	}
	return result, err
}

func (pt *ProjectType) WorkOrders(ctx context.Context) ([]*WorkOrderDefinition, error) {
	result, err := pt.Edges.WorkOrdersOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryWorkOrders().All(ctx)
	}
	return result, err
}

func (pt *ProjectType) Projects(ctx context.Context) ([]*Project, error) {
	result, err := pt.Edges.ProjectsOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryProjects().All(ctx)
	}
	return result, err
}

func (pr *Property) Type(ctx context.Context) (*PropertyType, error) {
	result, err := pr.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryType().Only(ctx)
	}
	return result, err
}

func (pr *Property) Location(ctx context.Context) (*Location, error) {
	result, err := pr.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) Equipment(ctx context.Context) (*Equipment, error) {
	result, err := pr.Edges.EquipmentOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryEquipment().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) Service(ctx context.Context) (*Service, error) {
	result, err := pr.Edges.ServiceOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryService().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) EquipmentPort(ctx context.Context) (*EquipmentPort, error) {
	result, err := pr.Edges.EquipmentPortOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryEquipmentPort().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) Link(ctx context.Context) (*Link, error) {
	result, err := pr.Edges.LinkOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryLink().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) WorkOrder(ctx context.Context) (*WorkOrder, error) {
	result, err := pr.Edges.WorkOrderOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryWorkOrder().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) Project(ctx context.Context) (*Project, error) {
	result, err := pr.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryProject().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) EquipmentValue(ctx context.Context) (*Equipment, error) {
	result, err := pr.Edges.EquipmentValueOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryEquipmentValue().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) LocationValue(ctx context.Context) (*Location, error) {
	result, err := pr.Edges.LocationValueOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryLocationValue().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) ServiceValue(ctx context.Context) (*Service, error) {
	result, err := pr.Edges.ServiceValueOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryServiceValue().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) WorkOrderValue(ctx context.Context) (*WorkOrder, error) {
	result, err := pr.Edges.WorkOrderValueOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryWorkOrderValue().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) UserValue(ctx context.Context) (*User, error) {
	result, err := pr.Edges.UserValueOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryUserValue().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pr *Property) ProjectValue(ctx context.Context) (*Project, error) {
	result, err := pr.Edges.ProjectValueOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryProjectValue().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pc *PropertyCategory) PropertiesType(ctx context.Context) ([]*PropertyType, error) {
	result, err := pc.Edges.PropertiesTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pc.QueryPropertiesType().All(ctx)
	}
	return result, err
}

func (pc *PropertyCategory) ParameterCatalog(ctx context.Context) (*ParameterCatalog, error) {
	result, err := pc.Edges.ParameterCatalogOrErr()
	if IsNotLoaded(err) {
		result, err = pc.QueryParameterCatalog().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) Properties(ctx context.Context) ([]*Property, error) {
	result, err := pt.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryProperties().All(ctx)
	}
	return result, err
}

func (pt *PropertyType) LocationType(ctx context.Context) (*LocationType, error) {
	result, err := pt.Edges.LocationTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryLocationType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) EquipmentPortType(ctx context.Context) (*EquipmentPortType, error) {
	result, err := pt.Edges.EquipmentPortTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryEquipmentPortType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) LinkEquipmentPortType(ctx context.Context) (*EquipmentPortType, error) {
	result, err := pt.Edges.LinkEquipmentPortTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryLinkEquipmentPortType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) EquipmentType(ctx context.Context) (*EquipmentType, error) {
	result, err := pt.Edges.EquipmentTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryEquipmentType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) ServiceType(ctx context.Context) (*ServiceType, error) {
	result, err := pt.Edges.ServiceTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryServiceType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) WorkOrderType(ctx context.Context) (*WorkOrderType, error) {
	result, err := pt.Edges.WorkOrderTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryWorkOrderType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) WorkOrderTemplate(ctx context.Context) (*WorkOrderTemplate, error) {
	result, err := pt.Edges.WorkOrderTemplateOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryWorkOrderTemplate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) ProjectType(ctx context.Context) (*ProjectType, error) {
	result, err := pt.Edges.ProjectTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryProjectType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) ProjectTemplate(ctx context.Context) (*ProjectTemplate, error) {
	result, err := pt.Edges.ProjectTemplateOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryProjectTemplate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) WorkerType(ctx context.Context) (*WorkerType, error) {
	result, err := pt.Edges.WorkerTypeOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryWorkerType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (pt *PropertyType) PropertyCategory(ctx context.Context) (*PropertyCategory, error) {
	result, err := pt.Edges.PropertyCategoryOrErr()
	if IsNotLoaded(err) {
		result, err = pt.QueryPropertyCategory().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Recommendations) RecomendationSources(ctx context.Context) (*RecommendationsSources, error) {
	result, err := r.Edges.RecomendationSourcesOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryRecomendationSources().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Recommendations) RecomendationCategory(ctx context.Context) (*RecommendationsCategory, error) {
	result, err := r.Edges.RecomendationCategoryOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryRecomendationCategory().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Recommendations) UserCreate(ctx context.Context) (*User, error) {
	result, err := r.Edges.UserCreateOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryUserCreate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Recommendations) UserApprobed(ctx context.Context) (*User, error) {
	result, err := r.Edges.UserApprobedOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryUserApprobed().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Recommendations) VendorsRecomendations(ctx context.Context) (*Vendor, error) {
	result, err := r.Edges.VendorsRecomendationsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryVendorsRecomendations().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (rc *RecommendationsCategory) Recommendations(ctx context.Context) ([]*Recommendations, error) {
	result, err := rc.Edges.RecommendationsOrErr()
	if IsNotLoaded(err) {
		result, err = rc.QueryRecommendations().All(ctx)
	}
	return result, err
}

func (rs *RecommendationsSources) Recommendations(ctx context.Context) ([]*Recommendations, error) {
	result, err := rs.Edges.RecommendationsOrErr()
	if IsNotLoaded(err) {
		result, err = rs.QueryRecommendations().All(ctx)
	}
	return result, err
}

func (r *Rule) Ruletype(ctx context.Context) (*RuleType, error) {
	result, err := r.Edges.RuletypeOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryRuletype().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Rule) Eventseverity(ctx context.Context) (*EventSeverity, error) {
	result, err := r.Edges.EventseverityOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryEventseverity().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Rule) Threshold(ctx context.Context) (*Threshold, error) {
	result, err := r.Edges.ThresholdOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryThreshold().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Rule) Rulelimitrule(ctx context.Context) ([]*RuleLimit, error) {
	result, err := r.Edges.RulelimitruleOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryRulelimitrule().All(ctx)
	}
	return result, err
}

func (rl *RuleLimit) Comparator(ctx context.Context) (*Comparator, error) {
	result, err := rl.Edges.ComparatorOrErr()
	if IsNotLoaded(err) {
		result, err = rl.QueryComparator().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (rl *RuleLimit) Rule(ctx context.Context) (*Rule, error) {
	result, err := rl.Edges.RuleOrErr()
	if IsNotLoaded(err) {
		result, err = rl.QueryRule().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (rt *RuleType) Ruletyperule(ctx context.Context) ([]*Rule, error) {
	result, err := rt.Edges.RuletyperuleOrErr()
	if IsNotLoaded(err) {
		result, err = rt.QueryRuletyperule().All(ctx)
	}
	return result, err
}

func (s *Service) Type(ctx context.Context) (*ServiceType, error) {
	result, err := s.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryType().Only(ctx)
	}
	return result, err
}

func (s *Service) Downstream(ctx context.Context) ([]*Service, error) {
	result, err := s.Edges.DownstreamOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryDownstream().All(ctx)
	}
	return result, err
}

func (s *Service) Upstream(ctx context.Context) ([]*Service, error) {
	result, err := s.Edges.UpstreamOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryUpstream().All(ctx)
	}
	return result, err
}

func (s *Service) Properties(ctx context.Context) ([]*Property, error) {
	result, err := s.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryProperties().All(ctx)
	}
	return result, err
}

func (s *Service) Links(ctx context.Context) ([]*Link, error) {
	result, err := s.Edges.LinksOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryLinks().All(ctx)
	}
	return result, err
}

func (s *Service) Ports(ctx context.Context) ([]*EquipmentPort, error) {
	result, err := s.Edges.PortsOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryPorts().All(ctx)
	}
	return result, err
}

func (s *Service) Customer(ctx context.Context) ([]*Customer, error) {
	result, err := s.Edges.CustomerOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryCustomer().All(ctx)
	}
	return result, err
}

func (s *Service) Endpoints(ctx context.Context) ([]*ServiceEndpoint, error) {
	result, err := s.Edges.EndpointsOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryEndpoints().All(ctx)
	}
	return result, err
}

func (se *ServiceEndpoint) Port(ctx context.Context) (*EquipmentPort, error) {
	result, err := se.Edges.PortOrErr()
	if IsNotLoaded(err) {
		result, err = se.QueryPort().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (se *ServiceEndpoint) Equipment(ctx context.Context) (*Equipment, error) {
	result, err := se.Edges.EquipmentOrErr()
	if IsNotLoaded(err) {
		result, err = se.QueryEquipment().Only(ctx)
	}
	return result, err
}

func (se *ServiceEndpoint) Service(ctx context.Context) (*Service, error) {
	result, err := se.Edges.ServiceOrErr()
	if IsNotLoaded(err) {
		result, err = se.QueryService().Only(ctx)
	}
	return result, err
}

func (se *ServiceEndpoint) Definition(ctx context.Context) (*ServiceEndpointDefinition, error) {
	result, err := se.Edges.DefinitionOrErr()
	if IsNotLoaded(err) {
		result, err = se.QueryDefinition().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (sed *ServiceEndpointDefinition) Endpoints(ctx context.Context) ([]*ServiceEndpoint, error) {
	result, err := sed.Edges.EndpointsOrErr()
	if IsNotLoaded(err) {
		result, err = sed.QueryEndpoints().All(ctx)
	}
	return result, err
}

func (sed *ServiceEndpointDefinition) ServiceType(ctx context.Context) (*ServiceType, error) {
	result, err := sed.Edges.ServiceTypeOrErr()
	if IsNotLoaded(err) {
		result, err = sed.QueryServiceType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (sed *ServiceEndpointDefinition) EquipmentType(ctx context.Context) (*EquipmentType, error) {
	result, err := sed.Edges.EquipmentTypeOrErr()
	if IsNotLoaded(err) {
		result, err = sed.QueryEquipmentType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (st *ServiceType) Services(ctx context.Context) ([]*Service, error) {
	result, err := st.Edges.ServicesOrErr()
	if IsNotLoaded(err) {
		result, err = st.QueryServices().All(ctx)
	}
	return result, err
}

func (st *ServiceType) PropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := st.Edges.PropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = st.QueryPropertyTypes().All(ctx)
	}
	return result, err
}

func (st *ServiceType) EndpointDefinitions(ctx context.Context) ([]*ServiceEndpointDefinition, error) {
	result, err := st.Edges.EndpointDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = st.QueryEndpointDefinitions().All(ctx)
	}
	return result, err
}

func (s *Survey) Location(ctx context.Context) (*Location, error) {
	result, err := s.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Survey) SourceFile(ctx context.Context) (*File, error) {
	result, err := s.Edges.SourceFileOrErr()
	if IsNotLoaded(err) {
		result, err = s.QuerySourceFile().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Survey) Questions(ctx context.Context) ([]*SurveyQuestion, error) {
	result, err := s.Edges.QuestionsOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryQuestions().All(ctx)
	}
	return result, err
}

func (scs *SurveyCellScan) ChecklistItem(ctx context.Context) (*CheckListItem, error) {
	result, err := scs.Edges.ChecklistItemOrErr()
	if IsNotLoaded(err) {
		result, err = scs.QueryChecklistItem().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (scs *SurveyCellScan) SurveyQuestion(ctx context.Context) (*SurveyQuestion, error) {
	result, err := scs.Edges.SurveyQuestionOrErr()
	if IsNotLoaded(err) {
		result, err = scs.QuerySurveyQuestion().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (scs *SurveyCellScan) Location(ctx context.Context) (*Location, error) {
	result, err := scs.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = scs.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (sq *SurveyQuestion) Survey(ctx context.Context) (*Survey, error) {
	result, err := sq.Edges.SurveyOrErr()
	if IsNotLoaded(err) {
		result, err = sq.QuerySurvey().Only(ctx)
	}
	return result, err
}

func (sq *SurveyQuestion) WifiScan(ctx context.Context) ([]*SurveyWiFiScan, error) {
	result, err := sq.Edges.WifiScanOrErr()
	if IsNotLoaded(err) {
		result, err = sq.QueryWifiScan().All(ctx)
	}
	return result, err
}

func (sq *SurveyQuestion) CellScan(ctx context.Context) ([]*SurveyCellScan, error) {
	result, err := sq.Edges.CellScanOrErr()
	if IsNotLoaded(err) {
		result, err = sq.QueryCellScan().All(ctx)
	}
	return result, err
}

func (sq *SurveyQuestion) PhotoData(ctx context.Context) ([]*File, error) {
	result, err := sq.Edges.PhotoDataOrErr()
	if IsNotLoaded(err) {
		result, err = sq.QueryPhotoData().All(ctx)
	}
	return result, err
}

func (sq *SurveyQuestion) Images(ctx context.Context) ([]*File, error) {
	result, err := sq.Edges.ImagesOrErr()
	if IsNotLoaded(err) {
		result, err = sq.QueryImages().All(ctx)
	}
	return result, err
}

func (stc *SurveyTemplateCategory) SurveyTemplateQuestions(ctx context.Context) ([]*SurveyTemplateQuestion, error) {
	result, err := stc.Edges.SurveyTemplateQuestionsOrErr()
	if IsNotLoaded(err) {
		result, err = stc.QuerySurveyTemplateQuestions().All(ctx)
	}
	return result, err
}

func (stc *SurveyTemplateCategory) LocationType(ctx context.Context) (*LocationType, error) {
	result, err := stc.Edges.LocationTypeOrErr()
	if IsNotLoaded(err) {
		result, err = stc.QueryLocationType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (stq *SurveyTemplateQuestion) Category(ctx context.Context) (*SurveyTemplateCategory, error) {
	result, err := stq.Edges.CategoryOrErr()
	if IsNotLoaded(err) {
		result, err = stq.QueryCategory().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (swfs *SurveyWiFiScan) ChecklistItem(ctx context.Context) (*CheckListItem, error) {
	result, err := swfs.Edges.ChecklistItemOrErr()
	if IsNotLoaded(err) {
		result, err = swfs.QueryChecklistItem().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (swfs *SurveyWiFiScan) SurveyQuestion(ctx context.Context) (*SurveyQuestion, error) {
	result, err := swfs.Edges.SurveyQuestionOrErr()
	if IsNotLoaded(err) {
		result, err = swfs.QuerySurveyQuestion().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (swfs *SurveyWiFiScan) Location(ctx context.Context) (*Location, error) {
	result, err := swfs.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = swfs.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (t *Tech) Domain(ctx context.Context) (*Domain, error) {
	result, err := t.Edges.DomainOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryDomain().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (t *Tech) Formulatech(ctx context.Context) ([]*Formula, error) {
	result, err := t.Edges.FormulatechOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryFormulatech().All(ctx)
	}
	return result, err
}

func (t *Threshold) Kpi(ctx context.Context) (*Kpi, error) {
	result, err := t.Edges.KpiOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryKpi().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (t *Threshold) Rulethreshold(ctx context.Context) ([]*Rule, error) {
	result, err := t.Edges.RulethresholdOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryRulethreshold().All(ctx)
	}
	return result, err
}

func (u *User) ProfilePhoto(ctx context.Context) (*File, error) {
	result, err := u.Edges.ProfilePhotoOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryProfilePhoto().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (u *User) UserCreate(ctx context.Context) ([]*Recommendations, error) {
	result, err := u.Edges.UserCreateOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryUserCreate().All(ctx)
	}
	return result, err
}

func (u *User) UserApproved(ctx context.Context) ([]*Recommendations, error) {
	result, err := u.Edges.UserApprovedOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryUserApproved().All(ctx)
	}
	return result, err
}

func (u *User) Groups(ctx context.Context) ([]*UsersGroup, error) {
	result, err := u.Edges.GroupsOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryGroups().All(ctx)
	}
	return result, err
}

func (u *User) Organization(ctx context.Context) (*Organization, error) {
	result, err := u.Edges.OrganizationOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryOrganization().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (u *User) OwnedWorkOrders(ctx context.Context) ([]*WorkOrder, error) {
	result, err := u.Edges.OwnedWorkOrdersOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryOwnedWorkOrders().All(ctx)
	}
	return result, err
}

func (u *User) AssignedWorkOrders(ctx context.Context) ([]*WorkOrder, error) {
	result, err := u.Edges.AssignedWorkOrdersOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryAssignedWorkOrders().All(ctx)
	}
	return result, err
}

func (u *User) CreatedProjects(ctx context.Context) ([]*Project, error) {
	result, err := u.Edges.CreatedProjectsOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryCreatedProjects().All(ctx)
	}
	return result, err
}

func (u *User) Features(ctx context.Context) ([]*Feature, error) {
	result, err := u.Edges.FeaturesOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryFeatures().All(ctx)
	}
	return result, err
}

func (u *User) Appointment(ctx context.Context) ([]*Appointment, error) {
	result, err := u.Edges.AppointmentOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryAppointment().All(ctx)
	}
	return result, err
}

func (ug *UsersGroup) Members(ctx context.Context) ([]*User, error) {
	result, err := ug.Edges.MembersOrErr()
	if IsNotLoaded(err) {
		result, err = ug.QueryMembers().All(ctx)
	}
	return result, err
}

func (ug *UsersGroup) Policies(ctx context.Context) ([]*PermissionsPolicy, error) {
	result, err := ug.Edges.PoliciesOrErr()
	if IsNotLoaded(err) {
		result, err = ug.QueryPolicies().All(ctx)
	}
	return result, err
}

func (ug *UsersGroup) Features(ctx context.Context) ([]*Feature, error) {
	result, err := ug.Edges.FeaturesOrErr()
	if IsNotLoaded(err) {
		result, err = ug.QueryFeatures().All(ctx)
	}
	return result, err
}

func (v *Vendor) VendorFk(ctx context.Context) ([]*Counter, error) {
	result, err := v.Edges.VendorFkOrErr()
	if IsNotLoaded(err) {
		result, err = v.QueryVendorFk().All(ctx)
	}
	return result, err
}

func (v *Vendor) VendorsRecomendations(ctx context.Context) ([]*Recommendations, error) {
	result, err := v.Edges.VendorsRecomendationsOrErr()
	if IsNotLoaded(err) {
		result, err = v.QueryVendorsRecomendations().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Type(ctx context.Context) (*WorkOrderType, error) {
	result, err := wo.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wo *WorkOrder) Template(ctx context.Context) (*WorkOrderTemplate, error) {
	result, err := wo.Edges.TemplateOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryTemplate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wo *WorkOrder) Equipment(ctx context.Context) ([]*Equipment, error) {
	result, err := wo.Edges.EquipmentOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryEquipment().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Links(ctx context.Context) ([]*Link, error) {
	result, err := wo.Edges.LinksOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryLinks().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Organization(ctx context.Context) (*Organization, error) {
	result, err := wo.Edges.OrganizationOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryOrganization().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wo *WorkOrder) Files(ctx context.Context) ([]*File, error) {
	result, err := wo.Edges.FilesOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryFiles().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Hyperlinks(ctx context.Context) ([]*Hyperlink, error) {
	result, err := wo.Edges.HyperlinksOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryHyperlinks().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Location(ctx context.Context) (*Location, error) {
	result, err := wo.Edges.LocationOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryLocation().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wo *WorkOrder) Comments(ctx context.Context) ([]*Comment, error) {
	result, err := wo.Edges.CommentsOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryComments().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Activities(ctx context.Context) ([]*Activity, error) {
	result, err := wo.Edges.ActivitiesOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryActivities().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Properties(ctx context.Context) ([]*Property, error) {
	result, err := wo.Edges.PropertiesOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryProperties().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) CheckListCategories(ctx context.Context) ([]*CheckListCategory, error) {
	result, err := wo.Edges.CheckListCategoriesOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryCheckListCategories().All(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Project(ctx context.Context) (*Project, error) {
	result, err := wo.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryProject().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wo *WorkOrder) Owner(ctx context.Context) (*User, error) {
	result, err := wo.Edges.OwnerOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryOwner().Only(ctx)
	}
	return result, err
}

func (wo *WorkOrder) Assignee(ctx context.Context) (*User, error) {
	result, err := wo.Edges.AssigneeOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryAssignee().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wo *WorkOrder) Appointment(ctx context.Context) ([]*Appointment, error) {
	result, err := wo.Edges.AppointmentOrErr()
	if IsNotLoaded(err) {
		result, err = wo.QueryAppointment().All(ctx)
	}
	return result, err
}

func (wod *WorkOrderDefinition) Type(ctx context.Context) (*WorkOrderType, error) {
	result, err := wod.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = wod.QueryType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wod *WorkOrderDefinition) ProjectType(ctx context.Context) (*ProjectType, error) {
	result, err := wod.Edges.ProjectTypeOrErr()
	if IsNotLoaded(err) {
		result, err = wod.QueryProjectType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wod *WorkOrderDefinition) ProjectTemplate(ctx context.Context) (*ProjectTemplate, error) {
	result, err := wod.Edges.ProjectTemplateOrErr()
	if IsNotLoaded(err) {
		result, err = wod.QueryProjectTemplate().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wot *WorkOrderTemplate) PropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := wot.Edges.PropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = wot.QueryPropertyTypes().All(ctx)
	}
	return result, err
}

func (wot *WorkOrderTemplate) CheckListCategoryDefinitions(ctx context.Context) ([]*CheckListCategoryDefinition, error) {
	result, err := wot.Edges.CheckListCategoryDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = wot.QueryCheckListCategoryDefinitions().All(ctx)
	}
	return result, err
}

func (wot *WorkOrderTemplate) Type(ctx context.Context) (*WorkOrderType, error) {
	result, err := wot.Edges.TypeOrErr()
	if IsNotLoaded(err) {
		result, err = wot.QueryType().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (wot *WorkOrderType) PropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := wot.Edges.PropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = wot.QueryPropertyTypes().All(ctx)
	}
	return result, err
}

func (wot *WorkOrderType) CheckListCategoryDefinitions(ctx context.Context) ([]*CheckListCategoryDefinition, error) {
	result, err := wot.Edges.CheckListCategoryDefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = wot.QueryCheckListCategoryDefinitions().All(ctx)
	}
	return result, err
}

func (wot *WorkOrderType) WorkOrders(ctx context.Context) ([]*WorkOrder, error) {
	result, err := wot.Edges.WorkOrdersOrErr()
	if IsNotLoaded(err) {
		result, err = wot.QueryWorkOrders().All(ctx)
	}
	return result, err
}

func (wot *WorkOrderType) Definitions(ctx context.Context) ([]*WorkOrderDefinition, error) {
	result, err := wot.Edges.DefinitionsOrErr()
	if IsNotLoaded(err) {
		result, err = wot.QueryDefinitions().All(ctx)
	}
	return result, err
}

func (wt *WorkerType) PropertyTypes(ctx context.Context) ([]*PropertyType, error) {
	result, err := wt.Edges.PropertyTypesOrErr()
	if IsNotLoaded(err) {
		result, err = wt.QueryPropertyTypes().All(ctx)
	}
	return result, err
}
