// Copyright (c) 2004-present Facebook All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/facebookincubator/symphony/pkg/authz/models"
	"github.com/facebookincubator/symphony/pkg/ent/activity"
	"github.com/facebookincubator/symphony/pkg/ent/alarmfilter"
	"github.com/facebookincubator/symphony/pkg/ent/alarmstatus"
	"github.com/facebookincubator/symphony/pkg/ent/appointment"
	"github.com/facebookincubator/symphony/pkg/ent/block"
	"github.com/facebookincubator/symphony/pkg/ent/blockinstance"
	"github.com/facebookincubator/symphony/pkg/ent/checklistcategory"
	"github.com/facebookincubator/symphony/pkg/ent/checklistcategorydefinition"
	"github.com/facebookincubator/symphony/pkg/ent/checklistitem"
	"github.com/facebookincubator/symphony/pkg/ent/checklistitemdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/comment"
	"github.com/facebookincubator/symphony/pkg/ent/comparator"
	"github.com/facebookincubator/symphony/pkg/ent/counter"
	"github.com/facebookincubator/symphony/pkg/ent/counterfamily"
	"github.com/facebookincubator/symphony/pkg/ent/counterformula"
	"github.com/facebookincubator/symphony/pkg/ent/customer"
	"github.com/facebookincubator/symphony/pkg/ent/documentcategory"
	"github.com/facebookincubator/symphony/pkg/ent/domain"
	"github.com/facebookincubator/symphony/pkg/ent/entrypoint"
	"github.com/facebookincubator/symphony/pkg/ent/equipment"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentcategory"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentport"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentportdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentporttype"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentposition"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentpositiondefinition"
	"github.com/facebookincubator/symphony/pkg/ent/equipmenttype"
	"github.com/facebookincubator/symphony/pkg/ent/eventseverity"
	"github.com/facebookincubator/symphony/pkg/ent/exitpoint"
	"github.com/facebookincubator/symphony/pkg/ent/exporttask"
	"github.com/facebookincubator/symphony/pkg/ent/feature"
	"github.com/facebookincubator/symphony/pkg/ent/file"
	"github.com/facebookincubator/symphony/pkg/ent/floorplan"
	"github.com/facebookincubator/symphony/pkg/ent/floorplanreferencepoint"
	"github.com/facebookincubator/symphony/pkg/ent/floorplanscale"
	"github.com/facebookincubator/symphony/pkg/ent/flow"
	"github.com/facebookincubator/symphony/pkg/ent/flowdraft"
	"github.com/facebookincubator/symphony/pkg/ent/flowexecutiontemplate"
	"github.com/facebookincubator/symphony/pkg/ent/flowinstance"
	"github.com/facebookincubator/symphony/pkg/ent/formula"
	"github.com/facebookincubator/symphony/pkg/ent/hyperlink"
	"github.com/facebookincubator/symphony/pkg/ent/kpi"
	"github.com/facebookincubator/symphony/pkg/ent/kpicategory"
	"github.com/facebookincubator/symphony/pkg/ent/kqi"
	"github.com/facebookincubator/symphony/pkg/ent/kqicategory"
	"github.com/facebookincubator/symphony/pkg/ent/kqicomparator"
	"github.com/facebookincubator/symphony/pkg/ent/kqiperspective"
	"github.com/facebookincubator/symphony/pkg/ent/kqisource"
	"github.com/facebookincubator/symphony/pkg/ent/kqitarget"
	"github.com/facebookincubator/symphony/pkg/ent/kqitemporalfrequency"
	"github.com/facebookincubator/symphony/pkg/ent/link"
	"github.com/facebookincubator/symphony/pkg/ent/location"
	"github.com/facebookincubator/symphony/pkg/ent/locationtype"
	"github.com/facebookincubator/symphony/pkg/ent/networktype"
	"github.com/facebookincubator/symphony/pkg/ent/organization"
	"github.com/facebookincubator/symphony/pkg/ent/parametercatalog"
	"github.com/facebookincubator/symphony/pkg/ent/permissionspolicy"
	"github.com/facebookincubator/symphony/pkg/ent/predicate"
	"github.com/facebookincubator/symphony/pkg/ent/project"
	"github.com/facebookincubator/symphony/pkg/ent/projecttemplate"
	"github.com/facebookincubator/symphony/pkg/ent/projecttype"
	"github.com/facebookincubator/symphony/pkg/ent/property"
	"github.com/facebookincubator/symphony/pkg/ent/propertycategory"
	"github.com/facebookincubator/symphony/pkg/ent/propertytype"
	"github.com/facebookincubator/symphony/pkg/ent/recommendations"
	"github.com/facebookincubator/symphony/pkg/ent/recommendationscategory"
	"github.com/facebookincubator/symphony/pkg/ent/recommendationssources"
	"github.com/facebookincubator/symphony/pkg/ent/reportfilter"
	"github.com/facebookincubator/symphony/pkg/ent/rule"
	"github.com/facebookincubator/symphony/pkg/ent/rulelimit"
	"github.com/facebookincubator/symphony/pkg/ent/ruletype"
	"github.com/facebookincubator/symphony/pkg/ent/schema/enum"
	"github.com/facebookincubator/symphony/pkg/ent/service"
	"github.com/facebookincubator/symphony/pkg/ent/serviceendpoint"
	"github.com/facebookincubator/symphony/pkg/ent/serviceendpointdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/servicetype"
	"github.com/facebookincubator/symphony/pkg/ent/survey"
	"github.com/facebookincubator/symphony/pkg/ent/surveycellscan"
	"github.com/facebookincubator/symphony/pkg/ent/surveyquestion"
	"github.com/facebookincubator/symphony/pkg/ent/surveytemplatecategory"
	"github.com/facebookincubator/symphony/pkg/ent/surveytemplatequestion"
	"github.com/facebookincubator/symphony/pkg/ent/surveywifiscan"
	"github.com/facebookincubator/symphony/pkg/ent/tech"
	"github.com/facebookincubator/symphony/pkg/ent/threshold"
	"github.com/facebookincubator/symphony/pkg/ent/user"
	"github.com/facebookincubator/symphony/pkg/ent/usersgroup"
	"github.com/facebookincubator/symphony/pkg/ent/vendor"
	"github.com/facebookincubator/symphony/pkg/ent/workertype"
	"github.com/facebookincubator/symphony/pkg/ent/workorder"
	"github.com/facebookincubator/symphony/pkg/ent/workorderdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/workordertemplate"
	"github.com/facebookincubator/symphony/pkg/ent/workordertype"
	"github.com/facebookincubator/symphony/pkg/flowengine/flowschema"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity                    = "Activity"
	TypeAlarmFilter                 = "AlarmFilter"
	TypeAlarmStatus                 = "AlarmStatus"
	TypeAppointment                 = "Appointment"
	TypeBlock                       = "Block"
	TypeBlockInstance               = "BlockInstance"
	TypeCheckListCategory           = "CheckListCategory"
	TypeCheckListCategoryDefinition = "CheckListCategoryDefinition"
	TypeCheckListItem               = "CheckListItem"
	TypeCheckListItemDefinition     = "CheckListItemDefinition"
	TypeComment                     = "Comment"
	TypeComparator                  = "Comparator"
	TypeCounter                     = "Counter"
	TypeCounterFamily               = "CounterFamily"
	TypeCounterFormula              = "CounterFormula"
	TypeCustomer                    = "Customer"
	TypeDocumentCategory            = "DocumentCategory"
	TypeDomain                      = "Domain"
	TypeEntryPoint                  = "EntryPoint"
	TypeEquipment                   = "Equipment"
	TypeEquipmentCategory           = "EquipmentCategory"
	TypeEquipmentPort               = "EquipmentPort"
	TypeEquipmentPortDefinition     = "EquipmentPortDefinition"
	TypeEquipmentPortType           = "EquipmentPortType"
	TypeEquipmentPosition           = "EquipmentPosition"
	TypeEquipmentPositionDefinition = "EquipmentPositionDefinition"
	TypeEquipmentType               = "EquipmentType"
	TypeEventSeverity               = "EventSeverity"
	TypeExitPoint                   = "ExitPoint"
	TypeExportTask                  = "ExportTask"
	TypeFeature                     = "Feature"
	TypeFile                        = "File"
	TypeFloorPlan                   = "FloorPlan"
	TypeFloorPlanReferencePoint     = "FloorPlanReferencePoint"
	TypeFloorPlanScale              = "FloorPlanScale"
	TypeFlow                        = "Flow"
	TypeFlowDraft                   = "FlowDraft"
	TypeFlowExecutionTemplate       = "FlowExecutionTemplate"
	TypeFlowInstance                = "FlowInstance"
	TypeFormula                     = "Formula"
	TypeHyperlink                   = "Hyperlink"
	TypeKpi                         = "Kpi"
	TypeKpiCategory                 = "KpiCategory"
	TypeKqi                         = "Kqi"
	TypeKqiCategory                 = "KqiCategory"
	TypeKqiComparator               = "KqiComparator"
	TypeKqiPerspective              = "KqiPerspective"
	TypeKqiSource                   = "KqiSource"
	TypeKqiTarget                   = "KqiTarget"
	TypeKqiTemporalFrequency        = "KqiTemporalFrequency"
	TypeLink                        = "Link"
	TypeLocation                    = "Location"
	TypeLocationType                = "LocationType"
	TypeNetworkType                 = "NetworkType"
	TypeOrganization                = "Organization"
	TypeParameterCatalog            = "ParameterCatalog"
	TypePermissionsPolicy           = "PermissionsPolicy"
	TypeProject                     = "Project"
	TypeProjectTemplate             = "ProjectTemplate"
	TypeProjectType                 = "ProjectType"
	TypeProperty                    = "Property"
	TypePropertyCategory            = "PropertyCategory"
	TypePropertyType                = "PropertyType"
	TypeRecommendations             = "Recommendations"
	TypeRecommendationsCategory     = "RecommendationsCategory"
	TypeRecommendationsSources      = "RecommendationsSources"
	TypeReportFilter                = "ReportFilter"
	TypeRule                        = "Rule"
	TypeRuleLimit                   = "RuleLimit"
	TypeRuleType                    = "RuleType"
	TypeService                     = "Service"
	TypeServiceEndpoint             = "ServiceEndpoint"
	TypeServiceEndpointDefinition   = "ServiceEndpointDefinition"
	TypeServiceType                 = "ServiceType"
	TypeSurvey                      = "Survey"
	TypeSurveyCellScan              = "SurveyCellScan"
	TypeSurveyQuestion              = "SurveyQuestion"
	TypeSurveyTemplateCategory      = "SurveyTemplateCategory"
	TypeSurveyTemplateQuestion      = "SurveyTemplateQuestion"
	TypeSurveyWiFiScan              = "SurveyWiFiScan"
	TypeTech                        = "Tech"
	TypeThreshold                   = "Threshold"
	TypeUser                        = "User"
	TypeUsersGroup                  = "UsersGroup"
	TypeVendor                      = "Vendor"
	TypeWorkOrder                   = "WorkOrder"
	TypeWorkOrderDefinition         = "WorkOrderDefinition"
	TypeWorkOrderTemplate           = "WorkOrderTemplate"
	TypeWorkOrderType               = "WorkOrderType"
	TypeWorkerType                  = "WorkerType"
)

// ActivityMutation represents an operation that mutate the Activities
// nodes in the graph.
type ActivityMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	activity_type     *activity.ActivityType
	is_create         *bool
	old_value         *string
	new_value         *string
	clock_details     *activity.ClockDetails
	clearedFields     map[string]struct{}
	author            *int
	clearedauthor     bool
	work_order        *int
	clearedwork_order bool
	done              bool
	oldValue          func(context.Context) (*Activity, error)
	predicates        []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows to manage the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for Activity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the id field of the mutation.
func withActivityID(id int) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ActivityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ActivityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ActivityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ActivityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ActivityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ActivityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ActivityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetActivityType sets the activity_type field.
func (m *ActivityMutation) SetActivityType(at activity.ActivityType) {
	m.activity_type = &at
}

// ActivityType returns the activity_type value in the mutation.
func (m *ActivityMutation) ActivityType() (r activity.ActivityType, exists bool) {
	v := m.activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityType returns the old activity_type value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldActivityType(ctx context.Context) (v activity.ActivityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivityType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityType: %w", err)
	}
	return oldValue.ActivityType, nil
}

// ResetActivityType reset all changes of the "activity_type" field.
func (m *ActivityMutation) ResetActivityType() {
	m.activity_type = nil
}

// SetIsCreate sets the is_create field.
func (m *ActivityMutation) SetIsCreate(b bool) {
	m.is_create = &b
}

// IsCreate returns the is_create value in the mutation.
func (m *ActivityMutation) IsCreate() (r bool, exists bool) {
	v := m.is_create
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCreate returns the old is_create value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldIsCreate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsCreate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsCreate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCreate: %w", err)
	}
	return oldValue.IsCreate, nil
}

// ResetIsCreate reset all changes of the "is_create" field.
func (m *ActivityMutation) ResetIsCreate() {
	m.is_create = nil
}

// SetOldValue sets the old_value field.
func (m *ActivityMutation) SetOldValue(s string) {
	m.old_value = &s
}

// OldValue returns the old_value value in the mutation.
func (m *ActivityMutation) OldValue() (r string, exists bool) {
	v := m.old_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOldValue returns the old old_value value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldOldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOldValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldValue: %w", err)
	}
	return oldValue.OldValue, nil
}

// ClearOldValue clears the value of old_value.
func (m *ActivityMutation) ClearOldValue() {
	m.old_value = nil
	m.clearedFields[activity.FieldOldValue] = struct{}{}
}

// OldValueCleared returns if the field old_value was cleared in this mutation.
func (m *ActivityMutation) OldValueCleared() bool {
	_, ok := m.clearedFields[activity.FieldOldValue]
	return ok
}

// ResetOldValue reset all changes of the "old_value" field.
func (m *ActivityMutation) ResetOldValue() {
	m.old_value = nil
	delete(m.clearedFields, activity.FieldOldValue)
}

// SetNewValue sets the new_value field.
func (m *ActivityMutation) SetNewValue(s string) {
	m.new_value = &s
}

// NewValue returns the new_value value in the mutation.
func (m *ActivityMutation) NewValue() (r string, exists bool) {
	v := m.new_value
	if v == nil {
		return
	}
	return *v, true
}

// OldNewValue returns the old new_value value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldNewValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNewValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNewValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewValue: %w", err)
	}
	return oldValue.NewValue, nil
}

// ClearNewValue clears the value of new_value.
func (m *ActivityMutation) ClearNewValue() {
	m.new_value = nil
	m.clearedFields[activity.FieldNewValue] = struct{}{}
}

// NewValueCleared returns if the field new_value was cleared in this mutation.
func (m *ActivityMutation) NewValueCleared() bool {
	_, ok := m.clearedFields[activity.FieldNewValue]
	return ok
}

// ResetNewValue reset all changes of the "new_value" field.
func (m *ActivityMutation) ResetNewValue() {
	m.new_value = nil
	delete(m.clearedFields, activity.FieldNewValue)
}

// SetClockDetails sets the clock_details field.
func (m *ActivityMutation) SetClockDetails(ad activity.ClockDetails) {
	m.clock_details = &ad
}

// ClockDetails returns the clock_details value in the mutation.
func (m *ActivityMutation) ClockDetails() (r activity.ClockDetails, exists bool) {
	v := m.clock_details
	if v == nil {
		return
	}
	return *v, true
}

// OldClockDetails returns the old clock_details value of the Activity.
// If the Activity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivityMutation) OldClockDetails(ctx context.Context) (v activity.ClockDetails, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClockDetails is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClockDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClockDetails: %w", err)
	}
	return oldValue.ClockDetails, nil
}

// ClearClockDetails clears the value of clock_details.
func (m *ActivityMutation) ClearClockDetails() {
	m.clock_details = nil
	m.clearedFields[activity.FieldClockDetails] = struct{}{}
}

// ClockDetailsCleared returns if the field clock_details was cleared in this mutation.
func (m *ActivityMutation) ClockDetailsCleared() bool {
	_, ok := m.clearedFields[activity.FieldClockDetails]
	return ok
}

// ResetClockDetails reset all changes of the "clock_details" field.
func (m *ActivityMutation) ResetClockDetails() {
	m.clock_details = nil
	delete(m.clearedFields, activity.FieldClockDetails)
}

// SetAuthorID sets the author edge to User by id.
func (m *ActivityMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the author edge to User.
func (m *ActivityMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared returns if the edge author was cleared.
func (m *ActivityMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the author id in the mutation.
func (m *ActivityMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the author ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor reset all changes of the "author" edge.
func (m *ActivityMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *ActivityMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *ActivityMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *ActivityMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *ActivityMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *ActivityMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, activity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, activity.FieldUpdateTime)
	}
	if m.activity_type != nil {
		fields = append(fields, activity.FieldActivityType)
	}
	if m.is_create != nil {
		fields = append(fields, activity.FieldIsCreate)
	}
	if m.old_value != nil {
		fields = append(fields, activity.FieldOldValue)
	}
	if m.new_value != nil {
		fields = append(fields, activity.FieldNewValue)
	}
	if m.clock_details != nil {
		fields = append(fields, activity.FieldClockDetails)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldCreateTime:
		return m.CreateTime()
	case activity.FieldUpdateTime:
		return m.UpdateTime()
	case activity.FieldActivityType:
		return m.ActivityType()
	case activity.FieldIsCreate:
		return m.IsCreate()
	case activity.FieldOldValue:
		return m.OldValue()
	case activity.FieldNewValue:
		return m.NewValue()
	case activity.FieldClockDetails:
		return m.ClockDetails()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case activity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case activity.FieldActivityType:
		return m.OldActivityType(ctx)
	case activity.FieldIsCreate:
		return m.OldIsCreate(ctx)
	case activity.FieldOldValue:
		return m.OldOldValue(ctx)
	case activity.FieldNewValue:
		return m.OldNewValue(ctx)
	case activity.FieldClockDetails:
		return m.OldClockDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case activity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case activity.FieldActivityType:
		v, ok := value.(activity.ActivityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityType(v)
		return nil
	case activity.FieldIsCreate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCreate(v)
		return nil
	case activity.FieldOldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldValue(v)
		return nil
	case activity.FieldNewValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewValue(v)
		return nil
	case activity.FieldClockDetails:
		v, ok := value.(activity.ClockDetails)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClockDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldOldValue) {
		fields = append(fields, activity.FieldOldValue)
	}
	if m.FieldCleared(activity.FieldNewValue) {
		fields = append(fields, activity.FieldNewValue)
	}
	if m.FieldCleared(activity.FieldClockDetails) {
		fields = append(fields, activity.FieldClockDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldOldValue:
		m.ClearOldValue()
		return nil
	case activity.FieldNewValue:
		m.ClearNewValue()
		return nil
	case activity.FieldClockDetails:
		m.ClearClockDetails()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case activity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case activity.FieldActivityType:
		m.ResetActivityType()
		return nil
	case activity.FieldIsCreate:
		m.ResetIsCreate()
		return nil
	case activity.FieldOldValue:
		m.ResetOldValue()
		return nil
	case activity.FieldNewValue:
		m.ResetNewValue()
		return nil
	case activity.FieldClockDetails:
		m.ResetClockDetails()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, activity.EdgeAuthor)
	}
	if m.work_order != nil {
		edges = append(edges, activity.EdgeWorkOrder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, activity.EdgeAuthor)
	}
	if m.clearedwork_order {
		edges = append(edges, activity.EdgeWorkOrder)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeAuthor:
		return m.clearedauthor
	case activity.EdgeWorkOrder:
		return m.clearedwork_order
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	case activity.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case activity.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case activity.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// AlarmFilterMutation represents an operation that mutate the AlarmFilters
// nodes in the graph.
type AlarmFilterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	networkResource      *string
	beginTime            *time.Time
	endTime              *time.Time
	reason               *string
	user                 *string
	creationTime         *time.Time
	enable               *bool
	clearedFields        map[string]struct{}
	alarmStatusFk        *int
	clearedalarmStatusFk bool
	done                 bool
	oldValue             func(context.Context) (*AlarmFilter, error)
	predicates           []predicate.AlarmFilter
}

var _ ent.Mutation = (*AlarmFilterMutation)(nil)

// alarmfilterOption allows to manage the mutation configuration using functional options.
type alarmfilterOption func(*AlarmFilterMutation)

// newAlarmFilterMutation creates new mutation for AlarmFilter.
func newAlarmFilterMutation(c config, op Op, opts ...alarmfilterOption) *AlarmFilterMutation {
	m := &AlarmFilterMutation{
		config:        c,
		op:            op,
		typ:           TypeAlarmFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlarmFilterID sets the id field of the mutation.
func withAlarmFilterID(id int) alarmfilterOption {
	return func(m *AlarmFilterMutation) {
		var (
			err   error
			once  sync.Once
			value *AlarmFilter
		)
		m.oldValue = func(ctx context.Context) (*AlarmFilter, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlarmFilter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlarmFilter sets the old AlarmFilter of the mutation.
func withAlarmFilter(node *AlarmFilter) alarmfilterOption {
	return func(m *AlarmFilterMutation) {
		m.oldValue = func(context.Context) (*AlarmFilter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlarmFilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlarmFilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AlarmFilterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *AlarmFilterMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *AlarmFilterMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *AlarmFilterMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *AlarmFilterMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *AlarmFilterMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *AlarmFilterMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *AlarmFilterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AlarmFilterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AlarmFilterMutation) ResetName() {
	m.name = nil
}

// SetNetworkResource sets the networkResource field.
func (m *AlarmFilterMutation) SetNetworkResource(s string) {
	m.networkResource = &s
}

// NetworkResource returns the networkResource value in the mutation.
func (m *AlarmFilterMutation) NetworkResource() (r string, exists bool) {
	v := m.networkResource
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkResource returns the old networkResource value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldNetworkResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetworkResource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetworkResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkResource: %w", err)
	}
	return oldValue.NetworkResource, nil
}

// ResetNetworkResource reset all changes of the "networkResource" field.
func (m *AlarmFilterMutation) ResetNetworkResource() {
	m.networkResource = nil
}

// SetBeginTime sets the beginTime field.
func (m *AlarmFilterMutation) SetBeginTime(t time.Time) {
	m.beginTime = &t
}

// BeginTime returns the beginTime value in the mutation.
func (m *AlarmFilterMutation) BeginTime() (r time.Time, exists bool) {
	v := m.beginTime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old beginTime value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldBeginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBeginTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime reset all changes of the "beginTime" field.
func (m *AlarmFilterMutation) ResetBeginTime() {
	m.beginTime = nil
}

// SetEndTime sets the endTime field.
func (m *AlarmFilterMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the endTime value in the mutation.
func (m *AlarmFilterMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old endTime value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime reset all changes of the "endTime" field.
func (m *AlarmFilterMutation) ResetEndTime() {
	m.endTime = nil
}

// SetReason sets the reason field.
func (m *AlarmFilterMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the reason value in the mutation.
func (m *AlarmFilterMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old reason value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReason is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason reset all changes of the "reason" field.
func (m *AlarmFilterMutation) ResetReason() {
	m.reason = nil
}

// SetUser sets the user field.
func (m *AlarmFilterMutation) SetUser(s string) {
	m.user = &s
}

// User returns the user value in the mutation.
func (m *AlarmFilterMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old user value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUser is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser reset all changes of the "user" field.
func (m *AlarmFilterMutation) ResetUser() {
	m.user = nil
}

// SetCreationTime sets the creationTime field.
func (m *AlarmFilterMutation) SetCreationTime(t time.Time) {
	m.creationTime = &t
}

// CreationTime returns the creationTime value in the mutation.
func (m *AlarmFilterMutation) CreationTime() (r time.Time, exists bool) {
	v := m.creationTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationTime returns the old creationTime value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldCreationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreationTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationTime: %w", err)
	}
	return oldValue.CreationTime, nil
}

// ResetCreationTime reset all changes of the "creationTime" field.
func (m *AlarmFilterMutation) ResetCreationTime() {
	m.creationTime = nil
}

// SetEnable sets the enable field.
func (m *AlarmFilterMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the enable value in the mutation.
func (m *AlarmFilterMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old enable value of the AlarmFilter.
// If the AlarmFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmFilterMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnable is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable reset all changes of the "enable" field.
func (m *AlarmFilterMutation) ResetEnable() {
	m.enable = nil
}

// SetAlarmStatusFkID sets the alarmStatusFk edge to AlarmStatus by id.
func (m *AlarmFilterMutation) SetAlarmStatusFkID(id int) {
	m.alarmStatusFk = &id
}

// ClearAlarmStatusFk clears the alarmStatusFk edge to AlarmStatus.
func (m *AlarmFilterMutation) ClearAlarmStatusFk() {
	m.clearedalarmStatusFk = true
}

// AlarmStatusFkCleared returns if the edge alarmStatusFk was cleared.
func (m *AlarmFilterMutation) AlarmStatusFkCleared() bool {
	return m.clearedalarmStatusFk
}

// AlarmStatusFkID returns the alarmStatusFk id in the mutation.
func (m *AlarmFilterMutation) AlarmStatusFkID() (id int, exists bool) {
	if m.alarmStatusFk != nil {
		return *m.alarmStatusFk, true
	}
	return
}

// AlarmStatusFkIDs returns the alarmStatusFk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AlarmStatusFkID instead. It exists only for internal usage by the builders.
func (m *AlarmFilterMutation) AlarmStatusFkIDs() (ids []int) {
	if id := m.alarmStatusFk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlarmStatusFk reset all changes of the "alarmStatusFk" edge.
func (m *AlarmFilterMutation) ResetAlarmStatusFk() {
	m.alarmStatusFk = nil
	m.clearedalarmStatusFk = false
}

// Op returns the operation name.
func (m *AlarmFilterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AlarmFilter).
func (m *AlarmFilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AlarmFilterMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, alarmfilter.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, alarmfilter.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, alarmfilter.FieldName)
	}
	if m.networkResource != nil {
		fields = append(fields, alarmfilter.FieldNetworkResource)
	}
	if m.beginTime != nil {
		fields = append(fields, alarmfilter.FieldBeginTime)
	}
	if m.endTime != nil {
		fields = append(fields, alarmfilter.FieldEndTime)
	}
	if m.reason != nil {
		fields = append(fields, alarmfilter.FieldReason)
	}
	if m.user != nil {
		fields = append(fields, alarmfilter.FieldUser)
	}
	if m.creationTime != nil {
		fields = append(fields, alarmfilter.FieldCreationTime)
	}
	if m.enable != nil {
		fields = append(fields, alarmfilter.FieldEnable)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AlarmFilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alarmfilter.FieldCreateTime:
		return m.CreateTime()
	case alarmfilter.FieldUpdateTime:
		return m.UpdateTime()
	case alarmfilter.FieldName:
		return m.Name()
	case alarmfilter.FieldNetworkResource:
		return m.NetworkResource()
	case alarmfilter.FieldBeginTime:
		return m.BeginTime()
	case alarmfilter.FieldEndTime:
		return m.EndTime()
	case alarmfilter.FieldReason:
		return m.Reason()
	case alarmfilter.FieldUser:
		return m.User()
	case alarmfilter.FieldCreationTime:
		return m.CreationTime()
	case alarmfilter.FieldEnable:
		return m.Enable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AlarmFilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alarmfilter.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case alarmfilter.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case alarmfilter.FieldName:
		return m.OldName(ctx)
	case alarmfilter.FieldNetworkResource:
		return m.OldNetworkResource(ctx)
	case alarmfilter.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case alarmfilter.FieldEndTime:
		return m.OldEndTime(ctx)
	case alarmfilter.FieldReason:
		return m.OldReason(ctx)
	case alarmfilter.FieldUser:
		return m.OldUser(ctx)
	case alarmfilter.FieldCreationTime:
		return m.OldCreationTime(ctx)
	case alarmfilter.FieldEnable:
		return m.OldEnable(ctx)
	}
	return nil, fmt.Errorf("unknown AlarmFilter field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AlarmFilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alarmfilter.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case alarmfilter.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case alarmfilter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alarmfilter.FieldNetworkResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkResource(v)
		return nil
	case alarmfilter.FieldBeginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case alarmfilter.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case alarmfilter.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case alarmfilter.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case alarmfilter.FieldCreationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationTime(v)
		return nil
	case alarmfilter.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	}
	return fmt.Errorf("unknown AlarmFilter field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AlarmFilterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AlarmFilterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AlarmFilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlarmFilter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AlarmFilterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AlarmFilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlarmFilterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AlarmFilter nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AlarmFilterMutation) ResetField(name string) error {
	switch name {
	case alarmfilter.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case alarmfilter.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case alarmfilter.FieldName:
		m.ResetName()
		return nil
	case alarmfilter.FieldNetworkResource:
		m.ResetNetworkResource()
		return nil
	case alarmfilter.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case alarmfilter.FieldEndTime:
		m.ResetEndTime()
		return nil
	case alarmfilter.FieldReason:
		m.ResetReason()
		return nil
	case alarmfilter.FieldUser:
		m.ResetUser()
		return nil
	case alarmfilter.FieldCreationTime:
		m.ResetCreationTime()
		return nil
	case alarmfilter.FieldEnable:
		m.ResetEnable()
		return nil
	}
	return fmt.Errorf("unknown AlarmFilter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AlarmFilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.alarmStatusFk != nil {
		edges = append(edges, alarmfilter.EdgeAlarmStatusFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AlarmFilterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alarmfilter.EdgeAlarmStatusFk:
		if id := m.alarmStatusFk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AlarmFilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AlarmFilterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AlarmFilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedalarmStatusFk {
		edges = append(edges, alarmfilter.EdgeAlarmStatusFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AlarmFilterMutation) EdgeCleared(name string) bool {
	switch name {
	case alarmfilter.EdgeAlarmStatusFk:
		return m.clearedalarmStatusFk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AlarmFilterMutation) ClearEdge(name string) error {
	switch name {
	case alarmfilter.EdgeAlarmStatusFk:
		m.ClearAlarmStatusFk()
		return nil
	}
	return fmt.Errorf("unknown AlarmFilter unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AlarmFilterMutation) ResetEdge(name string) error {
	switch name {
	case alarmfilter.EdgeAlarmStatusFk:
		m.ResetAlarmStatusFk()
		return nil
	}
	return fmt.Errorf("unknown AlarmFilter edge %s", name)
}

// AlarmStatusMutation represents an operation that mutate the AlarmStatusSlice
// nodes in the graph.
type AlarmStatusMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	clearedFields        map[string]struct{}
	alarmStatusFk        map[int]struct{}
	removedalarmStatusFk map[int]struct{}
	clearedalarmStatusFk bool
	done                 bool
	oldValue             func(context.Context) (*AlarmStatus, error)
	predicates           []predicate.AlarmStatus
}

var _ ent.Mutation = (*AlarmStatusMutation)(nil)

// alarmstatusOption allows to manage the mutation configuration using functional options.
type alarmstatusOption func(*AlarmStatusMutation)

// newAlarmStatusMutation creates new mutation for AlarmStatus.
func newAlarmStatusMutation(c config, op Op, opts ...alarmstatusOption) *AlarmStatusMutation {
	m := &AlarmStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeAlarmStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlarmStatusID sets the id field of the mutation.
func withAlarmStatusID(id int) alarmstatusOption {
	return func(m *AlarmStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *AlarmStatus
		)
		m.oldValue = func(ctx context.Context) (*AlarmStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlarmStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlarmStatus sets the old AlarmStatus of the mutation.
func withAlarmStatus(node *AlarmStatus) alarmstatusOption {
	return func(m *AlarmStatusMutation) {
		m.oldValue = func(context.Context) (*AlarmStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlarmStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlarmStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AlarmStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *AlarmStatusMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *AlarmStatusMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the AlarmStatus.
// If the AlarmStatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmStatusMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *AlarmStatusMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *AlarmStatusMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *AlarmStatusMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the AlarmStatus.
// If the AlarmStatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmStatusMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *AlarmStatusMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *AlarmStatusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AlarmStatusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the AlarmStatus.
// If the AlarmStatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AlarmStatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AlarmStatusMutation) ResetName() {
	m.name = nil
}

// AddAlarmStatusFkIDs adds the alarmStatusFk edge to AlarmFilter by ids.
func (m *AlarmStatusMutation) AddAlarmStatusFkIDs(ids ...int) {
	if m.alarmStatusFk == nil {
		m.alarmStatusFk = make(map[int]struct{})
	}
	for i := range ids {
		m.alarmStatusFk[ids[i]] = struct{}{}
	}
}

// ClearAlarmStatusFk clears the alarmStatusFk edge to AlarmFilter.
func (m *AlarmStatusMutation) ClearAlarmStatusFk() {
	m.clearedalarmStatusFk = true
}

// AlarmStatusFkCleared returns if the edge alarmStatusFk was cleared.
func (m *AlarmStatusMutation) AlarmStatusFkCleared() bool {
	return m.clearedalarmStatusFk
}

// RemoveAlarmStatusFkIDs removes the alarmStatusFk edge to AlarmFilter by ids.
func (m *AlarmStatusMutation) RemoveAlarmStatusFkIDs(ids ...int) {
	if m.removedalarmStatusFk == nil {
		m.removedalarmStatusFk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedalarmStatusFk[ids[i]] = struct{}{}
	}
}

// RemovedAlarmStatusFk returns the removed ids of alarmStatusFk.
func (m *AlarmStatusMutation) RemovedAlarmStatusFkIDs() (ids []int) {
	for id := range m.removedalarmStatusFk {
		ids = append(ids, id)
	}
	return
}

// AlarmStatusFkIDs returns the alarmStatusFk ids in the mutation.
func (m *AlarmStatusMutation) AlarmStatusFkIDs() (ids []int) {
	for id := range m.alarmStatusFk {
		ids = append(ids, id)
	}
	return
}

// ResetAlarmStatusFk reset all changes of the "alarmStatusFk" edge.
func (m *AlarmStatusMutation) ResetAlarmStatusFk() {
	m.alarmStatusFk = nil
	m.clearedalarmStatusFk = false
	m.removedalarmStatusFk = nil
}

// Op returns the operation name.
func (m *AlarmStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AlarmStatus).
func (m *AlarmStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AlarmStatusMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, alarmstatus.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, alarmstatus.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, alarmstatus.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AlarmStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alarmstatus.FieldCreateTime:
		return m.CreateTime()
	case alarmstatus.FieldUpdateTime:
		return m.UpdateTime()
	case alarmstatus.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AlarmStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alarmstatus.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case alarmstatus.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case alarmstatus.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown AlarmStatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AlarmStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alarmstatus.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case alarmstatus.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case alarmstatus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown AlarmStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AlarmStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AlarmStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AlarmStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlarmStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AlarmStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AlarmStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlarmStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AlarmStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AlarmStatusMutation) ResetField(name string) error {
	switch name {
	case alarmstatus.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case alarmstatus.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case alarmstatus.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown AlarmStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AlarmStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.alarmStatusFk != nil {
		edges = append(edges, alarmstatus.EdgeAlarmStatusFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AlarmStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alarmstatus.EdgeAlarmStatusFk:
		ids := make([]ent.Value, 0, len(m.alarmStatusFk))
		for id := range m.alarmStatusFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AlarmStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedalarmStatusFk != nil {
		edges = append(edges, alarmstatus.EdgeAlarmStatusFk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AlarmStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alarmstatus.EdgeAlarmStatusFk:
		ids := make([]ent.Value, 0, len(m.removedalarmStatusFk))
		for id := range m.removedalarmStatusFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AlarmStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedalarmStatusFk {
		edges = append(edges, alarmstatus.EdgeAlarmStatusFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AlarmStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case alarmstatus.EdgeAlarmStatusFk:
		return m.clearedalarmStatusFk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AlarmStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AlarmStatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AlarmStatusMutation) ResetEdge(name string) error {
	switch name {
	case alarmstatus.EdgeAlarmStatusFk:
		m.ResetAlarmStatusFk()
		return nil
	}
	return fmt.Errorf("unknown AlarmStatus edge %s", name)
}

// AppointmentMutation represents an operation that mutate the Appointments
// nodes in the graph.
type AppointmentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	start            *time.Time
	end              *time.Time
	duration         *float64
	addduration      *float64
	status           *appointment.Status
	creation_date    *time.Time
	clearedFields    map[string]struct{}
	workorder        *int
	clearedworkorder bool
	assignee         *int
	clearedassignee  bool
	done             bool
	oldValue         func(context.Context) (*Appointment, error)
	predicates       []predicate.Appointment
}

var _ ent.Mutation = (*AppointmentMutation)(nil)

// appointmentOption allows to manage the mutation configuration using functional options.
type appointmentOption func(*AppointmentMutation)

// newAppointmentMutation creates new mutation for Appointment.
func newAppointmentMutation(c config, op Op, opts ...appointmentOption) *AppointmentMutation {
	m := &AppointmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentID sets the id field of the mutation.
func withAppointmentID(id int) appointmentOption {
	return func(m *AppointmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Appointment
		)
		m.oldValue = func(ctx context.Context) (*Appointment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Appointment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointment sets the old Appointment of the mutation.
func withAppointment(node *Appointment) appointmentOption {
	return func(m *AppointmentMutation) {
		m.oldValue = func(context.Context) (*Appointment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AppointmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *AppointmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *AppointmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *AppointmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *AppointmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *AppointmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *AppointmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStart sets the start field.
func (m *AppointmentMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the start value in the mutation.
func (m *AppointmentMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old start value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart reset all changes of the "start" field.
func (m *AppointmentMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the end field.
func (m *AppointmentMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the end value in the mutation.
func (m *AppointmentMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old end value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd reset all changes of the "end" field.
func (m *AppointmentMutation) ResetEnd() {
	m.end = nil
}

// SetDuration sets the duration field.
func (m *AppointmentMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *AppointmentMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to duration.
func (m *AppointmentMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *AppointmentMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration reset all changes of the "duration" field.
func (m *AppointmentMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetStatus sets the status field.
func (m *AppointmentMutation) SetStatus(a appointment.Status) {
	m.status = &a
}

// Status returns the status value in the mutation.
func (m *AppointmentMutation) Status() (r appointment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldStatus(ctx context.Context) (v appointment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *AppointmentMutation) ResetStatus() {
	m.status = nil
}

// SetCreationDate sets the creation_date field.
func (m *AppointmentMutation) SetCreationDate(t time.Time) {
	m.creation_date = &t
}

// CreationDate returns the creation_date value in the mutation.
func (m *AppointmentMutation) CreationDate() (r time.Time, exists bool) {
	v := m.creation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationDate returns the old creation_date value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldCreationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreationDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationDate: %w", err)
	}
	return oldValue.CreationDate, nil
}

// ResetCreationDate reset all changes of the "creation_date" field.
func (m *AppointmentMutation) ResetCreationDate() {
	m.creation_date = nil
}

// SetWorkorderID sets the workorder edge to WorkOrder by id.
func (m *AppointmentMutation) SetWorkorderID(id int) {
	m.workorder = &id
}

// ClearWorkorder clears the workorder edge to WorkOrder.
func (m *AppointmentMutation) ClearWorkorder() {
	m.clearedworkorder = true
}

// WorkorderCleared returns if the edge workorder was cleared.
func (m *AppointmentMutation) WorkorderCleared() bool {
	return m.clearedworkorder
}

// WorkorderID returns the workorder id in the mutation.
func (m *AppointmentMutation) WorkorderID() (id int, exists bool) {
	if m.workorder != nil {
		return *m.workorder, true
	}
	return
}

// WorkorderIDs returns the workorder ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkorderID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) WorkorderIDs() (ids []int) {
	if id := m.workorder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkorder reset all changes of the "workorder" edge.
func (m *AppointmentMutation) ResetWorkorder() {
	m.workorder = nil
	m.clearedworkorder = false
}

// SetAssigneeID sets the assignee edge to User by id.
func (m *AppointmentMutation) SetAssigneeID(id int) {
	m.assignee = &id
}

// ClearAssignee clears the assignee edge to User.
func (m *AppointmentMutation) ClearAssignee() {
	m.clearedassignee = true
}

// AssigneeCleared returns if the edge assignee was cleared.
func (m *AppointmentMutation) AssigneeCleared() bool {
	return m.clearedassignee
}

// AssigneeID returns the assignee id in the mutation.
func (m *AppointmentMutation) AssigneeID() (id int, exists bool) {
	if m.assignee != nil {
		return *m.assignee, true
	}
	return
}

// AssigneeIDs returns the assignee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) AssigneeIDs() (ids []int) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee reset all changes of the "assignee" edge.
func (m *AppointmentMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// Op returns the operation name.
func (m *AppointmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Appointment).
func (m *AppointmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AppointmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, appointment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, appointment.FieldUpdateTime)
	}
	if m.start != nil {
		fields = append(fields, appointment.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, appointment.FieldEnd)
	}
	if m.duration != nil {
		fields = append(fields, appointment.FieldDuration)
	}
	if m.status != nil {
		fields = append(fields, appointment.FieldStatus)
	}
	if m.creation_date != nil {
		fields = append(fields, appointment.FieldCreationDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AppointmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldCreateTime:
		return m.CreateTime()
	case appointment.FieldUpdateTime:
		return m.UpdateTime()
	case appointment.FieldStart:
		return m.Start()
	case appointment.FieldEnd:
		return m.End()
	case appointment.FieldDuration:
		return m.Duration()
	case appointment.FieldStatus:
		return m.Status()
	case appointment.FieldCreationDate:
		return m.CreationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AppointmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case appointment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case appointment.FieldStart:
		return m.OldStart(ctx)
	case appointment.FieldEnd:
		return m.OldEnd(ctx)
	case appointment.FieldDuration:
		return m.OldDuration(ctx)
	case appointment.FieldStatus:
		return m.OldStatus(ctx)
	case appointment.FieldCreationDate:
		return m.OldCreationDate(ctx)
	}
	return nil, fmt.Errorf("unknown Appointment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppointmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case appointment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case appointment.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case appointment.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case appointment.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case appointment.FieldStatus:
		v, ok := value.(appointment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case appointment.FieldCreationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationDate(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AppointmentMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, appointment.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AppointmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppointmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AppointmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AppointmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Appointment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AppointmentMutation) ResetField(name string) error {
	switch name {
	case appointment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case appointment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case appointment.FieldStart:
		m.ResetStart()
		return nil
	case appointment.FieldEnd:
		m.ResetEnd()
		return nil
	case appointment.FieldDuration:
		m.ResetDuration()
		return nil
	case appointment.FieldStatus:
		m.ResetStatus()
		return nil
	case appointment.FieldCreationDate:
		m.ResetCreationDate()
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AppointmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workorder != nil {
		edges = append(edges, appointment.EdgeWorkorder)
	}
	if m.assignee != nil {
		edges = append(edges, appointment.EdgeAssignee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AppointmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appointment.EdgeWorkorder:
		if id := m.workorder; id != nil {
			return []ent.Value{*id}
		}
	case appointment.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AppointmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AppointmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AppointmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkorder {
		edges = append(edges, appointment.EdgeWorkorder)
	}
	if m.clearedassignee {
		edges = append(edges, appointment.EdgeAssignee)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AppointmentMutation) EdgeCleared(name string) bool {
	switch name {
	case appointment.EdgeWorkorder:
		return m.clearedworkorder
	case appointment.EdgeAssignee:
		return m.clearedassignee
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AppointmentMutation) ClearEdge(name string) error {
	switch name {
	case appointment.EdgeWorkorder:
		m.ClearWorkorder()
		return nil
	case appointment.EdgeAssignee:
		m.ClearAssignee()
		return nil
	}
	return fmt.Errorf("unknown Appointment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AppointmentMutation) ResetEdge(name string) error {
	switch name {
	case appointment.EdgeWorkorder:
		m.ResetWorkorder()
		return nil
	case appointment.EdgeAssignee:
		m.ResetAssignee()
		return nil
	}
	return fmt.Errorf("unknown Appointment edge %s", name)
}

// BlockMutation represents an operation that mutate the Blocks
// nodes in the graph.
type BlockMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	cid                     *string
	_type                   *block.Type
	action_type             *flowschema.ActionTypeID
	trigger_type            *flowschema.TriggerTypeID
	start_param_definitions *[]*flowschema.VariableDefinition
	input_params            *[]*flowschema.VariableExpression
	ui_representation       **flowschema.BlockUIRepresentation
	clearedFields           map[string]struct{}
	flow                    *int
	clearedflow             bool
	flow_template           *int
	clearedflow_template    bool
	flow_draft              *int
	clearedflow_draft       bool
	sub_flow                *int
	clearedsub_flow         bool
	source_block            map[int]struct{}
	removedsource_block     map[int]struct{}
	clearedsource_block     bool
	goto_block              *int
	clearedgoto_block       bool
	instances               map[int]struct{}
	removedinstances        map[int]struct{}
	clearedinstances        bool
	entry_point             *int
	clearedentry_point      bool
	exit_points             map[int]struct{}
	removedexit_points      map[int]struct{}
	clearedexit_points      bool
	done                    bool
	oldValue                func(context.Context) (*Block, error)
	predicates              []predicate.Block
}

var _ ent.Mutation = (*BlockMutation)(nil)

// blockOption allows to manage the mutation configuration using functional options.
type blockOption func(*BlockMutation)

// newBlockMutation creates new mutation for Block.
func newBlockMutation(c config, op Op, opts ...blockOption) *BlockMutation {
	m := &BlockMutation{
		config:        c,
		op:            op,
		typ:           TypeBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockID sets the id field of the mutation.
func withBlockID(id int) blockOption {
	return func(m *BlockMutation) {
		var (
			err   error
			once  sync.Once
			value *Block
		)
		m.oldValue = func(ctx context.Context) (*Block, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Block.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlock sets the old Block of the mutation.
func withBlock(node *Block) blockOption {
	return func(m *BlockMutation) {
		m.oldValue = func(context.Context) (*Block, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BlockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *BlockMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *BlockMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *BlockMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *BlockMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *BlockMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *BlockMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCid sets the cid field.
func (m *BlockMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the cid value in the mutation.
func (m *BlockMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old cid value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldCid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid reset all changes of the "cid" field.
func (m *BlockMutation) ResetCid() {
	m.cid = nil
}

// SetType sets the type field.
func (m *BlockMutation) SetType(b block.Type) {
	m._type = &b
}

// GetType returns the type value in the mutation.
func (m *BlockMutation) GetType() (r block.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldType(ctx context.Context) (v block.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *BlockMutation) ResetType() {
	m._type = nil
}

// SetActionType sets the action_type field.
func (m *BlockMutation) SetActionType(fti flowschema.ActionTypeID) {
	m.action_type = &fti
}

// ActionType returns the action_type value in the mutation.
func (m *BlockMutation) ActionType() (r flowschema.ActionTypeID, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old action_type value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldActionType(ctx context.Context) (v *flowschema.ActionTypeID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActionType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ClearActionType clears the value of action_type.
func (m *BlockMutation) ClearActionType() {
	m.action_type = nil
	m.clearedFields[block.FieldActionType] = struct{}{}
}

// ActionTypeCleared returns if the field action_type was cleared in this mutation.
func (m *BlockMutation) ActionTypeCleared() bool {
	_, ok := m.clearedFields[block.FieldActionType]
	return ok
}

// ResetActionType reset all changes of the "action_type" field.
func (m *BlockMutation) ResetActionType() {
	m.action_type = nil
	delete(m.clearedFields, block.FieldActionType)
}

// SetTriggerType sets the trigger_type field.
func (m *BlockMutation) SetTriggerType(fti flowschema.TriggerTypeID) {
	m.trigger_type = &fti
}

// TriggerType returns the trigger_type value in the mutation.
func (m *BlockMutation) TriggerType() (r flowschema.TriggerTypeID, exists bool) {
	v := m.trigger_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerType returns the old trigger_type value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldTriggerType(ctx context.Context) (v *flowschema.TriggerTypeID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTriggerType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTriggerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerType: %w", err)
	}
	return oldValue.TriggerType, nil
}

// ClearTriggerType clears the value of trigger_type.
func (m *BlockMutation) ClearTriggerType() {
	m.trigger_type = nil
	m.clearedFields[block.FieldTriggerType] = struct{}{}
}

// TriggerTypeCleared returns if the field trigger_type was cleared in this mutation.
func (m *BlockMutation) TriggerTypeCleared() bool {
	_, ok := m.clearedFields[block.FieldTriggerType]
	return ok
}

// ResetTriggerType reset all changes of the "trigger_type" field.
func (m *BlockMutation) ResetTriggerType() {
	m.trigger_type = nil
	delete(m.clearedFields, block.FieldTriggerType)
}

// SetStartParamDefinitions sets the start_param_definitions field.
func (m *BlockMutation) SetStartParamDefinitions(fd []*flowschema.VariableDefinition) {
	m.start_param_definitions = &fd
}

// StartParamDefinitions returns the start_param_definitions value in the mutation.
func (m *BlockMutation) StartParamDefinitions() (r []*flowschema.VariableDefinition, exists bool) {
	v := m.start_param_definitions
	if v == nil {
		return
	}
	return *v, true
}

// OldStartParamDefinitions returns the old start_param_definitions value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldStartParamDefinitions(ctx context.Context) (v []*flowschema.VariableDefinition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartParamDefinitions is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartParamDefinitions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartParamDefinitions: %w", err)
	}
	return oldValue.StartParamDefinitions, nil
}

// ClearStartParamDefinitions clears the value of start_param_definitions.
func (m *BlockMutation) ClearStartParamDefinitions() {
	m.start_param_definitions = nil
	m.clearedFields[block.FieldStartParamDefinitions] = struct{}{}
}

// StartParamDefinitionsCleared returns if the field start_param_definitions was cleared in this mutation.
func (m *BlockMutation) StartParamDefinitionsCleared() bool {
	_, ok := m.clearedFields[block.FieldStartParamDefinitions]
	return ok
}

// ResetStartParamDefinitions reset all changes of the "start_param_definitions" field.
func (m *BlockMutation) ResetStartParamDefinitions() {
	m.start_param_definitions = nil
	delete(m.clearedFields, block.FieldStartParamDefinitions)
}

// SetInputParams sets the input_params field.
func (m *BlockMutation) SetInputParams(fe []*flowschema.VariableExpression) {
	m.input_params = &fe
}

// InputParams returns the input_params value in the mutation.
func (m *BlockMutation) InputParams() (r []*flowschema.VariableExpression, exists bool) {
	v := m.input_params
	if v == nil {
		return
	}
	return *v, true
}

// OldInputParams returns the old input_params value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldInputParams(ctx context.Context) (v []*flowschema.VariableExpression, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInputParams is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInputParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputParams: %w", err)
	}
	return oldValue.InputParams, nil
}

// ClearInputParams clears the value of input_params.
func (m *BlockMutation) ClearInputParams() {
	m.input_params = nil
	m.clearedFields[block.FieldInputParams] = struct{}{}
}

// InputParamsCleared returns if the field input_params was cleared in this mutation.
func (m *BlockMutation) InputParamsCleared() bool {
	_, ok := m.clearedFields[block.FieldInputParams]
	return ok
}

// ResetInputParams reset all changes of the "input_params" field.
func (m *BlockMutation) ResetInputParams() {
	m.input_params = nil
	delete(m.clearedFields, block.FieldInputParams)
}

// SetUIRepresentation sets the ui_representation field.
func (m *BlockMutation) SetUIRepresentation(fur *flowschema.BlockUIRepresentation) {
	m.ui_representation = &fur
}

// UIRepresentation returns the ui_representation value in the mutation.
func (m *BlockMutation) UIRepresentation() (r *flowschema.BlockUIRepresentation, exists bool) {
	v := m.ui_representation
	if v == nil {
		return
	}
	return *v, true
}

// OldUIRepresentation returns the old ui_representation value of the Block.
// If the Block object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockMutation) OldUIRepresentation(ctx context.Context) (v *flowschema.BlockUIRepresentation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUIRepresentation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUIRepresentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUIRepresentation: %w", err)
	}
	return oldValue.UIRepresentation, nil
}

// ClearUIRepresentation clears the value of ui_representation.
func (m *BlockMutation) ClearUIRepresentation() {
	m.ui_representation = nil
	m.clearedFields[block.FieldUIRepresentation] = struct{}{}
}

// UIRepresentationCleared returns if the field ui_representation was cleared in this mutation.
func (m *BlockMutation) UIRepresentationCleared() bool {
	_, ok := m.clearedFields[block.FieldUIRepresentation]
	return ok
}

// ResetUIRepresentation reset all changes of the "ui_representation" field.
func (m *BlockMutation) ResetUIRepresentation() {
	m.ui_representation = nil
	delete(m.clearedFields, block.FieldUIRepresentation)
}

// SetFlowID sets the flow edge to Flow by id.
func (m *BlockMutation) SetFlowID(id int) {
	m.flow = &id
}

// ClearFlow clears the flow edge to Flow.
func (m *BlockMutation) ClearFlow() {
	m.clearedflow = true
}

// FlowCleared returns if the edge flow was cleared.
func (m *BlockMutation) FlowCleared() bool {
	return m.clearedflow
}

// FlowID returns the flow id in the mutation.
func (m *BlockMutation) FlowID() (id int, exists bool) {
	if m.flow != nil {
		return *m.flow, true
	}
	return
}

// FlowIDs returns the flow ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowID instead. It exists only for internal usage by the builders.
func (m *BlockMutation) FlowIDs() (ids []int) {
	if id := m.flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlow reset all changes of the "flow" edge.
func (m *BlockMutation) ResetFlow() {
	m.flow = nil
	m.clearedflow = false
}

// SetFlowTemplateID sets the flow_template edge to FlowExecutionTemplate by id.
func (m *BlockMutation) SetFlowTemplateID(id int) {
	m.flow_template = &id
}

// ClearFlowTemplate clears the flow_template edge to FlowExecutionTemplate.
func (m *BlockMutation) ClearFlowTemplate() {
	m.clearedflow_template = true
}

// FlowTemplateCleared returns if the edge flow_template was cleared.
func (m *BlockMutation) FlowTemplateCleared() bool {
	return m.clearedflow_template
}

// FlowTemplateID returns the flow_template id in the mutation.
func (m *BlockMutation) FlowTemplateID() (id int, exists bool) {
	if m.flow_template != nil {
		return *m.flow_template, true
	}
	return
}

// FlowTemplateIDs returns the flow_template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowTemplateID instead. It exists only for internal usage by the builders.
func (m *BlockMutation) FlowTemplateIDs() (ids []int) {
	if id := m.flow_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlowTemplate reset all changes of the "flow_template" edge.
func (m *BlockMutation) ResetFlowTemplate() {
	m.flow_template = nil
	m.clearedflow_template = false
}

// SetFlowDraftID sets the flow_draft edge to FlowDraft by id.
func (m *BlockMutation) SetFlowDraftID(id int) {
	m.flow_draft = &id
}

// ClearFlowDraft clears the flow_draft edge to FlowDraft.
func (m *BlockMutation) ClearFlowDraft() {
	m.clearedflow_draft = true
}

// FlowDraftCleared returns if the edge flow_draft was cleared.
func (m *BlockMutation) FlowDraftCleared() bool {
	return m.clearedflow_draft
}

// FlowDraftID returns the flow_draft id in the mutation.
func (m *BlockMutation) FlowDraftID() (id int, exists bool) {
	if m.flow_draft != nil {
		return *m.flow_draft, true
	}
	return
}

// FlowDraftIDs returns the flow_draft ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowDraftID instead. It exists only for internal usage by the builders.
func (m *BlockMutation) FlowDraftIDs() (ids []int) {
	if id := m.flow_draft; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlowDraft reset all changes of the "flow_draft" edge.
func (m *BlockMutation) ResetFlowDraft() {
	m.flow_draft = nil
	m.clearedflow_draft = false
}

// SetSubFlowID sets the sub_flow edge to Flow by id.
func (m *BlockMutation) SetSubFlowID(id int) {
	m.sub_flow = &id
}

// ClearSubFlow clears the sub_flow edge to Flow.
func (m *BlockMutation) ClearSubFlow() {
	m.clearedsub_flow = true
}

// SubFlowCleared returns if the edge sub_flow was cleared.
func (m *BlockMutation) SubFlowCleared() bool {
	return m.clearedsub_flow
}

// SubFlowID returns the sub_flow id in the mutation.
func (m *BlockMutation) SubFlowID() (id int, exists bool) {
	if m.sub_flow != nil {
		return *m.sub_flow, true
	}
	return
}

// SubFlowIDs returns the sub_flow ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SubFlowID instead. It exists only for internal usage by the builders.
func (m *BlockMutation) SubFlowIDs() (ids []int) {
	if id := m.sub_flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubFlow reset all changes of the "sub_flow" edge.
func (m *BlockMutation) ResetSubFlow() {
	m.sub_flow = nil
	m.clearedsub_flow = false
}

// AddSourceBlockIDs adds the source_block edge to Block by ids.
func (m *BlockMutation) AddSourceBlockIDs(ids ...int) {
	if m.source_block == nil {
		m.source_block = make(map[int]struct{})
	}
	for i := range ids {
		m.source_block[ids[i]] = struct{}{}
	}
}

// ClearSourceBlock clears the source_block edge to Block.
func (m *BlockMutation) ClearSourceBlock() {
	m.clearedsource_block = true
}

// SourceBlockCleared returns if the edge source_block was cleared.
func (m *BlockMutation) SourceBlockCleared() bool {
	return m.clearedsource_block
}

// RemoveSourceBlockIDs removes the source_block edge to Block by ids.
func (m *BlockMutation) RemoveSourceBlockIDs(ids ...int) {
	if m.removedsource_block == nil {
		m.removedsource_block = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsource_block[ids[i]] = struct{}{}
	}
}

// RemovedSourceBlock returns the removed ids of source_block.
func (m *BlockMutation) RemovedSourceBlockIDs() (ids []int) {
	for id := range m.removedsource_block {
		ids = append(ids, id)
	}
	return
}

// SourceBlockIDs returns the source_block ids in the mutation.
func (m *BlockMutation) SourceBlockIDs() (ids []int) {
	for id := range m.source_block {
		ids = append(ids, id)
	}
	return
}

// ResetSourceBlock reset all changes of the "source_block" edge.
func (m *BlockMutation) ResetSourceBlock() {
	m.source_block = nil
	m.clearedsource_block = false
	m.removedsource_block = nil
}

// SetGotoBlockID sets the goto_block edge to Block by id.
func (m *BlockMutation) SetGotoBlockID(id int) {
	m.goto_block = &id
}

// ClearGotoBlock clears the goto_block edge to Block.
func (m *BlockMutation) ClearGotoBlock() {
	m.clearedgoto_block = true
}

// GotoBlockCleared returns if the edge goto_block was cleared.
func (m *BlockMutation) GotoBlockCleared() bool {
	return m.clearedgoto_block
}

// GotoBlockID returns the goto_block id in the mutation.
func (m *BlockMutation) GotoBlockID() (id int, exists bool) {
	if m.goto_block != nil {
		return *m.goto_block, true
	}
	return
}

// GotoBlockIDs returns the goto_block ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GotoBlockID instead. It exists only for internal usage by the builders.
func (m *BlockMutation) GotoBlockIDs() (ids []int) {
	if id := m.goto_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGotoBlock reset all changes of the "goto_block" edge.
func (m *BlockMutation) ResetGotoBlock() {
	m.goto_block = nil
	m.clearedgoto_block = false
}

// AddInstanceIDs adds the instances edge to BlockInstance by ids.
func (m *BlockMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the instances edge to BlockInstance.
func (m *BlockMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared returns if the edge instances was cleared.
func (m *BlockMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the instances edge to BlockInstance by ids.
func (m *BlockMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed ids of instances.
func (m *BlockMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the instances ids in the mutation.
func (m *BlockMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances reset all changes of the "instances" edge.
func (m *BlockMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// SetEntryPointID sets the entry_point edge to EntryPoint by id.
func (m *BlockMutation) SetEntryPointID(id int) {
	m.entry_point = &id
}

// ClearEntryPoint clears the entry_point edge to EntryPoint.
func (m *BlockMutation) ClearEntryPoint() {
	m.clearedentry_point = true
}

// EntryPointCleared returns if the edge entry_point was cleared.
func (m *BlockMutation) EntryPointCleared() bool {
	return m.clearedentry_point
}

// EntryPointID returns the entry_point id in the mutation.
func (m *BlockMutation) EntryPointID() (id int, exists bool) {
	if m.entry_point != nil {
		return *m.entry_point, true
	}
	return
}

// EntryPointIDs returns the entry_point ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EntryPointID instead. It exists only for internal usage by the builders.
func (m *BlockMutation) EntryPointIDs() (ids []int) {
	if id := m.entry_point; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntryPoint reset all changes of the "entry_point" edge.
func (m *BlockMutation) ResetEntryPoint() {
	m.entry_point = nil
	m.clearedentry_point = false
}

// AddExitPointIDs adds the exit_points edge to ExitPoint by ids.
func (m *BlockMutation) AddExitPointIDs(ids ...int) {
	if m.exit_points == nil {
		m.exit_points = make(map[int]struct{})
	}
	for i := range ids {
		m.exit_points[ids[i]] = struct{}{}
	}
}

// ClearExitPoints clears the exit_points edge to ExitPoint.
func (m *BlockMutation) ClearExitPoints() {
	m.clearedexit_points = true
}

// ExitPointsCleared returns if the edge exit_points was cleared.
func (m *BlockMutation) ExitPointsCleared() bool {
	return m.clearedexit_points
}

// RemoveExitPointIDs removes the exit_points edge to ExitPoint by ids.
func (m *BlockMutation) RemoveExitPointIDs(ids ...int) {
	if m.removedexit_points == nil {
		m.removedexit_points = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexit_points[ids[i]] = struct{}{}
	}
}

// RemovedExitPoints returns the removed ids of exit_points.
func (m *BlockMutation) RemovedExitPointsIDs() (ids []int) {
	for id := range m.removedexit_points {
		ids = append(ids, id)
	}
	return
}

// ExitPointsIDs returns the exit_points ids in the mutation.
func (m *BlockMutation) ExitPointsIDs() (ids []int) {
	for id := range m.exit_points {
		ids = append(ids, id)
	}
	return
}

// ResetExitPoints reset all changes of the "exit_points" edge.
func (m *BlockMutation) ResetExitPoints() {
	m.exit_points = nil
	m.clearedexit_points = false
	m.removedexit_points = nil
}

// Op returns the operation name.
func (m *BlockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Block).
func (m *BlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BlockMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, block.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, block.FieldUpdateTime)
	}
	if m.cid != nil {
		fields = append(fields, block.FieldCid)
	}
	if m._type != nil {
		fields = append(fields, block.FieldType)
	}
	if m.action_type != nil {
		fields = append(fields, block.FieldActionType)
	}
	if m.trigger_type != nil {
		fields = append(fields, block.FieldTriggerType)
	}
	if m.start_param_definitions != nil {
		fields = append(fields, block.FieldStartParamDefinitions)
	}
	if m.input_params != nil {
		fields = append(fields, block.FieldInputParams)
	}
	if m.ui_representation != nil {
		fields = append(fields, block.FieldUIRepresentation)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case block.FieldCreateTime:
		return m.CreateTime()
	case block.FieldUpdateTime:
		return m.UpdateTime()
	case block.FieldCid:
		return m.Cid()
	case block.FieldType:
		return m.GetType()
	case block.FieldActionType:
		return m.ActionType()
	case block.FieldTriggerType:
		return m.TriggerType()
	case block.FieldStartParamDefinitions:
		return m.StartParamDefinitions()
	case block.FieldInputParams:
		return m.InputParams()
	case block.FieldUIRepresentation:
		return m.UIRepresentation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case block.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case block.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case block.FieldCid:
		return m.OldCid(ctx)
	case block.FieldType:
		return m.OldType(ctx)
	case block.FieldActionType:
		return m.OldActionType(ctx)
	case block.FieldTriggerType:
		return m.OldTriggerType(ctx)
	case block.FieldStartParamDefinitions:
		return m.OldStartParamDefinitions(ctx)
	case block.FieldInputParams:
		return m.OldInputParams(ctx)
	case block.FieldUIRepresentation:
		return m.OldUIRepresentation(ctx)
	}
	return nil, fmt.Errorf("unknown Block field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case block.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case block.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case block.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case block.FieldType:
		v, ok := value.(block.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case block.FieldActionType:
		v, ok := value.(flowschema.ActionTypeID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case block.FieldTriggerType:
		v, ok := value.(flowschema.TriggerTypeID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerType(v)
		return nil
	case block.FieldStartParamDefinitions:
		v, ok := value.([]*flowschema.VariableDefinition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartParamDefinitions(v)
		return nil
	case block.FieldInputParams:
		v, ok := value.([]*flowschema.VariableExpression)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputParams(v)
		return nil
	case block.FieldUIRepresentation:
		v, ok := value.(*flowschema.BlockUIRepresentation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUIRepresentation(v)
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BlockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BlockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Block numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BlockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(block.FieldActionType) {
		fields = append(fields, block.FieldActionType)
	}
	if m.FieldCleared(block.FieldTriggerType) {
		fields = append(fields, block.FieldTriggerType)
	}
	if m.FieldCleared(block.FieldStartParamDefinitions) {
		fields = append(fields, block.FieldStartParamDefinitions)
	}
	if m.FieldCleared(block.FieldInputParams) {
		fields = append(fields, block.FieldInputParams)
	}
	if m.FieldCleared(block.FieldUIRepresentation) {
		fields = append(fields, block.FieldUIRepresentation)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockMutation) ClearField(name string) error {
	switch name {
	case block.FieldActionType:
		m.ClearActionType()
		return nil
	case block.FieldTriggerType:
		m.ClearTriggerType()
		return nil
	case block.FieldStartParamDefinitions:
		m.ClearStartParamDefinitions()
		return nil
	case block.FieldInputParams:
		m.ClearInputParams()
		return nil
	case block.FieldUIRepresentation:
		m.ClearUIRepresentation()
		return nil
	}
	return fmt.Errorf("unknown Block nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BlockMutation) ResetField(name string) error {
	switch name {
	case block.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case block.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case block.FieldCid:
		m.ResetCid()
		return nil
	case block.FieldType:
		m.ResetType()
		return nil
	case block.FieldActionType:
		m.ResetActionType()
		return nil
	case block.FieldTriggerType:
		m.ResetTriggerType()
		return nil
	case block.FieldStartParamDefinitions:
		m.ResetStartParamDefinitions()
		return nil
	case block.FieldInputParams:
		m.ResetInputParams()
		return nil
	case block.FieldUIRepresentation:
		m.ResetUIRepresentation()
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.flow != nil {
		edges = append(edges, block.EdgeFlow)
	}
	if m.flow_template != nil {
		edges = append(edges, block.EdgeFlowTemplate)
	}
	if m.flow_draft != nil {
		edges = append(edges, block.EdgeFlowDraft)
	}
	if m.sub_flow != nil {
		edges = append(edges, block.EdgeSubFlow)
	}
	if m.source_block != nil {
		edges = append(edges, block.EdgeSourceBlock)
	}
	if m.goto_block != nil {
		edges = append(edges, block.EdgeGotoBlock)
	}
	if m.instances != nil {
		edges = append(edges, block.EdgeInstances)
	}
	if m.entry_point != nil {
		edges = append(edges, block.EdgeEntryPoint)
	}
	if m.exit_points != nil {
		edges = append(edges, block.EdgeExitPoints)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case block.EdgeFlow:
		if id := m.flow; id != nil {
			return []ent.Value{*id}
		}
	case block.EdgeFlowTemplate:
		if id := m.flow_template; id != nil {
			return []ent.Value{*id}
		}
	case block.EdgeFlowDraft:
		if id := m.flow_draft; id != nil {
			return []ent.Value{*id}
		}
	case block.EdgeSubFlow:
		if id := m.sub_flow; id != nil {
			return []ent.Value{*id}
		}
	case block.EdgeSourceBlock:
		ids := make([]ent.Value, 0, len(m.source_block))
		for id := range m.source_block {
			ids = append(ids, id)
		}
		return ids
	case block.EdgeGotoBlock:
		if id := m.goto_block; id != nil {
			return []ent.Value{*id}
		}
	case block.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case block.EdgeEntryPoint:
		if id := m.entry_point; id != nil {
			return []ent.Value{*id}
		}
	case block.EdgeExitPoints:
		ids := make([]ent.Value, 0, len(m.exit_points))
		for id := range m.exit_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedsource_block != nil {
		edges = append(edges, block.EdgeSourceBlock)
	}
	if m.removedinstances != nil {
		edges = append(edges, block.EdgeInstances)
	}
	if m.removedexit_points != nil {
		edges = append(edges, block.EdgeExitPoints)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BlockMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case block.EdgeSourceBlock:
		ids := make([]ent.Value, 0, len(m.removedsource_block))
		for id := range m.removedsource_block {
			ids = append(ids, id)
		}
		return ids
	case block.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case block.EdgeExitPoints:
		ids := make([]ent.Value, 0, len(m.removedexit_points))
		for id := range m.removedexit_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedflow {
		edges = append(edges, block.EdgeFlow)
	}
	if m.clearedflow_template {
		edges = append(edges, block.EdgeFlowTemplate)
	}
	if m.clearedflow_draft {
		edges = append(edges, block.EdgeFlowDraft)
	}
	if m.clearedsub_flow {
		edges = append(edges, block.EdgeSubFlow)
	}
	if m.clearedsource_block {
		edges = append(edges, block.EdgeSourceBlock)
	}
	if m.clearedgoto_block {
		edges = append(edges, block.EdgeGotoBlock)
	}
	if m.clearedinstances {
		edges = append(edges, block.EdgeInstances)
	}
	if m.clearedentry_point {
		edges = append(edges, block.EdgeEntryPoint)
	}
	if m.clearedexit_points {
		edges = append(edges, block.EdgeExitPoints)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BlockMutation) EdgeCleared(name string) bool {
	switch name {
	case block.EdgeFlow:
		return m.clearedflow
	case block.EdgeFlowTemplate:
		return m.clearedflow_template
	case block.EdgeFlowDraft:
		return m.clearedflow_draft
	case block.EdgeSubFlow:
		return m.clearedsub_flow
	case block.EdgeSourceBlock:
		return m.clearedsource_block
	case block.EdgeGotoBlock:
		return m.clearedgoto_block
	case block.EdgeInstances:
		return m.clearedinstances
	case block.EdgeEntryPoint:
		return m.clearedentry_point
	case block.EdgeExitPoints:
		return m.clearedexit_points
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BlockMutation) ClearEdge(name string) error {
	switch name {
	case block.EdgeFlow:
		m.ClearFlow()
		return nil
	case block.EdgeFlowTemplate:
		m.ClearFlowTemplate()
		return nil
	case block.EdgeFlowDraft:
		m.ClearFlowDraft()
		return nil
	case block.EdgeSubFlow:
		m.ClearSubFlow()
		return nil
	case block.EdgeGotoBlock:
		m.ClearGotoBlock()
		return nil
	case block.EdgeEntryPoint:
		m.ClearEntryPoint()
		return nil
	}
	return fmt.Errorf("unknown Block unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BlockMutation) ResetEdge(name string) error {
	switch name {
	case block.EdgeFlow:
		m.ResetFlow()
		return nil
	case block.EdgeFlowTemplate:
		m.ResetFlowTemplate()
		return nil
	case block.EdgeFlowDraft:
		m.ResetFlowDraft()
		return nil
	case block.EdgeSubFlow:
		m.ResetSubFlow()
		return nil
	case block.EdgeSourceBlock:
		m.ResetSourceBlock()
		return nil
	case block.EdgeGotoBlock:
		m.ResetGotoBlock()
		return nil
	case block.EdgeInstances:
		m.ResetInstances()
		return nil
	case block.EdgeEntryPoint:
		m.ResetEntryPoint()
		return nil
	case block.EdgeExitPoints:
		m.ResetExitPoints()
		return nil
	}
	return fmt.Errorf("unknown Block edge %s", name)
}

// BlockInstanceMutation represents an operation that mutate the BlockInstances
// nodes in the graph.
type BlockInstanceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	create_time               *time.Time
	update_time               *time.Time
	status                    *blockinstance.Status
	inputs                    *[]*flowschema.VariableValue
	outputs                   *[]*flowschema.VariableValue
	failure_reason            *string
	block_instance_counter    *int
	addblock_instance_counter *int
	start_date                *time.Time
	end_date                  *time.Time
	clearedFields             map[string]struct{}
	flow_instance             *int
	clearedflow_instance      bool
	block                     *int
	clearedblock              bool
	subflow_instance          *int
	clearedsubflow_instance   bool
	done                      bool
	oldValue                  func(context.Context) (*BlockInstance, error)
	predicates                []predicate.BlockInstance
}

var _ ent.Mutation = (*BlockInstanceMutation)(nil)

// blockinstanceOption allows to manage the mutation configuration using functional options.
type blockinstanceOption func(*BlockInstanceMutation)

// newBlockInstanceMutation creates new mutation for BlockInstance.
func newBlockInstanceMutation(c config, op Op, opts ...blockinstanceOption) *BlockInstanceMutation {
	m := &BlockInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockInstanceID sets the id field of the mutation.
func withBlockInstanceID(id int) blockinstanceOption {
	return func(m *BlockInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockInstance
		)
		m.oldValue = func(ctx context.Context) (*BlockInstance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockInstance sets the old BlockInstance of the mutation.
func withBlockInstance(node *BlockInstance) blockinstanceOption {
	return func(m *BlockInstanceMutation) {
		m.oldValue = func(context.Context) (*BlockInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BlockInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *BlockInstanceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *BlockInstanceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *BlockInstanceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *BlockInstanceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *BlockInstanceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *BlockInstanceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the status field.
func (m *BlockInstanceMutation) SetStatus(b blockinstance.Status) {
	m.status = &b
}

// Status returns the status value in the mutation.
func (m *BlockInstanceMutation) Status() (r blockinstance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldStatus(ctx context.Context) (v blockinstance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *BlockInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetInputs sets the inputs field.
func (m *BlockInstanceMutation) SetInputs(fv []*flowschema.VariableValue) {
	m.inputs = &fv
}

// Inputs returns the inputs value in the mutation.
func (m *BlockInstanceMutation) Inputs() (r []*flowschema.VariableValue, exists bool) {
	v := m.inputs
	if v == nil {
		return
	}
	return *v, true
}

// OldInputs returns the old inputs value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldInputs(ctx context.Context) (v []*flowschema.VariableValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInputs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputs: %w", err)
	}
	return oldValue.Inputs, nil
}

// ClearInputs clears the value of inputs.
func (m *BlockInstanceMutation) ClearInputs() {
	m.inputs = nil
	m.clearedFields[blockinstance.FieldInputs] = struct{}{}
}

// InputsCleared returns if the field inputs was cleared in this mutation.
func (m *BlockInstanceMutation) InputsCleared() bool {
	_, ok := m.clearedFields[blockinstance.FieldInputs]
	return ok
}

// ResetInputs reset all changes of the "inputs" field.
func (m *BlockInstanceMutation) ResetInputs() {
	m.inputs = nil
	delete(m.clearedFields, blockinstance.FieldInputs)
}

// SetOutputs sets the outputs field.
func (m *BlockInstanceMutation) SetOutputs(fv []*flowschema.VariableValue) {
	m.outputs = &fv
}

// Outputs returns the outputs value in the mutation.
func (m *BlockInstanceMutation) Outputs() (r []*flowschema.VariableValue, exists bool) {
	v := m.outputs
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputs returns the old outputs value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldOutputs(ctx context.Context) (v []*flowschema.VariableValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutputs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutputs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputs: %w", err)
	}
	return oldValue.Outputs, nil
}

// ClearOutputs clears the value of outputs.
func (m *BlockInstanceMutation) ClearOutputs() {
	m.outputs = nil
	m.clearedFields[blockinstance.FieldOutputs] = struct{}{}
}

// OutputsCleared returns if the field outputs was cleared in this mutation.
func (m *BlockInstanceMutation) OutputsCleared() bool {
	_, ok := m.clearedFields[blockinstance.FieldOutputs]
	return ok
}

// ResetOutputs reset all changes of the "outputs" field.
func (m *BlockInstanceMutation) ResetOutputs() {
	m.outputs = nil
	delete(m.clearedFields, blockinstance.FieldOutputs)
}

// SetFailureReason sets the failure_reason field.
func (m *BlockInstanceMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the failure_reason value in the mutation.
func (m *BlockInstanceMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old failure_reason value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldFailureReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFailureReason is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of failure_reason.
func (m *BlockInstanceMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[blockinstance.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the field failure_reason was cleared in this mutation.
func (m *BlockInstanceMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[blockinstance.FieldFailureReason]
	return ok
}

// ResetFailureReason reset all changes of the "failure_reason" field.
func (m *BlockInstanceMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, blockinstance.FieldFailureReason)
}

// SetBlockInstanceCounter sets the block_instance_counter field.
func (m *BlockInstanceMutation) SetBlockInstanceCounter(i int) {
	m.block_instance_counter = &i
	m.addblock_instance_counter = nil
}

// BlockInstanceCounter returns the block_instance_counter value in the mutation.
func (m *BlockInstanceMutation) BlockInstanceCounter() (r int, exists bool) {
	v := m.block_instance_counter
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockInstanceCounter returns the old block_instance_counter value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldBlockInstanceCounter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBlockInstanceCounter is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBlockInstanceCounter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockInstanceCounter: %w", err)
	}
	return oldValue.BlockInstanceCounter, nil
}

// AddBlockInstanceCounter adds i to block_instance_counter.
func (m *BlockInstanceMutation) AddBlockInstanceCounter(i int) {
	if m.addblock_instance_counter != nil {
		*m.addblock_instance_counter += i
	} else {
		m.addblock_instance_counter = &i
	}
}

// AddedBlockInstanceCounter returns the value that was added to the block_instance_counter field in this mutation.
func (m *BlockInstanceMutation) AddedBlockInstanceCounter() (r int, exists bool) {
	v := m.addblock_instance_counter
	if v == nil {
		return
	}
	return *v, true
}

// ClearBlockInstanceCounter clears the value of block_instance_counter.
func (m *BlockInstanceMutation) ClearBlockInstanceCounter() {
	m.block_instance_counter = nil
	m.addblock_instance_counter = nil
	m.clearedFields[blockinstance.FieldBlockInstanceCounter] = struct{}{}
}

// BlockInstanceCounterCleared returns if the field block_instance_counter was cleared in this mutation.
func (m *BlockInstanceMutation) BlockInstanceCounterCleared() bool {
	_, ok := m.clearedFields[blockinstance.FieldBlockInstanceCounter]
	return ok
}

// ResetBlockInstanceCounter reset all changes of the "block_instance_counter" field.
func (m *BlockInstanceMutation) ResetBlockInstanceCounter() {
	m.block_instance_counter = nil
	m.addblock_instance_counter = nil
	delete(m.clearedFields, blockinstance.FieldBlockInstanceCounter)
}

// SetStartDate sets the start_date field.
func (m *BlockInstanceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the start_date value in the mutation.
func (m *BlockInstanceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old start_date value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate reset all changes of the "start_date" field.
func (m *BlockInstanceMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the end_date field.
func (m *BlockInstanceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the end_date value in the mutation.
func (m *BlockInstanceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old end_date value of the BlockInstance.
// If the BlockInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BlockInstanceMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of end_date.
func (m *BlockInstanceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[blockinstance.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the field end_date was cleared in this mutation.
func (m *BlockInstanceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[blockinstance.FieldEndDate]
	return ok
}

// ResetEndDate reset all changes of the "end_date" field.
func (m *BlockInstanceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, blockinstance.FieldEndDate)
}

// SetFlowInstanceID sets the flow_instance edge to FlowInstance by id.
func (m *BlockInstanceMutation) SetFlowInstanceID(id int) {
	m.flow_instance = &id
}

// ClearFlowInstance clears the flow_instance edge to FlowInstance.
func (m *BlockInstanceMutation) ClearFlowInstance() {
	m.clearedflow_instance = true
}

// FlowInstanceCleared returns if the edge flow_instance was cleared.
func (m *BlockInstanceMutation) FlowInstanceCleared() bool {
	return m.clearedflow_instance
}

// FlowInstanceID returns the flow_instance id in the mutation.
func (m *BlockInstanceMutation) FlowInstanceID() (id int, exists bool) {
	if m.flow_instance != nil {
		return *m.flow_instance, true
	}
	return
}

// FlowInstanceIDs returns the flow_instance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowInstanceID instead. It exists only for internal usage by the builders.
func (m *BlockInstanceMutation) FlowInstanceIDs() (ids []int) {
	if id := m.flow_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlowInstance reset all changes of the "flow_instance" edge.
func (m *BlockInstanceMutation) ResetFlowInstance() {
	m.flow_instance = nil
	m.clearedflow_instance = false
}

// SetBlockID sets the block edge to Block by id.
func (m *BlockInstanceMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the block edge to Block.
func (m *BlockInstanceMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared returns if the edge block was cleared.
func (m *BlockInstanceMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the block id in the mutation.
func (m *BlockInstanceMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the block ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *BlockInstanceMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock reset all changes of the "block" edge.
func (m *BlockInstanceMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// SetSubflowInstanceID sets the subflow_instance edge to FlowInstance by id.
func (m *BlockInstanceMutation) SetSubflowInstanceID(id int) {
	m.subflow_instance = &id
}

// ClearSubflowInstance clears the subflow_instance edge to FlowInstance.
func (m *BlockInstanceMutation) ClearSubflowInstance() {
	m.clearedsubflow_instance = true
}

// SubflowInstanceCleared returns if the edge subflow_instance was cleared.
func (m *BlockInstanceMutation) SubflowInstanceCleared() bool {
	return m.clearedsubflow_instance
}

// SubflowInstanceID returns the subflow_instance id in the mutation.
func (m *BlockInstanceMutation) SubflowInstanceID() (id int, exists bool) {
	if m.subflow_instance != nil {
		return *m.subflow_instance, true
	}
	return
}

// SubflowInstanceIDs returns the subflow_instance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SubflowInstanceID instead. It exists only for internal usage by the builders.
func (m *BlockInstanceMutation) SubflowInstanceIDs() (ids []int) {
	if id := m.subflow_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubflowInstance reset all changes of the "subflow_instance" edge.
func (m *BlockInstanceMutation) ResetSubflowInstance() {
	m.subflow_instance = nil
	m.clearedsubflow_instance = false
}

// Op returns the operation name.
func (m *BlockInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BlockInstance).
func (m *BlockInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BlockInstanceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, blockinstance.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, blockinstance.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, blockinstance.FieldStatus)
	}
	if m.inputs != nil {
		fields = append(fields, blockinstance.FieldInputs)
	}
	if m.outputs != nil {
		fields = append(fields, blockinstance.FieldOutputs)
	}
	if m.failure_reason != nil {
		fields = append(fields, blockinstance.FieldFailureReason)
	}
	if m.block_instance_counter != nil {
		fields = append(fields, blockinstance.FieldBlockInstanceCounter)
	}
	if m.start_date != nil {
		fields = append(fields, blockinstance.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, blockinstance.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BlockInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockinstance.FieldCreateTime:
		return m.CreateTime()
	case blockinstance.FieldUpdateTime:
		return m.UpdateTime()
	case blockinstance.FieldStatus:
		return m.Status()
	case blockinstance.FieldInputs:
		return m.Inputs()
	case blockinstance.FieldOutputs:
		return m.Outputs()
	case blockinstance.FieldFailureReason:
		return m.FailureReason()
	case blockinstance.FieldBlockInstanceCounter:
		return m.BlockInstanceCounter()
	case blockinstance.FieldStartDate:
		return m.StartDate()
	case blockinstance.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BlockInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockinstance.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case blockinstance.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case blockinstance.FieldStatus:
		return m.OldStatus(ctx)
	case blockinstance.FieldInputs:
		return m.OldInputs(ctx)
	case blockinstance.FieldOutputs:
		return m.OldOutputs(ctx)
	case blockinstance.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case blockinstance.FieldBlockInstanceCounter:
		return m.OldBlockInstanceCounter(ctx)
	case blockinstance.FieldStartDate:
		return m.OldStartDate(ctx)
	case blockinstance.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown BlockInstance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BlockInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockinstance.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case blockinstance.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case blockinstance.FieldStatus:
		v, ok := value.(blockinstance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blockinstance.FieldInputs:
		v, ok := value.([]*flowschema.VariableValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputs(v)
		return nil
	case blockinstance.FieldOutputs:
		v, ok := value.([]*flowschema.VariableValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputs(v)
		return nil
	case blockinstance.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case blockinstance.FieldBlockInstanceCounter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockInstanceCounter(v)
		return nil
	case blockinstance.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case blockinstance.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown BlockInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BlockInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addblock_instance_counter != nil {
		fields = append(fields, blockinstance.FieldBlockInstanceCounter)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BlockInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockinstance.FieldBlockInstanceCounter:
		return m.AddedBlockInstanceCounter()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BlockInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockinstance.FieldBlockInstanceCounter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockInstanceCounter(v)
		return nil
	}
	return fmt.Errorf("unknown BlockInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BlockInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockinstance.FieldInputs) {
		fields = append(fields, blockinstance.FieldInputs)
	}
	if m.FieldCleared(blockinstance.FieldOutputs) {
		fields = append(fields, blockinstance.FieldOutputs)
	}
	if m.FieldCleared(blockinstance.FieldFailureReason) {
		fields = append(fields, blockinstance.FieldFailureReason)
	}
	if m.FieldCleared(blockinstance.FieldBlockInstanceCounter) {
		fields = append(fields, blockinstance.FieldBlockInstanceCounter)
	}
	if m.FieldCleared(blockinstance.FieldEndDate) {
		fields = append(fields, blockinstance.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BlockInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockInstanceMutation) ClearField(name string) error {
	switch name {
	case blockinstance.FieldInputs:
		m.ClearInputs()
		return nil
	case blockinstance.FieldOutputs:
		m.ClearOutputs()
		return nil
	case blockinstance.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case blockinstance.FieldBlockInstanceCounter:
		m.ClearBlockInstanceCounter()
		return nil
	case blockinstance.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown BlockInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BlockInstanceMutation) ResetField(name string) error {
	switch name {
	case blockinstance.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case blockinstance.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case blockinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case blockinstance.FieldInputs:
		m.ResetInputs()
		return nil
	case blockinstance.FieldOutputs:
		m.ResetOutputs()
		return nil
	case blockinstance.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case blockinstance.FieldBlockInstanceCounter:
		m.ResetBlockInstanceCounter()
		return nil
	case blockinstance.FieldStartDate:
		m.ResetStartDate()
		return nil
	case blockinstance.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown BlockInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BlockInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.flow_instance != nil {
		edges = append(edges, blockinstance.EdgeFlowInstance)
	}
	if m.block != nil {
		edges = append(edges, blockinstance.EdgeBlock)
	}
	if m.subflow_instance != nil {
		edges = append(edges, blockinstance.EdgeSubflowInstance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BlockInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockinstance.EdgeFlowInstance:
		if id := m.flow_instance; id != nil {
			return []ent.Value{*id}
		}
	case blockinstance.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	case blockinstance.EdgeSubflowInstance:
		if id := m.subflow_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BlockInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BlockInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BlockInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedflow_instance {
		edges = append(edges, blockinstance.EdgeFlowInstance)
	}
	if m.clearedblock {
		edges = append(edges, blockinstance.EdgeBlock)
	}
	if m.clearedsubflow_instance {
		edges = append(edges, blockinstance.EdgeSubflowInstance)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BlockInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case blockinstance.EdgeFlowInstance:
		return m.clearedflow_instance
	case blockinstance.EdgeBlock:
		return m.clearedblock
	case blockinstance.EdgeSubflowInstance:
		return m.clearedsubflow_instance
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BlockInstanceMutation) ClearEdge(name string) error {
	switch name {
	case blockinstance.EdgeFlowInstance:
		m.ClearFlowInstance()
		return nil
	case blockinstance.EdgeBlock:
		m.ClearBlock()
		return nil
	case blockinstance.EdgeSubflowInstance:
		m.ClearSubflowInstance()
		return nil
	}
	return fmt.Errorf("unknown BlockInstance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BlockInstanceMutation) ResetEdge(name string) error {
	switch name {
	case blockinstance.EdgeFlowInstance:
		m.ResetFlowInstance()
		return nil
	case blockinstance.EdgeBlock:
		m.ResetBlock()
		return nil
	case blockinstance.EdgeSubflowInstance:
		m.ResetSubflowInstance()
		return nil
	}
	return fmt.Errorf("unknown BlockInstance edge %s", name)
}

// CheckListCategoryMutation represents an operation that mutate the CheckListCategories
// nodes in the graph.
type CheckListCategoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	title                   *string
	description             *string
	clearedFields           map[string]struct{}
	check_list_items        map[int]struct{}
	removedcheck_list_items map[int]struct{}
	clearedcheck_list_items bool
	work_order              *int
	clearedwork_order       bool
	done                    bool
	oldValue                func(context.Context) (*CheckListCategory, error)
	predicates              []predicate.CheckListCategory
}

var _ ent.Mutation = (*CheckListCategoryMutation)(nil)

// checklistcategoryOption allows to manage the mutation configuration using functional options.
type checklistcategoryOption func(*CheckListCategoryMutation)

// newCheckListCategoryMutation creates new mutation for CheckListCategory.
func newCheckListCategoryMutation(c config, op Op, opts ...checklistcategoryOption) *CheckListCategoryMutation {
	m := &CheckListCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckListCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckListCategoryID sets the id field of the mutation.
func withCheckListCategoryID(id int) checklistcategoryOption {
	return func(m *CheckListCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckListCategory
		)
		m.oldValue = func(ctx context.Context) (*CheckListCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckListCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckListCategory sets the old CheckListCategory of the mutation.
func withCheckListCategory(node *CheckListCategory) checklistcategoryOption {
	return func(m *CheckListCategoryMutation) {
		m.oldValue = func(context.Context) (*CheckListCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckListCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckListCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CheckListCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CheckListCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CheckListCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the CheckListCategory.
// If the CheckListCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CheckListCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CheckListCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CheckListCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the CheckListCategory.
// If the CheckListCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CheckListCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the title field.
func (m *CheckListCategoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *CheckListCategoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the CheckListCategory.
// If the CheckListCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *CheckListCategoryMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the description field.
func (m *CheckListCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *CheckListCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the CheckListCategory.
// If the CheckListCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *CheckListCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[checklistcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *CheckListCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[checklistcategory.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *CheckListCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, checklistcategory.FieldDescription)
}

// AddCheckListItemIDs adds the check_list_items edge to CheckListItem by ids.
func (m *CheckListCategoryMutation) AddCheckListItemIDs(ids ...int) {
	if m.check_list_items == nil {
		m.check_list_items = make(map[int]struct{})
	}
	for i := range ids {
		m.check_list_items[ids[i]] = struct{}{}
	}
}

// ClearCheckListItems clears the check_list_items edge to CheckListItem.
func (m *CheckListCategoryMutation) ClearCheckListItems() {
	m.clearedcheck_list_items = true
}

// CheckListItemsCleared returns if the edge check_list_items was cleared.
func (m *CheckListCategoryMutation) CheckListItemsCleared() bool {
	return m.clearedcheck_list_items
}

// RemoveCheckListItemIDs removes the check_list_items edge to CheckListItem by ids.
func (m *CheckListCategoryMutation) RemoveCheckListItemIDs(ids ...int) {
	if m.removedcheck_list_items == nil {
		m.removedcheck_list_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheck_list_items[ids[i]] = struct{}{}
	}
}

// RemovedCheckListItems returns the removed ids of check_list_items.
func (m *CheckListCategoryMutation) RemovedCheckListItemsIDs() (ids []int) {
	for id := range m.removedcheck_list_items {
		ids = append(ids, id)
	}
	return
}

// CheckListItemsIDs returns the check_list_items ids in the mutation.
func (m *CheckListCategoryMutation) CheckListItemsIDs() (ids []int) {
	for id := range m.check_list_items {
		ids = append(ids, id)
	}
	return
}

// ResetCheckListItems reset all changes of the "check_list_items" edge.
func (m *CheckListCategoryMutation) ResetCheckListItems() {
	m.check_list_items = nil
	m.clearedcheck_list_items = false
	m.removedcheck_list_items = nil
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *CheckListCategoryMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *CheckListCategoryMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *CheckListCategoryMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *CheckListCategoryMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *CheckListCategoryMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *CheckListCategoryMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// Op returns the operation name.
func (m *CheckListCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CheckListCategory).
func (m *CheckListCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CheckListCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, checklistcategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, checklistcategory.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, checklistcategory.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, checklistcategory.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CheckListCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checklistcategory.FieldCreateTime:
		return m.CreateTime()
	case checklistcategory.FieldUpdateTime:
		return m.UpdateTime()
	case checklistcategory.FieldTitle:
		return m.Title()
	case checklistcategory.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CheckListCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checklistcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case checklistcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case checklistcategory.FieldTitle:
		return m.OldTitle(ctx)
	case checklistcategory.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CheckListCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checklistcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case checklistcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case checklistcategory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case checklistcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CheckListCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CheckListCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CheckListCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CheckListCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CheckListCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checklistcategory.FieldDescription) {
		fields = append(fields, checklistcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CheckListCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckListCategoryMutation) ClearField(name string) error {
	switch name {
	case checklistcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CheckListCategoryMutation) ResetField(name string) error {
	switch name {
	case checklistcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case checklistcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case checklistcategory.FieldTitle:
		m.ResetTitle()
		return nil
	case checklistcategory.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CheckListCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.check_list_items != nil {
		edges = append(edges, checklistcategory.EdgeCheckListItems)
	}
	if m.work_order != nil {
		edges = append(edges, checklistcategory.EdgeWorkOrder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CheckListCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checklistcategory.EdgeCheckListItems:
		ids := make([]ent.Value, 0, len(m.check_list_items))
		for id := range m.check_list_items {
			ids = append(ids, id)
		}
		return ids
	case checklistcategory.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CheckListCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcheck_list_items != nil {
		edges = append(edges, checklistcategory.EdgeCheckListItems)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CheckListCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case checklistcategory.EdgeCheckListItems:
		ids := make([]ent.Value, 0, len(m.removedcheck_list_items))
		for id := range m.removedcheck_list_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CheckListCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcheck_list_items {
		edges = append(edges, checklistcategory.EdgeCheckListItems)
	}
	if m.clearedwork_order {
		edges = append(edges, checklistcategory.EdgeWorkOrder)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CheckListCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case checklistcategory.EdgeCheckListItems:
		return m.clearedcheck_list_items
	case checklistcategory.EdgeWorkOrder:
		return m.clearedwork_order
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CheckListCategoryMutation) ClearEdge(name string) error {
	switch name {
	case checklistcategory.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CheckListCategoryMutation) ResetEdge(name string) error {
	switch name {
	case checklistcategory.EdgeCheckListItems:
		m.ResetCheckListItems()
		return nil
	case checklistcategory.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategory edge %s", name)
}

// CheckListCategoryDefinitionMutation represents an operation that mutate the CheckListCategoryDefinitions
// nodes in the graph.
type CheckListCategoryDefinitionMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	create_time                        *time.Time
	update_time                        *time.Time
	title                              *string
	description                        *string
	clearedFields                      map[string]struct{}
	check_list_item_definitions        map[int]struct{}
	removedcheck_list_item_definitions map[int]struct{}
	clearedcheck_list_item_definitions bool
	work_order_type                    *int
	clearedwork_order_type             bool
	work_order_template                *int
	clearedwork_order_template         bool
	done                               bool
	oldValue                           func(context.Context) (*CheckListCategoryDefinition, error)
	predicates                         []predicate.CheckListCategoryDefinition
}

var _ ent.Mutation = (*CheckListCategoryDefinitionMutation)(nil)

// checklistcategorydefinitionOption allows to manage the mutation configuration using functional options.
type checklistcategorydefinitionOption func(*CheckListCategoryDefinitionMutation)

// newCheckListCategoryDefinitionMutation creates new mutation for CheckListCategoryDefinition.
func newCheckListCategoryDefinitionMutation(c config, op Op, opts ...checklistcategorydefinitionOption) *CheckListCategoryDefinitionMutation {
	m := &CheckListCategoryDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckListCategoryDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckListCategoryDefinitionID sets the id field of the mutation.
func withCheckListCategoryDefinitionID(id int) checklistcategorydefinitionOption {
	return func(m *CheckListCategoryDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckListCategoryDefinition
		)
		m.oldValue = func(ctx context.Context) (*CheckListCategoryDefinition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckListCategoryDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckListCategoryDefinition sets the old CheckListCategoryDefinition of the mutation.
func withCheckListCategoryDefinition(node *CheckListCategoryDefinition) checklistcategorydefinitionOption {
	return func(m *CheckListCategoryDefinitionMutation) {
		m.oldValue = func(context.Context) (*CheckListCategoryDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckListCategoryDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckListCategoryDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CheckListCategoryDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CheckListCategoryDefinitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CheckListCategoryDefinitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the CheckListCategoryDefinition.
// If the CheckListCategoryDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryDefinitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CheckListCategoryDefinitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CheckListCategoryDefinitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CheckListCategoryDefinitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the CheckListCategoryDefinition.
// If the CheckListCategoryDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryDefinitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CheckListCategoryDefinitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the title field.
func (m *CheckListCategoryDefinitionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *CheckListCategoryDefinitionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the CheckListCategoryDefinition.
// If the CheckListCategoryDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryDefinitionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *CheckListCategoryDefinitionMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the description field.
func (m *CheckListCategoryDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *CheckListCategoryDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the CheckListCategoryDefinition.
// If the CheckListCategoryDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListCategoryDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *CheckListCategoryDefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[checklistcategorydefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *CheckListCategoryDefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[checklistcategorydefinition.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *CheckListCategoryDefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, checklistcategorydefinition.FieldDescription)
}

// AddCheckListItemDefinitionIDs adds the check_list_item_definitions edge to CheckListItemDefinition by ids.
func (m *CheckListCategoryDefinitionMutation) AddCheckListItemDefinitionIDs(ids ...int) {
	if m.check_list_item_definitions == nil {
		m.check_list_item_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.check_list_item_definitions[ids[i]] = struct{}{}
	}
}

// ClearCheckListItemDefinitions clears the check_list_item_definitions edge to CheckListItemDefinition.
func (m *CheckListCategoryDefinitionMutation) ClearCheckListItemDefinitions() {
	m.clearedcheck_list_item_definitions = true
}

// CheckListItemDefinitionsCleared returns if the edge check_list_item_definitions was cleared.
func (m *CheckListCategoryDefinitionMutation) CheckListItemDefinitionsCleared() bool {
	return m.clearedcheck_list_item_definitions
}

// RemoveCheckListItemDefinitionIDs removes the check_list_item_definitions edge to CheckListItemDefinition by ids.
func (m *CheckListCategoryDefinitionMutation) RemoveCheckListItemDefinitionIDs(ids ...int) {
	if m.removedcheck_list_item_definitions == nil {
		m.removedcheck_list_item_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheck_list_item_definitions[ids[i]] = struct{}{}
	}
}

// RemovedCheckListItemDefinitions returns the removed ids of check_list_item_definitions.
func (m *CheckListCategoryDefinitionMutation) RemovedCheckListItemDefinitionsIDs() (ids []int) {
	for id := range m.removedcheck_list_item_definitions {
		ids = append(ids, id)
	}
	return
}

// CheckListItemDefinitionsIDs returns the check_list_item_definitions ids in the mutation.
func (m *CheckListCategoryDefinitionMutation) CheckListItemDefinitionsIDs() (ids []int) {
	for id := range m.check_list_item_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetCheckListItemDefinitions reset all changes of the "check_list_item_definitions" edge.
func (m *CheckListCategoryDefinitionMutation) ResetCheckListItemDefinitions() {
	m.check_list_item_definitions = nil
	m.clearedcheck_list_item_definitions = false
	m.removedcheck_list_item_definitions = nil
}

// SetWorkOrderTypeID sets the work_order_type edge to WorkOrderType by id.
func (m *CheckListCategoryDefinitionMutation) SetWorkOrderTypeID(id int) {
	m.work_order_type = &id
}

// ClearWorkOrderType clears the work_order_type edge to WorkOrderType.
func (m *CheckListCategoryDefinitionMutation) ClearWorkOrderType() {
	m.clearedwork_order_type = true
}

// WorkOrderTypeCleared returns if the edge work_order_type was cleared.
func (m *CheckListCategoryDefinitionMutation) WorkOrderTypeCleared() bool {
	return m.clearedwork_order_type
}

// WorkOrderTypeID returns the work_order_type id in the mutation.
func (m *CheckListCategoryDefinitionMutation) WorkOrderTypeID() (id int, exists bool) {
	if m.work_order_type != nil {
		return *m.work_order_type, true
	}
	return
}

// WorkOrderTypeIDs returns the work_order_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderTypeID instead. It exists only for internal usage by the builders.
func (m *CheckListCategoryDefinitionMutation) WorkOrderTypeIDs() (ids []int) {
	if id := m.work_order_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrderType reset all changes of the "work_order_type" edge.
func (m *CheckListCategoryDefinitionMutation) ResetWorkOrderType() {
	m.work_order_type = nil
	m.clearedwork_order_type = false
}

// SetWorkOrderTemplateID sets the work_order_template edge to WorkOrderTemplate by id.
func (m *CheckListCategoryDefinitionMutation) SetWorkOrderTemplateID(id int) {
	m.work_order_template = &id
}

// ClearWorkOrderTemplate clears the work_order_template edge to WorkOrderTemplate.
func (m *CheckListCategoryDefinitionMutation) ClearWorkOrderTemplate() {
	m.clearedwork_order_template = true
}

// WorkOrderTemplateCleared returns if the edge work_order_template was cleared.
func (m *CheckListCategoryDefinitionMutation) WorkOrderTemplateCleared() bool {
	return m.clearedwork_order_template
}

// WorkOrderTemplateID returns the work_order_template id in the mutation.
func (m *CheckListCategoryDefinitionMutation) WorkOrderTemplateID() (id int, exists bool) {
	if m.work_order_template != nil {
		return *m.work_order_template, true
	}
	return
}

// WorkOrderTemplateIDs returns the work_order_template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderTemplateID instead. It exists only for internal usage by the builders.
func (m *CheckListCategoryDefinitionMutation) WorkOrderTemplateIDs() (ids []int) {
	if id := m.work_order_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrderTemplate reset all changes of the "work_order_template" edge.
func (m *CheckListCategoryDefinitionMutation) ResetWorkOrderTemplate() {
	m.work_order_template = nil
	m.clearedwork_order_template = false
}

// Op returns the operation name.
func (m *CheckListCategoryDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CheckListCategoryDefinition).
func (m *CheckListCategoryDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CheckListCategoryDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, checklistcategorydefinition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, checklistcategorydefinition.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, checklistcategorydefinition.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, checklistcategorydefinition.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CheckListCategoryDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checklistcategorydefinition.FieldCreateTime:
		return m.CreateTime()
	case checklistcategorydefinition.FieldUpdateTime:
		return m.UpdateTime()
	case checklistcategorydefinition.FieldTitle:
		return m.Title()
	case checklistcategorydefinition.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CheckListCategoryDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checklistcategorydefinition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case checklistcategorydefinition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case checklistcategorydefinition.FieldTitle:
		return m.OldTitle(ctx)
	case checklistcategorydefinition.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CheckListCategoryDefinition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListCategoryDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checklistcategorydefinition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case checklistcategorydefinition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case checklistcategorydefinition.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case checklistcategorydefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CheckListCategoryDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CheckListCategoryDefinitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CheckListCategoryDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListCategoryDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CheckListCategoryDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CheckListCategoryDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checklistcategorydefinition.FieldDescription) {
		fields = append(fields, checklistcategorydefinition.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CheckListCategoryDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckListCategoryDefinitionMutation) ClearField(name string) error {
	switch name {
	case checklistcategorydefinition.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategoryDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CheckListCategoryDefinitionMutation) ResetField(name string) error {
	switch name {
	case checklistcategorydefinition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case checklistcategorydefinition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case checklistcategorydefinition.FieldTitle:
		m.ResetTitle()
		return nil
	case checklistcategorydefinition.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategoryDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CheckListCategoryDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.check_list_item_definitions != nil {
		edges = append(edges, checklistcategorydefinition.EdgeCheckListItemDefinitions)
	}
	if m.work_order_type != nil {
		edges = append(edges, checklistcategorydefinition.EdgeWorkOrderType)
	}
	if m.work_order_template != nil {
		edges = append(edges, checklistcategorydefinition.EdgeWorkOrderTemplate)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CheckListCategoryDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checklistcategorydefinition.EdgeCheckListItemDefinitions:
		ids := make([]ent.Value, 0, len(m.check_list_item_definitions))
		for id := range m.check_list_item_definitions {
			ids = append(ids, id)
		}
		return ids
	case checklistcategorydefinition.EdgeWorkOrderType:
		if id := m.work_order_type; id != nil {
			return []ent.Value{*id}
		}
	case checklistcategorydefinition.EdgeWorkOrderTemplate:
		if id := m.work_order_template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CheckListCategoryDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcheck_list_item_definitions != nil {
		edges = append(edges, checklistcategorydefinition.EdgeCheckListItemDefinitions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CheckListCategoryDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case checklistcategorydefinition.EdgeCheckListItemDefinitions:
		ids := make([]ent.Value, 0, len(m.removedcheck_list_item_definitions))
		for id := range m.removedcheck_list_item_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CheckListCategoryDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcheck_list_item_definitions {
		edges = append(edges, checklistcategorydefinition.EdgeCheckListItemDefinitions)
	}
	if m.clearedwork_order_type {
		edges = append(edges, checklistcategorydefinition.EdgeWorkOrderType)
	}
	if m.clearedwork_order_template {
		edges = append(edges, checklistcategorydefinition.EdgeWorkOrderTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CheckListCategoryDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case checklistcategorydefinition.EdgeCheckListItemDefinitions:
		return m.clearedcheck_list_item_definitions
	case checklistcategorydefinition.EdgeWorkOrderType:
		return m.clearedwork_order_type
	case checklistcategorydefinition.EdgeWorkOrderTemplate:
		return m.clearedwork_order_template
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CheckListCategoryDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case checklistcategorydefinition.EdgeWorkOrderType:
		m.ClearWorkOrderType()
		return nil
	case checklistcategorydefinition.EdgeWorkOrderTemplate:
		m.ClearWorkOrderTemplate()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategoryDefinition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CheckListCategoryDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case checklistcategorydefinition.EdgeCheckListItemDefinitions:
		m.ResetCheckListItemDefinitions()
		return nil
	case checklistcategorydefinition.EdgeWorkOrderType:
		m.ResetWorkOrderType()
		return nil
	case checklistcategorydefinition.EdgeWorkOrderTemplate:
		m.ResetWorkOrderTemplate()
		return nil
	}
	return fmt.Errorf("unknown CheckListCategoryDefinition edge %s", name)
}

// CheckListItemMutation represents an operation that mutate the CheckListItems
// nodes in the graph.
type CheckListItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	title                      *string
	_type                      *enum.CheckListItemType
	index                      *int
	addindex                   *int
	is_mandatory               *bool
	checked                    *bool
	string_val                 *string
	enum_values                *string
	enum_selection_mode_value  *enum.CheckListItemEnumSelectionMode
	selected_enum_values       *string
	yes_no_val                 *checklistitem.YesNoVal
	help_text                  *string
	clearedFields              map[string]struct{}
	files                      map[int]struct{}
	removedfiles               map[int]struct{}
	clearedfiles               bool
	wifi_scan                  map[int]struct{}
	removedwifi_scan           map[int]struct{}
	clearedwifi_scan           bool
	cell_scan                  map[int]struct{}
	removedcell_scan           map[int]struct{}
	clearedcell_scan           bool
	check_list_category        *int
	clearedcheck_list_category bool
	done                       bool
	oldValue                   func(context.Context) (*CheckListItem, error)
	predicates                 []predicate.CheckListItem
}

var _ ent.Mutation = (*CheckListItemMutation)(nil)

// checklistitemOption allows to manage the mutation configuration using functional options.
type checklistitemOption func(*CheckListItemMutation)

// newCheckListItemMutation creates new mutation for CheckListItem.
func newCheckListItemMutation(c config, op Op, opts ...checklistitemOption) *CheckListItemMutation {
	m := &CheckListItemMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckListItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckListItemID sets the id field of the mutation.
func withCheckListItemID(id int) checklistitemOption {
	return func(m *CheckListItemMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckListItem
		)
		m.oldValue = func(ctx context.Context) (*CheckListItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckListItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckListItem sets the old CheckListItem of the mutation.
func withCheckListItem(node *CheckListItem) checklistitemOption {
	return func(m *CheckListItemMutation) {
		m.oldValue = func(context.Context) (*CheckListItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckListItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckListItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CheckListItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTitle sets the title field.
func (m *CheckListItemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *CheckListItemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *CheckListItemMutation) ResetTitle() {
	m.title = nil
}

// SetType sets the type field.
func (m *CheckListItemMutation) SetType(elit enum.CheckListItemType) {
	m._type = &elit
}

// GetType returns the type value in the mutation.
func (m *CheckListItemMutation) GetType() (r enum.CheckListItemType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldType(ctx context.Context) (v enum.CheckListItemType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *CheckListItemMutation) ResetType() {
	m._type = nil
}

// SetIndex sets the index field.
func (m *CheckListItemMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *CheckListItemMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *CheckListItemMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *CheckListItemMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *CheckListItemMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[checklistitem.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *CheckListItemMutation) IndexCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *CheckListItemMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, checklistitem.FieldIndex)
}

// SetIsMandatory sets the is_mandatory field.
func (m *CheckListItemMutation) SetIsMandatory(b bool) {
	m.is_mandatory = &b
}

// IsMandatory returns the is_mandatory value in the mutation.
func (m *CheckListItemMutation) IsMandatory() (r bool, exists bool) {
	v := m.is_mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMandatory returns the old is_mandatory value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldIsMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsMandatory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMandatory: %w", err)
	}
	return oldValue.IsMandatory, nil
}

// ClearIsMandatory clears the value of is_mandatory.
func (m *CheckListItemMutation) ClearIsMandatory() {
	m.is_mandatory = nil
	m.clearedFields[checklistitem.FieldIsMandatory] = struct{}{}
}

// IsMandatoryCleared returns if the field is_mandatory was cleared in this mutation.
func (m *CheckListItemMutation) IsMandatoryCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldIsMandatory]
	return ok
}

// ResetIsMandatory reset all changes of the "is_mandatory" field.
func (m *CheckListItemMutation) ResetIsMandatory() {
	m.is_mandatory = nil
	delete(m.clearedFields, checklistitem.FieldIsMandatory)
}

// SetChecked sets the checked field.
func (m *CheckListItemMutation) SetChecked(b bool) {
	m.checked = &b
}

// Checked returns the checked value in the mutation.
func (m *CheckListItemMutation) Checked() (r bool, exists bool) {
	v := m.checked
	if v == nil {
		return
	}
	return *v, true
}

// OldChecked returns the old checked value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldChecked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChecked is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChecked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecked: %w", err)
	}
	return oldValue.Checked, nil
}

// ClearChecked clears the value of checked.
func (m *CheckListItemMutation) ClearChecked() {
	m.checked = nil
	m.clearedFields[checklistitem.FieldChecked] = struct{}{}
}

// CheckedCleared returns if the field checked was cleared in this mutation.
func (m *CheckListItemMutation) CheckedCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldChecked]
	return ok
}

// ResetChecked reset all changes of the "checked" field.
func (m *CheckListItemMutation) ResetChecked() {
	m.checked = nil
	delete(m.clearedFields, checklistitem.FieldChecked)
}

// SetStringVal sets the string_val field.
func (m *CheckListItemMutation) SetStringVal(s string) {
	m.string_val = &s
}

// StringVal returns the string_val value in the mutation.
func (m *CheckListItemMutation) StringVal() (r string, exists bool) {
	v := m.string_val
	if v == nil {
		return
	}
	return *v, true
}

// OldStringVal returns the old string_val value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldStringVal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringVal: %w", err)
	}
	return oldValue.StringVal, nil
}

// ClearStringVal clears the value of string_val.
func (m *CheckListItemMutation) ClearStringVal() {
	m.string_val = nil
	m.clearedFields[checklistitem.FieldStringVal] = struct{}{}
}

// StringValCleared returns if the field string_val was cleared in this mutation.
func (m *CheckListItemMutation) StringValCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldStringVal]
	return ok
}

// ResetStringVal reset all changes of the "string_val" field.
func (m *CheckListItemMutation) ResetStringVal() {
	m.string_val = nil
	delete(m.clearedFields, checklistitem.FieldStringVal)
}

// SetEnumValues sets the enum_values field.
func (m *CheckListItemMutation) SetEnumValues(s string) {
	m.enum_values = &s
}

// EnumValues returns the enum_values value in the mutation.
func (m *CheckListItemMutation) EnumValues() (r string, exists bool) {
	v := m.enum_values
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumValues returns the old enum_values value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldEnumValues(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnumValues is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnumValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumValues: %w", err)
	}
	return oldValue.EnumValues, nil
}

// ClearEnumValues clears the value of enum_values.
func (m *CheckListItemMutation) ClearEnumValues() {
	m.enum_values = nil
	m.clearedFields[checklistitem.FieldEnumValues] = struct{}{}
}

// EnumValuesCleared returns if the field enum_values was cleared in this mutation.
func (m *CheckListItemMutation) EnumValuesCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldEnumValues]
	return ok
}

// ResetEnumValues reset all changes of the "enum_values" field.
func (m *CheckListItemMutation) ResetEnumValues() {
	m.enum_values = nil
	delete(m.clearedFields, checklistitem.FieldEnumValues)
}

// SetEnumSelectionModeValue sets the enum_selection_mode_value field.
func (m *CheckListItemMutation) SetEnumSelectionModeValue(eliesm enum.CheckListItemEnumSelectionMode) {
	m.enum_selection_mode_value = &eliesm
}

// EnumSelectionModeValue returns the enum_selection_mode_value value in the mutation.
func (m *CheckListItemMutation) EnumSelectionModeValue() (r enum.CheckListItemEnumSelectionMode, exists bool) {
	v := m.enum_selection_mode_value
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumSelectionModeValue returns the old enum_selection_mode_value value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldEnumSelectionModeValue(ctx context.Context) (v *enum.CheckListItemEnumSelectionMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnumSelectionModeValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnumSelectionModeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumSelectionModeValue: %w", err)
	}
	return oldValue.EnumSelectionModeValue, nil
}

// ClearEnumSelectionModeValue clears the value of enum_selection_mode_value.
func (m *CheckListItemMutation) ClearEnumSelectionModeValue() {
	m.enum_selection_mode_value = nil
	m.clearedFields[checklistitem.FieldEnumSelectionModeValue] = struct{}{}
}

// EnumSelectionModeValueCleared returns if the field enum_selection_mode_value was cleared in this mutation.
func (m *CheckListItemMutation) EnumSelectionModeValueCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldEnumSelectionModeValue]
	return ok
}

// ResetEnumSelectionModeValue reset all changes of the "enum_selection_mode_value" field.
func (m *CheckListItemMutation) ResetEnumSelectionModeValue() {
	m.enum_selection_mode_value = nil
	delete(m.clearedFields, checklistitem.FieldEnumSelectionModeValue)
}

// SetSelectedEnumValues sets the selected_enum_values field.
func (m *CheckListItemMutation) SetSelectedEnumValues(s string) {
	m.selected_enum_values = &s
}

// SelectedEnumValues returns the selected_enum_values value in the mutation.
func (m *CheckListItemMutation) SelectedEnumValues() (r string, exists bool) {
	v := m.selected_enum_values
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedEnumValues returns the old selected_enum_values value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldSelectedEnumValues(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelectedEnumValues is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelectedEnumValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedEnumValues: %w", err)
	}
	return oldValue.SelectedEnumValues, nil
}

// ClearSelectedEnumValues clears the value of selected_enum_values.
func (m *CheckListItemMutation) ClearSelectedEnumValues() {
	m.selected_enum_values = nil
	m.clearedFields[checklistitem.FieldSelectedEnumValues] = struct{}{}
}

// SelectedEnumValuesCleared returns if the field selected_enum_values was cleared in this mutation.
func (m *CheckListItemMutation) SelectedEnumValuesCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldSelectedEnumValues]
	return ok
}

// ResetSelectedEnumValues reset all changes of the "selected_enum_values" field.
func (m *CheckListItemMutation) ResetSelectedEnumValues() {
	m.selected_enum_values = nil
	delete(m.clearedFields, checklistitem.FieldSelectedEnumValues)
}

// SetYesNoVal sets the yes_no_val field.
func (m *CheckListItemMutation) SetYesNoVal(cnv checklistitem.YesNoVal) {
	m.yes_no_val = &cnv
}

// YesNoVal returns the yes_no_val value in the mutation.
func (m *CheckListItemMutation) YesNoVal() (r checklistitem.YesNoVal, exists bool) {
	v := m.yes_no_val
	if v == nil {
		return
	}
	return *v, true
}

// OldYesNoVal returns the old yes_no_val value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldYesNoVal(ctx context.Context) (v *checklistitem.YesNoVal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldYesNoVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldYesNoVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYesNoVal: %w", err)
	}
	return oldValue.YesNoVal, nil
}

// ClearYesNoVal clears the value of yes_no_val.
func (m *CheckListItemMutation) ClearYesNoVal() {
	m.yes_no_val = nil
	m.clearedFields[checklistitem.FieldYesNoVal] = struct{}{}
}

// YesNoValCleared returns if the field yes_no_val was cleared in this mutation.
func (m *CheckListItemMutation) YesNoValCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldYesNoVal]
	return ok
}

// ResetYesNoVal reset all changes of the "yes_no_val" field.
func (m *CheckListItemMutation) ResetYesNoVal() {
	m.yes_no_val = nil
	delete(m.clearedFields, checklistitem.FieldYesNoVal)
}

// SetHelpText sets the help_text field.
func (m *CheckListItemMutation) SetHelpText(s string) {
	m.help_text = &s
}

// HelpText returns the help_text value in the mutation.
func (m *CheckListItemMutation) HelpText() (r string, exists bool) {
	v := m.help_text
	if v == nil {
		return
	}
	return *v, true
}

// OldHelpText returns the old help_text value of the CheckListItem.
// If the CheckListItem object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemMutation) OldHelpText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHelpText is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHelpText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHelpText: %w", err)
	}
	return oldValue.HelpText, nil
}

// ClearHelpText clears the value of help_text.
func (m *CheckListItemMutation) ClearHelpText() {
	m.help_text = nil
	m.clearedFields[checklistitem.FieldHelpText] = struct{}{}
}

// HelpTextCleared returns if the field help_text was cleared in this mutation.
func (m *CheckListItemMutation) HelpTextCleared() bool {
	_, ok := m.clearedFields[checklistitem.FieldHelpText]
	return ok
}

// ResetHelpText reset all changes of the "help_text" field.
func (m *CheckListItemMutation) ResetHelpText() {
	m.help_text = nil
	delete(m.clearedFields, checklistitem.FieldHelpText)
}

// AddFileIDs adds the files edge to File by ids.
func (m *CheckListItemMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the files edge to File.
func (m *CheckListItemMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared returns if the edge files was cleared.
func (m *CheckListItemMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the files edge to File by ids.
func (m *CheckListItemMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed ids of files.
func (m *CheckListItemMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the files ids in the mutation.
func (m *CheckListItemMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles reset all changes of the "files" edge.
func (m *CheckListItemMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddWifiScanIDs adds the wifi_scan edge to SurveyWiFiScan by ids.
func (m *CheckListItemMutation) AddWifiScanIDs(ids ...int) {
	if m.wifi_scan == nil {
		m.wifi_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.wifi_scan[ids[i]] = struct{}{}
	}
}

// ClearWifiScan clears the wifi_scan edge to SurveyWiFiScan.
func (m *CheckListItemMutation) ClearWifiScan() {
	m.clearedwifi_scan = true
}

// WifiScanCleared returns if the edge wifi_scan was cleared.
func (m *CheckListItemMutation) WifiScanCleared() bool {
	return m.clearedwifi_scan
}

// RemoveWifiScanIDs removes the wifi_scan edge to SurveyWiFiScan by ids.
func (m *CheckListItemMutation) RemoveWifiScanIDs(ids ...int) {
	if m.removedwifi_scan == nil {
		m.removedwifi_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwifi_scan[ids[i]] = struct{}{}
	}
}

// RemovedWifiScan returns the removed ids of wifi_scan.
func (m *CheckListItemMutation) RemovedWifiScanIDs() (ids []int) {
	for id := range m.removedwifi_scan {
		ids = append(ids, id)
	}
	return
}

// WifiScanIDs returns the wifi_scan ids in the mutation.
func (m *CheckListItemMutation) WifiScanIDs() (ids []int) {
	for id := range m.wifi_scan {
		ids = append(ids, id)
	}
	return
}

// ResetWifiScan reset all changes of the "wifi_scan" edge.
func (m *CheckListItemMutation) ResetWifiScan() {
	m.wifi_scan = nil
	m.clearedwifi_scan = false
	m.removedwifi_scan = nil
}

// AddCellScanIDs adds the cell_scan edge to SurveyCellScan by ids.
func (m *CheckListItemMutation) AddCellScanIDs(ids ...int) {
	if m.cell_scan == nil {
		m.cell_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.cell_scan[ids[i]] = struct{}{}
	}
}

// ClearCellScan clears the cell_scan edge to SurveyCellScan.
func (m *CheckListItemMutation) ClearCellScan() {
	m.clearedcell_scan = true
}

// CellScanCleared returns if the edge cell_scan was cleared.
func (m *CheckListItemMutation) CellScanCleared() bool {
	return m.clearedcell_scan
}

// RemoveCellScanIDs removes the cell_scan edge to SurveyCellScan by ids.
func (m *CheckListItemMutation) RemoveCellScanIDs(ids ...int) {
	if m.removedcell_scan == nil {
		m.removedcell_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcell_scan[ids[i]] = struct{}{}
	}
}

// RemovedCellScan returns the removed ids of cell_scan.
func (m *CheckListItemMutation) RemovedCellScanIDs() (ids []int) {
	for id := range m.removedcell_scan {
		ids = append(ids, id)
	}
	return
}

// CellScanIDs returns the cell_scan ids in the mutation.
func (m *CheckListItemMutation) CellScanIDs() (ids []int) {
	for id := range m.cell_scan {
		ids = append(ids, id)
	}
	return
}

// ResetCellScan reset all changes of the "cell_scan" edge.
func (m *CheckListItemMutation) ResetCellScan() {
	m.cell_scan = nil
	m.clearedcell_scan = false
	m.removedcell_scan = nil
}

// SetCheckListCategoryID sets the check_list_category edge to CheckListCategory by id.
func (m *CheckListItemMutation) SetCheckListCategoryID(id int) {
	m.check_list_category = &id
}

// ClearCheckListCategory clears the check_list_category edge to CheckListCategory.
func (m *CheckListItemMutation) ClearCheckListCategory() {
	m.clearedcheck_list_category = true
}

// CheckListCategoryCleared returns if the edge check_list_category was cleared.
func (m *CheckListItemMutation) CheckListCategoryCleared() bool {
	return m.clearedcheck_list_category
}

// CheckListCategoryID returns the check_list_category id in the mutation.
func (m *CheckListItemMutation) CheckListCategoryID() (id int, exists bool) {
	if m.check_list_category != nil {
		return *m.check_list_category, true
	}
	return
}

// CheckListCategoryIDs returns the check_list_category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CheckListCategoryID instead. It exists only for internal usage by the builders.
func (m *CheckListItemMutation) CheckListCategoryIDs() (ids []int) {
	if id := m.check_list_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheckListCategory reset all changes of the "check_list_category" edge.
func (m *CheckListItemMutation) ResetCheckListCategory() {
	m.check_list_category = nil
	m.clearedcheck_list_category = false
}

// Op returns the operation name.
func (m *CheckListItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CheckListItem).
func (m *CheckListItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CheckListItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, checklistitem.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, checklistitem.FieldType)
	}
	if m.index != nil {
		fields = append(fields, checklistitem.FieldIndex)
	}
	if m.is_mandatory != nil {
		fields = append(fields, checklistitem.FieldIsMandatory)
	}
	if m.checked != nil {
		fields = append(fields, checklistitem.FieldChecked)
	}
	if m.string_val != nil {
		fields = append(fields, checklistitem.FieldStringVal)
	}
	if m.enum_values != nil {
		fields = append(fields, checklistitem.FieldEnumValues)
	}
	if m.enum_selection_mode_value != nil {
		fields = append(fields, checklistitem.FieldEnumSelectionModeValue)
	}
	if m.selected_enum_values != nil {
		fields = append(fields, checklistitem.FieldSelectedEnumValues)
	}
	if m.yes_no_val != nil {
		fields = append(fields, checklistitem.FieldYesNoVal)
	}
	if m.help_text != nil {
		fields = append(fields, checklistitem.FieldHelpText)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CheckListItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checklistitem.FieldTitle:
		return m.Title()
	case checklistitem.FieldType:
		return m.GetType()
	case checklistitem.FieldIndex:
		return m.Index()
	case checklistitem.FieldIsMandatory:
		return m.IsMandatory()
	case checklistitem.FieldChecked:
		return m.Checked()
	case checklistitem.FieldStringVal:
		return m.StringVal()
	case checklistitem.FieldEnumValues:
		return m.EnumValues()
	case checklistitem.FieldEnumSelectionModeValue:
		return m.EnumSelectionModeValue()
	case checklistitem.FieldSelectedEnumValues:
		return m.SelectedEnumValues()
	case checklistitem.FieldYesNoVal:
		return m.YesNoVal()
	case checklistitem.FieldHelpText:
		return m.HelpText()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CheckListItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checklistitem.FieldTitle:
		return m.OldTitle(ctx)
	case checklistitem.FieldType:
		return m.OldType(ctx)
	case checklistitem.FieldIndex:
		return m.OldIndex(ctx)
	case checklistitem.FieldIsMandatory:
		return m.OldIsMandatory(ctx)
	case checklistitem.FieldChecked:
		return m.OldChecked(ctx)
	case checklistitem.FieldStringVal:
		return m.OldStringVal(ctx)
	case checklistitem.FieldEnumValues:
		return m.OldEnumValues(ctx)
	case checklistitem.FieldEnumSelectionModeValue:
		return m.OldEnumSelectionModeValue(ctx)
	case checklistitem.FieldSelectedEnumValues:
		return m.OldSelectedEnumValues(ctx)
	case checklistitem.FieldYesNoVal:
		return m.OldYesNoVal(ctx)
	case checklistitem.FieldHelpText:
		return m.OldHelpText(ctx)
	}
	return nil, fmt.Errorf("unknown CheckListItem field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checklistitem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case checklistitem.FieldType:
		v, ok := value.(enum.CheckListItemType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case checklistitem.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case checklistitem.FieldIsMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMandatory(v)
		return nil
	case checklistitem.FieldChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecked(v)
		return nil
	case checklistitem.FieldStringVal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringVal(v)
		return nil
	case checklistitem.FieldEnumValues:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumValues(v)
		return nil
	case checklistitem.FieldEnumSelectionModeValue:
		v, ok := value.(enum.CheckListItemEnumSelectionMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumSelectionModeValue(v)
		return nil
	case checklistitem.FieldSelectedEnumValues:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedEnumValues(v)
		return nil
	case checklistitem.FieldYesNoVal:
		v, ok := value.(checklistitem.YesNoVal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYesNoVal(v)
		return nil
	case checklistitem.FieldHelpText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHelpText(v)
		return nil
	}
	return fmt.Errorf("unknown CheckListItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CheckListItemMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, checklistitem.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CheckListItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case checklistitem.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case checklistitem.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown CheckListItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CheckListItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checklistitem.FieldIndex) {
		fields = append(fields, checklistitem.FieldIndex)
	}
	if m.FieldCleared(checklistitem.FieldIsMandatory) {
		fields = append(fields, checklistitem.FieldIsMandatory)
	}
	if m.FieldCleared(checklistitem.FieldChecked) {
		fields = append(fields, checklistitem.FieldChecked)
	}
	if m.FieldCleared(checklistitem.FieldStringVal) {
		fields = append(fields, checklistitem.FieldStringVal)
	}
	if m.FieldCleared(checklistitem.FieldEnumValues) {
		fields = append(fields, checklistitem.FieldEnumValues)
	}
	if m.FieldCleared(checklistitem.FieldEnumSelectionModeValue) {
		fields = append(fields, checklistitem.FieldEnumSelectionModeValue)
	}
	if m.FieldCleared(checklistitem.FieldSelectedEnumValues) {
		fields = append(fields, checklistitem.FieldSelectedEnumValues)
	}
	if m.FieldCleared(checklistitem.FieldYesNoVal) {
		fields = append(fields, checklistitem.FieldYesNoVal)
	}
	if m.FieldCleared(checklistitem.FieldHelpText) {
		fields = append(fields, checklistitem.FieldHelpText)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CheckListItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckListItemMutation) ClearField(name string) error {
	switch name {
	case checklistitem.FieldIndex:
		m.ClearIndex()
		return nil
	case checklistitem.FieldIsMandatory:
		m.ClearIsMandatory()
		return nil
	case checklistitem.FieldChecked:
		m.ClearChecked()
		return nil
	case checklistitem.FieldStringVal:
		m.ClearStringVal()
		return nil
	case checklistitem.FieldEnumValues:
		m.ClearEnumValues()
		return nil
	case checklistitem.FieldEnumSelectionModeValue:
		m.ClearEnumSelectionModeValue()
		return nil
	case checklistitem.FieldSelectedEnumValues:
		m.ClearSelectedEnumValues()
		return nil
	case checklistitem.FieldYesNoVal:
		m.ClearYesNoVal()
		return nil
	case checklistitem.FieldHelpText:
		m.ClearHelpText()
		return nil
	}
	return fmt.Errorf("unknown CheckListItem nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CheckListItemMutation) ResetField(name string) error {
	switch name {
	case checklistitem.FieldTitle:
		m.ResetTitle()
		return nil
	case checklistitem.FieldType:
		m.ResetType()
		return nil
	case checklistitem.FieldIndex:
		m.ResetIndex()
		return nil
	case checklistitem.FieldIsMandatory:
		m.ResetIsMandatory()
		return nil
	case checklistitem.FieldChecked:
		m.ResetChecked()
		return nil
	case checklistitem.FieldStringVal:
		m.ResetStringVal()
		return nil
	case checklistitem.FieldEnumValues:
		m.ResetEnumValues()
		return nil
	case checklistitem.FieldEnumSelectionModeValue:
		m.ResetEnumSelectionModeValue()
		return nil
	case checklistitem.FieldSelectedEnumValues:
		m.ResetSelectedEnumValues()
		return nil
	case checklistitem.FieldYesNoVal:
		m.ResetYesNoVal()
		return nil
	case checklistitem.FieldHelpText:
		m.ResetHelpText()
		return nil
	}
	return fmt.Errorf("unknown CheckListItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CheckListItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.files != nil {
		edges = append(edges, checklistitem.EdgeFiles)
	}
	if m.wifi_scan != nil {
		edges = append(edges, checklistitem.EdgeWifiScan)
	}
	if m.cell_scan != nil {
		edges = append(edges, checklistitem.EdgeCellScan)
	}
	if m.check_list_category != nil {
		edges = append(edges, checklistitem.EdgeCheckListCategory)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CheckListItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checklistitem.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case checklistitem.EdgeWifiScan:
		ids := make([]ent.Value, 0, len(m.wifi_scan))
		for id := range m.wifi_scan {
			ids = append(ids, id)
		}
		return ids
	case checklistitem.EdgeCellScan:
		ids := make([]ent.Value, 0, len(m.cell_scan))
		for id := range m.cell_scan {
			ids = append(ids, id)
		}
		return ids
	case checklistitem.EdgeCheckListCategory:
		if id := m.check_list_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CheckListItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedfiles != nil {
		edges = append(edges, checklistitem.EdgeFiles)
	}
	if m.removedwifi_scan != nil {
		edges = append(edges, checklistitem.EdgeWifiScan)
	}
	if m.removedcell_scan != nil {
		edges = append(edges, checklistitem.EdgeCellScan)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CheckListItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case checklistitem.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case checklistitem.EdgeWifiScan:
		ids := make([]ent.Value, 0, len(m.removedwifi_scan))
		for id := range m.removedwifi_scan {
			ids = append(ids, id)
		}
		return ids
	case checklistitem.EdgeCellScan:
		ids := make([]ent.Value, 0, len(m.removedcell_scan))
		for id := range m.removedcell_scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CheckListItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedfiles {
		edges = append(edges, checklistitem.EdgeFiles)
	}
	if m.clearedwifi_scan {
		edges = append(edges, checklistitem.EdgeWifiScan)
	}
	if m.clearedcell_scan {
		edges = append(edges, checklistitem.EdgeCellScan)
	}
	if m.clearedcheck_list_category {
		edges = append(edges, checklistitem.EdgeCheckListCategory)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CheckListItemMutation) EdgeCleared(name string) bool {
	switch name {
	case checklistitem.EdgeFiles:
		return m.clearedfiles
	case checklistitem.EdgeWifiScan:
		return m.clearedwifi_scan
	case checklistitem.EdgeCellScan:
		return m.clearedcell_scan
	case checklistitem.EdgeCheckListCategory:
		return m.clearedcheck_list_category
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CheckListItemMutation) ClearEdge(name string) error {
	switch name {
	case checklistitem.EdgeCheckListCategory:
		m.ClearCheckListCategory()
		return nil
	}
	return fmt.Errorf("unknown CheckListItem unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CheckListItemMutation) ResetEdge(name string) error {
	switch name {
	case checklistitem.EdgeFiles:
		m.ResetFiles()
		return nil
	case checklistitem.EdgeWifiScan:
		m.ResetWifiScan()
		return nil
	case checklistitem.EdgeCellScan:
		m.ResetCellScan()
		return nil
	case checklistitem.EdgeCheckListCategory:
		m.ResetCheckListCategory()
		return nil
	}
	return fmt.Errorf("unknown CheckListItem edge %s", name)
}

// CheckListItemDefinitionMutation represents an operation that mutate the CheckListItemDefinitions
// nodes in the graph.
type CheckListItemDefinitionMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *int
	create_time                           *time.Time
	update_time                           *time.Time
	title                                 *string
	_type                                 *enum.CheckListItemType
	index                                 *int
	addindex                              *int
	is_mandatory                          *bool
	enum_values                           *string
	enum_selection_mode_value             *enum.CheckListItemEnumSelectionMode
	help_text                             *string
	clearedFields                         map[string]struct{}
	check_list_category_definition        *int
	clearedcheck_list_category_definition bool
	done                                  bool
	oldValue                              func(context.Context) (*CheckListItemDefinition, error)
	predicates                            []predicate.CheckListItemDefinition
}

var _ ent.Mutation = (*CheckListItemDefinitionMutation)(nil)

// checklistitemdefinitionOption allows to manage the mutation configuration using functional options.
type checklistitemdefinitionOption func(*CheckListItemDefinitionMutation)

// newCheckListItemDefinitionMutation creates new mutation for CheckListItemDefinition.
func newCheckListItemDefinitionMutation(c config, op Op, opts ...checklistitemdefinitionOption) *CheckListItemDefinitionMutation {
	m := &CheckListItemDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckListItemDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckListItemDefinitionID sets the id field of the mutation.
func withCheckListItemDefinitionID(id int) checklistitemdefinitionOption {
	return func(m *CheckListItemDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckListItemDefinition
		)
		m.oldValue = func(ctx context.Context) (*CheckListItemDefinition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckListItemDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckListItemDefinition sets the old CheckListItemDefinition of the mutation.
func withCheckListItemDefinition(node *CheckListItemDefinition) checklistitemdefinitionOption {
	return func(m *CheckListItemDefinitionMutation) {
		m.oldValue = func(context.Context) (*CheckListItemDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckListItemDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckListItemDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CheckListItemDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CheckListItemDefinitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CheckListItemDefinitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CheckListItemDefinitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CheckListItemDefinitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CheckListItemDefinitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CheckListItemDefinitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the title field.
func (m *CheckListItemDefinitionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *CheckListItemDefinitionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *CheckListItemDefinitionMutation) ResetTitle() {
	m.title = nil
}

// SetType sets the type field.
func (m *CheckListItemDefinitionMutation) SetType(elit enum.CheckListItemType) {
	m._type = &elit
}

// GetType returns the type value in the mutation.
func (m *CheckListItemDefinitionMutation) GetType() (r enum.CheckListItemType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldType(ctx context.Context) (v enum.CheckListItemType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *CheckListItemDefinitionMutation) ResetType() {
	m._type = nil
}

// SetIndex sets the index field.
func (m *CheckListItemDefinitionMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *CheckListItemDefinitionMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *CheckListItemDefinitionMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *CheckListItemDefinitionMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *CheckListItemDefinitionMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[checklistitemdefinition.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *CheckListItemDefinitionMutation) IndexCleared() bool {
	_, ok := m.clearedFields[checklistitemdefinition.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *CheckListItemDefinitionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, checklistitemdefinition.FieldIndex)
}

// SetIsMandatory sets the is_mandatory field.
func (m *CheckListItemDefinitionMutation) SetIsMandatory(b bool) {
	m.is_mandatory = &b
}

// IsMandatory returns the is_mandatory value in the mutation.
func (m *CheckListItemDefinitionMutation) IsMandatory() (r bool, exists bool) {
	v := m.is_mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMandatory returns the old is_mandatory value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldIsMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsMandatory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMandatory: %w", err)
	}
	return oldValue.IsMandatory, nil
}

// ClearIsMandatory clears the value of is_mandatory.
func (m *CheckListItemDefinitionMutation) ClearIsMandatory() {
	m.is_mandatory = nil
	m.clearedFields[checklistitemdefinition.FieldIsMandatory] = struct{}{}
}

// IsMandatoryCleared returns if the field is_mandatory was cleared in this mutation.
func (m *CheckListItemDefinitionMutation) IsMandatoryCleared() bool {
	_, ok := m.clearedFields[checklistitemdefinition.FieldIsMandatory]
	return ok
}

// ResetIsMandatory reset all changes of the "is_mandatory" field.
func (m *CheckListItemDefinitionMutation) ResetIsMandatory() {
	m.is_mandatory = nil
	delete(m.clearedFields, checklistitemdefinition.FieldIsMandatory)
}

// SetEnumValues sets the enum_values field.
func (m *CheckListItemDefinitionMutation) SetEnumValues(s string) {
	m.enum_values = &s
}

// EnumValues returns the enum_values value in the mutation.
func (m *CheckListItemDefinitionMutation) EnumValues() (r string, exists bool) {
	v := m.enum_values
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumValues returns the old enum_values value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldEnumValues(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnumValues is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnumValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumValues: %w", err)
	}
	return oldValue.EnumValues, nil
}

// ClearEnumValues clears the value of enum_values.
func (m *CheckListItemDefinitionMutation) ClearEnumValues() {
	m.enum_values = nil
	m.clearedFields[checklistitemdefinition.FieldEnumValues] = struct{}{}
}

// EnumValuesCleared returns if the field enum_values was cleared in this mutation.
func (m *CheckListItemDefinitionMutation) EnumValuesCleared() bool {
	_, ok := m.clearedFields[checklistitemdefinition.FieldEnumValues]
	return ok
}

// ResetEnumValues reset all changes of the "enum_values" field.
func (m *CheckListItemDefinitionMutation) ResetEnumValues() {
	m.enum_values = nil
	delete(m.clearedFields, checklistitemdefinition.FieldEnumValues)
}

// SetEnumSelectionModeValue sets the enum_selection_mode_value field.
func (m *CheckListItemDefinitionMutation) SetEnumSelectionModeValue(eliesm enum.CheckListItemEnumSelectionMode) {
	m.enum_selection_mode_value = &eliesm
}

// EnumSelectionModeValue returns the enum_selection_mode_value value in the mutation.
func (m *CheckListItemDefinitionMutation) EnumSelectionModeValue() (r enum.CheckListItemEnumSelectionMode, exists bool) {
	v := m.enum_selection_mode_value
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumSelectionModeValue returns the old enum_selection_mode_value value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldEnumSelectionModeValue(ctx context.Context) (v *enum.CheckListItemEnumSelectionMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnumSelectionModeValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnumSelectionModeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumSelectionModeValue: %w", err)
	}
	return oldValue.EnumSelectionModeValue, nil
}

// ClearEnumSelectionModeValue clears the value of enum_selection_mode_value.
func (m *CheckListItemDefinitionMutation) ClearEnumSelectionModeValue() {
	m.enum_selection_mode_value = nil
	m.clearedFields[checklistitemdefinition.FieldEnumSelectionModeValue] = struct{}{}
}

// EnumSelectionModeValueCleared returns if the field enum_selection_mode_value was cleared in this mutation.
func (m *CheckListItemDefinitionMutation) EnumSelectionModeValueCleared() bool {
	_, ok := m.clearedFields[checklistitemdefinition.FieldEnumSelectionModeValue]
	return ok
}

// ResetEnumSelectionModeValue reset all changes of the "enum_selection_mode_value" field.
func (m *CheckListItemDefinitionMutation) ResetEnumSelectionModeValue() {
	m.enum_selection_mode_value = nil
	delete(m.clearedFields, checklistitemdefinition.FieldEnumSelectionModeValue)
}

// SetHelpText sets the help_text field.
func (m *CheckListItemDefinitionMutation) SetHelpText(s string) {
	m.help_text = &s
}

// HelpText returns the help_text value in the mutation.
func (m *CheckListItemDefinitionMutation) HelpText() (r string, exists bool) {
	v := m.help_text
	if v == nil {
		return
	}
	return *v, true
}

// OldHelpText returns the old help_text value of the CheckListItemDefinition.
// If the CheckListItemDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CheckListItemDefinitionMutation) OldHelpText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHelpText is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHelpText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHelpText: %w", err)
	}
	return oldValue.HelpText, nil
}

// ClearHelpText clears the value of help_text.
func (m *CheckListItemDefinitionMutation) ClearHelpText() {
	m.help_text = nil
	m.clearedFields[checklistitemdefinition.FieldHelpText] = struct{}{}
}

// HelpTextCleared returns if the field help_text was cleared in this mutation.
func (m *CheckListItemDefinitionMutation) HelpTextCleared() bool {
	_, ok := m.clearedFields[checklistitemdefinition.FieldHelpText]
	return ok
}

// ResetHelpText reset all changes of the "help_text" field.
func (m *CheckListItemDefinitionMutation) ResetHelpText() {
	m.help_text = nil
	delete(m.clearedFields, checklistitemdefinition.FieldHelpText)
}

// SetCheckListCategoryDefinitionID sets the check_list_category_definition edge to CheckListCategoryDefinition by id.
func (m *CheckListItemDefinitionMutation) SetCheckListCategoryDefinitionID(id int) {
	m.check_list_category_definition = &id
}

// ClearCheckListCategoryDefinition clears the check_list_category_definition edge to CheckListCategoryDefinition.
func (m *CheckListItemDefinitionMutation) ClearCheckListCategoryDefinition() {
	m.clearedcheck_list_category_definition = true
}

// CheckListCategoryDefinitionCleared returns if the edge check_list_category_definition was cleared.
func (m *CheckListItemDefinitionMutation) CheckListCategoryDefinitionCleared() bool {
	return m.clearedcheck_list_category_definition
}

// CheckListCategoryDefinitionID returns the check_list_category_definition id in the mutation.
func (m *CheckListItemDefinitionMutation) CheckListCategoryDefinitionID() (id int, exists bool) {
	if m.check_list_category_definition != nil {
		return *m.check_list_category_definition, true
	}
	return
}

// CheckListCategoryDefinitionIDs returns the check_list_category_definition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CheckListCategoryDefinitionID instead. It exists only for internal usage by the builders.
func (m *CheckListItemDefinitionMutation) CheckListCategoryDefinitionIDs() (ids []int) {
	if id := m.check_list_category_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheckListCategoryDefinition reset all changes of the "check_list_category_definition" edge.
func (m *CheckListItemDefinitionMutation) ResetCheckListCategoryDefinition() {
	m.check_list_category_definition = nil
	m.clearedcheck_list_category_definition = false
}

// Op returns the operation name.
func (m *CheckListItemDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CheckListItemDefinition).
func (m *CheckListItemDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CheckListItemDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, checklistitemdefinition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, checklistitemdefinition.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, checklistitemdefinition.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, checklistitemdefinition.FieldType)
	}
	if m.index != nil {
		fields = append(fields, checklistitemdefinition.FieldIndex)
	}
	if m.is_mandatory != nil {
		fields = append(fields, checklistitemdefinition.FieldIsMandatory)
	}
	if m.enum_values != nil {
		fields = append(fields, checklistitemdefinition.FieldEnumValues)
	}
	if m.enum_selection_mode_value != nil {
		fields = append(fields, checklistitemdefinition.FieldEnumSelectionModeValue)
	}
	if m.help_text != nil {
		fields = append(fields, checklistitemdefinition.FieldHelpText)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CheckListItemDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checklistitemdefinition.FieldCreateTime:
		return m.CreateTime()
	case checklistitemdefinition.FieldUpdateTime:
		return m.UpdateTime()
	case checklistitemdefinition.FieldTitle:
		return m.Title()
	case checklistitemdefinition.FieldType:
		return m.GetType()
	case checklistitemdefinition.FieldIndex:
		return m.Index()
	case checklistitemdefinition.FieldIsMandatory:
		return m.IsMandatory()
	case checklistitemdefinition.FieldEnumValues:
		return m.EnumValues()
	case checklistitemdefinition.FieldEnumSelectionModeValue:
		return m.EnumSelectionModeValue()
	case checklistitemdefinition.FieldHelpText:
		return m.HelpText()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CheckListItemDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checklistitemdefinition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case checklistitemdefinition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case checklistitemdefinition.FieldTitle:
		return m.OldTitle(ctx)
	case checklistitemdefinition.FieldType:
		return m.OldType(ctx)
	case checklistitemdefinition.FieldIndex:
		return m.OldIndex(ctx)
	case checklistitemdefinition.FieldIsMandatory:
		return m.OldIsMandatory(ctx)
	case checklistitemdefinition.FieldEnumValues:
		return m.OldEnumValues(ctx)
	case checklistitemdefinition.FieldEnumSelectionModeValue:
		return m.OldEnumSelectionModeValue(ctx)
	case checklistitemdefinition.FieldHelpText:
		return m.OldHelpText(ctx)
	}
	return nil, fmt.Errorf("unknown CheckListItemDefinition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListItemDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checklistitemdefinition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case checklistitemdefinition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case checklistitemdefinition.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case checklistitemdefinition.FieldType:
		v, ok := value.(enum.CheckListItemType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case checklistitemdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case checklistitemdefinition.FieldIsMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMandatory(v)
		return nil
	case checklistitemdefinition.FieldEnumValues:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumValues(v)
		return nil
	case checklistitemdefinition.FieldEnumSelectionModeValue:
		v, ok := value.(enum.CheckListItemEnumSelectionMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumSelectionModeValue(v)
		return nil
	case checklistitemdefinition.FieldHelpText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHelpText(v)
		return nil
	}
	return fmt.Errorf("unknown CheckListItemDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CheckListItemDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, checklistitemdefinition.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CheckListItemDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case checklistitemdefinition.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CheckListItemDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case checklistitemdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown CheckListItemDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CheckListItemDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checklistitemdefinition.FieldIndex) {
		fields = append(fields, checklistitemdefinition.FieldIndex)
	}
	if m.FieldCleared(checklistitemdefinition.FieldIsMandatory) {
		fields = append(fields, checklistitemdefinition.FieldIsMandatory)
	}
	if m.FieldCleared(checklistitemdefinition.FieldEnumValues) {
		fields = append(fields, checklistitemdefinition.FieldEnumValues)
	}
	if m.FieldCleared(checklistitemdefinition.FieldEnumSelectionModeValue) {
		fields = append(fields, checklistitemdefinition.FieldEnumSelectionModeValue)
	}
	if m.FieldCleared(checklistitemdefinition.FieldHelpText) {
		fields = append(fields, checklistitemdefinition.FieldHelpText)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CheckListItemDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckListItemDefinitionMutation) ClearField(name string) error {
	switch name {
	case checklistitemdefinition.FieldIndex:
		m.ClearIndex()
		return nil
	case checklistitemdefinition.FieldIsMandatory:
		m.ClearIsMandatory()
		return nil
	case checklistitemdefinition.FieldEnumValues:
		m.ClearEnumValues()
		return nil
	case checklistitemdefinition.FieldEnumSelectionModeValue:
		m.ClearEnumSelectionModeValue()
		return nil
	case checklistitemdefinition.FieldHelpText:
		m.ClearHelpText()
		return nil
	}
	return fmt.Errorf("unknown CheckListItemDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CheckListItemDefinitionMutation) ResetField(name string) error {
	switch name {
	case checklistitemdefinition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case checklistitemdefinition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case checklistitemdefinition.FieldTitle:
		m.ResetTitle()
		return nil
	case checklistitemdefinition.FieldType:
		m.ResetType()
		return nil
	case checklistitemdefinition.FieldIndex:
		m.ResetIndex()
		return nil
	case checklistitemdefinition.FieldIsMandatory:
		m.ResetIsMandatory()
		return nil
	case checklistitemdefinition.FieldEnumValues:
		m.ResetEnumValues()
		return nil
	case checklistitemdefinition.FieldEnumSelectionModeValue:
		m.ResetEnumSelectionModeValue()
		return nil
	case checklistitemdefinition.FieldHelpText:
		m.ResetHelpText()
		return nil
	}
	return fmt.Errorf("unknown CheckListItemDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CheckListItemDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.check_list_category_definition != nil {
		edges = append(edges, checklistitemdefinition.EdgeCheckListCategoryDefinition)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CheckListItemDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checklistitemdefinition.EdgeCheckListCategoryDefinition:
		if id := m.check_list_category_definition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CheckListItemDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CheckListItemDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CheckListItemDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcheck_list_category_definition {
		edges = append(edges, checklistitemdefinition.EdgeCheckListCategoryDefinition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CheckListItemDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case checklistitemdefinition.EdgeCheckListCategoryDefinition:
		return m.clearedcheck_list_category_definition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CheckListItemDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case checklistitemdefinition.EdgeCheckListCategoryDefinition:
		m.ClearCheckListCategoryDefinition()
		return nil
	}
	return fmt.Errorf("unknown CheckListItemDefinition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CheckListItemDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case checklistitemdefinition.EdgeCheckListCategoryDefinition:
		m.ResetCheckListCategoryDefinition()
		return nil
	}
	return fmt.Errorf("unknown CheckListItemDefinition edge %s", name)
}

// CommentMutation represents an operation that mutate the Comments
// nodes in the graph.
type CommentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	text              *string
	clearedFields     map[string]struct{}
	author            *int
	clearedauthor     bool
	work_order        *int
	clearedwork_order bool
	project           *int
	clearedproject    bool
	done              bool
	oldValue          func(context.Context) (*Comment, error)
	predicates        []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows to manage the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for Comment.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the id field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CommentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CommentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Comment.
// If the Comment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CommentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CommentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CommentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Comment.
// If the Comment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CommentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetText sets the text field.
func (m *CommentMutation) SetText(s string) {
	m.text = &s
}

// Text returns the text value in the mutation.
func (m *CommentMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old text value of the Comment.
// If the Comment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CommentMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldText is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText reset all changes of the "text" field.
func (m *CommentMutation) ResetText() {
	m.text = nil
}

// SetAuthorID sets the author edge to User by id.
func (m *CommentMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the author edge to User.
func (m *CommentMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared returns if the edge author was cleared.
func (m *CommentMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the author id in the mutation.
func (m *CommentMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the author ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor reset all changes of the "author" edge.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *CommentMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *CommentMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *CommentMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *CommentMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *CommentMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// SetProjectID sets the project edge to Project by id.
func (m *CommentMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the project edge to Project.
func (m *CommentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared returns if the edge project was cleared.
func (m *CommentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the project id in the mutation.
func (m *CommentMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the project ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject reset all changes of the "project" edge.
func (m *CommentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, comment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, comment.FieldUpdateTime)
	}
	if m.text != nil {
		fields = append(fields, comment.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreateTime:
		return m.CreateTime()
	case comment.FieldUpdateTime:
		return m.UpdateTime()
	case comment.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case comment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case comment.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case comment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case comment.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case comment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case comment.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.author != nil {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.work_order != nil {
		edges = append(edges, comment.EdgeWorkOrder)
	}
	if m.project != nil {
		edges = append(edges, comment.EdgeProject)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauthor {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.clearedwork_order {
		edges = append(edges, comment.EdgeWorkOrder)
	}
	if m.clearedproject {
		edges = append(edges, comment.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeAuthor:
		return m.clearedauthor
	case comment.EdgeWorkOrder:
		return m.clearedwork_order
	case comment.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case comment.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	case comment.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case comment.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	case comment.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// ComparatorMutation represents an operation that mutate the Comparators
// nodes in the graph.
type ComparatorMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	name                         *string
	clearedFields                map[string]struct{}
	comparatorrulelimit          map[int]struct{}
	removedcomparatorrulelimit   map[int]struct{}
	clearedcomparatorrulelimit   bool
	comparatorkqitargetfk        map[int]struct{}
	removedcomparatorkqitargetfk map[int]struct{}
	clearedcomparatorkqitargetfk bool
	done                         bool
	oldValue                     func(context.Context) (*Comparator, error)
	predicates                   []predicate.Comparator
}

var _ ent.Mutation = (*ComparatorMutation)(nil)

// comparatorOption allows to manage the mutation configuration using functional options.
type comparatorOption func(*ComparatorMutation)

// newComparatorMutation creates new mutation for Comparator.
func newComparatorMutation(c config, op Op, opts ...comparatorOption) *ComparatorMutation {
	m := &ComparatorMutation{
		config:        c,
		op:            op,
		typ:           TypeComparator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComparatorID sets the id field of the mutation.
func withComparatorID(id int) comparatorOption {
	return func(m *ComparatorMutation) {
		var (
			err   error
			once  sync.Once
			value *Comparator
		)
		m.oldValue = func(ctx context.Context) (*Comparator, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comparator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComparator sets the old Comparator of the mutation.
func withComparator(node *Comparator) comparatorOption {
	return func(m *ComparatorMutation) {
		m.oldValue = func(context.Context) (*Comparator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComparatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComparatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ComparatorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ComparatorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ComparatorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Comparator.
// If the Comparator object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ComparatorMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ComparatorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ComparatorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ComparatorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Comparator.
// If the Comparator object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ComparatorMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ComparatorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ComparatorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ComparatorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Comparator.
// If the Comparator object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ComparatorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ComparatorMutation) ResetName() {
	m.name = nil
}

// AddComparatorrulelimitIDs adds the comparatorrulelimit edge to RuleLimit by ids.
func (m *ComparatorMutation) AddComparatorrulelimitIDs(ids ...int) {
	if m.comparatorrulelimit == nil {
		m.comparatorrulelimit = make(map[int]struct{})
	}
	for i := range ids {
		m.comparatorrulelimit[ids[i]] = struct{}{}
	}
}

// ClearComparatorrulelimit clears the comparatorrulelimit edge to RuleLimit.
func (m *ComparatorMutation) ClearComparatorrulelimit() {
	m.clearedcomparatorrulelimit = true
}

// ComparatorrulelimitCleared returns if the edge comparatorrulelimit was cleared.
func (m *ComparatorMutation) ComparatorrulelimitCleared() bool {
	return m.clearedcomparatorrulelimit
}

// RemoveComparatorrulelimitIDs removes the comparatorrulelimit edge to RuleLimit by ids.
func (m *ComparatorMutation) RemoveComparatorrulelimitIDs(ids ...int) {
	if m.removedcomparatorrulelimit == nil {
		m.removedcomparatorrulelimit = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcomparatorrulelimit[ids[i]] = struct{}{}
	}
}

// RemovedComparatorrulelimit returns the removed ids of comparatorrulelimit.
func (m *ComparatorMutation) RemovedComparatorrulelimitIDs() (ids []int) {
	for id := range m.removedcomparatorrulelimit {
		ids = append(ids, id)
	}
	return
}

// ComparatorrulelimitIDs returns the comparatorrulelimit ids in the mutation.
func (m *ComparatorMutation) ComparatorrulelimitIDs() (ids []int) {
	for id := range m.comparatorrulelimit {
		ids = append(ids, id)
	}
	return
}

// ResetComparatorrulelimit reset all changes of the "comparatorrulelimit" edge.
func (m *ComparatorMutation) ResetComparatorrulelimit() {
	m.comparatorrulelimit = nil
	m.clearedcomparatorrulelimit = false
	m.removedcomparatorrulelimit = nil
}

// AddComparatorkqitargetfkIDs adds the comparatorkqitargetfk edge to KqiComparator by ids.
func (m *ComparatorMutation) AddComparatorkqitargetfkIDs(ids ...int) {
	if m.comparatorkqitargetfk == nil {
		m.comparatorkqitargetfk = make(map[int]struct{})
	}
	for i := range ids {
		m.comparatorkqitargetfk[ids[i]] = struct{}{}
	}
}

// ClearComparatorkqitargetfk clears the comparatorkqitargetfk edge to KqiComparator.
func (m *ComparatorMutation) ClearComparatorkqitargetfk() {
	m.clearedcomparatorkqitargetfk = true
}

// ComparatorkqitargetfkCleared returns if the edge comparatorkqitargetfk was cleared.
func (m *ComparatorMutation) ComparatorkqitargetfkCleared() bool {
	return m.clearedcomparatorkqitargetfk
}

// RemoveComparatorkqitargetfkIDs removes the comparatorkqitargetfk edge to KqiComparator by ids.
func (m *ComparatorMutation) RemoveComparatorkqitargetfkIDs(ids ...int) {
	if m.removedcomparatorkqitargetfk == nil {
		m.removedcomparatorkqitargetfk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcomparatorkqitargetfk[ids[i]] = struct{}{}
	}
}

// RemovedComparatorkqitargetfk returns the removed ids of comparatorkqitargetfk.
func (m *ComparatorMutation) RemovedComparatorkqitargetfkIDs() (ids []int) {
	for id := range m.removedcomparatorkqitargetfk {
		ids = append(ids, id)
	}
	return
}

// ComparatorkqitargetfkIDs returns the comparatorkqitargetfk ids in the mutation.
func (m *ComparatorMutation) ComparatorkqitargetfkIDs() (ids []int) {
	for id := range m.comparatorkqitargetfk {
		ids = append(ids, id)
	}
	return
}

// ResetComparatorkqitargetfk reset all changes of the "comparatorkqitargetfk" edge.
func (m *ComparatorMutation) ResetComparatorkqitargetfk() {
	m.comparatorkqitargetfk = nil
	m.clearedcomparatorkqitargetfk = false
	m.removedcomparatorkqitargetfk = nil
}

// Op returns the operation name.
func (m *ComparatorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comparator).
func (m *ComparatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ComparatorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, comparator.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, comparator.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, comparator.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ComparatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comparator.FieldCreateTime:
		return m.CreateTime()
	case comparator.FieldUpdateTime:
		return m.UpdateTime()
	case comparator.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ComparatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comparator.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case comparator.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case comparator.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Comparator field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ComparatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comparator.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case comparator.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case comparator.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Comparator field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ComparatorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ComparatorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ComparatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comparator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ComparatorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ComparatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComparatorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comparator nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ComparatorMutation) ResetField(name string) error {
	switch name {
	case comparator.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case comparator.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case comparator.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Comparator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ComparatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.comparatorrulelimit != nil {
		edges = append(edges, comparator.EdgeComparatorrulelimit)
	}
	if m.comparatorkqitargetfk != nil {
		edges = append(edges, comparator.EdgeComparatorkqitargetfk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ComparatorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comparator.EdgeComparatorrulelimit:
		ids := make([]ent.Value, 0, len(m.comparatorrulelimit))
		for id := range m.comparatorrulelimit {
			ids = append(ids, id)
		}
		return ids
	case comparator.EdgeComparatorkqitargetfk:
		ids := make([]ent.Value, 0, len(m.comparatorkqitargetfk))
		for id := range m.comparatorkqitargetfk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ComparatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomparatorrulelimit != nil {
		edges = append(edges, comparator.EdgeComparatorrulelimit)
	}
	if m.removedcomparatorkqitargetfk != nil {
		edges = append(edges, comparator.EdgeComparatorkqitargetfk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ComparatorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comparator.EdgeComparatorrulelimit:
		ids := make([]ent.Value, 0, len(m.removedcomparatorrulelimit))
		for id := range m.removedcomparatorrulelimit {
			ids = append(ids, id)
		}
		return ids
	case comparator.EdgeComparatorkqitargetfk:
		ids := make([]ent.Value, 0, len(m.removedcomparatorkqitargetfk))
		for id := range m.removedcomparatorkqitargetfk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ComparatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomparatorrulelimit {
		edges = append(edges, comparator.EdgeComparatorrulelimit)
	}
	if m.clearedcomparatorkqitargetfk {
		edges = append(edges, comparator.EdgeComparatorkqitargetfk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ComparatorMutation) EdgeCleared(name string) bool {
	switch name {
	case comparator.EdgeComparatorrulelimit:
		return m.clearedcomparatorrulelimit
	case comparator.EdgeComparatorkqitargetfk:
		return m.clearedcomparatorkqitargetfk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ComparatorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Comparator unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ComparatorMutation) ResetEdge(name string) error {
	switch name {
	case comparator.EdgeComparatorrulelimit:
		m.ResetComparatorrulelimit()
		return nil
	case comparator.EdgeComparatorkqitargetfk:
		m.ResetComparatorkqitargetfk()
		return nil
	}
	return fmt.Errorf("unknown Comparator edge %s", name)
}

// CounterMutation represents an operation that mutate the Counters
// nodes in the graph.
type CounterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	externalId           *string
	networkManagerSystem *string
	clearedFields        map[string]struct{}
	counterfamily        *int
	clearedcounterfamily bool
	vendor               *int
	clearedvendor        bool
	counter_fk           map[int]struct{}
	removedcounter_fk    map[int]struct{}
	clearedcounter_fk    bool
	done                 bool
	oldValue             func(context.Context) (*Counter, error)
	predicates           []predicate.Counter
}

var _ ent.Mutation = (*CounterMutation)(nil)

// counterOption allows to manage the mutation configuration using functional options.
type counterOption func(*CounterMutation)

// newCounterMutation creates new mutation for Counter.
func newCounterMutation(c config, op Op, opts ...counterOption) *CounterMutation {
	m := &CounterMutation{
		config:        c,
		op:            op,
		typ:           TypeCounter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCounterID sets the id field of the mutation.
func withCounterID(id int) counterOption {
	return func(m *CounterMutation) {
		var (
			err   error
			once  sync.Once
			value *Counter
		)
		m.oldValue = func(ctx context.Context) (*Counter, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Counter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCounter sets the old Counter of the mutation.
func withCounter(node *Counter) counterOption {
	return func(m *CounterMutation) {
		m.oldValue = func(context.Context) (*Counter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CounterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CounterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CounterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CounterMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CounterMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Counter.
// If the Counter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CounterMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CounterMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CounterMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Counter.
// If the Counter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CounterMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *CounterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CounterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Counter.
// If the Counter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CounterMutation) ResetName() {
	m.name = nil
}

// SetExternalId sets the externalId field.
func (m *CounterMutation) SetExternalId(s string) {
	m.externalId = &s
}

// ExternalId returns the externalId value in the mutation.
func (m *CounterMutation) ExternalId() (r string, exists bool) {
	v := m.externalId
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalId returns the old externalId value of the Counter.
// If the Counter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterMutation) OldExternalId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalId: %w", err)
	}
	return oldValue.ExternalId, nil
}

// ResetExternalId reset all changes of the "externalId" field.
func (m *CounterMutation) ResetExternalId() {
	m.externalId = nil
}

// SetNetworkManagerSystem sets the networkManagerSystem field.
func (m *CounterMutation) SetNetworkManagerSystem(s string) {
	m.networkManagerSystem = &s
}

// NetworkManagerSystem returns the networkManagerSystem value in the mutation.
func (m *CounterMutation) NetworkManagerSystem() (r string, exists bool) {
	v := m.networkManagerSystem
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkManagerSystem returns the old networkManagerSystem value of the Counter.
// If the Counter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterMutation) OldNetworkManagerSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetworkManagerSystem is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetworkManagerSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkManagerSystem: %w", err)
	}
	return oldValue.NetworkManagerSystem, nil
}

// ResetNetworkManagerSystem reset all changes of the "networkManagerSystem" field.
func (m *CounterMutation) ResetNetworkManagerSystem() {
	m.networkManagerSystem = nil
}

// SetCounterfamilyID sets the counterfamily edge to CounterFamily by id.
func (m *CounterMutation) SetCounterfamilyID(id int) {
	m.counterfamily = &id
}

// ClearCounterfamily clears the counterfamily edge to CounterFamily.
func (m *CounterMutation) ClearCounterfamily() {
	m.clearedcounterfamily = true
}

// CounterfamilyCleared returns if the edge counterfamily was cleared.
func (m *CounterMutation) CounterfamilyCleared() bool {
	return m.clearedcounterfamily
}

// CounterfamilyID returns the counterfamily id in the mutation.
func (m *CounterMutation) CounterfamilyID() (id int, exists bool) {
	if m.counterfamily != nil {
		return *m.counterfamily, true
	}
	return
}

// CounterfamilyIDs returns the counterfamily ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CounterfamilyID instead. It exists only for internal usage by the builders.
func (m *CounterMutation) CounterfamilyIDs() (ids []int) {
	if id := m.counterfamily; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCounterfamily reset all changes of the "counterfamily" edge.
func (m *CounterMutation) ResetCounterfamily() {
	m.counterfamily = nil
	m.clearedcounterfamily = false
}

// SetVendorID sets the vendor edge to Vendor by id.
func (m *CounterMutation) SetVendorID(id int) {
	m.vendor = &id
}

// ClearVendor clears the vendor edge to Vendor.
func (m *CounterMutation) ClearVendor() {
	m.clearedvendor = true
}

// VendorCleared returns if the edge vendor was cleared.
func (m *CounterMutation) VendorCleared() bool {
	return m.clearedvendor
}

// VendorID returns the vendor id in the mutation.
func (m *CounterMutation) VendorID() (id int, exists bool) {
	if m.vendor != nil {
		return *m.vendor, true
	}
	return
}

// VendorIDs returns the vendor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// VendorID instead. It exists only for internal usage by the builders.
func (m *CounterMutation) VendorIDs() (ids []int) {
	if id := m.vendor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendor reset all changes of the "vendor" edge.
func (m *CounterMutation) ResetVendor() {
	m.vendor = nil
	m.clearedvendor = false
}

// AddCounterFkIDs adds the counter_fk edge to CounterFormula by ids.
func (m *CounterMutation) AddCounterFkIDs(ids ...int) {
	if m.counter_fk == nil {
		m.counter_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.counter_fk[ids[i]] = struct{}{}
	}
}

// ClearCounterFk clears the counter_fk edge to CounterFormula.
func (m *CounterMutation) ClearCounterFk() {
	m.clearedcounter_fk = true
}

// CounterFkCleared returns if the edge counter_fk was cleared.
func (m *CounterMutation) CounterFkCleared() bool {
	return m.clearedcounter_fk
}

// RemoveCounterFkIDs removes the counter_fk edge to CounterFormula by ids.
func (m *CounterMutation) RemoveCounterFkIDs(ids ...int) {
	if m.removedcounter_fk == nil {
		m.removedcounter_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcounter_fk[ids[i]] = struct{}{}
	}
}

// RemovedCounterFk returns the removed ids of counter_fk.
func (m *CounterMutation) RemovedCounterFkIDs() (ids []int) {
	for id := range m.removedcounter_fk {
		ids = append(ids, id)
	}
	return
}

// CounterFkIDs returns the counter_fk ids in the mutation.
func (m *CounterMutation) CounterFkIDs() (ids []int) {
	for id := range m.counter_fk {
		ids = append(ids, id)
	}
	return
}

// ResetCounterFk reset all changes of the "counter_fk" edge.
func (m *CounterMutation) ResetCounterFk() {
	m.counter_fk = nil
	m.clearedcounter_fk = false
	m.removedcounter_fk = nil
}

// Op returns the operation name.
func (m *CounterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Counter).
func (m *CounterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CounterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, counter.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, counter.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, counter.FieldName)
	}
	if m.externalId != nil {
		fields = append(fields, counter.FieldExternalId)
	}
	if m.networkManagerSystem != nil {
		fields = append(fields, counter.FieldNetworkManagerSystem)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CounterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case counter.FieldCreateTime:
		return m.CreateTime()
	case counter.FieldUpdateTime:
		return m.UpdateTime()
	case counter.FieldName:
		return m.Name()
	case counter.FieldExternalId:
		return m.ExternalId()
	case counter.FieldNetworkManagerSystem:
		return m.NetworkManagerSystem()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CounterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case counter.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case counter.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case counter.FieldName:
		return m.OldName(ctx)
	case counter.FieldExternalId:
		return m.OldExternalId(ctx)
	case counter.FieldNetworkManagerSystem:
		return m.OldNetworkManagerSystem(ctx)
	}
	return nil, fmt.Errorf("unknown Counter field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case counter.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case counter.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case counter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case counter.FieldExternalId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalId(v)
		return nil
	case counter.FieldNetworkManagerSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkManagerSystem(v)
		return nil
	}
	return fmt.Errorf("unknown Counter field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CounterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CounterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Counter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CounterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CounterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CounterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Counter nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CounterMutation) ResetField(name string) error {
	switch name {
	case counter.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case counter.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case counter.FieldName:
		m.ResetName()
		return nil
	case counter.FieldExternalId:
		m.ResetExternalId()
		return nil
	case counter.FieldNetworkManagerSystem:
		m.ResetNetworkManagerSystem()
		return nil
	}
	return fmt.Errorf("unknown Counter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CounterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.counterfamily != nil {
		edges = append(edges, counter.EdgeCounterfamily)
	}
	if m.vendor != nil {
		edges = append(edges, counter.EdgeVendor)
	}
	if m.counter_fk != nil {
		edges = append(edges, counter.EdgeCounterFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CounterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case counter.EdgeCounterfamily:
		if id := m.counterfamily; id != nil {
			return []ent.Value{*id}
		}
	case counter.EdgeVendor:
		if id := m.vendor; id != nil {
			return []ent.Value{*id}
		}
	case counter.EdgeCounterFk:
		ids := make([]ent.Value, 0, len(m.counter_fk))
		for id := range m.counter_fk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CounterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcounter_fk != nil {
		edges = append(edges, counter.EdgeCounterFk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CounterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case counter.EdgeCounterFk:
		ids := make([]ent.Value, 0, len(m.removedcounter_fk))
		for id := range m.removedcounter_fk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CounterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcounterfamily {
		edges = append(edges, counter.EdgeCounterfamily)
	}
	if m.clearedvendor {
		edges = append(edges, counter.EdgeVendor)
	}
	if m.clearedcounter_fk {
		edges = append(edges, counter.EdgeCounterFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CounterMutation) EdgeCleared(name string) bool {
	switch name {
	case counter.EdgeCounterfamily:
		return m.clearedcounterfamily
	case counter.EdgeVendor:
		return m.clearedvendor
	case counter.EdgeCounterFk:
		return m.clearedcounter_fk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CounterMutation) ClearEdge(name string) error {
	switch name {
	case counter.EdgeCounterfamily:
		m.ClearCounterfamily()
		return nil
	case counter.EdgeVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown Counter unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CounterMutation) ResetEdge(name string) error {
	switch name {
	case counter.EdgeCounterfamily:
		m.ResetCounterfamily()
		return nil
	case counter.EdgeVendor:
		m.ResetVendor()
		return nil
	case counter.EdgeCounterFk:
		m.ResetCounterFk()
		return nil
	}
	return fmt.Errorf("unknown Counter edge %s", name)
}

// CounterFamilyMutation represents an operation that mutate the CounterFamilies
// nodes in the graph.
type CounterFamilyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	clearedFields        map[string]struct{}
	counterfamily        map[int]struct{}
	removedcounterfamily map[int]struct{}
	clearedcounterfamily bool
	done                 bool
	oldValue             func(context.Context) (*CounterFamily, error)
	predicates           []predicate.CounterFamily
}

var _ ent.Mutation = (*CounterFamilyMutation)(nil)

// counterfamilyOption allows to manage the mutation configuration using functional options.
type counterfamilyOption func(*CounterFamilyMutation)

// newCounterFamilyMutation creates new mutation for CounterFamily.
func newCounterFamilyMutation(c config, op Op, opts ...counterfamilyOption) *CounterFamilyMutation {
	m := &CounterFamilyMutation{
		config:        c,
		op:            op,
		typ:           TypeCounterFamily,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCounterFamilyID sets the id field of the mutation.
func withCounterFamilyID(id int) counterfamilyOption {
	return func(m *CounterFamilyMutation) {
		var (
			err   error
			once  sync.Once
			value *CounterFamily
		)
		m.oldValue = func(ctx context.Context) (*CounterFamily, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CounterFamily.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCounterFamily sets the old CounterFamily of the mutation.
func withCounterFamily(node *CounterFamily) counterfamilyOption {
	return func(m *CounterFamilyMutation) {
		m.oldValue = func(context.Context) (*CounterFamily, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CounterFamilyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CounterFamilyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CounterFamilyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CounterFamilyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CounterFamilyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the CounterFamily.
// If the CounterFamily object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterFamilyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CounterFamilyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CounterFamilyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CounterFamilyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the CounterFamily.
// If the CounterFamily object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterFamilyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CounterFamilyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *CounterFamilyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CounterFamilyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CounterFamily.
// If the CounterFamily object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterFamilyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CounterFamilyMutation) ResetName() {
	m.name = nil
}

// AddCounterfamilyIDs adds the counterfamily edge to Counter by ids.
func (m *CounterFamilyMutation) AddCounterfamilyIDs(ids ...int) {
	if m.counterfamily == nil {
		m.counterfamily = make(map[int]struct{})
	}
	for i := range ids {
		m.counterfamily[ids[i]] = struct{}{}
	}
}

// ClearCounterfamily clears the counterfamily edge to Counter.
func (m *CounterFamilyMutation) ClearCounterfamily() {
	m.clearedcounterfamily = true
}

// CounterfamilyCleared returns if the edge counterfamily was cleared.
func (m *CounterFamilyMutation) CounterfamilyCleared() bool {
	return m.clearedcounterfamily
}

// RemoveCounterfamilyIDs removes the counterfamily edge to Counter by ids.
func (m *CounterFamilyMutation) RemoveCounterfamilyIDs(ids ...int) {
	if m.removedcounterfamily == nil {
		m.removedcounterfamily = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcounterfamily[ids[i]] = struct{}{}
	}
}

// RemovedCounterfamily returns the removed ids of counterfamily.
func (m *CounterFamilyMutation) RemovedCounterfamilyIDs() (ids []int) {
	for id := range m.removedcounterfamily {
		ids = append(ids, id)
	}
	return
}

// CounterfamilyIDs returns the counterfamily ids in the mutation.
func (m *CounterFamilyMutation) CounterfamilyIDs() (ids []int) {
	for id := range m.counterfamily {
		ids = append(ids, id)
	}
	return
}

// ResetCounterfamily reset all changes of the "counterfamily" edge.
func (m *CounterFamilyMutation) ResetCounterfamily() {
	m.counterfamily = nil
	m.clearedcounterfamily = false
	m.removedcounterfamily = nil
}

// Op returns the operation name.
func (m *CounterFamilyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CounterFamily).
func (m *CounterFamilyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CounterFamilyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, counterfamily.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, counterfamily.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, counterfamily.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CounterFamilyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case counterfamily.FieldCreateTime:
		return m.CreateTime()
	case counterfamily.FieldUpdateTime:
		return m.UpdateTime()
	case counterfamily.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CounterFamilyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case counterfamily.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case counterfamily.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case counterfamily.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CounterFamily field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterFamilyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case counterfamily.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case counterfamily.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case counterfamily.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CounterFamily field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CounterFamilyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CounterFamilyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterFamilyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CounterFamily numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CounterFamilyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CounterFamilyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CounterFamilyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CounterFamily nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CounterFamilyMutation) ResetField(name string) error {
	switch name {
	case counterfamily.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case counterfamily.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case counterfamily.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CounterFamily field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CounterFamilyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.counterfamily != nil {
		edges = append(edges, counterfamily.EdgeCounterfamily)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CounterFamilyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case counterfamily.EdgeCounterfamily:
		ids := make([]ent.Value, 0, len(m.counterfamily))
		for id := range m.counterfamily {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CounterFamilyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcounterfamily != nil {
		edges = append(edges, counterfamily.EdgeCounterfamily)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CounterFamilyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case counterfamily.EdgeCounterfamily:
		ids := make([]ent.Value, 0, len(m.removedcounterfamily))
		for id := range m.removedcounterfamily {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CounterFamilyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcounterfamily {
		edges = append(edges, counterfamily.EdgeCounterfamily)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CounterFamilyMutation) EdgeCleared(name string) bool {
	switch name {
	case counterfamily.EdgeCounterfamily:
		return m.clearedcounterfamily
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CounterFamilyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CounterFamily unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CounterFamilyMutation) ResetEdge(name string) error {
	switch name {
	case counterfamily.EdgeCounterfamily:
		m.ResetCounterfamily()
		return nil
	}
	return fmt.Errorf("unknown CounterFamily edge %s", name)
}

// CounterFormulaMutation represents an operation that mutate the CounterFormulas
// nodes in the graph.
type CounterFormulaMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	mandatory      *bool
	clearedFields  map[string]struct{}
	formula        *int
	clearedformula bool
	counter        *int
	clearedcounter bool
	done           bool
	oldValue       func(context.Context) (*CounterFormula, error)
	predicates     []predicate.CounterFormula
}

var _ ent.Mutation = (*CounterFormulaMutation)(nil)

// counterformulaOption allows to manage the mutation configuration using functional options.
type counterformulaOption func(*CounterFormulaMutation)

// newCounterFormulaMutation creates new mutation for CounterFormula.
func newCounterFormulaMutation(c config, op Op, opts ...counterformulaOption) *CounterFormulaMutation {
	m := &CounterFormulaMutation{
		config:        c,
		op:            op,
		typ:           TypeCounterFormula,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCounterFormulaID sets the id field of the mutation.
func withCounterFormulaID(id int) counterformulaOption {
	return func(m *CounterFormulaMutation) {
		var (
			err   error
			once  sync.Once
			value *CounterFormula
		)
		m.oldValue = func(ctx context.Context) (*CounterFormula, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CounterFormula.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCounterFormula sets the old CounterFormula of the mutation.
func withCounterFormula(node *CounterFormula) counterformulaOption {
	return func(m *CounterFormulaMutation) {
		m.oldValue = func(context.Context) (*CounterFormula, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CounterFormulaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CounterFormulaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CounterFormulaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CounterFormulaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CounterFormulaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the CounterFormula.
// If the CounterFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterFormulaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CounterFormulaMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CounterFormulaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CounterFormulaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the CounterFormula.
// If the CounterFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterFormulaMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CounterFormulaMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetMandatory sets the mandatory field.
func (m *CounterFormulaMutation) SetMandatory(b bool) {
	m.mandatory = &b
}

// Mandatory returns the mandatory value in the mutation.
func (m *CounterFormulaMutation) Mandatory() (r bool, exists bool) {
	v := m.mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldMandatory returns the old mandatory value of the CounterFormula.
// If the CounterFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CounterFormulaMutation) OldMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMandatory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMandatory: %w", err)
	}
	return oldValue.Mandatory, nil
}

// ResetMandatory reset all changes of the "mandatory" field.
func (m *CounterFormulaMutation) ResetMandatory() {
	m.mandatory = nil
}

// SetFormulaID sets the formula edge to Formula by id.
func (m *CounterFormulaMutation) SetFormulaID(id int) {
	m.formula = &id
}

// ClearFormula clears the formula edge to Formula.
func (m *CounterFormulaMutation) ClearFormula() {
	m.clearedformula = true
}

// FormulaCleared returns if the edge formula was cleared.
func (m *CounterFormulaMutation) FormulaCleared() bool {
	return m.clearedformula
}

// FormulaID returns the formula id in the mutation.
func (m *CounterFormulaMutation) FormulaID() (id int, exists bool) {
	if m.formula != nil {
		return *m.formula, true
	}
	return
}

// FormulaIDs returns the formula ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FormulaID instead. It exists only for internal usage by the builders.
func (m *CounterFormulaMutation) FormulaIDs() (ids []int) {
	if id := m.formula; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFormula reset all changes of the "formula" edge.
func (m *CounterFormulaMutation) ResetFormula() {
	m.formula = nil
	m.clearedformula = false
}

// SetCounterID sets the counter edge to Counter by id.
func (m *CounterFormulaMutation) SetCounterID(id int) {
	m.counter = &id
}

// ClearCounter clears the counter edge to Counter.
func (m *CounterFormulaMutation) ClearCounter() {
	m.clearedcounter = true
}

// CounterCleared returns if the edge counter was cleared.
func (m *CounterFormulaMutation) CounterCleared() bool {
	return m.clearedcounter
}

// CounterID returns the counter id in the mutation.
func (m *CounterFormulaMutation) CounterID() (id int, exists bool) {
	if m.counter != nil {
		return *m.counter, true
	}
	return
}

// CounterIDs returns the counter ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CounterID instead. It exists only for internal usage by the builders.
func (m *CounterFormulaMutation) CounterIDs() (ids []int) {
	if id := m.counter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCounter reset all changes of the "counter" edge.
func (m *CounterFormulaMutation) ResetCounter() {
	m.counter = nil
	m.clearedcounter = false
}

// Op returns the operation name.
func (m *CounterFormulaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CounterFormula).
func (m *CounterFormulaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CounterFormulaMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, counterformula.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, counterformula.FieldUpdateTime)
	}
	if m.mandatory != nil {
		fields = append(fields, counterformula.FieldMandatory)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CounterFormulaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case counterformula.FieldCreateTime:
		return m.CreateTime()
	case counterformula.FieldUpdateTime:
		return m.UpdateTime()
	case counterformula.FieldMandatory:
		return m.Mandatory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CounterFormulaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case counterformula.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case counterformula.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case counterformula.FieldMandatory:
		return m.OldMandatory(ctx)
	}
	return nil, fmt.Errorf("unknown CounterFormula field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterFormulaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case counterformula.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case counterformula.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case counterformula.FieldMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMandatory(v)
		return nil
	}
	return fmt.Errorf("unknown CounterFormula field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CounterFormulaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CounterFormulaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CounterFormulaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CounterFormula numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CounterFormulaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CounterFormulaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CounterFormulaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CounterFormula nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CounterFormulaMutation) ResetField(name string) error {
	switch name {
	case counterformula.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case counterformula.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case counterformula.FieldMandatory:
		m.ResetMandatory()
		return nil
	}
	return fmt.Errorf("unknown CounterFormula field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CounterFormulaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.formula != nil {
		edges = append(edges, counterformula.EdgeFormula)
	}
	if m.counter != nil {
		edges = append(edges, counterformula.EdgeCounter)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CounterFormulaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case counterformula.EdgeFormula:
		if id := m.formula; id != nil {
			return []ent.Value{*id}
		}
	case counterformula.EdgeCounter:
		if id := m.counter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CounterFormulaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CounterFormulaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CounterFormulaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedformula {
		edges = append(edges, counterformula.EdgeFormula)
	}
	if m.clearedcounter {
		edges = append(edges, counterformula.EdgeCounter)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CounterFormulaMutation) EdgeCleared(name string) bool {
	switch name {
	case counterformula.EdgeFormula:
		return m.clearedformula
	case counterformula.EdgeCounter:
		return m.clearedcounter
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CounterFormulaMutation) ClearEdge(name string) error {
	switch name {
	case counterformula.EdgeFormula:
		m.ClearFormula()
		return nil
	case counterformula.EdgeCounter:
		m.ClearCounter()
		return nil
	}
	return fmt.Errorf("unknown CounterFormula unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CounterFormulaMutation) ResetEdge(name string) error {
	switch name {
	case counterformula.EdgeFormula:
		m.ResetFormula()
		return nil
	case counterformula.EdgeCounter:
		m.ResetCounter()
		return nil
	}
	return fmt.Errorf("unknown CounterFormula edge %s", name)
}

// CustomerMutation represents an operation that mutate the Customers
// nodes in the graph.
type CustomerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	external_id     *string
	clearedFields   map[string]struct{}
	services        map[int]struct{}
	removedservices map[int]struct{}
	clearedservices bool
	done            bool
	oldValue        func(context.Context) (*Customer, error)
	predicates      []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows to manage the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for Customer.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the id field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *CustomerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *CustomerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *CustomerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *CustomerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *CustomerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *CustomerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetExternalID sets the external_id field.
func (m *CustomerMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the external_id value in the mutation.
func (m *CustomerMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old external_id value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of external_id.
func (m *CustomerMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[customer.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the field external_id was cleared in this mutation.
func (m *CustomerMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldExternalID]
	return ok
}

// ResetExternalID reset all changes of the "external_id" field.
func (m *CustomerMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, customer.FieldExternalID)
}

// AddServiceIDs adds the services edge to Service by ids.
func (m *CustomerMutation) AddServiceIDs(ids ...int) {
	if m.services == nil {
		m.services = make(map[int]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the services edge to Service.
func (m *CustomerMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared returns if the edge services was cleared.
func (m *CustomerMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the services edge to Service by ids.
func (m *CustomerMutation) RemoveServiceIDs(ids ...int) {
	if m.removedservices == nil {
		m.removedservices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed ids of services.
func (m *CustomerMutation) RemovedServicesIDs() (ids []int) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the services ids in the mutation.
func (m *CustomerMutation) ServicesIDs() (ids []int) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices reset all changes of the "services" edge.
func (m *CustomerMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, customer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, customer.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.external_id != nil {
		fields = append(fields, customer.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreateTime:
		return m.CreateTime()
	case customer.FieldUpdateTime:
		return m.UpdateTime()
	case customer.FieldName:
		return m.Name()
	case customer.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case customer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case customer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldExternalID) {
		fields = append(fields, customer.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case customer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.services != nil {
		edges = append(edges, customer.EdgeServices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservices != nil {
		edges = append(edges, customer.EdgeServices)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservices {
		edges = append(edges, customer.EdgeServices)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeServices:
		return m.clearedservices
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeServices:
		m.ResetServices()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// DocumentCategoryMutation represents an operation that mutate the DocumentCategories
// nodes in the graph.
type DocumentCategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	index                *int
	addindex             *int
	clearedFields        map[string]struct{}
	location_type        *int
	clearedlocation_type bool
	files                map[int]struct{}
	removedfiles         map[int]struct{}
	clearedfiles         bool
	hyperlinks           map[int]struct{}
	removedhyperlinks    map[int]struct{}
	clearedhyperlinks    bool
	done                 bool
	oldValue             func(context.Context) (*DocumentCategory, error)
	predicates           []predicate.DocumentCategory
}

var _ ent.Mutation = (*DocumentCategoryMutation)(nil)

// documentcategoryOption allows to manage the mutation configuration using functional options.
type documentcategoryOption func(*DocumentCategoryMutation)

// newDocumentCategoryMutation creates new mutation for DocumentCategory.
func newDocumentCategoryMutation(c config, op Op, opts ...documentcategoryOption) *DocumentCategoryMutation {
	m := &DocumentCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentCategoryID sets the id field of the mutation.
func withDocumentCategoryID(id int) documentcategoryOption {
	return func(m *DocumentCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentCategory
		)
		m.oldValue = func(ctx context.Context) (*DocumentCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentCategory sets the old DocumentCategory of the mutation.
func withDocumentCategory(node *DocumentCategory) documentcategoryOption {
	return func(m *DocumentCategoryMutation) {
		m.oldValue = func(context.Context) (*DocumentCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DocumentCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *DocumentCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *DocumentCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the DocumentCategory.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DocumentCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *DocumentCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *DocumentCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *DocumentCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the DocumentCategory.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DocumentCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *DocumentCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *DocumentCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DocumentCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the DocumentCategory.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DocumentCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DocumentCategoryMutation) ResetName() {
	m.name = nil
}

// SetIndex sets the index field.
func (m *DocumentCategoryMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *DocumentCategoryMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the DocumentCategory.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DocumentCategoryMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *DocumentCategoryMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *DocumentCategoryMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *DocumentCategoryMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetLocationTypeID sets the location_type edge to LocationType by id.
func (m *DocumentCategoryMutation) SetLocationTypeID(id int) {
	m.location_type = &id
}

// ClearLocationType clears the location_type edge to LocationType.
func (m *DocumentCategoryMutation) ClearLocationType() {
	m.clearedlocation_type = true
}

// LocationTypeCleared returns if the edge location_type was cleared.
func (m *DocumentCategoryMutation) LocationTypeCleared() bool {
	return m.clearedlocation_type
}

// LocationTypeID returns the location_type id in the mutation.
func (m *DocumentCategoryMutation) LocationTypeID() (id int, exists bool) {
	if m.location_type != nil {
		return *m.location_type, true
	}
	return
}

// LocationTypeIDs returns the location_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationTypeID instead. It exists only for internal usage by the builders.
func (m *DocumentCategoryMutation) LocationTypeIDs() (ids []int) {
	if id := m.location_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocationType reset all changes of the "location_type" edge.
func (m *DocumentCategoryMutation) ResetLocationType() {
	m.location_type = nil
	m.clearedlocation_type = false
}

// AddFileIDs adds the files edge to File by ids.
func (m *DocumentCategoryMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the files edge to File.
func (m *DocumentCategoryMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared returns if the edge files was cleared.
func (m *DocumentCategoryMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the files edge to File by ids.
func (m *DocumentCategoryMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed ids of files.
func (m *DocumentCategoryMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the files ids in the mutation.
func (m *DocumentCategoryMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles reset all changes of the "files" edge.
func (m *DocumentCategoryMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddHyperlinkIDs adds the hyperlinks edge to Hyperlink by ids.
func (m *DocumentCategoryMutation) AddHyperlinkIDs(ids ...int) {
	if m.hyperlinks == nil {
		m.hyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.hyperlinks[ids[i]] = struct{}{}
	}
}

// ClearHyperlinks clears the hyperlinks edge to Hyperlink.
func (m *DocumentCategoryMutation) ClearHyperlinks() {
	m.clearedhyperlinks = true
}

// HyperlinksCleared returns if the edge hyperlinks was cleared.
func (m *DocumentCategoryMutation) HyperlinksCleared() bool {
	return m.clearedhyperlinks
}

// RemoveHyperlinkIDs removes the hyperlinks edge to Hyperlink by ids.
func (m *DocumentCategoryMutation) RemoveHyperlinkIDs(ids ...int) {
	if m.removedhyperlinks == nil {
		m.removedhyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhyperlinks[ids[i]] = struct{}{}
	}
}

// RemovedHyperlinks returns the removed ids of hyperlinks.
func (m *DocumentCategoryMutation) RemovedHyperlinksIDs() (ids []int) {
	for id := range m.removedhyperlinks {
		ids = append(ids, id)
	}
	return
}

// HyperlinksIDs returns the hyperlinks ids in the mutation.
func (m *DocumentCategoryMutation) HyperlinksIDs() (ids []int) {
	for id := range m.hyperlinks {
		ids = append(ids, id)
	}
	return
}

// ResetHyperlinks reset all changes of the "hyperlinks" edge.
func (m *DocumentCategoryMutation) ResetHyperlinks() {
	m.hyperlinks = nil
	m.clearedhyperlinks = false
	m.removedhyperlinks = nil
}

// Op returns the operation name.
func (m *DocumentCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DocumentCategory).
func (m *DocumentCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DocumentCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, documentcategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, documentcategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, documentcategory.FieldName)
	}
	if m.index != nil {
		fields = append(fields, documentcategory.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DocumentCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentcategory.FieldCreateTime:
		return m.CreateTime()
	case documentcategory.FieldUpdateTime:
		return m.UpdateTime()
	case documentcategory.FieldName:
		return m.Name()
	case documentcategory.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DocumentCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case documentcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case documentcategory.FieldName:
		return m.OldName(ctx)
	case documentcategory.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DocumentCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case documentcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case documentcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case documentcategory.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DocumentCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, documentcategory.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DocumentCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case documentcategory.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DocumentCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case documentcategory.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DocumentCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DocumentCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DocumentCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DocumentCategoryMutation) ResetField(name string) error {
	switch name {
	case documentcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case documentcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case documentcategory.FieldName:
		m.ResetName()
		return nil
	case documentcategory.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DocumentCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.location_type != nil {
		edges = append(edges, documentcategory.EdgeLocationType)
	}
	if m.files != nil {
		edges = append(edges, documentcategory.EdgeFiles)
	}
	if m.hyperlinks != nil {
		edges = append(edges, documentcategory.EdgeHyperlinks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DocumentCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documentcategory.EdgeLocationType:
		if id := m.location_type; id != nil {
			return []ent.Value{*id}
		}
	case documentcategory.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case documentcategory.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.hyperlinks))
		for id := range m.hyperlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DocumentCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfiles != nil {
		edges = append(edges, documentcategory.EdgeFiles)
	}
	if m.removedhyperlinks != nil {
		edges = append(edges, documentcategory.EdgeHyperlinks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DocumentCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case documentcategory.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case documentcategory.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.removedhyperlinks))
		for id := range m.removedhyperlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DocumentCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlocation_type {
		edges = append(edges, documentcategory.EdgeLocationType)
	}
	if m.clearedfiles {
		edges = append(edges, documentcategory.EdgeFiles)
	}
	if m.clearedhyperlinks {
		edges = append(edges, documentcategory.EdgeHyperlinks)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DocumentCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case documentcategory.EdgeLocationType:
		return m.clearedlocation_type
	case documentcategory.EdgeFiles:
		return m.clearedfiles
	case documentcategory.EdgeHyperlinks:
		return m.clearedhyperlinks
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DocumentCategoryMutation) ClearEdge(name string) error {
	switch name {
	case documentcategory.EdgeLocationType:
		m.ClearLocationType()
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DocumentCategoryMutation) ResetEdge(name string) error {
	switch name {
	case documentcategory.EdgeLocationType:
		m.ResetLocationType()
		return nil
	case documentcategory.EdgeFiles:
		m.ResetFiles()
		return nil
	case documentcategory.EdgeHyperlinks:
		m.ResetHyperlinks()
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory edge %s", name)
}

// DomainMutation represents an operation that mutate the Domains
// nodes in the graph.
type DomainMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	name              *string
	clearedFields     map[string]struct{}
	techdomain        map[int]struct{}
	removedtechdomain map[int]struct{}
	clearedtechdomain bool
	kpidomain         map[int]struct{}
	removedkpidomain  map[int]struct{}
	clearedkpidomain  bool
	done              bool
	oldValue          func(context.Context) (*Domain, error)
	predicates        []predicate.Domain
}

var _ ent.Mutation = (*DomainMutation)(nil)

// domainOption allows to manage the mutation configuration using functional options.
type domainOption func(*DomainMutation)

// newDomainMutation creates new mutation for Domain.
func newDomainMutation(c config, op Op, opts ...domainOption) *DomainMutation {
	m := &DomainMutation{
		config:        c,
		op:            op,
		typ:           TypeDomain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainID sets the id field of the mutation.
func withDomainID(id int) domainOption {
	return func(m *DomainMutation) {
		var (
			err   error
			once  sync.Once
			value *Domain
		)
		m.oldValue = func(ctx context.Context) (*Domain, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Domain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomain sets the old Domain of the mutation.
func withDomain(node *Domain) domainOption {
	return func(m *DomainMutation) {
		m.oldValue = func(context.Context) (*Domain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DomainMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *DomainMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *DomainMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Domain.
// If the Domain object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DomainMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *DomainMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *DomainMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *DomainMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Domain.
// If the Domain object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DomainMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *DomainMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *DomainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DomainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Domain.
// If the Domain object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DomainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DomainMutation) ResetName() {
	m.name = nil
}

// AddTechdomainIDs adds the techdomain edge to Tech by ids.
func (m *DomainMutation) AddTechdomainIDs(ids ...int) {
	if m.techdomain == nil {
		m.techdomain = make(map[int]struct{})
	}
	for i := range ids {
		m.techdomain[ids[i]] = struct{}{}
	}
}

// ClearTechdomain clears the techdomain edge to Tech.
func (m *DomainMutation) ClearTechdomain() {
	m.clearedtechdomain = true
}

// TechdomainCleared returns if the edge techdomain was cleared.
func (m *DomainMutation) TechdomainCleared() bool {
	return m.clearedtechdomain
}

// RemoveTechdomainIDs removes the techdomain edge to Tech by ids.
func (m *DomainMutation) RemoveTechdomainIDs(ids ...int) {
	if m.removedtechdomain == nil {
		m.removedtechdomain = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtechdomain[ids[i]] = struct{}{}
	}
}

// RemovedTechdomain returns the removed ids of techdomain.
func (m *DomainMutation) RemovedTechdomainIDs() (ids []int) {
	for id := range m.removedtechdomain {
		ids = append(ids, id)
	}
	return
}

// TechdomainIDs returns the techdomain ids in the mutation.
func (m *DomainMutation) TechdomainIDs() (ids []int) {
	for id := range m.techdomain {
		ids = append(ids, id)
	}
	return
}

// ResetTechdomain reset all changes of the "techdomain" edge.
func (m *DomainMutation) ResetTechdomain() {
	m.techdomain = nil
	m.clearedtechdomain = false
	m.removedtechdomain = nil
}

// AddKpidomainIDs adds the kpidomain edge to Kpi by ids.
func (m *DomainMutation) AddKpidomainIDs(ids ...int) {
	if m.kpidomain == nil {
		m.kpidomain = make(map[int]struct{})
	}
	for i := range ids {
		m.kpidomain[ids[i]] = struct{}{}
	}
}

// ClearKpidomain clears the kpidomain edge to Kpi.
func (m *DomainMutation) ClearKpidomain() {
	m.clearedkpidomain = true
}

// KpidomainCleared returns if the edge kpidomain was cleared.
func (m *DomainMutation) KpidomainCleared() bool {
	return m.clearedkpidomain
}

// RemoveKpidomainIDs removes the kpidomain edge to Kpi by ids.
func (m *DomainMutation) RemoveKpidomainIDs(ids ...int) {
	if m.removedkpidomain == nil {
		m.removedkpidomain = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkpidomain[ids[i]] = struct{}{}
	}
}

// RemovedKpidomain returns the removed ids of kpidomain.
func (m *DomainMutation) RemovedKpidomainIDs() (ids []int) {
	for id := range m.removedkpidomain {
		ids = append(ids, id)
	}
	return
}

// KpidomainIDs returns the kpidomain ids in the mutation.
func (m *DomainMutation) KpidomainIDs() (ids []int) {
	for id := range m.kpidomain {
		ids = append(ids, id)
	}
	return
}

// ResetKpidomain reset all changes of the "kpidomain" edge.
func (m *DomainMutation) ResetKpidomain() {
	m.kpidomain = nil
	m.clearedkpidomain = false
	m.removedkpidomain = nil
}

// Op returns the operation name.
func (m *DomainMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Domain).
func (m *DomainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DomainMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, domain.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, domain.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, domain.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DomainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldCreateTime:
		return m.CreateTime()
	case domain.FieldUpdateTime:
		return m.UpdateTime()
	case domain.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DomainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domain.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case domain.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case domain.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Domain field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DomainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domain.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case domain.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case domain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DomainMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DomainMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DomainMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DomainMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DomainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Domain nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DomainMutation) ResetField(name string) error {
	switch name {
	case domain.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case domain.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case domain.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DomainMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.techdomain != nil {
		edges = append(edges, domain.EdgeTechdomain)
	}
	if m.kpidomain != nil {
		edges = append(edges, domain.EdgeKpidomain)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DomainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeTechdomain:
		ids := make([]ent.Value, 0, len(m.techdomain))
		for id := range m.techdomain {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeKpidomain:
		ids := make([]ent.Value, 0, len(m.kpidomain))
		for id := range m.kpidomain {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DomainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtechdomain != nil {
		edges = append(edges, domain.EdgeTechdomain)
	}
	if m.removedkpidomain != nil {
		edges = append(edges, domain.EdgeKpidomain)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DomainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeTechdomain:
		ids := make([]ent.Value, 0, len(m.removedtechdomain))
		for id := range m.removedtechdomain {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeKpidomain:
		ids := make([]ent.Value, 0, len(m.removedkpidomain))
		for id := range m.removedkpidomain {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DomainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtechdomain {
		edges = append(edges, domain.EdgeTechdomain)
	}
	if m.clearedkpidomain {
		edges = append(edges, domain.EdgeKpidomain)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DomainMutation) EdgeCleared(name string) bool {
	switch name {
	case domain.EdgeTechdomain:
		return m.clearedtechdomain
	case domain.EdgeKpidomain:
		return m.clearedkpidomain
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DomainMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DomainMutation) ResetEdge(name string) error {
	switch name {
	case domain.EdgeTechdomain:
		m.ResetTechdomain()
		return nil
	case domain.EdgeKpidomain:
		m.ResetKpidomain()
		return nil
	}
	return fmt.Errorf("unknown Domain edge %s", name)
}

// EntryPointMutation represents an operation that mutate the EntryPoints
// nodes in the graph.
type EntryPointMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	role                    *flowschema.EntryPointRole
	cid                     *string
	clearedFields           map[string]struct{}
	prev_exit_points        map[int]struct{}
	removedprev_exit_points map[int]struct{}
	clearedprev_exit_points bool
	parent_block            *int
	clearedparent_block     bool
	done                    bool
	oldValue                func(context.Context) (*EntryPoint, error)
	predicates              []predicate.EntryPoint
}

var _ ent.Mutation = (*EntryPointMutation)(nil)

// entrypointOption allows to manage the mutation configuration using functional options.
type entrypointOption func(*EntryPointMutation)

// newEntryPointMutation creates new mutation for EntryPoint.
func newEntryPointMutation(c config, op Op, opts ...entrypointOption) *EntryPointMutation {
	m := &EntryPointMutation{
		config:        c,
		op:            op,
		typ:           TypeEntryPoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntryPointID sets the id field of the mutation.
func withEntryPointID(id int) entrypointOption {
	return func(m *EntryPointMutation) {
		var (
			err   error
			once  sync.Once
			value *EntryPoint
		)
		m.oldValue = func(ctx context.Context) (*EntryPoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntryPoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntryPoint sets the old EntryPoint of the mutation.
func withEntryPoint(node *EntryPoint) entrypointOption {
	return func(m *EntryPointMutation) {
		m.oldValue = func(context.Context) (*EntryPoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntryPointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntryPointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EntryPointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EntryPointMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EntryPointMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EntryPoint.
// If the EntryPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EntryPointMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EntryPointMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EntryPointMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EntryPointMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EntryPoint.
// If the EntryPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EntryPointMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EntryPointMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRole sets the role field.
func (m *EntryPointMutation) SetRole(fpr flowschema.EntryPointRole) {
	m.role = &fpr
}

// Role returns the role value in the mutation.
func (m *EntryPointMutation) Role() (r flowschema.EntryPointRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old role value of the EntryPoint.
// If the EntryPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EntryPointMutation) OldRole(ctx context.Context) (v flowschema.EntryPointRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole reset all changes of the "role" field.
func (m *EntryPointMutation) ResetRole() {
	m.role = nil
}

// SetCid sets the cid field.
func (m *EntryPointMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the cid value in the mutation.
func (m *EntryPointMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old cid value of the EntryPoint.
// If the EntryPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EntryPointMutation) OldCid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ClearCid clears the value of cid.
func (m *EntryPointMutation) ClearCid() {
	m.cid = nil
	m.clearedFields[entrypoint.FieldCid] = struct{}{}
}

// CidCleared returns if the field cid was cleared in this mutation.
func (m *EntryPointMutation) CidCleared() bool {
	_, ok := m.clearedFields[entrypoint.FieldCid]
	return ok
}

// ResetCid reset all changes of the "cid" field.
func (m *EntryPointMutation) ResetCid() {
	m.cid = nil
	delete(m.clearedFields, entrypoint.FieldCid)
}

// AddPrevExitPointIDs adds the prev_exit_points edge to ExitPoint by ids.
func (m *EntryPointMutation) AddPrevExitPointIDs(ids ...int) {
	if m.prev_exit_points == nil {
		m.prev_exit_points = make(map[int]struct{})
	}
	for i := range ids {
		m.prev_exit_points[ids[i]] = struct{}{}
	}
}

// ClearPrevExitPoints clears the prev_exit_points edge to ExitPoint.
func (m *EntryPointMutation) ClearPrevExitPoints() {
	m.clearedprev_exit_points = true
}

// PrevExitPointsCleared returns if the edge prev_exit_points was cleared.
func (m *EntryPointMutation) PrevExitPointsCleared() bool {
	return m.clearedprev_exit_points
}

// RemovePrevExitPointIDs removes the prev_exit_points edge to ExitPoint by ids.
func (m *EntryPointMutation) RemovePrevExitPointIDs(ids ...int) {
	if m.removedprev_exit_points == nil {
		m.removedprev_exit_points = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprev_exit_points[ids[i]] = struct{}{}
	}
}

// RemovedPrevExitPoints returns the removed ids of prev_exit_points.
func (m *EntryPointMutation) RemovedPrevExitPointsIDs() (ids []int) {
	for id := range m.removedprev_exit_points {
		ids = append(ids, id)
	}
	return
}

// PrevExitPointsIDs returns the prev_exit_points ids in the mutation.
func (m *EntryPointMutation) PrevExitPointsIDs() (ids []int) {
	for id := range m.prev_exit_points {
		ids = append(ids, id)
	}
	return
}

// ResetPrevExitPoints reset all changes of the "prev_exit_points" edge.
func (m *EntryPointMutation) ResetPrevExitPoints() {
	m.prev_exit_points = nil
	m.clearedprev_exit_points = false
	m.removedprev_exit_points = nil
}

// SetParentBlockID sets the parent_block edge to Block by id.
func (m *EntryPointMutation) SetParentBlockID(id int) {
	m.parent_block = &id
}

// ClearParentBlock clears the parent_block edge to Block.
func (m *EntryPointMutation) ClearParentBlock() {
	m.clearedparent_block = true
}

// ParentBlockCleared returns if the edge parent_block was cleared.
func (m *EntryPointMutation) ParentBlockCleared() bool {
	return m.clearedparent_block
}

// ParentBlockID returns the parent_block id in the mutation.
func (m *EntryPointMutation) ParentBlockID() (id int, exists bool) {
	if m.parent_block != nil {
		return *m.parent_block, true
	}
	return
}

// ParentBlockIDs returns the parent_block ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentBlockID instead. It exists only for internal usage by the builders.
func (m *EntryPointMutation) ParentBlockIDs() (ids []int) {
	if id := m.parent_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentBlock reset all changes of the "parent_block" edge.
func (m *EntryPointMutation) ResetParentBlock() {
	m.parent_block = nil
	m.clearedparent_block = false
}

// Op returns the operation name.
func (m *EntryPointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntryPoint).
func (m *EntryPointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EntryPointMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, entrypoint.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, entrypoint.FieldUpdateTime)
	}
	if m.role != nil {
		fields = append(fields, entrypoint.FieldRole)
	}
	if m.cid != nil {
		fields = append(fields, entrypoint.FieldCid)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EntryPointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entrypoint.FieldCreateTime:
		return m.CreateTime()
	case entrypoint.FieldUpdateTime:
		return m.UpdateTime()
	case entrypoint.FieldRole:
		return m.Role()
	case entrypoint.FieldCid:
		return m.Cid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EntryPointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entrypoint.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case entrypoint.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case entrypoint.FieldRole:
		return m.OldRole(ctx)
	case entrypoint.FieldCid:
		return m.OldCid(ctx)
	}
	return nil, fmt.Errorf("unknown EntryPoint field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EntryPointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entrypoint.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case entrypoint.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case entrypoint.FieldRole:
		v, ok := value.(flowschema.EntryPointRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case entrypoint.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	}
	return fmt.Errorf("unknown EntryPoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EntryPointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EntryPointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EntryPointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntryPoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EntryPointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entrypoint.FieldCid) {
		fields = append(fields, entrypoint.FieldCid)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EntryPointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntryPointMutation) ClearField(name string) error {
	switch name {
	case entrypoint.FieldCid:
		m.ClearCid()
		return nil
	}
	return fmt.Errorf("unknown EntryPoint nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EntryPointMutation) ResetField(name string) error {
	switch name {
	case entrypoint.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case entrypoint.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case entrypoint.FieldRole:
		m.ResetRole()
		return nil
	case entrypoint.FieldCid:
		m.ResetCid()
		return nil
	}
	return fmt.Errorf("unknown EntryPoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EntryPointMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.prev_exit_points != nil {
		edges = append(edges, entrypoint.EdgePrevExitPoints)
	}
	if m.parent_block != nil {
		edges = append(edges, entrypoint.EdgeParentBlock)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EntryPointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entrypoint.EdgePrevExitPoints:
		ids := make([]ent.Value, 0, len(m.prev_exit_points))
		for id := range m.prev_exit_points {
			ids = append(ids, id)
		}
		return ids
	case entrypoint.EdgeParentBlock:
		if id := m.parent_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EntryPointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprev_exit_points != nil {
		edges = append(edges, entrypoint.EdgePrevExitPoints)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EntryPointMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entrypoint.EdgePrevExitPoints:
		ids := make([]ent.Value, 0, len(m.removedprev_exit_points))
		for id := range m.removedprev_exit_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EntryPointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprev_exit_points {
		edges = append(edges, entrypoint.EdgePrevExitPoints)
	}
	if m.clearedparent_block {
		edges = append(edges, entrypoint.EdgeParentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EntryPointMutation) EdgeCleared(name string) bool {
	switch name {
	case entrypoint.EdgePrevExitPoints:
		return m.clearedprev_exit_points
	case entrypoint.EdgeParentBlock:
		return m.clearedparent_block
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EntryPointMutation) ClearEdge(name string) error {
	switch name {
	case entrypoint.EdgeParentBlock:
		m.ClearParentBlock()
		return nil
	}
	return fmt.Errorf("unknown EntryPoint unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EntryPointMutation) ResetEdge(name string) error {
	switch name {
	case entrypoint.EdgePrevExitPoints:
		m.ResetPrevExitPoints()
		return nil
	case entrypoint.EdgeParentBlock:
		m.ResetParentBlock()
		return nil
	}
	return fmt.Errorf("unknown EntryPoint edge %s", name)
}

// EquipmentMutation represents an operation that mutate the EquipmentSlice
// nodes in the graph.
type EquipmentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	name                   *string
	future_state           *enum.FutureState
	device_id              *string
	external_id            *string
	clearedFields          map[string]struct{}
	_type                  *int
	cleared_type           bool
	location               *int
	clearedlocation        bool
	parent_position        *int
	clearedparent_position bool
	positions              map[int]struct{}
	removedpositions       map[int]struct{}
	clearedpositions       bool
	ports                  map[int]struct{}
	removedports           map[int]struct{}
	clearedports           bool
	work_order             *int
	clearedwork_order      bool
	properties             map[int]struct{}
	removedproperties      map[int]struct{}
	clearedproperties      bool
	files                  map[int]struct{}
	removedfiles           map[int]struct{}
	clearedfiles           bool
	hyperlinks             map[int]struct{}
	removedhyperlinks      map[int]struct{}
	clearedhyperlinks      bool
	endpoints              map[int]struct{}
	removedendpoints       map[int]struct{}
	clearedendpoints       bool
	done                   bool
	oldValue               func(context.Context) (*Equipment, error)
	predicates             []predicate.Equipment
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows to manage the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for Equipment.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the id field of the mutation.
func withEquipmentID(id int) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *EquipmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EquipmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EquipmentMutation) ResetName() {
	m.name = nil
}

// SetFutureState sets the future_state field.
func (m *EquipmentMutation) SetFutureState(es enum.FutureState) {
	m.future_state = &es
}

// FutureState returns the future_state value in the mutation.
func (m *EquipmentMutation) FutureState() (r enum.FutureState, exists bool) {
	v := m.future_state
	if v == nil {
		return
	}
	return *v, true
}

// OldFutureState returns the old future_state value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldFutureState(ctx context.Context) (v *enum.FutureState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFutureState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFutureState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFutureState: %w", err)
	}
	return oldValue.FutureState, nil
}

// ClearFutureState clears the value of future_state.
func (m *EquipmentMutation) ClearFutureState() {
	m.future_state = nil
	m.clearedFields[equipment.FieldFutureState] = struct{}{}
}

// FutureStateCleared returns if the field future_state was cleared in this mutation.
func (m *EquipmentMutation) FutureStateCleared() bool {
	_, ok := m.clearedFields[equipment.FieldFutureState]
	return ok
}

// ResetFutureState reset all changes of the "future_state" field.
func (m *EquipmentMutation) ResetFutureState() {
	m.future_state = nil
	delete(m.clearedFields, equipment.FieldFutureState)
}

// SetDeviceID sets the device_id field.
func (m *EquipmentMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the device_id value in the mutation.
func (m *EquipmentMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old device_id value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of device_id.
func (m *EquipmentMutation) ClearDeviceID() {
	m.device_id = nil
	m.clearedFields[equipment.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the field device_id was cleared in this mutation.
func (m *EquipmentMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[equipment.FieldDeviceID]
	return ok
}

// ResetDeviceID reset all changes of the "device_id" field.
func (m *EquipmentMutation) ResetDeviceID() {
	m.device_id = nil
	delete(m.clearedFields, equipment.FieldDeviceID)
}

// SetExternalID sets the external_id field.
func (m *EquipmentMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the external_id value in the mutation.
func (m *EquipmentMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old external_id value of the Equipment.
// If the Equipment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of external_id.
func (m *EquipmentMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[equipment.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the field external_id was cleared in this mutation.
func (m *EquipmentMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[equipment.FieldExternalID]
	return ok
}

// ResetExternalID reset all changes of the "external_id" field.
func (m *EquipmentMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, equipment.FieldExternalID)
}

// SetTypeID sets the type edge to EquipmentType by id.
func (m *EquipmentMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to EquipmentType.
func (m *EquipmentMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *EquipmentMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *EquipmentMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *EquipmentMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetLocationID sets the location edge to Location by id.
func (m *EquipmentMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *EquipmentMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *EquipmentMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *EquipmentMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *EquipmentMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetParentPositionID sets the parent_position edge to EquipmentPosition by id.
func (m *EquipmentMutation) SetParentPositionID(id int) {
	m.parent_position = &id
}

// ClearParentPosition clears the parent_position edge to EquipmentPosition.
func (m *EquipmentMutation) ClearParentPosition() {
	m.clearedparent_position = true
}

// ParentPositionCleared returns if the edge parent_position was cleared.
func (m *EquipmentMutation) ParentPositionCleared() bool {
	return m.clearedparent_position
}

// ParentPositionID returns the parent_position id in the mutation.
func (m *EquipmentMutation) ParentPositionID() (id int, exists bool) {
	if m.parent_position != nil {
		return *m.parent_position, true
	}
	return
}

// ParentPositionIDs returns the parent_position ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentPositionID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) ParentPositionIDs() (ids []int) {
	if id := m.parent_position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentPosition reset all changes of the "parent_position" edge.
func (m *EquipmentMutation) ResetParentPosition() {
	m.parent_position = nil
	m.clearedparent_position = false
}

// AddPositionIDs adds the positions edge to EquipmentPosition by ids.
func (m *EquipmentMutation) AddPositionIDs(ids ...int) {
	if m.positions == nil {
		m.positions = make(map[int]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the positions edge to EquipmentPosition.
func (m *EquipmentMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared returns if the edge positions was cleared.
func (m *EquipmentMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the positions edge to EquipmentPosition by ids.
func (m *EquipmentMutation) RemovePositionIDs(ids ...int) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed ids of positions.
func (m *EquipmentMutation) RemovedPositionsIDs() (ids []int) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the positions ids in the mutation.
func (m *EquipmentMutation) PositionsIDs() (ids []int) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions reset all changes of the "positions" edge.
func (m *EquipmentMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// AddPortIDs adds the ports edge to EquipmentPort by ids.
func (m *EquipmentMutation) AddPortIDs(ids ...int) {
	if m.ports == nil {
		m.ports = make(map[int]struct{})
	}
	for i := range ids {
		m.ports[ids[i]] = struct{}{}
	}
}

// ClearPorts clears the ports edge to EquipmentPort.
func (m *EquipmentMutation) ClearPorts() {
	m.clearedports = true
}

// PortsCleared returns if the edge ports was cleared.
func (m *EquipmentMutation) PortsCleared() bool {
	return m.clearedports
}

// RemovePortIDs removes the ports edge to EquipmentPort by ids.
func (m *EquipmentMutation) RemovePortIDs(ids ...int) {
	if m.removedports == nil {
		m.removedports = make(map[int]struct{})
	}
	for i := range ids {
		m.removedports[ids[i]] = struct{}{}
	}
}

// RemovedPorts returns the removed ids of ports.
func (m *EquipmentMutation) RemovedPortsIDs() (ids []int) {
	for id := range m.removedports {
		ids = append(ids, id)
	}
	return
}

// PortsIDs returns the ports ids in the mutation.
func (m *EquipmentMutation) PortsIDs() (ids []int) {
	for id := range m.ports {
		ids = append(ids, id)
	}
	return
}

// ResetPorts reset all changes of the "ports" edge.
func (m *EquipmentMutation) ResetPorts() {
	m.ports = nil
	m.clearedports = false
	m.removedports = nil
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *EquipmentMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *EquipmentMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *EquipmentMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *EquipmentMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *EquipmentMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *EquipmentMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *EquipmentMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *EquipmentMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *EquipmentMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *EquipmentMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *EquipmentMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *EquipmentMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddFileIDs adds the files edge to File by ids.
func (m *EquipmentMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the files edge to File.
func (m *EquipmentMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared returns if the edge files was cleared.
func (m *EquipmentMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the files edge to File by ids.
func (m *EquipmentMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed ids of files.
func (m *EquipmentMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the files ids in the mutation.
func (m *EquipmentMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles reset all changes of the "files" edge.
func (m *EquipmentMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddHyperlinkIDs adds the hyperlinks edge to Hyperlink by ids.
func (m *EquipmentMutation) AddHyperlinkIDs(ids ...int) {
	if m.hyperlinks == nil {
		m.hyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.hyperlinks[ids[i]] = struct{}{}
	}
}

// ClearHyperlinks clears the hyperlinks edge to Hyperlink.
func (m *EquipmentMutation) ClearHyperlinks() {
	m.clearedhyperlinks = true
}

// HyperlinksCleared returns if the edge hyperlinks was cleared.
func (m *EquipmentMutation) HyperlinksCleared() bool {
	return m.clearedhyperlinks
}

// RemoveHyperlinkIDs removes the hyperlinks edge to Hyperlink by ids.
func (m *EquipmentMutation) RemoveHyperlinkIDs(ids ...int) {
	if m.removedhyperlinks == nil {
		m.removedhyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhyperlinks[ids[i]] = struct{}{}
	}
}

// RemovedHyperlinks returns the removed ids of hyperlinks.
func (m *EquipmentMutation) RemovedHyperlinksIDs() (ids []int) {
	for id := range m.removedhyperlinks {
		ids = append(ids, id)
	}
	return
}

// HyperlinksIDs returns the hyperlinks ids in the mutation.
func (m *EquipmentMutation) HyperlinksIDs() (ids []int) {
	for id := range m.hyperlinks {
		ids = append(ids, id)
	}
	return
}

// ResetHyperlinks reset all changes of the "hyperlinks" edge.
func (m *EquipmentMutation) ResetHyperlinks() {
	m.hyperlinks = nil
	m.clearedhyperlinks = false
	m.removedhyperlinks = nil
}

// AddEndpointIDs adds the endpoints edge to ServiceEndpoint by ids.
func (m *EquipmentMutation) AddEndpointIDs(ids ...int) {
	if m.endpoints == nil {
		m.endpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.endpoints[ids[i]] = struct{}{}
	}
}

// ClearEndpoints clears the endpoints edge to ServiceEndpoint.
func (m *EquipmentMutation) ClearEndpoints() {
	m.clearedendpoints = true
}

// EndpointsCleared returns if the edge endpoints was cleared.
func (m *EquipmentMutation) EndpointsCleared() bool {
	return m.clearedendpoints
}

// RemoveEndpointIDs removes the endpoints edge to ServiceEndpoint by ids.
func (m *EquipmentMutation) RemoveEndpointIDs(ids ...int) {
	if m.removedendpoints == nil {
		m.removedendpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.removedendpoints[ids[i]] = struct{}{}
	}
}

// RemovedEndpoints returns the removed ids of endpoints.
func (m *EquipmentMutation) RemovedEndpointsIDs() (ids []int) {
	for id := range m.removedendpoints {
		ids = append(ids, id)
	}
	return
}

// EndpointsIDs returns the endpoints ids in the mutation.
func (m *EquipmentMutation) EndpointsIDs() (ids []int) {
	for id := range m.endpoints {
		ids = append(ids, id)
	}
	return
}

// ResetEndpoints reset all changes of the "endpoints" edge.
func (m *EquipmentMutation) ResetEndpoints() {
	m.endpoints = nil
	m.clearedendpoints = false
	m.removedendpoints = nil
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, equipment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipment.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, equipment.FieldName)
	}
	if m.future_state != nil {
		fields = append(fields, equipment.FieldFutureState)
	}
	if m.device_id != nil {
		fields = append(fields, equipment.FieldDeviceID)
	}
	if m.external_id != nil {
		fields = append(fields, equipment.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldCreateTime:
		return m.CreateTime()
	case equipment.FieldUpdateTime:
		return m.UpdateTime()
	case equipment.FieldName:
		return m.Name()
	case equipment.FieldFutureState:
		return m.FutureState()
	case equipment.FieldDeviceID:
		return m.DeviceID()
	case equipment.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case equipment.FieldName:
		return m.OldName(ctx)
	case equipment.FieldFutureState:
		return m.OldFutureState(ctx)
	case equipment.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case equipment.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case equipment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipment.FieldFutureState:
		v, ok := value.(enum.FutureState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFutureState(v)
		return nil
	case equipment.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case equipment.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipment.FieldFutureState) {
		fields = append(fields, equipment.FieldFutureState)
	}
	if m.FieldCleared(equipment.FieldDeviceID) {
		fields = append(fields, equipment.FieldDeviceID)
	}
	if m.FieldCleared(equipment.FieldExternalID) {
		fields = append(fields, equipment.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	switch name {
	case equipment.FieldFutureState:
		m.ClearFutureState()
		return nil
	case equipment.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	case equipment.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case equipment.FieldName:
		m.ResetName()
		return nil
	case equipment.FieldFutureState:
		m.ResetFutureState()
		return nil
	case equipment.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case equipment.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m._type != nil {
		edges = append(edges, equipment.EdgeType)
	}
	if m.location != nil {
		edges = append(edges, equipment.EdgeLocation)
	}
	if m.parent_position != nil {
		edges = append(edges, equipment.EdgeParentPosition)
	}
	if m.positions != nil {
		edges = append(edges, equipment.EdgePositions)
	}
	if m.ports != nil {
		edges = append(edges, equipment.EdgePorts)
	}
	if m.work_order != nil {
		edges = append(edges, equipment.EdgeWorkOrder)
	}
	if m.properties != nil {
		edges = append(edges, equipment.EdgeProperties)
	}
	if m.files != nil {
		edges = append(edges, equipment.EdgeFiles)
	}
	if m.hyperlinks != nil {
		edges = append(edges, equipment.EdgeHyperlinks)
	}
	if m.endpoints != nil {
		edges = append(edges, equipment.EdgeEndpoints)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeParentPosition:
		if id := m.parent_position; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgePorts:
		ids := make([]ent.Value, 0, len(m.ports))
		for id := range m.ports {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.hyperlinks))
		for id := range m.hyperlinks {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.endpoints))
		for id := range m.endpoints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedpositions != nil {
		edges = append(edges, equipment.EdgePositions)
	}
	if m.removedports != nil {
		edges = append(edges, equipment.EdgePorts)
	}
	if m.removedproperties != nil {
		edges = append(edges, equipment.EdgeProperties)
	}
	if m.removedfiles != nil {
		edges = append(edges, equipment.EdgeFiles)
	}
	if m.removedhyperlinks != nil {
		edges = append(edges, equipment.EdgeHyperlinks)
	}
	if m.removedendpoints != nil {
		edges = append(edges, equipment.EdgeEndpoints)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgePorts:
		ids := make([]ent.Value, 0, len(m.removedports))
		for id := range m.removedports {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.removedhyperlinks))
		for id := range m.removedhyperlinks {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.removedendpoints))
		for id := range m.removedendpoints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleared_type {
		edges = append(edges, equipment.EdgeType)
	}
	if m.clearedlocation {
		edges = append(edges, equipment.EdgeLocation)
	}
	if m.clearedparent_position {
		edges = append(edges, equipment.EdgeParentPosition)
	}
	if m.clearedpositions {
		edges = append(edges, equipment.EdgePositions)
	}
	if m.clearedports {
		edges = append(edges, equipment.EdgePorts)
	}
	if m.clearedwork_order {
		edges = append(edges, equipment.EdgeWorkOrder)
	}
	if m.clearedproperties {
		edges = append(edges, equipment.EdgeProperties)
	}
	if m.clearedfiles {
		edges = append(edges, equipment.EdgeFiles)
	}
	if m.clearedhyperlinks {
		edges = append(edges, equipment.EdgeHyperlinks)
	}
	if m.clearedendpoints {
		edges = append(edges, equipment.EdgeEndpoints)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case equipment.EdgeType:
		return m.cleared_type
	case equipment.EdgeLocation:
		return m.clearedlocation
	case equipment.EdgeParentPosition:
		return m.clearedparent_position
	case equipment.EdgePositions:
		return m.clearedpositions
	case equipment.EdgePorts:
		return m.clearedports
	case equipment.EdgeWorkOrder:
		return m.clearedwork_order
	case equipment.EdgeProperties:
		return m.clearedproperties
	case equipment.EdgeFiles:
		return m.clearedfiles
	case equipment.EdgeHyperlinks:
		return m.clearedhyperlinks
	case equipment.EdgeEndpoints:
		return m.clearedendpoints
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	switch name {
	case equipment.EdgeType:
		m.ClearType()
		return nil
	case equipment.EdgeLocation:
		m.ClearLocation()
		return nil
	case equipment.EdgeParentPosition:
		m.ClearParentPosition()
		return nil
	case equipment.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	}
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	switch name {
	case equipment.EdgeType:
		m.ResetType()
		return nil
	case equipment.EdgeLocation:
		m.ResetLocation()
		return nil
	case equipment.EdgeParentPosition:
		m.ResetParentPosition()
		return nil
	case equipment.EdgePositions:
		m.ResetPositions()
		return nil
	case equipment.EdgePorts:
		m.ResetPorts()
		return nil
	case equipment.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	case equipment.EdgeProperties:
		m.ResetProperties()
		return nil
	case equipment.EdgeFiles:
		m.ResetFiles()
		return nil
	case equipment.EdgeHyperlinks:
		m.ResetHyperlinks()
		return nil
	case equipment.EdgeEndpoints:
		m.ResetEndpoints()
		return nil
	}
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// EquipmentCategoryMutation represents an operation that mutate the EquipmentCategories
// nodes in the graph.
type EquipmentCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	clearedFields map[string]struct{}
	types         map[int]struct{}
	removedtypes  map[int]struct{}
	clearedtypes  bool
	done          bool
	oldValue      func(context.Context) (*EquipmentCategory, error)
	predicates    []predicate.EquipmentCategory
}

var _ ent.Mutation = (*EquipmentCategoryMutation)(nil)

// equipmentcategoryOption allows to manage the mutation configuration using functional options.
type equipmentcategoryOption func(*EquipmentCategoryMutation)

// newEquipmentCategoryMutation creates new mutation for EquipmentCategory.
func newEquipmentCategoryMutation(c config, op Op, opts ...equipmentcategoryOption) *EquipmentCategoryMutation {
	m := &EquipmentCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentCategoryID sets the id field of the mutation.
func withEquipmentCategoryID(id int) equipmentcategoryOption {
	return func(m *EquipmentCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentCategory
		)
		m.oldValue = func(ctx context.Context) (*EquipmentCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentCategory sets the old EquipmentCategory of the mutation.
func withEquipmentCategory(node *EquipmentCategory) equipmentcategoryOption {
	return func(m *EquipmentCategoryMutation) {
		m.oldValue = func(context.Context) (*EquipmentCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EquipmentCategory.
// If the EquipmentCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EquipmentCategory.
// If the EquipmentCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *EquipmentCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EquipmentCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EquipmentCategory.
// If the EquipmentCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EquipmentCategoryMutation) ResetName() {
	m.name = nil
}

// AddTypeIDs adds the types edge to EquipmentType by ids.
func (m *EquipmentCategoryMutation) AddTypeIDs(ids ...int) {
	if m.types == nil {
		m.types = make(map[int]struct{})
	}
	for i := range ids {
		m.types[ids[i]] = struct{}{}
	}
}

// ClearTypes clears the types edge to EquipmentType.
func (m *EquipmentCategoryMutation) ClearTypes() {
	m.clearedtypes = true
}

// TypesCleared returns if the edge types was cleared.
func (m *EquipmentCategoryMutation) TypesCleared() bool {
	return m.clearedtypes
}

// RemoveTypeIDs removes the types edge to EquipmentType by ids.
func (m *EquipmentCategoryMutation) RemoveTypeIDs(ids ...int) {
	if m.removedtypes == nil {
		m.removedtypes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtypes[ids[i]] = struct{}{}
	}
}

// RemovedTypes returns the removed ids of types.
func (m *EquipmentCategoryMutation) RemovedTypesIDs() (ids []int) {
	for id := range m.removedtypes {
		ids = append(ids, id)
	}
	return
}

// TypesIDs returns the types ids in the mutation.
func (m *EquipmentCategoryMutation) TypesIDs() (ids []int) {
	for id := range m.types {
		ids = append(ids, id)
	}
	return
}

// ResetTypes reset all changes of the "types" edge.
func (m *EquipmentCategoryMutation) ResetTypes() {
	m.types = nil
	m.clearedtypes = false
	m.removedtypes = nil
}

// Op returns the operation name.
func (m *EquipmentCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentCategory).
func (m *EquipmentCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, equipmentcategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipmentcategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, equipmentcategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentcategory.FieldCreateTime:
		return m.CreateTime()
	case equipmentcategory.FieldUpdateTime:
		return m.UpdateTime()
	case equipmentcategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipmentcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case equipmentcategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipmentcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case equipmentcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentCategoryMutation) ResetField(name string) error {
	switch name {
	case equipmentcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipmentcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case equipmentcategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EquipmentCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.types != nil {
		edges = append(edges, equipmentcategory.EdgeTypes)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentcategory.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.types))
		for id := range m.types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtypes != nil {
		edges = append(edges, equipmentcategory.EdgeTypes)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmentcategory.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.removedtypes))
		for id := range m.removedtypes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtypes {
		edges = append(edges, equipmentcategory.EdgeTypes)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentcategory.EdgeTypes:
		return m.clearedtypes
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentCategoryMutation) ResetEdge(name string) error {
	switch name {
	case equipmentcategory.EdgeTypes:
		m.ResetTypes()
		return nil
	}
	return fmt.Errorf("unknown EquipmentCategory edge %s", name)
}

// EquipmentPortMutation represents an operation that mutate the EquipmentPorts
// nodes in the graph.
type EquipmentPortMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	definition        *int
	cleareddefinition bool
	parent            *int
	clearedparent     bool
	link              *int
	clearedlink       bool
	properties        map[int]struct{}
	removedproperties map[int]struct{}
	clearedproperties bool
	endpoints         map[int]struct{}
	removedendpoints  map[int]struct{}
	clearedendpoints  bool
	service           map[int]struct{}
	removedservice    map[int]struct{}
	clearedservice    bool
	done              bool
	oldValue          func(context.Context) (*EquipmentPort, error)
	predicates        []predicate.EquipmentPort
}

var _ ent.Mutation = (*EquipmentPortMutation)(nil)

// equipmentportOption allows to manage the mutation configuration using functional options.
type equipmentportOption func(*EquipmentPortMutation)

// newEquipmentPortMutation creates new mutation for EquipmentPort.
func newEquipmentPortMutation(c config, op Op, opts ...equipmentportOption) *EquipmentPortMutation {
	m := &EquipmentPortMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentPort,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentPortID sets the id field of the mutation.
func withEquipmentPortID(id int) equipmentportOption {
	return func(m *EquipmentPortMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentPort
		)
		m.oldValue = func(ctx context.Context) (*EquipmentPort, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentPort.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentPort sets the old EquipmentPort of the mutation.
func withEquipmentPort(node *EquipmentPort) equipmentportOption {
	return func(m *EquipmentPortMutation) {
		m.oldValue = func(context.Context) (*EquipmentPort, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentPortMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentPortMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentPortMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentPortMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentPortMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EquipmentPort.
// If the EquipmentPort object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentPortMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentPortMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentPortMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EquipmentPort.
// If the EquipmentPort object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentPortMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDefinitionID sets the definition edge to EquipmentPortDefinition by id.
func (m *EquipmentPortMutation) SetDefinitionID(id int) {
	m.definition = &id
}

// ClearDefinition clears the definition edge to EquipmentPortDefinition.
func (m *EquipmentPortMutation) ClearDefinition() {
	m.cleareddefinition = true
}

// DefinitionCleared returns if the edge definition was cleared.
func (m *EquipmentPortMutation) DefinitionCleared() bool {
	return m.cleareddefinition
}

// DefinitionID returns the definition id in the mutation.
func (m *EquipmentPortMutation) DefinitionID() (id int, exists bool) {
	if m.definition != nil {
		return *m.definition, true
	}
	return
}

// DefinitionIDs returns the definition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DefinitionID instead. It exists only for internal usage by the builders.
func (m *EquipmentPortMutation) DefinitionIDs() (ids []int) {
	if id := m.definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefinition reset all changes of the "definition" edge.
func (m *EquipmentPortMutation) ResetDefinition() {
	m.definition = nil
	m.cleareddefinition = false
}

// SetParentID sets the parent edge to Equipment by id.
func (m *EquipmentPortMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the parent edge to Equipment.
func (m *EquipmentPortMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *EquipmentPortMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *EquipmentPortMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *EquipmentPortMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *EquipmentPortMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetLinkID sets the link edge to Link by id.
func (m *EquipmentPortMutation) SetLinkID(id int) {
	m.link = &id
}

// ClearLink clears the link edge to Link.
func (m *EquipmentPortMutation) ClearLink() {
	m.clearedlink = true
}

// LinkCleared returns if the edge link was cleared.
func (m *EquipmentPortMutation) LinkCleared() bool {
	return m.clearedlink
}

// LinkID returns the link id in the mutation.
func (m *EquipmentPortMutation) LinkID() (id int, exists bool) {
	if m.link != nil {
		return *m.link, true
	}
	return
}

// LinkIDs returns the link ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *EquipmentPortMutation) LinkIDs() (ids []int) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink reset all changes of the "link" edge.
func (m *EquipmentPortMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *EquipmentPortMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *EquipmentPortMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *EquipmentPortMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *EquipmentPortMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *EquipmentPortMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *EquipmentPortMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *EquipmentPortMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddEndpointIDs adds the endpoints edge to ServiceEndpoint by ids.
func (m *EquipmentPortMutation) AddEndpointIDs(ids ...int) {
	if m.endpoints == nil {
		m.endpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.endpoints[ids[i]] = struct{}{}
	}
}

// ClearEndpoints clears the endpoints edge to ServiceEndpoint.
func (m *EquipmentPortMutation) ClearEndpoints() {
	m.clearedendpoints = true
}

// EndpointsCleared returns if the edge endpoints was cleared.
func (m *EquipmentPortMutation) EndpointsCleared() bool {
	return m.clearedendpoints
}

// RemoveEndpointIDs removes the endpoints edge to ServiceEndpoint by ids.
func (m *EquipmentPortMutation) RemoveEndpointIDs(ids ...int) {
	if m.removedendpoints == nil {
		m.removedendpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.removedendpoints[ids[i]] = struct{}{}
	}
}

// RemovedEndpoints returns the removed ids of endpoints.
func (m *EquipmentPortMutation) RemovedEndpointsIDs() (ids []int) {
	for id := range m.removedendpoints {
		ids = append(ids, id)
	}
	return
}

// EndpointsIDs returns the endpoints ids in the mutation.
func (m *EquipmentPortMutation) EndpointsIDs() (ids []int) {
	for id := range m.endpoints {
		ids = append(ids, id)
	}
	return
}

// ResetEndpoints reset all changes of the "endpoints" edge.
func (m *EquipmentPortMutation) ResetEndpoints() {
	m.endpoints = nil
	m.clearedendpoints = false
	m.removedendpoints = nil
}

// AddServiceIDs adds the service edge to Service by ids.
func (m *EquipmentPortMutation) AddServiceIDs(ids ...int) {
	if m.service == nil {
		m.service = make(map[int]struct{})
	}
	for i := range ids {
		m.service[ids[i]] = struct{}{}
	}
}

// ClearService clears the service edge to Service.
func (m *EquipmentPortMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared returns if the edge service was cleared.
func (m *EquipmentPortMutation) ServiceCleared() bool {
	return m.clearedservice
}

// RemoveServiceIDs removes the service edge to Service by ids.
func (m *EquipmentPortMutation) RemoveServiceIDs(ids ...int) {
	if m.removedservice == nil {
		m.removedservice = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservice[ids[i]] = struct{}{}
	}
}

// RemovedService returns the removed ids of service.
func (m *EquipmentPortMutation) RemovedServiceIDs() (ids []int) {
	for id := range m.removedservice {
		ids = append(ids, id)
	}
	return
}

// ServiceIDs returns the service ids in the mutation.
func (m *EquipmentPortMutation) ServiceIDs() (ids []int) {
	for id := range m.service {
		ids = append(ids, id)
	}
	return
}

// ResetService reset all changes of the "service" edge.
func (m *EquipmentPortMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
	m.removedservice = nil
}

// Op returns the operation name.
func (m *EquipmentPortMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentPort).
func (m *EquipmentPortMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentPortMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, equipmentport.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipmentport.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentPortMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentport.FieldCreateTime:
		return m.CreateTime()
	case equipmentport.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentPortMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentport.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipmentport.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentPort field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPortMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentport.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipmentport.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentPort field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentPortMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentPortMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPortMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentPort numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentPortMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentPortMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentPortMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentPort nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentPortMutation) ResetField(name string) error {
	switch name {
	case equipmentport.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipmentport.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPort field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentPortMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.definition != nil {
		edges = append(edges, equipmentport.EdgeDefinition)
	}
	if m.parent != nil {
		edges = append(edges, equipmentport.EdgeParent)
	}
	if m.link != nil {
		edges = append(edges, equipmentport.EdgeLink)
	}
	if m.properties != nil {
		edges = append(edges, equipmentport.EdgeProperties)
	}
	if m.endpoints != nil {
		edges = append(edges, equipmentport.EdgeEndpoints)
	}
	if m.service != nil {
		edges = append(edges, equipmentport.EdgeService)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentPortMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentport.EdgeDefinition:
		if id := m.definition; id != nil {
			return []ent.Value{*id}
		}
	case equipmentport.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case equipmentport.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	case equipmentport.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case equipmentport.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.endpoints))
		for id := range m.endpoints {
			ids = append(ids, id)
		}
		return ids
	case equipmentport.EdgeService:
		ids := make([]ent.Value, 0, len(m.service))
		for id := range m.service {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentPortMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedproperties != nil {
		edges = append(edges, equipmentport.EdgeProperties)
	}
	if m.removedendpoints != nil {
		edges = append(edges, equipmentport.EdgeEndpoints)
	}
	if m.removedservice != nil {
		edges = append(edges, equipmentport.EdgeService)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentPortMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmentport.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case equipmentport.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.removedendpoints))
		for id := range m.removedendpoints {
			ids = append(ids, id)
		}
		return ids
	case equipmentport.EdgeService:
		ids := make([]ent.Value, 0, len(m.removedservice))
		for id := range m.removedservice {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentPortMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareddefinition {
		edges = append(edges, equipmentport.EdgeDefinition)
	}
	if m.clearedparent {
		edges = append(edges, equipmentport.EdgeParent)
	}
	if m.clearedlink {
		edges = append(edges, equipmentport.EdgeLink)
	}
	if m.clearedproperties {
		edges = append(edges, equipmentport.EdgeProperties)
	}
	if m.clearedendpoints {
		edges = append(edges, equipmentport.EdgeEndpoints)
	}
	if m.clearedservice {
		edges = append(edges, equipmentport.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentPortMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentport.EdgeDefinition:
		return m.cleareddefinition
	case equipmentport.EdgeParent:
		return m.clearedparent
	case equipmentport.EdgeLink:
		return m.clearedlink
	case equipmentport.EdgeProperties:
		return m.clearedproperties
	case equipmentport.EdgeEndpoints:
		return m.clearedendpoints
	case equipmentport.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentPortMutation) ClearEdge(name string) error {
	switch name {
	case equipmentport.EdgeDefinition:
		m.ClearDefinition()
		return nil
	case equipmentport.EdgeParent:
		m.ClearParent()
		return nil
	case equipmentport.EdgeLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPort unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentPortMutation) ResetEdge(name string) error {
	switch name {
	case equipmentport.EdgeDefinition:
		m.ResetDefinition()
		return nil
	case equipmentport.EdgeParent:
		m.ResetParent()
		return nil
	case equipmentport.EdgeLink:
		m.ResetLink()
		return nil
	case equipmentport.EdgeProperties:
		m.ResetProperties()
		return nil
	case equipmentport.EdgeEndpoints:
		m.ResetEndpoints()
		return nil
	case equipmentport.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPort edge %s", name)
}

// EquipmentPortDefinitionMutation represents an operation that mutate the EquipmentPortDefinitions
// nodes in the graph.
type EquipmentPortDefinitionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	name                       *string
	index                      *int
	addindex                   *int
	bandwidth                  *string
	visibility_label           *string
	clearedFields              map[string]struct{}
	equipment_port_type        *int
	clearedequipment_port_type bool
	ports                      map[int]struct{}
	removedports               map[int]struct{}
	clearedports               bool
	equipment_type             *int
	clearedequipment_type      bool
	connected_ports            map[int]struct{}
	removedconnected_ports     map[int]struct{}
	clearedconnected_ports     bool
	done                       bool
	oldValue                   func(context.Context) (*EquipmentPortDefinition, error)
	predicates                 []predicate.EquipmentPortDefinition
}

var _ ent.Mutation = (*EquipmentPortDefinitionMutation)(nil)

// equipmentportdefinitionOption allows to manage the mutation configuration using functional options.
type equipmentportdefinitionOption func(*EquipmentPortDefinitionMutation)

// newEquipmentPortDefinitionMutation creates new mutation for EquipmentPortDefinition.
func newEquipmentPortDefinitionMutation(c config, op Op, opts ...equipmentportdefinitionOption) *EquipmentPortDefinitionMutation {
	m := &EquipmentPortDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentPortDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentPortDefinitionID sets the id field of the mutation.
func withEquipmentPortDefinitionID(id int) equipmentportdefinitionOption {
	return func(m *EquipmentPortDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentPortDefinition
		)
		m.oldValue = func(ctx context.Context) (*EquipmentPortDefinition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentPortDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentPortDefinition sets the old EquipmentPortDefinition of the mutation.
func withEquipmentPortDefinition(node *EquipmentPortDefinition) equipmentportdefinitionOption {
	return func(m *EquipmentPortDefinitionMutation) {
		m.oldValue = func(context.Context) (*EquipmentPortDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentPortDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentPortDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentPortDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentPortDefinitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentPortDefinitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EquipmentPortDefinition.
// If the EquipmentPortDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortDefinitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentPortDefinitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentPortDefinitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentPortDefinitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EquipmentPortDefinition.
// If the EquipmentPortDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortDefinitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentPortDefinitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *EquipmentPortDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EquipmentPortDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EquipmentPortDefinition.
// If the EquipmentPortDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EquipmentPortDefinitionMutation) ResetName() {
	m.name = nil
}

// SetIndex sets the index field.
func (m *EquipmentPortDefinitionMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *EquipmentPortDefinitionMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the EquipmentPortDefinition.
// If the EquipmentPortDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortDefinitionMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *EquipmentPortDefinitionMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *EquipmentPortDefinitionMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *EquipmentPortDefinitionMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[equipmentportdefinition.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *EquipmentPortDefinitionMutation) IndexCleared() bool {
	_, ok := m.clearedFields[equipmentportdefinition.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *EquipmentPortDefinitionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, equipmentportdefinition.FieldIndex)
}

// SetBandwidth sets the bandwidth field.
func (m *EquipmentPortDefinitionMutation) SetBandwidth(s string) {
	m.bandwidth = &s
}

// Bandwidth returns the bandwidth value in the mutation.
func (m *EquipmentPortDefinitionMutation) Bandwidth() (r string, exists bool) {
	v := m.bandwidth
	if v == nil {
		return
	}
	return *v, true
}

// OldBandwidth returns the old bandwidth value of the EquipmentPortDefinition.
// If the EquipmentPortDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortDefinitionMutation) OldBandwidth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBandwidth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBandwidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBandwidth: %w", err)
	}
	return oldValue.Bandwidth, nil
}

// ClearBandwidth clears the value of bandwidth.
func (m *EquipmentPortDefinitionMutation) ClearBandwidth() {
	m.bandwidth = nil
	m.clearedFields[equipmentportdefinition.FieldBandwidth] = struct{}{}
}

// BandwidthCleared returns if the field bandwidth was cleared in this mutation.
func (m *EquipmentPortDefinitionMutation) BandwidthCleared() bool {
	_, ok := m.clearedFields[equipmentportdefinition.FieldBandwidth]
	return ok
}

// ResetBandwidth reset all changes of the "bandwidth" field.
func (m *EquipmentPortDefinitionMutation) ResetBandwidth() {
	m.bandwidth = nil
	delete(m.clearedFields, equipmentportdefinition.FieldBandwidth)
}

// SetVisibilityLabel sets the visibility_label field.
func (m *EquipmentPortDefinitionMutation) SetVisibilityLabel(s string) {
	m.visibility_label = &s
}

// VisibilityLabel returns the visibility_label value in the mutation.
func (m *EquipmentPortDefinitionMutation) VisibilityLabel() (r string, exists bool) {
	v := m.visibility_label
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibilityLabel returns the old visibility_label value of the EquipmentPortDefinition.
// If the EquipmentPortDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortDefinitionMutation) OldVisibilityLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVisibilityLabel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVisibilityLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibilityLabel: %w", err)
	}
	return oldValue.VisibilityLabel, nil
}

// ClearVisibilityLabel clears the value of visibility_label.
func (m *EquipmentPortDefinitionMutation) ClearVisibilityLabel() {
	m.visibility_label = nil
	m.clearedFields[equipmentportdefinition.FieldVisibilityLabel] = struct{}{}
}

// VisibilityLabelCleared returns if the field visibility_label was cleared in this mutation.
func (m *EquipmentPortDefinitionMutation) VisibilityLabelCleared() bool {
	_, ok := m.clearedFields[equipmentportdefinition.FieldVisibilityLabel]
	return ok
}

// ResetVisibilityLabel reset all changes of the "visibility_label" field.
func (m *EquipmentPortDefinitionMutation) ResetVisibilityLabel() {
	m.visibility_label = nil
	delete(m.clearedFields, equipmentportdefinition.FieldVisibilityLabel)
}

// SetEquipmentPortTypeID sets the equipment_port_type edge to EquipmentPortType by id.
func (m *EquipmentPortDefinitionMutation) SetEquipmentPortTypeID(id int) {
	m.equipment_port_type = &id
}

// ClearEquipmentPortType clears the equipment_port_type edge to EquipmentPortType.
func (m *EquipmentPortDefinitionMutation) ClearEquipmentPortType() {
	m.clearedequipment_port_type = true
}

// EquipmentPortTypeCleared returns if the edge equipment_port_type was cleared.
func (m *EquipmentPortDefinitionMutation) EquipmentPortTypeCleared() bool {
	return m.clearedequipment_port_type
}

// EquipmentPortTypeID returns the equipment_port_type id in the mutation.
func (m *EquipmentPortDefinitionMutation) EquipmentPortTypeID() (id int, exists bool) {
	if m.equipment_port_type != nil {
		return *m.equipment_port_type, true
	}
	return
}

// EquipmentPortTypeIDs returns the equipment_port_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentPortTypeID instead. It exists only for internal usage by the builders.
func (m *EquipmentPortDefinitionMutation) EquipmentPortTypeIDs() (ids []int) {
	if id := m.equipment_port_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentPortType reset all changes of the "equipment_port_type" edge.
func (m *EquipmentPortDefinitionMutation) ResetEquipmentPortType() {
	m.equipment_port_type = nil
	m.clearedequipment_port_type = false
}

// AddPortIDs adds the ports edge to EquipmentPort by ids.
func (m *EquipmentPortDefinitionMutation) AddPortIDs(ids ...int) {
	if m.ports == nil {
		m.ports = make(map[int]struct{})
	}
	for i := range ids {
		m.ports[ids[i]] = struct{}{}
	}
}

// ClearPorts clears the ports edge to EquipmentPort.
func (m *EquipmentPortDefinitionMutation) ClearPorts() {
	m.clearedports = true
}

// PortsCleared returns if the edge ports was cleared.
func (m *EquipmentPortDefinitionMutation) PortsCleared() bool {
	return m.clearedports
}

// RemovePortIDs removes the ports edge to EquipmentPort by ids.
func (m *EquipmentPortDefinitionMutation) RemovePortIDs(ids ...int) {
	if m.removedports == nil {
		m.removedports = make(map[int]struct{})
	}
	for i := range ids {
		m.removedports[ids[i]] = struct{}{}
	}
}

// RemovedPorts returns the removed ids of ports.
func (m *EquipmentPortDefinitionMutation) RemovedPortsIDs() (ids []int) {
	for id := range m.removedports {
		ids = append(ids, id)
	}
	return
}

// PortsIDs returns the ports ids in the mutation.
func (m *EquipmentPortDefinitionMutation) PortsIDs() (ids []int) {
	for id := range m.ports {
		ids = append(ids, id)
	}
	return
}

// ResetPorts reset all changes of the "ports" edge.
func (m *EquipmentPortDefinitionMutation) ResetPorts() {
	m.ports = nil
	m.clearedports = false
	m.removedports = nil
}

// SetEquipmentTypeID sets the equipment_type edge to EquipmentType by id.
func (m *EquipmentPortDefinitionMutation) SetEquipmentTypeID(id int) {
	m.equipment_type = &id
}

// ClearEquipmentType clears the equipment_type edge to EquipmentType.
func (m *EquipmentPortDefinitionMutation) ClearEquipmentType() {
	m.clearedequipment_type = true
}

// EquipmentTypeCleared returns if the edge equipment_type was cleared.
func (m *EquipmentPortDefinitionMutation) EquipmentTypeCleared() bool {
	return m.clearedequipment_type
}

// EquipmentTypeID returns the equipment_type id in the mutation.
func (m *EquipmentPortDefinitionMutation) EquipmentTypeID() (id int, exists bool) {
	if m.equipment_type != nil {
		return *m.equipment_type, true
	}
	return
}

// EquipmentTypeIDs returns the equipment_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentTypeID instead. It exists only for internal usage by the builders.
func (m *EquipmentPortDefinitionMutation) EquipmentTypeIDs() (ids []int) {
	if id := m.equipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentType reset all changes of the "equipment_type" edge.
func (m *EquipmentPortDefinitionMutation) ResetEquipmentType() {
	m.equipment_type = nil
	m.clearedequipment_type = false
}

// AddConnectedPortIDs adds the connected_ports edge to EquipmentPortDefinition by ids.
func (m *EquipmentPortDefinitionMutation) AddConnectedPortIDs(ids ...int) {
	if m.connected_ports == nil {
		m.connected_ports = make(map[int]struct{})
	}
	for i := range ids {
		m.connected_ports[ids[i]] = struct{}{}
	}
}

// ClearConnectedPorts clears the connected_ports edge to EquipmentPortDefinition.
func (m *EquipmentPortDefinitionMutation) ClearConnectedPorts() {
	m.clearedconnected_ports = true
}

// ConnectedPortsCleared returns if the edge connected_ports was cleared.
func (m *EquipmentPortDefinitionMutation) ConnectedPortsCleared() bool {
	return m.clearedconnected_ports
}

// RemoveConnectedPortIDs removes the connected_ports edge to EquipmentPortDefinition by ids.
func (m *EquipmentPortDefinitionMutation) RemoveConnectedPortIDs(ids ...int) {
	if m.removedconnected_ports == nil {
		m.removedconnected_ports = make(map[int]struct{})
	}
	for i := range ids {
		m.removedconnected_ports[ids[i]] = struct{}{}
	}
}

// RemovedConnectedPorts returns the removed ids of connected_ports.
func (m *EquipmentPortDefinitionMutation) RemovedConnectedPortsIDs() (ids []int) {
	for id := range m.removedconnected_ports {
		ids = append(ids, id)
	}
	return
}

// ConnectedPortsIDs returns the connected_ports ids in the mutation.
func (m *EquipmentPortDefinitionMutation) ConnectedPortsIDs() (ids []int) {
	for id := range m.connected_ports {
		ids = append(ids, id)
	}
	return
}

// ResetConnectedPorts reset all changes of the "connected_ports" edge.
func (m *EquipmentPortDefinitionMutation) ResetConnectedPorts() {
	m.connected_ports = nil
	m.clearedconnected_ports = false
	m.removedconnected_ports = nil
}

// Op returns the operation name.
func (m *EquipmentPortDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentPortDefinition).
func (m *EquipmentPortDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentPortDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, equipmentportdefinition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipmentportdefinition.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, equipmentportdefinition.FieldName)
	}
	if m.index != nil {
		fields = append(fields, equipmentportdefinition.FieldIndex)
	}
	if m.bandwidth != nil {
		fields = append(fields, equipmentportdefinition.FieldBandwidth)
	}
	if m.visibility_label != nil {
		fields = append(fields, equipmentportdefinition.FieldVisibilityLabel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentPortDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentportdefinition.FieldCreateTime:
		return m.CreateTime()
	case equipmentportdefinition.FieldUpdateTime:
		return m.UpdateTime()
	case equipmentportdefinition.FieldName:
		return m.Name()
	case equipmentportdefinition.FieldIndex:
		return m.Index()
	case equipmentportdefinition.FieldBandwidth:
		return m.Bandwidth()
	case equipmentportdefinition.FieldVisibilityLabel:
		return m.VisibilityLabel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentPortDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentportdefinition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipmentportdefinition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case equipmentportdefinition.FieldName:
		return m.OldName(ctx)
	case equipmentportdefinition.FieldIndex:
		return m.OldIndex(ctx)
	case equipmentportdefinition.FieldBandwidth:
		return m.OldBandwidth(ctx)
	case equipmentportdefinition.FieldVisibilityLabel:
		return m.OldVisibilityLabel(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentPortDefinition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPortDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentportdefinition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipmentportdefinition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case equipmentportdefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipmentportdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case equipmentportdefinition.FieldBandwidth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBandwidth(v)
		return nil
	case equipmentportdefinition.FieldVisibilityLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibilityLabel(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentPortDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, equipmentportdefinition.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentPortDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentportdefinition.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPortDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentportdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentPortDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmentportdefinition.FieldIndex) {
		fields = append(fields, equipmentportdefinition.FieldIndex)
	}
	if m.FieldCleared(equipmentportdefinition.FieldBandwidth) {
		fields = append(fields, equipmentportdefinition.FieldBandwidth)
	}
	if m.FieldCleared(equipmentportdefinition.FieldVisibilityLabel) {
		fields = append(fields, equipmentportdefinition.FieldVisibilityLabel)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentPortDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentPortDefinitionMutation) ClearField(name string) error {
	switch name {
	case equipmentportdefinition.FieldIndex:
		m.ClearIndex()
		return nil
	case equipmentportdefinition.FieldBandwidth:
		m.ClearBandwidth()
		return nil
	case equipmentportdefinition.FieldVisibilityLabel:
		m.ClearVisibilityLabel()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentPortDefinitionMutation) ResetField(name string) error {
	switch name {
	case equipmentportdefinition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipmentportdefinition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case equipmentportdefinition.FieldName:
		m.ResetName()
		return nil
	case equipmentportdefinition.FieldIndex:
		m.ResetIndex()
		return nil
	case equipmentportdefinition.FieldBandwidth:
		m.ResetBandwidth()
		return nil
	case equipmentportdefinition.FieldVisibilityLabel:
		m.ResetVisibilityLabel()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentPortDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.equipment_port_type != nil {
		edges = append(edges, equipmentportdefinition.EdgeEquipmentPortType)
	}
	if m.ports != nil {
		edges = append(edges, equipmentportdefinition.EdgePorts)
	}
	if m.equipment_type != nil {
		edges = append(edges, equipmentportdefinition.EdgeEquipmentType)
	}
	if m.connected_ports != nil {
		edges = append(edges, equipmentportdefinition.EdgeConnectedPorts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentPortDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentportdefinition.EdgeEquipmentPortType:
		if id := m.equipment_port_type; id != nil {
			return []ent.Value{*id}
		}
	case equipmentportdefinition.EdgePorts:
		ids := make([]ent.Value, 0, len(m.ports))
		for id := range m.ports {
			ids = append(ids, id)
		}
		return ids
	case equipmentportdefinition.EdgeEquipmentType:
		if id := m.equipment_type; id != nil {
			return []ent.Value{*id}
		}
	case equipmentportdefinition.EdgeConnectedPorts:
		ids := make([]ent.Value, 0, len(m.connected_ports))
		for id := range m.connected_ports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentPortDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedports != nil {
		edges = append(edges, equipmentportdefinition.EdgePorts)
	}
	if m.removedconnected_ports != nil {
		edges = append(edges, equipmentportdefinition.EdgeConnectedPorts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentPortDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmentportdefinition.EdgePorts:
		ids := make([]ent.Value, 0, len(m.removedports))
		for id := range m.removedports {
			ids = append(ids, id)
		}
		return ids
	case equipmentportdefinition.EdgeConnectedPorts:
		ids := make([]ent.Value, 0, len(m.removedconnected_ports))
		for id := range m.removedconnected_ports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentPortDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedequipment_port_type {
		edges = append(edges, equipmentportdefinition.EdgeEquipmentPortType)
	}
	if m.clearedports {
		edges = append(edges, equipmentportdefinition.EdgePorts)
	}
	if m.clearedequipment_type {
		edges = append(edges, equipmentportdefinition.EdgeEquipmentType)
	}
	if m.clearedconnected_ports {
		edges = append(edges, equipmentportdefinition.EdgeConnectedPorts)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentPortDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentportdefinition.EdgeEquipmentPortType:
		return m.clearedequipment_port_type
	case equipmentportdefinition.EdgePorts:
		return m.clearedports
	case equipmentportdefinition.EdgeEquipmentType:
		return m.clearedequipment_type
	case equipmentportdefinition.EdgeConnectedPorts:
		return m.clearedconnected_ports
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentPortDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case equipmentportdefinition.EdgeEquipmentPortType:
		m.ClearEquipmentPortType()
		return nil
	case equipmentportdefinition.EdgeEquipmentType:
		m.ClearEquipmentType()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortDefinition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentPortDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case equipmentportdefinition.EdgeEquipmentPortType:
		m.ResetEquipmentPortType()
		return nil
	case equipmentportdefinition.EdgePorts:
		m.ResetPorts()
		return nil
	case equipmentportdefinition.EdgeEquipmentType:
		m.ResetEquipmentType()
		return nil
	case equipmentportdefinition.EdgeConnectedPorts:
		m.ResetConnectedPorts()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortDefinition edge %s", name)
}

// EquipmentPortTypeMutation represents an operation that mutate the EquipmentPortTypes
// nodes in the graph.
type EquipmentPortTypeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	name                       *string
	clearedFields              map[string]struct{}
	property_types             map[int]struct{}
	removedproperty_types      map[int]struct{}
	clearedproperty_types      bool
	link_property_types        map[int]struct{}
	removedlink_property_types map[int]struct{}
	clearedlink_property_types bool
	port_definitions           map[int]struct{}
	removedport_definitions    map[int]struct{}
	clearedport_definitions    bool
	done                       bool
	oldValue                   func(context.Context) (*EquipmentPortType, error)
	predicates                 []predicate.EquipmentPortType
}

var _ ent.Mutation = (*EquipmentPortTypeMutation)(nil)

// equipmentporttypeOption allows to manage the mutation configuration using functional options.
type equipmentporttypeOption func(*EquipmentPortTypeMutation)

// newEquipmentPortTypeMutation creates new mutation for EquipmentPortType.
func newEquipmentPortTypeMutation(c config, op Op, opts ...equipmentporttypeOption) *EquipmentPortTypeMutation {
	m := &EquipmentPortTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentPortType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentPortTypeID sets the id field of the mutation.
func withEquipmentPortTypeID(id int) equipmentporttypeOption {
	return func(m *EquipmentPortTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentPortType
		)
		m.oldValue = func(ctx context.Context) (*EquipmentPortType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentPortType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentPortType sets the old EquipmentPortType of the mutation.
func withEquipmentPortType(node *EquipmentPortType) equipmentporttypeOption {
	return func(m *EquipmentPortTypeMutation) {
		m.oldValue = func(context.Context) (*EquipmentPortType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentPortTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentPortTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentPortTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentPortTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentPortTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EquipmentPortType.
// If the EquipmentPortType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentPortTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentPortTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentPortTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EquipmentPortType.
// If the EquipmentPortType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentPortTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *EquipmentPortTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EquipmentPortTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EquipmentPortType.
// If the EquipmentPortType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPortTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EquipmentPortTypeMutation) ResetName() {
	m.name = nil
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *EquipmentPortTypeMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// ClearPropertyTypes clears the property_types edge to PropertyType.
func (m *EquipmentPortTypeMutation) ClearPropertyTypes() {
	m.clearedproperty_types = true
}

// PropertyTypesCleared returns if the edge property_types was cleared.
func (m *EquipmentPortTypeMutation) PropertyTypesCleared() bool {
	return m.clearedproperty_types
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *EquipmentPortTypeMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *EquipmentPortTypeMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *EquipmentPortTypeMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *EquipmentPortTypeMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.clearedproperty_types = false
	m.removedproperty_types = nil
}

// AddLinkPropertyTypeIDs adds the link_property_types edge to PropertyType by ids.
func (m *EquipmentPortTypeMutation) AddLinkPropertyTypeIDs(ids ...int) {
	if m.link_property_types == nil {
		m.link_property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.link_property_types[ids[i]] = struct{}{}
	}
}

// ClearLinkPropertyTypes clears the link_property_types edge to PropertyType.
func (m *EquipmentPortTypeMutation) ClearLinkPropertyTypes() {
	m.clearedlink_property_types = true
}

// LinkPropertyTypesCleared returns if the edge link_property_types was cleared.
func (m *EquipmentPortTypeMutation) LinkPropertyTypesCleared() bool {
	return m.clearedlink_property_types
}

// RemoveLinkPropertyTypeIDs removes the link_property_types edge to PropertyType by ids.
func (m *EquipmentPortTypeMutation) RemoveLinkPropertyTypeIDs(ids ...int) {
	if m.removedlink_property_types == nil {
		m.removedlink_property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlink_property_types[ids[i]] = struct{}{}
	}
}

// RemovedLinkPropertyTypes returns the removed ids of link_property_types.
func (m *EquipmentPortTypeMutation) RemovedLinkPropertyTypesIDs() (ids []int) {
	for id := range m.removedlink_property_types {
		ids = append(ids, id)
	}
	return
}

// LinkPropertyTypesIDs returns the link_property_types ids in the mutation.
func (m *EquipmentPortTypeMutation) LinkPropertyTypesIDs() (ids []int) {
	for id := range m.link_property_types {
		ids = append(ids, id)
	}
	return
}

// ResetLinkPropertyTypes reset all changes of the "link_property_types" edge.
func (m *EquipmentPortTypeMutation) ResetLinkPropertyTypes() {
	m.link_property_types = nil
	m.clearedlink_property_types = false
	m.removedlink_property_types = nil
}

// AddPortDefinitionIDs adds the port_definitions edge to EquipmentPortDefinition by ids.
func (m *EquipmentPortTypeMutation) AddPortDefinitionIDs(ids ...int) {
	if m.port_definitions == nil {
		m.port_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.port_definitions[ids[i]] = struct{}{}
	}
}

// ClearPortDefinitions clears the port_definitions edge to EquipmentPortDefinition.
func (m *EquipmentPortTypeMutation) ClearPortDefinitions() {
	m.clearedport_definitions = true
}

// PortDefinitionsCleared returns if the edge port_definitions was cleared.
func (m *EquipmentPortTypeMutation) PortDefinitionsCleared() bool {
	return m.clearedport_definitions
}

// RemovePortDefinitionIDs removes the port_definitions edge to EquipmentPortDefinition by ids.
func (m *EquipmentPortTypeMutation) RemovePortDefinitionIDs(ids ...int) {
	if m.removedport_definitions == nil {
		m.removedport_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedport_definitions[ids[i]] = struct{}{}
	}
}

// RemovedPortDefinitions returns the removed ids of port_definitions.
func (m *EquipmentPortTypeMutation) RemovedPortDefinitionsIDs() (ids []int) {
	for id := range m.removedport_definitions {
		ids = append(ids, id)
	}
	return
}

// PortDefinitionsIDs returns the port_definitions ids in the mutation.
func (m *EquipmentPortTypeMutation) PortDefinitionsIDs() (ids []int) {
	for id := range m.port_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetPortDefinitions reset all changes of the "port_definitions" edge.
func (m *EquipmentPortTypeMutation) ResetPortDefinitions() {
	m.port_definitions = nil
	m.clearedport_definitions = false
	m.removedport_definitions = nil
}

// Op returns the operation name.
func (m *EquipmentPortTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentPortType).
func (m *EquipmentPortTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentPortTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, equipmentporttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipmentporttype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, equipmentporttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentPortTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentporttype.FieldCreateTime:
		return m.CreateTime()
	case equipmentporttype.FieldUpdateTime:
		return m.UpdateTime()
	case equipmentporttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentPortTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentporttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipmentporttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case equipmentporttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentPortType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPortTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentporttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipmentporttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case equipmentporttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentPortTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentPortTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPortTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentPortType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentPortTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentPortTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentPortTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentPortType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentPortTypeMutation) ResetField(name string) error {
	switch name {
	case equipmentporttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipmentporttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case equipmentporttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentPortTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.property_types != nil {
		edges = append(edges, equipmentporttype.EdgePropertyTypes)
	}
	if m.link_property_types != nil {
		edges = append(edges, equipmentporttype.EdgeLinkPropertyTypes)
	}
	if m.port_definitions != nil {
		edges = append(edges, equipmentporttype.EdgePortDefinitions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentPortTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentporttype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	case equipmentporttype.EdgeLinkPropertyTypes:
		ids := make([]ent.Value, 0, len(m.link_property_types))
		for id := range m.link_property_types {
			ids = append(ids, id)
		}
		return ids
	case equipmentporttype.EdgePortDefinitions:
		ids := make([]ent.Value, 0, len(m.port_definitions))
		for id := range m.port_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentPortTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperty_types != nil {
		edges = append(edges, equipmentporttype.EdgePropertyTypes)
	}
	if m.removedlink_property_types != nil {
		edges = append(edges, equipmentporttype.EdgeLinkPropertyTypes)
	}
	if m.removedport_definitions != nil {
		edges = append(edges, equipmentporttype.EdgePortDefinitions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentPortTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmentporttype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	case equipmentporttype.EdgeLinkPropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedlink_property_types))
		for id := range m.removedlink_property_types {
			ids = append(ids, id)
		}
		return ids
	case equipmentporttype.EdgePortDefinitions:
		ids := make([]ent.Value, 0, len(m.removedport_definitions))
		for id := range m.removedport_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentPortTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproperty_types {
		edges = append(edges, equipmentporttype.EdgePropertyTypes)
	}
	if m.clearedlink_property_types {
		edges = append(edges, equipmentporttype.EdgeLinkPropertyTypes)
	}
	if m.clearedport_definitions {
		edges = append(edges, equipmentporttype.EdgePortDefinitions)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentPortTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentporttype.EdgePropertyTypes:
		return m.clearedproperty_types
	case equipmentporttype.EdgeLinkPropertyTypes:
		return m.clearedlink_property_types
	case equipmentporttype.EdgePortDefinitions:
		return m.clearedport_definitions
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentPortTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentPortType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentPortTypeMutation) ResetEdge(name string) error {
	switch name {
	case equipmentporttype.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	case equipmentporttype.EdgeLinkPropertyTypes:
		m.ResetLinkPropertyTypes()
		return nil
	case equipmentporttype.EdgePortDefinitions:
		m.ResetPortDefinitions()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPortType edge %s", name)
}

// EquipmentPositionMutation represents an operation that mutate the EquipmentPositions
// nodes in the graph.
type EquipmentPositionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	definition        *int
	cleareddefinition bool
	parent            *int
	clearedparent     bool
	attachment        *int
	clearedattachment bool
	done              bool
	oldValue          func(context.Context) (*EquipmentPosition, error)
	predicates        []predicate.EquipmentPosition
}

var _ ent.Mutation = (*EquipmentPositionMutation)(nil)

// equipmentpositionOption allows to manage the mutation configuration using functional options.
type equipmentpositionOption func(*EquipmentPositionMutation)

// newEquipmentPositionMutation creates new mutation for EquipmentPosition.
func newEquipmentPositionMutation(c config, op Op, opts ...equipmentpositionOption) *EquipmentPositionMutation {
	m := &EquipmentPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentPositionID sets the id field of the mutation.
func withEquipmentPositionID(id int) equipmentpositionOption {
	return func(m *EquipmentPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentPosition
		)
		m.oldValue = func(ctx context.Context) (*EquipmentPosition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentPosition sets the old EquipmentPosition of the mutation.
func withEquipmentPosition(node *EquipmentPosition) equipmentpositionOption {
	return func(m *EquipmentPositionMutation) {
		m.oldValue = func(context.Context) (*EquipmentPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentPositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentPositionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentPositionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EquipmentPosition.
// If the EquipmentPosition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPositionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentPositionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentPositionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentPositionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EquipmentPosition.
// If the EquipmentPosition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPositionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentPositionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDefinitionID sets the definition edge to EquipmentPositionDefinition by id.
func (m *EquipmentPositionMutation) SetDefinitionID(id int) {
	m.definition = &id
}

// ClearDefinition clears the definition edge to EquipmentPositionDefinition.
func (m *EquipmentPositionMutation) ClearDefinition() {
	m.cleareddefinition = true
}

// DefinitionCleared returns if the edge definition was cleared.
func (m *EquipmentPositionMutation) DefinitionCleared() bool {
	return m.cleareddefinition
}

// DefinitionID returns the definition id in the mutation.
func (m *EquipmentPositionMutation) DefinitionID() (id int, exists bool) {
	if m.definition != nil {
		return *m.definition, true
	}
	return
}

// DefinitionIDs returns the definition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DefinitionID instead. It exists only for internal usage by the builders.
func (m *EquipmentPositionMutation) DefinitionIDs() (ids []int) {
	if id := m.definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefinition reset all changes of the "definition" edge.
func (m *EquipmentPositionMutation) ResetDefinition() {
	m.definition = nil
	m.cleareddefinition = false
}

// SetParentID sets the parent edge to Equipment by id.
func (m *EquipmentPositionMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the parent edge to Equipment.
func (m *EquipmentPositionMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *EquipmentPositionMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *EquipmentPositionMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *EquipmentPositionMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *EquipmentPositionMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetAttachmentID sets the attachment edge to Equipment by id.
func (m *EquipmentPositionMutation) SetAttachmentID(id int) {
	m.attachment = &id
}

// ClearAttachment clears the attachment edge to Equipment.
func (m *EquipmentPositionMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared returns if the edge attachment was cleared.
func (m *EquipmentPositionMutation) AttachmentCleared() bool {
	return m.clearedattachment
}

// AttachmentID returns the attachment id in the mutation.
func (m *EquipmentPositionMutation) AttachmentID() (id int, exists bool) {
	if m.attachment != nil {
		return *m.attachment, true
	}
	return
}

// AttachmentIDs returns the attachment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentPositionMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment reset all changes of the "attachment" edge.
func (m *EquipmentPositionMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// Op returns the operation name.
func (m *EquipmentPositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentPosition).
func (m *EquipmentPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentPositionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, equipmentposition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipmentposition.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentposition.FieldCreateTime:
		return m.CreateTime()
	case equipmentposition.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentposition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipmentposition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentPosition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentposition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipmentposition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentPositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentPositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentPositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentPositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentPositionMutation) ResetField(name string) error {
	switch name {
	case equipmentposition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipmentposition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.definition != nil {
		edges = append(edges, equipmentposition.EdgeDefinition)
	}
	if m.parent != nil {
		edges = append(edges, equipmentposition.EdgeParent)
	}
	if m.attachment != nil {
		edges = append(edges, equipmentposition.EdgeAttachment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentPositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentposition.EdgeDefinition:
		if id := m.definition; id != nil {
			return []ent.Value{*id}
		}
	case equipmentposition.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case equipmentposition.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentPositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddefinition {
		edges = append(edges, equipmentposition.EdgeDefinition)
	}
	if m.clearedparent {
		edges = append(edges, equipmentposition.EdgeParent)
	}
	if m.clearedattachment {
		edges = append(edges, equipmentposition.EdgeAttachment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentPositionMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentposition.EdgeDefinition:
		return m.cleareddefinition
	case equipmentposition.EdgeParent:
		return m.clearedparent
	case equipmentposition.EdgeAttachment:
		return m.clearedattachment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentPositionMutation) ClearEdge(name string) error {
	switch name {
	case equipmentposition.EdgeDefinition:
		m.ClearDefinition()
		return nil
	case equipmentposition.EdgeParent:
		m.ClearParent()
		return nil
	case equipmentposition.EdgeAttachment:
		m.ClearAttachment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPosition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentPositionMutation) ResetEdge(name string) error {
	switch name {
	case equipmentposition.EdgeDefinition:
		m.ResetDefinition()
		return nil
	case equipmentposition.EdgeParent:
		m.ResetParent()
		return nil
	case equipmentposition.EdgeAttachment:
		m.ResetAttachment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPosition edge %s", name)
}

// EquipmentPositionDefinitionMutation represents an operation that mutate the EquipmentPositionDefinitions
// nodes in the graph.
type EquipmentPositionDefinitionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	index                 *int
	addindex              *int
	visibility_label      *string
	clearedFields         map[string]struct{}
	positions             map[int]struct{}
	removedpositions      map[int]struct{}
	clearedpositions      bool
	equipment_type        *int
	clearedequipment_type bool
	done                  bool
	oldValue              func(context.Context) (*EquipmentPositionDefinition, error)
	predicates            []predicate.EquipmentPositionDefinition
}

var _ ent.Mutation = (*EquipmentPositionDefinitionMutation)(nil)

// equipmentpositiondefinitionOption allows to manage the mutation configuration using functional options.
type equipmentpositiondefinitionOption func(*EquipmentPositionDefinitionMutation)

// newEquipmentPositionDefinitionMutation creates new mutation for EquipmentPositionDefinition.
func newEquipmentPositionDefinitionMutation(c config, op Op, opts ...equipmentpositiondefinitionOption) *EquipmentPositionDefinitionMutation {
	m := &EquipmentPositionDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentPositionDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentPositionDefinitionID sets the id field of the mutation.
func withEquipmentPositionDefinitionID(id int) equipmentpositiondefinitionOption {
	return func(m *EquipmentPositionDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentPositionDefinition
		)
		m.oldValue = func(ctx context.Context) (*EquipmentPositionDefinition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentPositionDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentPositionDefinition sets the old EquipmentPositionDefinition of the mutation.
func withEquipmentPositionDefinition(node *EquipmentPositionDefinition) equipmentpositiondefinitionOption {
	return func(m *EquipmentPositionDefinitionMutation) {
		m.oldValue = func(context.Context) (*EquipmentPositionDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentPositionDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentPositionDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentPositionDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentPositionDefinitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentPositionDefinitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EquipmentPositionDefinition.
// If the EquipmentPositionDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPositionDefinitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentPositionDefinitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentPositionDefinitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentPositionDefinitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EquipmentPositionDefinition.
// If the EquipmentPositionDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPositionDefinitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentPositionDefinitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *EquipmentPositionDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EquipmentPositionDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EquipmentPositionDefinition.
// If the EquipmentPositionDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPositionDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EquipmentPositionDefinitionMutation) ResetName() {
	m.name = nil
}

// SetIndex sets the index field.
func (m *EquipmentPositionDefinitionMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *EquipmentPositionDefinitionMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the EquipmentPositionDefinition.
// If the EquipmentPositionDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPositionDefinitionMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *EquipmentPositionDefinitionMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *EquipmentPositionDefinitionMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *EquipmentPositionDefinitionMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[equipmentpositiondefinition.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *EquipmentPositionDefinitionMutation) IndexCleared() bool {
	_, ok := m.clearedFields[equipmentpositiondefinition.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *EquipmentPositionDefinitionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, equipmentpositiondefinition.FieldIndex)
}

// SetVisibilityLabel sets the visibility_label field.
func (m *EquipmentPositionDefinitionMutation) SetVisibilityLabel(s string) {
	m.visibility_label = &s
}

// VisibilityLabel returns the visibility_label value in the mutation.
func (m *EquipmentPositionDefinitionMutation) VisibilityLabel() (r string, exists bool) {
	v := m.visibility_label
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibilityLabel returns the old visibility_label value of the EquipmentPositionDefinition.
// If the EquipmentPositionDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentPositionDefinitionMutation) OldVisibilityLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVisibilityLabel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVisibilityLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibilityLabel: %w", err)
	}
	return oldValue.VisibilityLabel, nil
}

// ClearVisibilityLabel clears the value of visibility_label.
func (m *EquipmentPositionDefinitionMutation) ClearVisibilityLabel() {
	m.visibility_label = nil
	m.clearedFields[equipmentpositiondefinition.FieldVisibilityLabel] = struct{}{}
}

// VisibilityLabelCleared returns if the field visibility_label was cleared in this mutation.
func (m *EquipmentPositionDefinitionMutation) VisibilityLabelCleared() bool {
	_, ok := m.clearedFields[equipmentpositiondefinition.FieldVisibilityLabel]
	return ok
}

// ResetVisibilityLabel reset all changes of the "visibility_label" field.
func (m *EquipmentPositionDefinitionMutation) ResetVisibilityLabel() {
	m.visibility_label = nil
	delete(m.clearedFields, equipmentpositiondefinition.FieldVisibilityLabel)
}

// AddPositionIDs adds the positions edge to EquipmentPosition by ids.
func (m *EquipmentPositionDefinitionMutation) AddPositionIDs(ids ...int) {
	if m.positions == nil {
		m.positions = make(map[int]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the positions edge to EquipmentPosition.
func (m *EquipmentPositionDefinitionMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared returns if the edge positions was cleared.
func (m *EquipmentPositionDefinitionMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the positions edge to EquipmentPosition by ids.
func (m *EquipmentPositionDefinitionMutation) RemovePositionIDs(ids ...int) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed ids of positions.
func (m *EquipmentPositionDefinitionMutation) RemovedPositionsIDs() (ids []int) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the positions ids in the mutation.
func (m *EquipmentPositionDefinitionMutation) PositionsIDs() (ids []int) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions reset all changes of the "positions" edge.
func (m *EquipmentPositionDefinitionMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// SetEquipmentTypeID sets the equipment_type edge to EquipmentType by id.
func (m *EquipmentPositionDefinitionMutation) SetEquipmentTypeID(id int) {
	m.equipment_type = &id
}

// ClearEquipmentType clears the equipment_type edge to EquipmentType.
func (m *EquipmentPositionDefinitionMutation) ClearEquipmentType() {
	m.clearedequipment_type = true
}

// EquipmentTypeCleared returns if the edge equipment_type was cleared.
func (m *EquipmentPositionDefinitionMutation) EquipmentTypeCleared() bool {
	return m.clearedequipment_type
}

// EquipmentTypeID returns the equipment_type id in the mutation.
func (m *EquipmentPositionDefinitionMutation) EquipmentTypeID() (id int, exists bool) {
	if m.equipment_type != nil {
		return *m.equipment_type, true
	}
	return
}

// EquipmentTypeIDs returns the equipment_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentTypeID instead. It exists only for internal usage by the builders.
func (m *EquipmentPositionDefinitionMutation) EquipmentTypeIDs() (ids []int) {
	if id := m.equipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentType reset all changes of the "equipment_type" edge.
func (m *EquipmentPositionDefinitionMutation) ResetEquipmentType() {
	m.equipment_type = nil
	m.clearedequipment_type = false
}

// Op returns the operation name.
func (m *EquipmentPositionDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentPositionDefinition).
func (m *EquipmentPositionDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentPositionDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, equipmentpositiondefinition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipmentpositiondefinition.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, equipmentpositiondefinition.FieldName)
	}
	if m.index != nil {
		fields = append(fields, equipmentpositiondefinition.FieldIndex)
	}
	if m.visibility_label != nil {
		fields = append(fields, equipmentpositiondefinition.FieldVisibilityLabel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentPositionDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentpositiondefinition.FieldCreateTime:
		return m.CreateTime()
	case equipmentpositiondefinition.FieldUpdateTime:
		return m.UpdateTime()
	case equipmentpositiondefinition.FieldName:
		return m.Name()
	case equipmentpositiondefinition.FieldIndex:
		return m.Index()
	case equipmentpositiondefinition.FieldVisibilityLabel:
		return m.VisibilityLabel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentPositionDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentpositiondefinition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipmentpositiondefinition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case equipmentpositiondefinition.FieldName:
		return m.OldName(ctx)
	case equipmentpositiondefinition.FieldIndex:
		return m.OldIndex(ctx)
	case equipmentpositiondefinition.FieldVisibilityLabel:
		return m.OldVisibilityLabel(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentPositionDefinition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPositionDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentpositiondefinition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipmentpositiondefinition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case equipmentpositiondefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipmentpositiondefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case equipmentpositiondefinition.FieldVisibilityLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibilityLabel(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentPositionDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentPositionDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, equipmentpositiondefinition.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentPositionDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentpositiondefinition.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentPositionDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentpositiondefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentPositionDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentPositionDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmentpositiondefinition.FieldIndex) {
		fields = append(fields, equipmentpositiondefinition.FieldIndex)
	}
	if m.FieldCleared(equipmentpositiondefinition.FieldVisibilityLabel) {
		fields = append(fields, equipmentpositiondefinition.FieldVisibilityLabel)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentPositionDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentPositionDefinitionMutation) ClearField(name string) error {
	switch name {
	case equipmentpositiondefinition.FieldIndex:
		m.ClearIndex()
		return nil
	case equipmentpositiondefinition.FieldVisibilityLabel:
		m.ClearVisibilityLabel()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPositionDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentPositionDefinitionMutation) ResetField(name string) error {
	switch name {
	case equipmentpositiondefinition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipmentpositiondefinition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case equipmentpositiondefinition.FieldName:
		m.ResetName()
		return nil
	case equipmentpositiondefinition.FieldIndex:
		m.ResetIndex()
		return nil
	case equipmentpositiondefinition.FieldVisibilityLabel:
		m.ResetVisibilityLabel()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPositionDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentPositionDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.positions != nil {
		edges = append(edges, equipmentpositiondefinition.EdgePositions)
	}
	if m.equipment_type != nil {
		edges = append(edges, equipmentpositiondefinition.EdgeEquipmentType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentPositionDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentpositiondefinition.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	case equipmentpositiondefinition.EdgeEquipmentType:
		if id := m.equipment_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentPositionDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpositions != nil {
		edges = append(edges, equipmentpositiondefinition.EdgePositions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentPositionDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmentpositiondefinition.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentPositionDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpositions {
		edges = append(edges, equipmentpositiondefinition.EdgePositions)
	}
	if m.clearedequipment_type {
		edges = append(edges, equipmentpositiondefinition.EdgeEquipmentType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentPositionDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentpositiondefinition.EdgePositions:
		return m.clearedpositions
	case equipmentpositiondefinition.EdgeEquipmentType:
		return m.clearedequipment_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentPositionDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case equipmentpositiondefinition.EdgeEquipmentType:
		m.ClearEquipmentType()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPositionDefinition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentPositionDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case equipmentpositiondefinition.EdgePositions:
		m.ResetPositions()
		return nil
	case equipmentpositiondefinition.EdgeEquipmentType:
		m.ResetEquipmentType()
		return nil
	}
	return fmt.Errorf("unknown EquipmentPositionDefinition edge %s", name)
}

// EquipmentTypeMutation represents an operation that mutate the EquipmentTypes
// nodes in the graph.
type EquipmentTypeMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	create_time                         *time.Time
	update_time                         *time.Time
	name                                *string
	clearedFields                       map[string]struct{}
	port_definitions                    map[int]struct{}
	removedport_definitions             map[int]struct{}
	clearedport_definitions             bool
	position_definitions                map[int]struct{}
	removedposition_definitions         map[int]struct{}
	clearedposition_definitions         bool
	property_types                      map[int]struct{}
	removedproperty_types               map[int]struct{}
	clearedproperty_types               bool
	equipment                           map[int]struct{}
	removedequipment                    map[int]struct{}
	clearedequipment                    bool
	category                            *int
	clearedcategory                     bool
	service_endpoint_definitions        map[int]struct{}
	removedservice_endpoint_definitions map[int]struct{}
	clearedservice_endpoint_definitions bool
	done                                bool
	oldValue                            func(context.Context) (*EquipmentType, error)
	predicates                          []predicate.EquipmentType
}

var _ ent.Mutation = (*EquipmentTypeMutation)(nil)

// equipmenttypeOption allows to manage the mutation configuration using functional options.
type equipmenttypeOption func(*EquipmentTypeMutation)

// newEquipmentTypeMutation creates new mutation for EquipmentType.
func newEquipmentTypeMutation(c config, op Op, opts ...equipmenttypeOption) *EquipmentTypeMutation {
	m := &EquipmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentTypeID sets the id field of the mutation.
func withEquipmentTypeID(id int) equipmenttypeOption {
	return func(m *EquipmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentType
		)
		m.oldValue = func(ctx context.Context) (*EquipmentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentType sets the old EquipmentType of the mutation.
func withEquipmentType(node *EquipmentType) equipmenttypeOption {
	return func(m *EquipmentTypeMutation) {
		m.oldValue = func(context.Context) (*EquipmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EquipmentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EquipmentTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EquipmentTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EquipmentType.
// If the EquipmentType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EquipmentTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EquipmentTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EquipmentTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EquipmentType.
// If the EquipmentType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EquipmentTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *EquipmentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EquipmentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EquipmentType.
// If the EquipmentType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EquipmentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EquipmentTypeMutation) ResetName() {
	m.name = nil
}

// AddPortDefinitionIDs adds the port_definitions edge to EquipmentPortDefinition by ids.
func (m *EquipmentTypeMutation) AddPortDefinitionIDs(ids ...int) {
	if m.port_definitions == nil {
		m.port_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.port_definitions[ids[i]] = struct{}{}
	}
}

// ClearPortDefinitions clears the port_definitions edge to EquipmentPortDefinition.
func (m *EquipmentTypeMutation) ClearPortDefinitions() {
	m.clearedport_definitions = true
}

// PortDefinitionsCleared returns if the edge port_definitions was cleared.
func (m *EquipmentTypeMutation) PortDefinitionsCleared() bool {
	return m.clearedport_definitions
}

// RemovePortDefinitionIDs removes the port_definitions edge to EquipmentPortDefinition by ids.
func (m *EquipmentTypeMutation) RemovePortDefinitionIDs(ids ...int) {
	if m.removedport_definitions == nil {
		m.removedport_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedport_definitions[ids[i]] = struct{}{}
	}
}

// RemovedPortDefinitions returns the removed ids of port_definitions.
func (m *EquipmentTypeMutation) RemovedPortDefinitionsIDs() (ids []int) {
	for id := range m.removedport_definitions {
		ids = append(ids, id)
	}
	return
}

// PortDefinitionsIDs returns the port_definitions ids in the mutation.
func (m *EquipmentTypeMutation) PortDefinitionsIDs() (ids []int) {
	for id := range m.port_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetPortDefinitions reset all changes of the "port_definitions" edge.
func (m *EquipmentTypeMutation) ResetPortDefinitions() {
	m.port_definitions = nil
	m.clearedport_definitions = false
	m.removedport_definitions = nil
}

// AddPositionDefinitionIDs adds the position_definitions edge to EquipmentPositionDefinition by ids.
func (m *EquipmentTypeMutation) AddPositionDefinitionIDs(ids ...int) {
	if m.position_definitions == nil {
		m.position_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.position_definitions[ids[i]] = struct{}{}
	}
}

// ClearPositionDefinitions clears the position_definitions edge to EquipmentPositionDefinition.
func (m *EquipmentTypeMutation) ClearPositionDefinitions() {
	m.clearedposition_definitions = true
}

// PositionDefinitionsCleared returns if the edge position_definitions was cleared.
func (m *EquipmentTypeMutation) PositionDefinitionsCleared() bool {
	return m.clearedposition_definitions
}

// RemovePositionDefinitionIDs removes the position_definitions edge to EquipmentPositionDefinition by ids.
func (m *EquipmentTypeMutation) RemovePositionDefinitionIDs(ids ...int) {
	if m.removedposition_definitions == nil {
		m.removedposition_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedposition_definitions[ids[i]] = struct{}{}
	}
}

// RemovedPositionDefinitions returns the removed ids of position_definitions.
func (m *EquipmentTypeMutation) RemovedPositionDefinitionsIDs() (ids []int) {
	for id := range m.removedposition_definitions {
		ids = append(ids, id)
	}
	return
}

// PositionDefinitionsIDs returns the position_definitions ids in the mutation.
func (m *EquipmentTypeMutation) PositionDefinitionsIDs() (ids []int) {
	for id := range m.position_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetPositionDefinitions reset all changes of the "position_definitions" edge.
func (m *EquipmentTypeMutation) ResetPositionDefinitions() {
	m.position_definitions = nil
	m.clearedposition_definitions = false
	m.removedposition_definitions = nil
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *EquipmentTypeMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// ClearPropertyTypes clears the property_types edge to PropertyType.
func (m *EquipmentTypeMutation) ClearPropertyTypes() {
	m.clearedproperty_types = true
}

// PropertyTypesCleared returns if the edge property_types was cleared.
func (m *EquipmentTypeMutation) PropertyTypesCleared() bool {
	return m.clearedproperty_types
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *EquipmentTypeMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *EquipmentTypeMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *EquipmentTypeMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *EquipmentTypeMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.clearedproperty_types = false
	m.removedproperty_types = nil
}

// AddEquipmentIDs adds the equipment edge to Equipment by ids.
func (m *EquipmentTypeMutation) AddEquipmentIDs(ids ...int) {
	if m.equipment == nil {
		m.equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *EquipmentTypeMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *EquipmentTypeMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// RemoveEquipmentIDs removes the equipment edge to Equipment by ids.
func (m *EquipmentTypeMutation) RemoveEquipmentIDs(ids ...int) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed ids of equipment.
func (m *EquipmentTypeMutation) RemovedEquipmentIDs() (ids []int) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
func (m *EquipmentTypeMutation) EquipmentIDs() (ids []int) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *EquipmentTypeMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
	m.removedequipment = nil
}

// SetCategoryID sets the category edge to EquipmentCategory by id.
func (m *EquipmentTypeMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the category edge to EquipmentCategory.
func (m *EquipmentTypeMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared returns if the edge category was cleared.
func (m *EquipmentTypeMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the category id in the mutation.
func (m *EquipmentTypeMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *EquipmentTypeMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory reset all changes of the "category" edge.
func (m *EquipmentTypeMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddServiceEndpointDefinitionIDs adds the service_endpoint_definitions edge to ServiceEndpointDefinition by ids.
func (m *EquipmentTypeMutation) AddServiceEndpointDefinitionIDs(ids ...int) {
	if m.service_endpoint_definitions == nil {
		m.service_endpoint_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.service_endpoint_definitions[ids[i]] = struct{}{}
	}
}

// ClearServiceEndpointDefinitions clears the service_endpoint_definitions edge to ServiceEndpointDefinition.
func (m *EquipmentTypeMutation) ClearServiceEndpointDefinitions() {
	m.clearedservice_endpoint_definitions = true
}

// ServiceEndpointDefinitionsCleared returns if the edge service_endpoint_definitions was cleared.
func (m *EquipmentTypeMutation) ServiceEndpointDefinitionsCleared() bool {
	return m.clearedservice_endpoint_definitions
}

// RemoveServiceEndpointDefinitionIDs removes the service_endpoint_definitions edge to ServiceEndpointDefinition by ids.
func (m *EquipmentTypeMutation) RemoveServiceEndpointDefinitionIDs(ids ...int) {
	if m.removedservice_endpoint_definitions == nil {
		m.removedservice_endpoint_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservice_endpoint_definitions[ids[i]] = struct{}{}
	}
}

// RemovedServiceEndpointDefinitions returns the removed ids of service_endpoint_definitions.
func (m *EquipmentTypeMutation) RemovedServiceEndpointDefinitionsIDs() (ids []int) {
	for id := range m.removedservice_endpoint_definitions {
		ids = append(ids, id)
	}
	return
}

// ServiceEndpointDefinitionsIDs returns the service_endpoint_definitions ids in the mutation.
func (m *EquipmentTypeMutation) ServiceEndpointDefinitionsIDs() (ids []int) {
	for id := range m.service_endpoint_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetServiceEndpointDefinitions reset all changes of the "service_endpoint_definitions" edge.
func (m *EquipmentTypeMutation) ResetServiceEndpointDefinitions() {
	m.service_endpoint_definitions = nil
	m.clearedservice_endpoint_definitions = false
	m.removedservice_endpoint_definitions = nil
}

// Op returns the operation name.
func (m *EquipmentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentType).
func (m *EquipmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EquipmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, equipmenttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, equipmenttype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, equipmenttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EquipmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmenttype.FieldCreateTime:
		return m.CreateTime()
	case equipmenttype.FieldUpdateTime:
		return m.UpdateTime()
	case equipmenttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EquipmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmenttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case equipmenttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case equipmenttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmenttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case equipmenttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case equipmenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EquipmentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EquipmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EquipmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EquipmentTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EquipmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EquipmentTypeMutation) ResetField(name string) error {
	switch name {
	case equipmenttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case equipmenttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case equipmenttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EquipmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.port_definitions != nil {
		edges = append(edges, equipmenttype.EdgePortDefinitions)
	}
	if m.position_definitions != nil {
		edges = append(edges, equipmenttype.EdgePositionDefinitions)
	}
	if m.property_types != nil {
		edges = append(edges, equipmenttype.EdgePropertyTypes)
	}
	if m.equipment != nil {
		edges = append(edges, equipmenttype.EdgeEquipment)
	}
	if m.category != nil {
		edges = append(edges, equipmenttype.EdgeCategory)
	}
	if m.service_endpoint_definitions != nil {
		edges = append(edges, equipmenttype.EdgeServiceEndpointDefinitions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EquipmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmenttype.EdgePortDefinitions:
		ids := make([]ent.Value, 0, len(m.port_definitions))
		for id := range m.port_definitions {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgePositionDefinitions:
		ids := make([]ent.Value, 0, len(m.position_definitions))
		for id := range m.position_definitions {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case equipmenttype.EdgeServiceEndpointDefinitions:
		ids := make([]ent.Value, 0, len(m.service_endpoint_definitions))
		for id := range m.service_endpoint_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EquipmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedport_definitions != nil {
		edges = append(edges, equipmenttype.EdgePortDefinitions)
	}
	if m.removedposition_definitions != nil {
		edges = append(edges, equipmenttype.EdgePositionDefinitions)
	}
	if m.removedproperty_types != nil {
		edges = append(edges, equipmenttype.EdgePropertyTypes)
	}
	if m.removedequipment != nil {
		edges = append(edges, equipmenttype.EdgeEquipment)
	}
	if m.removedservice_endpoint_definitions != nil {
		edges = append(edges, equipmenttype.EdgeServiceEndpointDefinitions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EquipmentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmenttype.EdgePortDefinitions:
		ids := make([]ent.Value, 0, len(m.removedport_definitions))
		for id := range m.removedport_definitions {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgePositionDefinitions:
		ids := make([]ent.Value, 0, len(m.removedposition_definitions))
		for id := range m.removedposition_definitions {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	case equipmenttype.EdgeServiceEndpointDefinitions:
		ids := make([]ent.Value, 0, len(m.removedservice_endpoint_definitions))
		for id := range m.removedservice_endpoint_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EquipmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedport_definitions {
		edges = append(edges, equipmenttype.EdgePortDefinitions)
	}
	if m.clearedposition_definitions {
		edges = append(edges, equipmenttype.EdgePositionDefinitions)
	}
	if m.clearedproperty_types {
		edges = append(edges, equipmenttype.EdgePropertyTypes)
	}
	if m.clearedequipment {
		edges = append(edges, equipmenttype.EdgeEquipment)
	}
	if m.clearedcategory {
		edges = append(edges, equipmenttype.EdgeCategory)
	}
	if m.clearedservice_endpoint_definitions {
		edges = append(edges, equipmenttype.EdgeServiceEndpointDefinitions)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EquipmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmenttype.EdgePortDefinitions:
		return m.clearedport_definitions
	case equipmenttype.EdgePositionDefinitions:
		return m.clearedposition_definitions
	case equipmenttype.EdgePropertyTypes:
		return m.clearedproperty_types
	case equipmenttype.EdgeEquipment:
		return m.clearedequipment
	case equipmenttype.EdgeCategory:
		return m.clearedcategory
	case equipmenttype.EdgeServiceEndpointDefinitions:
		return m.clearedservice_endpoint_definitions
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EquipmentTypeMutation) ClearEdge(name string) error {
	switch name {
	case equipmenttype.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EquipmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case equipmenttype.EdgePortDefinitions:
		m.ResetPortDefinitions()
		return nil
	case equipmenttype.EdgePositionDefinitions:
		m.ResetPositionDefinitions()
		return nil
	case equipmenttype.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	case equipmenttype.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case equipmenttype.EdgeCategory:
		m.ResetCategory()
		return nil
	case equipmenttype.EdgeServiceEndpointDefinitions:
		m.ResetServiceEndpointDefinitions()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType edge %s", name)
}

// EventSeverityMutation represents an operation that mutate the EventSeverities
// nodes in the graph.
type EventSeverityMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	create_time              *time.Time
	update_time              *time.Time
	name                     *string
	clearedFields            map[string]struct{}
	eventseverityrule        map[int]struct{}
	removedeventseverityrule map[int]struct{}
	clearedeventseverityrule bool
	done                     bool
	oldValue                 func(context.Context) (*EventSeverity, error)
	predicates               []predicate.EventSeverity
}

var _ ent.Mutation = (*EventSeverityMutation)(nil)

// eventseverityOption allows to manage the mutation configuration using functional options.
type eventseverityOption func(*EventSeverityMutation)

// newEventSeverityMutation creates new mutation for EventSeverity.
func newEventSeverityMutation(c config, op Op, opts ...eventseverityOption) *EventSeverityMutation {
	m := &EventSeverityMutation{
		config:        c,
		op:            op,
		typ:           TypeEventSeverity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventSeverityID sets the id field of the mutation.
func withEventSeverityID(id int) eventseverityOption {
	return func(m *EventSeverityMutation) {
		var (
			err   error
			once  sync.Once
			value *EventSeverity
		)
		m.oldValue = func(ctx context.Context) (*EventSeverity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventSeverity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventSeverity sets the old EventSeverity of the mutation.
func withEventSeverity(node *EventSeverity) eventseverityOption {
	return func(m *EventSeverityMutation) {
		m.oldValue = func(context.Context) (*EventSeverity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventSeverityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventSeverityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EventSeverityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *EventSeverityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *EventSeverityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the EventSeverity.
// If the EventSeverity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventSeverityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *EventSeverityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *EventSeverityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *EventSeverityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the EventSeverity.
// If the EventSeverity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventSeverityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *EventSeverityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *EventSeverityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EventSeverityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EventSeverity.
// If the EventSeverity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventSeverityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EventSeverityMutation) ResetName() {
	m.name = nil
}

// AddEventseverityruleIDs adds the eventseverityrule edge to Rule by ids.
func (m *EventSeverityMutation) AddEventseverityruleIDs(ids ...int) {
	if m.eventseverityrule == nil {
		m.eventseverityrule = make(map[int]struct{})
	}
	for i := range ids {
		m.eventseverityrule[ids[i]] = struct{}{}
	}
}

// ClearEventseverityrule clears the eventseverityrule edge to Rule.
func (m *EventSeverityMutation) ClearEventseverityrule() {
	m.clearedeventseverityrule = true
}

// EventseverityruleCleared returns if the edge eventseverityrule was cleared.
func (m *EventSeverityMutation) EventseverityruleCleared() bool {
	return m.clearedeventseverityrule
}

// RemoveEventseverityruleIDs removes the eventseverityrule edge to Rule by ids.
func (m *EventSeverityMutation) RemoveEventseverityruleIDs(ids ...int) {
	if m.removedeventseverityrule == nil {
		m.removedeventseverityrule = make(map[int]struct{})
	}
	for i := range ids {
		m.removedeventseverityrule[ids[i]] = struct{}{}
	}
}

// RemovedEventseverityrule returns the removed ids of eventseverityrule.
func (m *EventSeverityMutation) RemovedEventseverityruleIDs() (ids []int) {
	for id := range m.removedeventseverityrule {
		ids = append(ids, id)
	}
	return
}

// EventseverityruleIDs returns the eventseverityrule ids in the mutation.
func (m *EventSeverityMutation) EventseverityruleIDs() (ids []int) {
	for id := range m.eventseverityrule {
		ids = append(ids, id)
	}
	return
}

// ResetEventseverityrule reset all changes of the "eventseverityrule" edge.
func (m *EventSeverityMutation) ResetEventseverityrule() {
	m.eventseverityrule = nil
	m.clearedeventseverityrule = false
	m.removedeventseverityrule = nil
}

// Op returns the operation name.
func (m *EventSeverityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EventSeverity).
func (m *EventSeverityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EventSeverityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, eventseverity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, eventseverity.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, eventseverity.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EventSeverityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventseverity.FieldCreateTime:
		return m.CreateTime()
	case eventseverity.FieldUpdateTime:
		return m.UpdateTime()
	case eventseverity.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EventSeverityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventseverity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case eventseverity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case eventseverity.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EventSeverity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventSeverityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventseverity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case eventseverity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case eventseverity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EventSeverity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EventSeverityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EventSeverityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventSeverityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventSeverity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EventSeverityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EventSeverityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventSeverityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventSeverity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EventSeverityMutation) ResetField(name string) error {
	switch name {
	case eventseverity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case eventseverity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case eventseverity.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EventSeverity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EventSeverityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.eventseverityrule != nil {
		edges = append(edges, eventseverity.EdgeEventseverityrule)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EventSeverityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventseverity.EdgeEventseverityrule:
		ids := make([]ent.Value, 0, len(m.eventseverityrule))
		for id := range m.eventseverityrule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EventSeverityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedeventseverityrule != nil {
		edges = append(edges, eventseverity.EdgeEventseverityrule)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EventSeverityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case eventseverity.EdgeEventseverityrule:
		ids := make([]ent.Value, 0, len(m.removedeventseverityrule))
		for id := range m.removedeventseverityrule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EventSeverityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedeventseverityrule {
		edges = append(edges, eventseverity.EdgeEventseverityrule)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EventSeverityMutation) EdgeCleared(name string) bool {
	switch name {
	case eventseverity.EdgeEventseverityrule:
		return m.clearedeventseverityrule
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EventSeverityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EventSeverity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EventSeverityMutation) ResetEdge(name string) error {
	switch name {
	case eventseverity.EdgeEventseverityrule:
		m.ResetEventseverityrule()
		return nil
	}
	return fmt.Errorf("unknown EventSeverity edge %s", name)
}

// ExitPointMutation represents an operation that mutate the ExitPoints
// nodes in the graph.
type ExitPointMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	create_time              *time.Time
	update_time              *time.Time
	role                     *flowschema.ExitPointRole
	cid                      *string
	condition                **flowschema.VariableExpression
	clearedFields            map[string]struct{}
	next_entry_points        map[int]struct{}
	removednext_entry_points map[int]struct{}
	clearednext_entry_points bool
	parent_block             *int
	clearedparent_block      bool
	done                     bool
	oldValue                 func(context.Context) (*ExitPoint, error)
	predicates               []predicate.ExitPoint
}

var _ ent.Mutation = (*ExitPointMutation)(nil)

// exitpointOption allows to manage the mutation configuration using functional options.
type exitpointOption func(*ExitPointMutation)

// newExitPointMutation creates new mutation for ExitPoint.
func newExitPointMutation(c config, op Op, opts ...exitpointOption) *ExitPointMutation {
	m := &ExitPointMutation{
		config:        c,
		op:            op,
		typ:           TypeExitPoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExitPointID sets the id field of the mutation.
func withExitPointID(id int) exitpointOption {
	return func(m *ExitPointMutation) {
		var (
			err   error
			once  sync.Once
			value *ExitPoint
		)
		m.oldValue = func(ctx context.Context) (*ExitPoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExitPoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExitPoint sets the old ExitPoint of the mutation.
func withExitPoint(node *ExitPoint) exitpointOption {
	return func(m *ExitPointMutation) {
		m.oldValue = func(context.Context) (*ExitPoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExitPointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExitPointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ExitPointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ExitPointMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ExitPointMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ExitPoint.
// If the ExitPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitPointMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ExitPointMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ExitPointMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ExitPointMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ExitPoint.
// If the ExitPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitPointMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ExitPointMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRole sets the role field.
func (m *ExitPointMutation) SetRole(fpr flowschema.ExitPointRole) {
	m.role = &fpr
}

// Role returns the role value in the mutation.
func (m *ExitPointMutation) Role() (r flowschema.ExitPointRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old role value of the ExitPoint.
// If the ExitPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitPointMutation) OldRole(ctx context.Context) (v flowschema.ExitPointRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole reset all changes of the "role" field.
func (m *ExitPointMutation) ResetRole() {
	m.role = nil
}

// SetCid sets the cid field.
func (m *ExitPointMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the cid value in the mutation.
func (m *ExitPointMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old cid value of the ExitPoint.
// If the ExitPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitPointMutation) OldCid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ClearCid clears the value of cid.
func (m *ExitPointMutation) ClearCid() {
	m.cid = nil
	m.clearedFields[exitpoint.FieldCid] = struct{}{}
}

// CidCleared returns if the field cid was cleared in this mutation.
func (m *ExitPointMutation) CidCleared() bool {
	_, ok := m.clearedFields[exitpoint.FieldCid]
	return ok
}

// ResetCid reset all changes of the "cid" field.
func (m *ExitPointMutation) ResetCid() {
	m.cid = nil
	delete(m.clearedFields, exitpoint.FieldCid)
}

// SetCondition sets the condition field.
func (m *ExitPointMutation) SetCondition(fe *flowschema.VariableExpression) {
	m.condition = &fe
}

// Condition returns the condition value in the mutation.
func (m *ExitPointMutation) Condition() (r *flowschema.VariableExpression, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old condition value of the ExitPoint.
// If the ExitPoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitPointMutation) OldCondition(ctx context.Context) (v *flowschema.VariableExpression, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCondition is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ClearCondition clears the value of condition.
func (m *ExitPointMutation) ClearCondition() {
	m.condition = nil
	m.clearedFields[exitpoint.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the field condition was cleared in this mutation.
func (m *ExitPointMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[exitpoint.FieldCondition]
	return ok
}

// ResetCondition reset all changes of the "condition" field.
func (m *ExitPointMutation) ResetCondition() {
	m.condition = nil
	delete(m.clearedFields, exitpoint.FieldCondition)
}

// AddNextEntryPointIDs adds the next_entry_points edge to EntryPoint by ids.
func (m *ExitPointMutation) AddNextEntryPointIDs(ids ...int) {
	if m.next_entry_points == nil {
		m.next_entry_points = make(map[int]struct{})
	}
	for i := range ids {
		m.next_entry_points[ids[i]] = struct{}{}
	}
}

// ClearNextEntryPoints clears the next_entry_points edge to EntryPoint.
func (m *ExitPointMutation) ClearNextEntryPoints() {
	m.clearednext_entry_points = true
}

// NextEntryPointsCleared returns if the edge next_entry_points was cleared.
func (m *ExitPointMutation) NextEntryPointsCleared() bool {
	return m.clearednext_entry_points
}

// RemoveNextEntryPointIDs removes the next_entry_points edge to EntryPoint by ids.
func (m *ExitPointMutation) RemoveNextEntryPointIDs(ids ...int) {
	if m.removednext_entry_points == nil {
		m.removednext_entry_points = make(map[int]struct{})
	}
	for i := range ids {
		m.removednext_entry_points[ids[i]] = struct{}{}
	}
}

// RemovedNextEntryPoints returns the removed ids of next_entry_points.
func (m *ExitPointMutation) RemovedNextEntryPointsIDs() (ids []int) {
	for id := range m.removednext_entry_points {
		ids = append(ids, id)
	}
	return
}

// NextEntryPointsIDs returns the next_entry_points ids in the mutation.
func (m *ExitPointMutation) NextEntryPointsIDs() (ids []int) {
	for id := range m.next_entry_points {
		ids = append(ids, id)
	}
	return
}

// ResetNextEntryPoints reset all changes of the "next_entry_points" edge.
func (m *ExitPointMutation) ResetNextEntryPoints() {
	m.next_entry_points = nil
	m.clearednext_entry_points = false
	m.removednext_entry_points = nil
}

// SetParentBlockID sets the parent_block edge to Block by id.
func (m *ExitPointMutation) SetParentBlockID(id int) {
	m.parent_block = &id
}

// ClearParentBlock clears the parent_block edge to Block.
func (m *ExitPointMutation) ClearParentBlock() {
	m.clearedparent_block = true
}

// ParentBlockCleared returns if the edge parent_block was cleared.
func (m *ExitPointMutation) ParentBlockCleared() bool {
	return m.clearedparent_block
}

// ParentBlockID returns the parent_block id in the mutation.
func (m *ExitPointMutation) ParentBlockID() (id int, exists bool) {
	if m.parent_block != nil {
		return *m.parent_block, true
	}
	return
}

// ParentBlockIDs returns the parent_block ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentBlockID instead. It exists only for internal usage by the builders.
func (m *ExitPointMutation) ParentBlockIDs() (ids []int) {
	if id := m.parent_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentBlock reset all changes of the "parent_block" edge.
func (m *ExitPointMutation) ResetParentBlock() {
	m.parent_block = nil
	m.clearedparent_block = false
}

// Op returns the operation name.
func (m *ExitPointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ExitPoint).
func (m *ExitPointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ExitPointMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, exitpoint.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, exitpoint.FieldUpdateTime)
	}
	if m.role != nil {
		fields = append(fields, exitpoint.FieldRole)
	}
	if m.cid != nil {
		fields = append(fields, exitpoint.FieldCid)
	}
	if m.condition != nil {
		fields = append(fields, exitpoint.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ExitPointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exitpoint.FieldCreateTime:
		return m.CreateTime()
	case exitpoint.FieldUpdateTime:
		return m.UpdateTime()
	case exitpoint.FieldRole:
		return m.Role()
	case exitpoint.FieldCid:
		return m.Cid()
	case exitpoint.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ExitPointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exitpoint.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case exitpoint.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case exitpoint.FieldRole:
		return m.OldRole(ctx)
	case exitpoint.FieldCid:
		return m.OldCid(ctx)
	case exitpoint.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown ExitPoint field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExitPointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exitpoint.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case exitpoint.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case exitpoint.FieldRole:
		v, ok := value.(flowschema.ExitPointRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case exitpoint.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case exitpoint.FieldCondition:
		v, ok := value.(*flowschema.VariableExpression)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown ExitPoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ExitPointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ExitPointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExitPointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExitPoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ExitPointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exitpoint.FieldCid) {
		fields = append(fields, exitpoint.FieldCid)
	}
	if m.FieldCleared(exitpoint.FieldCondition) {
		fields = append(fields, exitpoint.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ExitPointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExitPointMutation) ClearField(name string) error {
	switch name {
	case exitpoint.FieldCid:
		m.ClearCid()
		return nil
	case exitpoint.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown ExitPoint nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ExitPointMutation) ResetField(name string) error {
	switch name {
	case exitpoint.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case exitpoint.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case exitpoint.FieldRole:
		m.ResetRole()
		return nil
	case exitpoint.FieldCid:
		m.ResetCid()
		return nil
	case exitpoint.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown ExitPoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ExitPointMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.next_entry_points != nil {
		edges = append(edges, exitpoint.EdgeNextEntryPoints)
	}
	if m.parent_block != nil {
		edges = append(edges, exitpoint.EdgeParentBlock)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ExitPointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exitpoint.EdgeNextEntryPoints:
		ids := make([]ent.Value, 0, len(m.next_entry_points))
		for id := range m.next_entry_points {
			ids = append(ids, id)
		}
		return ids
	case exitpoint.EdgeParentBlock:
		if id := m.parent_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ExitPointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednext_entry_points != nil {
		edges = append(edges, exitpoint.EdgeNextEntryPoints)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ExitPointMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exitpoint.EdgeNextEntryPoints:
		ids := make([]ent.Value, 0, len(m.removednext_entry_points))
		for id := range m.removednext_entry_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ExitPointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednext_entry_points {
		edges = append(edges, exitpoint.EdgeNextEntryPoints)
	}
	if m.clearedparent_block {
		edges = append(edges, exitpoint.EdgeParentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ExitPointMutation) EdgeCleared(name string) bool {
	switch name {
	case exitpoint.EdgeNextEntryPoints:
		return m.clearednext_entry_points
	case exitpoint.EdgeParentBlock:
		return m.clearedparent_block
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ExitPointMutation) ClearEdge(name string) error {
	switch name {
	case exitpoint.EdgeParentBlock:
		m.ClearParentBlock()
		return nil
	}
	return fmt.Errorf("unknown ExitPoint unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ExitPointMutation) ResetEdge(name string) error {
	switch name {
	case exitpoint.EdgeNextEntryPoints:
		m.ResetNextEntryPoints()
		return nil
	case exitpoint.EdgeParentBlock:
		m.ResetParentBlock()
		return nil
	}
	return fmt.Errorf("unknown ExitPoint edge %s", name)
}

// ExportTaskMutation represents an operation that mutate the ExportTasks
// nodes in the graph.
type ExportTaskMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_type              *exporttask.Type
	status             *exporttask.Status
	progress           *float64
	addprogress        *float64
	filters            *string
	store_key          *string
	wo_id_to_export    *int
	addwo_id_to_export *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*ExportTask, error)
	predicates         []predicate.ExportTask
}

var _ ent.Mutation = (*ExportTaskMutation)(nil)

// exporttaskOption allows to manage the mutation configuration using functional options.
type exporttaskOption func(*ExportTaskMutation)

// newExportTaskMutation creates new mutation for ExportTask.
func newExportTaskMutation(c config, op Op, opts ...exporttaskOption) *ExportTaskMutation {
	m := &ExportTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeExportTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExportTaskID sets the id field of the mutation.
func withExportTaskID(id int) exporttaskOption {
	return func(m *ExportTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ExportTask
		)
		m.oldValue = func(ctx context.Context) (*ExportTask, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExportTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExportTask sets the old ExportTask of the mutation.
func withExportTask(node *ExportTask) exporttaskOption {
	return func(m *ExportTaskMutation) {
		m.oldValue = func(context.Context) (*ExportTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExportTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExportTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ExportTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *ExportTaskMutation) SetType(e exporttask.Type) {
	m._type = &e
}

// GetType returns the type value in the mutation.
func (m *ExportTaskMutation) GetType() (r exporttask.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the ExportTask.
// If the ExportTask object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExportTaskMutation) OldType(ctx context.Context) (v exporttask.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *ExportTaskMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the status field.
func (m *ExportTaskMutation) SetStatus(e exporttask.Status) {
	m.status = &e
}

// Status returns the status value in the mutation.
func (m *ExportTaskMutation) Status() (r exporttask.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the ExportTask.
// If the ExportTask object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExportTaskMutation) OldStatus(ctx context.Context) (v exporttask.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *ExportTaskMutation) ResetStatus() {
	m.status = nil
}

// SetProgress sets the progress field.
func (m *ExportTaskMutation) SetProgress(f float64) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the progress value in the mutation.
func (m *ExportTaskMutation) Progress() (r float64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old progress value of the ExportTask.
// If the ExportTask object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExportTaskMutation) OldProgress(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProgress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to progress.
func (m *ExportTaskMutation) AddProgress(f float64) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the progress field in this mutation.
func (m *ExportTaskMutation) AddedProgress() (r float64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress reset all changes of the "progress" field.
func (m *ExportTaskMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetFilters sets the filters field.
func (m *ExportTaskMutation) SetFilters(s string) {
	m.filters = &s
}

// Filters returns the filters value in the mutation.
func (m *ExportTaskMutation) Filters() (r string, exists bool) {
	v := m.filters
	if v == nil {
		return
	}
	return *v, true
}

// OldFilters returns the old filters value of the ExportTask.
// If the ExportTask object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExportTaskMutation) OldFilters(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFilters is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilters: %w", err)
	}
	return oldValue.Filters, nil
}

// ResetFilters reset all changes of the "filters" field.
func (m *ExportTaskMutation) ResetFilters() {
	m.filters = nil
}

// SetStoreKey sets the store_key field.
func (m *ExportTaskMutation) SetStoreKey(s string) {
	m.store_key = &s
}

// StoreKey returns the store_key value in the mutation.
func (m *ExportTaskMutation) StoreKey() (r string, exists bool) {
	v := m.store_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreKey returns the old store_key value of the ExportTask.
// If the ExportTask object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExportTaskMutation) OldStoreKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoreKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoreKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreKey: %w", err)
	}
	return oldValue.StoreKey, nil
}

// ClearStoreKey clears the value of store_key.
func (m *ExportTaskMutation) ClearStoreKey() {
	m.store_key = nil
	m.clearedFields[exporttask.FieldStoreKey] = struct{}{}
}

// StoreKeyCleared returns if the field store_key was cleared in this mutation.
func (m *ExportTaskMutation) StoreKeyCleared() bool {
	_, ok := m.clearedFields[exporttask.FieldStoreKey]
	return ok
}

// ResetStoreKey reset all changes of the "store_key" field.
func (m *ExportTaskMutation) ResetStoreKey() {
	m.store_key = nil
	delete(m.clearedFields, exporttask.FieldStoreKey)
}

// SetWoIDToExport sets the wo_id_to_export field.
func (m *ExportTaskMutation) SetWoIDToExport(i int) {
	m.wo_id_to_export = &i
	m.addwo_id_to_export = nil
}

// WoIDToExport returns the wo_id_to_export value in the mutation.
func (m *ExportTaskMutation) WoIDToExport() (r int, exists bool) {
	v := m.wo_id_to_export
	if v == nil {
		return
	}
	return *v, true
}

// OldWoIDToExport returns the old wo_id_to_export value of the ExportTask.
// If the ExportTask object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExportTaskMutation) OldWoIDToExport(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWoIDToExport is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWoIDToExport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWoIDToExport: %w", err)
	}
	return oldValue.WoIDToExport, nil
}

// AddWoIDToExport adds i to wo_id_to_export.
func (m *ExportTaskMutation) AddWoIDToExport(i int) {
	if m.addwo_id_to_export != nil {
		*m.addwo_id_to_export += i
	} else {
		m.addwo_id_to_export = &i
	}
}

// AddedWoIDToExport returns the value that was added to the wo_id_to_export field in this mutation.
func (m *ExportTaskMutation) AddedWoIDToExport() (r int, exists bool) {
	v := m.addwo_id_to_export
	if v == nil {
		return
	}
	return *v, true
}

// ClearWoIDToExport clears the value of wo_id_to_export.
func (m *ExportTaskMutation) ClearWoIDToExport() {
	m.wo_id_to_export = nil
	m.addwo_id_to_export = nil
	m.clearedFields[exporttask.FieldWoIDToExport] = struct{}{}
}

// WoIDToExportCleared returns if the field wo_id_to_export was cleared in this mutation.
func (m *ExportTaskMutation) WoIDToExportCleared() bool {
	_, ok := m.clearedFields[exporttask.FieldWoIDToExport]
	return ok
}

// ResetWoIDToExport reset all changes of the "wo_id_to_export" field.
func (m *ExportTaskMutation) ResetWoIDToExport() {
	m.wo_id_to_export = nil
	m.addwo_id_to_export = nil
	delete(m.clearedFields, exporttask.FieldWoIDToExport)
}

// Op returns the operation name.
func (m *ExportTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ExportTask).
func (m *ExportTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ExportTaskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._type != nil {
		fields = append(fields, exporttask.FieldType)
	}
	if m.status != nil {
		fields = append(fields, exporttask.FieldStatus)
	}
	if m.progress != nil {
		fields = append(fields, exporttask.FieldProgress)
	}
	if m.filters != nil {
		fields = append(fields, exporttask.FieldFilters)
	}
	if m.store_key != nil {
		fields = append(fields, exporttask.FieldStoreKey)
	}
	if m.wo_id_to_export != nil {
		fields = append(fields, exporttask.FieldWoIDToExport)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ExportTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exporttask.FieldType:
		return m.GetType()
	case exporttask.FieldStatus:
		return m.Status()
	case exporttask.FieldProgress:
		return m.Progress()
	case exporttask.FieldFilters:
		return m.Filters()
	case exporttask.FieldStoreKey:
		return m.StoreKey()
	case exporttask.FieldWoIDToExport:
		return m.WoIDToExport()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ExportTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exporttask.FieldType:
		return m.OldType(ctx)
	case exporttask.FieldStatus:
		return m.OldStatus(ctx)
	case exporttask.FieldProgress:
		return m.OldProgress(ctx)
	case exporttask.FieldFilters:
		return m.OldFilters(ctx)
	case exporttask.FieldStoreKey:
		return m.OldStoreKey(ctx)
	case exporttask.FieldWoIDToExport:
		return m.OldWoIDToExport(ctx)
	}
	return nil, fmt.Errorf("unknown ExportTask field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExportTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exporttask.FieldType:
		v, ok := value.(exporttask.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case exporttask.FieldStatus:
		v, ok := value.(exporttask.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case exporttask.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case exporttask.FieldFilters:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilters(v)
		return nil
	case exporttask.FieldStoreKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreKey(v)
		return nil
	case exporttask.FieldWoIDToExport:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoIDToExport(v)
		return nil
	}
	return fmt.Errorf("unknown ExportTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ExportTaskMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, exporttask.FieldProgress)
	}
	if m.addwo_id_to_export != nil {
		fields = append(fields, exporttask.FieldWoIDToExport)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ExportTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exporttask.FieldProgress:
		return m.AddedProgress()
	case exporttask.FieldWoIDToExport:
		return m.AddedWoIDToExport()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExportTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exporttask.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	case exporttask.FieldWoIDToExport:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoIDToExport(v)
		return nil
	}
	return fmt.Errorf("unknown ExportTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ExportTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exporttask.FieldStoreKey) {
		fields = append(fields, exporttask.FieldStoreKey)
	}
	if m.FieldCleared(exporttask.FieldWoIDToExport) {
		fields = append(fields, exporttask.FieldWoIDToExport)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ExportTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExportTaskMutation) ClearField(name string) error {
	switch name {
	case exporttask.FieldStoreKey:
		m.ClearStoreKey()
		return nil
	case exporttask.FieldWoIDToExport:
		m.ClearWoIDToExport()
		return nil
	}
	return fmt.Errorf("unknown ExportTask nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ExportTaskMutation) ResetField(name string) error {
	switch name {
	case exporttask.FieldType:
		m.ResetType()
		return nil
	case exporttask.FieldStatus:
		m.ResetStatus()
		return nil
	case exporttask.FieldProgress:
		m.ResetProgress()
		return nil
	case exporttask.FieldFilters:
		m.ResetFilters()
		return nil
	case exporttask.FieldStoreKey:
		m.ResetStoreKey()
		return nil
	case exporttask.FieldWoIDToExport:
		m.ResetWoIDToExport()
		return nil
	}
	return fmt.Errorf("unknown ExportTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ExportTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ExportTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ExportTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ExportTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ExportTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ExportTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ExportTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExportTask unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ExportTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExportTask edge %s", name)
}

// FeatureMutation represents an operation that mutate the Features
// nodes in the graph.
type FeatureMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	global        *bool
	enabled       *bool
	description   *string
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	groups        map[int]struct{}
	removedgroups map[int]struct{}
	clearedgroups bool
	done          bool
	oldValue      func(context.Context) (*Feature, error)
	predicates    []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows to manage the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for Feature.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the id field of the mutation.
func withFeatureID(id int) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FeatureMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FeatureMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Feature.
// If the Feature object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeatureMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FeatureMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FeatureMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FeatureMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Feature.
// If the Feature object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeatureMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FeatureMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Feature.
// If the Feature object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetGlobal sets the global field.
func (m *FeatureMutation) SetGlobal(b bool) {
	m.global = &b
}

// Global returns the global value in the mutation.
func (m *FeatureMutation) Global() (r bool, exists bool) {
	v := m.global
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobal returns the old global value of the Feature.
// If the Feature object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeatureMutation) OldGlobal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGlobal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGlobal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobal: %w", err)
	}
	return oldValue.Global, nil
}

// ResetGlobal reset all changes of the "global" field.
func (m *FeatureMutation) ResetGlobal() {
	m.global = nil
}

// SetEnabled sets the enabled field.
func (m *FeatureMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the enabled value in the mutation.
func (m *FeatureMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old enabled value of the Feature.
// If the Feature object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeatureMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled reset all changes of the "enabled" field.
func (m *FeatureMutation) ResetEnabled() {
	m.enabled = nil
}

// SetDescription sets the description field.
func (m *FeatureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *FeatureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Feature.
// If the Feature object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeatureMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *FeatureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feature.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *FeatureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feature.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *FeatureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feature.FieldDescription)
}

// AddUserIDs adds the users edge to User by ids.
func (m *FeatureMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the users edge to User.
func (m *FeatureMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared returns if the edge users was cleared.
func (m *FeatureMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the users edge to User by ids.
func (m *FeatureMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *FeatureMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *FeatureMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *FeatureMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddGroupIDs adds the groups edge to UsersGroup by ids.
func (m *FeatureMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the groups edge to UsersGroup.
func (m *FeatureMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared returns if the edge groups was cleared.
func (m *FeatureMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the groups edge to UsersGroup by ids.
func (m *FeatureMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed ids of groups.
func (m *FeatureMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the groups ids in the mutation.
func (m *FeatureMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups reset all changes of the "groups" edge.
func (m *FeatureMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, feature.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, feature.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.global != nil {
		fields = append(fields, feature.FieldGlobal)
	}
	if m.enabled != nil {
		fields = append(fields, feature.FieldEnabled)
	}
	if m.description != nil {
		fields = append(fields, feature.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldCreateTime:
		return m.CreateTime()
	case feature.FieldUpdateTime:
		return m.UpdateTime()
	case feature.FieldName:
		return m.Name()
	case feature.FieldGlobal:
		return m.Global()
	case feature.FieldEnabled:
		return m.Enabled()
	case feature.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case feature.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldGlobal:
		return m.OldGlobal(ctx)
	case feature.FieldEnabled:
		return m.OldEnabled(ctx)
	case feature.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case feature.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldGlobal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobal(v)
		return nil
	case feature.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case feature.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feature.FieldDescription) {
		fields = append(fields, feature.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	switch name {
	case feature.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case feature.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldGlobal:
		m.ResetGlobal()
		return nil
	case feature.FieldEnabled:
		m.ResetEnabled()
		return nil
	case feature.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, feature.EdgeUsers)
	}
	if m.groups != nil {
		edges = append(edges, feature.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, feature.EdgeUsers)
	}
	if m.removedgroups != nil {
		edges = append(edges, feature.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, feature.EdgeUsers)
	}
	if m.clearedgroups {
		edges = append(edges, feature.EdgeGroups)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeUsers:
		return m.clearedusers
	case feature.EdgeGroups:
		return m.clearedgroups
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeUsers:
		m.ResetUsers()
		return nil
	case feature.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// FileMutation represents an operation that mutate the Files
// nodes in the graph.
type FileMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	_type                        *file.Type
	name                         *string
	size                         *int
	addsize                      *int
	modified_at                  *time.Time
	uploaded_at                  *time.Time
	content_type                 *string
	store_key                    *string
	category                     *string
	annotation                   *string
	clearedFields                map[string]struct{}
	location                     *int
	clearedlocation              bool
	equipment                    *int
	clearedequipment             bool
	user                         *int
	cleareduser                  bool
	work_order                   *int
	clearedwork_order            bool
	checklist_item               *int
	clearedchecklist_item        bool
	survey                       *int
	clearedsurvey                bool
	floor_plan                   *int
	clearedfloor_plan            bool
	photo_survey_question        *int
	clearedphoto_survey_question bool
	survey_question              *int
	clearedsurvey_question       bool
	document_category            *int
	cleareddocument_category     bool
	done                         bool
	oldValue                     func(context.Context) (*File, error)
	predicates                   []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows to manage the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for File.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the id field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the type field.
func (m *FileMutation) SetType(f file.Type) {
	m._type = &f
}

// GetType returns the type value in the mutation.
func (m *FileMutation) GetType() (r file.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v file.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetName sets the name field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSize sets the size field.
func (m *FileMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the size value in the mutation.
func (m *FileMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old size value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSize is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to size.
func (m *FileMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the size field in this mutation.
func (m *FileMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of size.
func (m *FileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[file.FieldSize] = struct{}{}
}

// SizeCleared returns if the field size was cleared in this mutation.
func (m *FileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[file.FieldSize]
	return ok
}

// ResetSize reset all changes of the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, file.FieldSize)
}

// SetModifiedAt sets the modified_at field.
func (m *FileMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the modified_at value in the mutation.
func (m *FileMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old modified_at value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModifiedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ClearModifiedAt clears the value of modified_at.
func (m *FileMutation) ClearModifiedAt() {
	m.modified_at = nil
	m.clearedFields[file.FieldModifiedAt] = struct{}{}
}

// ModifiedAtCleared returns if the field modified_at was cleared in this mutation.
func (m *FileMutation) ModifiedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldModifiedAt]
	return ok
}

// ResetModifiedAt reset all changes of the "modified_at" field.
func (m *FileMutation) ResetModifiedAt() {
	m.modified_at = nil
	delete(m.clearedFields, file.FieldModifiedAt)
}

// SetUploadedAt sets the uploaded_at field.
func (m *FileMutation) SetUploadedAt(t time.Time) {
	m.uploaded_at = &t
}

// UploadedAt returns the uploaded_at value in the mutation.
func (m *FileMutation) UploadedAt() (r time.Time, exists bool) {
	v := m.uploaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedAt returns the old uploaded_at value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldUploadedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUploadedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUploadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedAt: %w", err)
	}
	return oldValue.UploadedAt, nil
}

// ClearUploadedAt clears the value of uploaded_at.
func (m *FileMutation) ClearUploadedAt() {
	m.uploaded_at = nil
	m.clearedFields[file.FieldUploadedAt] = struct{}{}
}

// UploadedAtCleared returns if the field uploaded_at was cleared in this mutation.
func (m *FileMutation) UploadedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldUploadedAt]
	return ok
}

// ResetUploadedAt reset all changes of the "uploaded_at" field.
func (m *FileMutation) ResetUploadedAt() {
	m.uploaded_at = nil
	delete(m.clearedFields, file.FieldUploadedAt)
}

// SetContentType sets the content_type field.
func (m *FileMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the content_type value in the mutation.
func (m *FileMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old content_type value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContentType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType reset all changes of the "content_type" field.
func (m *FileMutation) ResetContentType() {
	m.content_type = nil
}

// SetStoreKey sets the store_key field.
func (m *FileMutation) SetStoreKey(s string) {
	m.store_key = &s
}

// StoreKey returns the store_key value in the mutation.
func (m *FileMutation) StoreKey() (r string, exists bool) {
	v := m.store_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreKey returns the old store_key value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldStoreKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoreKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoreKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreKey: %w", err)
	}
	return oldValue.StoreKey, nil
}

// ResetStoreKey reset all changes of the "store_key" field.
func (m *FileMutation) ResetStoreKey() {
	m.store_key = nil
}

// SetCategory sets the category field.
func (m *FileMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the category value in the mutation.
func (m *FileMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old category value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of category.
func (m *FileMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[file.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the field category was cleared in this mutation.
func (m *FileMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[file.FieldCategory]
	return ok
}

// ResetCategory reset all changes of the "category" field.
func (m *FileMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, file.FieldCategory)
}

// SetAnnotation sets the annotation field.
func (m *FileMutation) SetAnnotation(s string) {
	m.annotation = &s
}

// Annotation returns the annotation value in the mutation.
func (m *FileMutation) Annotation() (r string, exists bool) {
	v := m.annotation
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotation returns the old annotation value of the File.
// If the File object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FileMutation) OldAnnotation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnnotation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnnotation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotation: %w", err)
	}
	return oldValue.Annotation, nil
}

// ClearAnnotation clears the value of annotation.
func (m *FileMutation) ClearAnnotation() {
	m.annotation = nil
	m.clearedFields[file.FieldAnnotation] = struct{}{}
}

// AnnotationCleared returns if the field annotation was cleared in this mutation.
func (m *FileMutation) AnnotationCleared() bool {
	_, ok := m.clearedFields[file.FieldAnnotation]
	return ok
}

// ResetAnnotation reset all changes of the "annotation" field.
func (m *FileMutation) ResetAnnotation() {
	m.annotation = nil
	delete(m.clearedFields, file.FieldAnnotation)
}

// SetLocationID sets the location edge to Location by id.
func (m *FileMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *FileMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *FileMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *FileMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *FileMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *FileMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetEquipmentID sets the equipment edge to Equipment by id.
func (m *FileMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *FileMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *FileMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the equipment id in the mutation.
func (m *FileMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *FileMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *FileMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetUserID sets the user edge to User by id.
func (m *FileMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *FileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *FileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *FileMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *FileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *FileMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *FileMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *FileMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *FileMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *FileMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *FileMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// SetChecklistItemID sets the checklist_item edge to CheckListItem by id.
func (m *FileMutation) SetChecklistItemID(id int) {
	m.checklist_item = &id
}

// ClearChecklistItem clears the checklist_item edge to CheckListItem.
func (m *FileMutation) ClearChecklistItem() {
	m.clearedchecklist_item = true
}

// ChecklistItemCleared returns if the edge checklist_item was cleared.
func (m *FileMutation) ChecklistItemCleared() bool {
	return m.clearedchecklist_item
}

// ChecklistItemID returns the checklist_item id in the mutation.
func (m *FileMutation) ChecklistItemID() (id int, exists bool) {
	if m.checklist_item != nil {
		return *m.checklist_item, true
	}
	return
}

// ChecklistItemIDs returns the checklist_item ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ChecklistItemID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ChecklistItemIDs() (ids []int) {
	if id := m.checklist_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChecklistItem reset all changes of the "checklist_item" edge.
func (m *FileMutation) ResetChecklistItem() {
	m.checklist_item = nil
	m.clearedchecklist_item = false
}

// SetSurveyID sets the survey edge to Survey by id.
func (m *FileMutation) SetSurveyID(id int) {
	m.survey = &id
}

// ClearSurvey clears the survey edge to Survey.
func (m *FileMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared returns if the edge survey was cleared.
func (m *FileMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyID returns the survey id in the mutation.
func (m *FileMutation) SurveyID() (id int, exists bool) {
	if m.survey != nil {
		return *m.survey, true
	}
	return
}

// SurveyIDs returns the survey ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *FileMutation) SurveyIDs() (ids []int) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey reset all changes of the "survey" edge.
func (m *FileMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// SetFloorPlanID sets the floor_plan edge to FloorPlan by id.
func (m *FileMutation) SetFloorPlanID(id int) {
	m.floor_plan = &id
}

// ClearFloorPlan clears the floor_plan edge to FloorPlan.
func (m *FileMutation) ClearFloorPlan() {
	m.clearedfloor_plan = true
}

// FloorPlanCleared returns if the edge floor_plan was cleared.
func (m *FileMutation) FloorPlanCleared() bool {
	return m.clearedfloor_plan
}

// FloorPlanID returns the floor_plan id in the mutation.
func (m *FileMutation) FloorPlanID() (id int, exists bool) {
	if m.floor_plan != nil {
		return *m.floor_plan, true
	}
	return
}

// FloorPlanIDs returns the floor_plan ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FloorPlanID instead. It exists only for internal usage by the builders.
func (m *FileMutation) FloorPlanIDs() (ids []int) {
	if id := m.floor_plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFloorPlan reset all changes of the "floor_plan" edge.
func (m *FileMutation) ResetFloorPlan() {
	m.floor_plan = nil
	m.clearedfloor_plan = false
}

// SetPhotoSurveyQuestionID sets the photo_survey_question edge to SurveyQuestion by id.
func (m *FileMutation) SetPhotoSurveyQuestionID(id int) {
	m.photo_survey_question = &id
}

// ClearPhotoSurveyQuestion clears the photo_survey_question edge to SurveyQuestion.
func (m *FileMutation) ClearPhotoSurveyQuestion() {
	m.clearedphoto_survey_question = true
}

// PhotoSurveyQuestionCleared returns if the edge photo_survey_question was cleared.
func (m *FileMutation) PhotoSurveyQuestionCleared() bool {
	return m.clearedphoto_survey_question
}

// PhotoSurveyQuestionID returns the photo_survey_question id in the mutation.
func (m *FileMutation) PhotoSurveyQuestionID() (id int, exists bool) {
	if m.photo_survey_question != nil {
		return *m.photo_survey_question, true
	}
	return
}

// PhotoSurveyQuestionIDs returns the photo_survey_question ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PhotoSurveyQuestionID instead. It exists only for internal usage by the builders.
func (m *FileMutation) PhotoSurveyQuestionIDs() (ids []int) {
	if id := m.photo_survey_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPhotoSurveyQuestion reset all changes of the "photo_survey_question" edge.
func (m *FileMutation) ResetPhotoSurveyQuestion() {
	m.photo_survey_question = nil
	m.clearedphoto_survey_question = false
}

// SetSurveyQuestionID sets the survey_question edge to SurveyQuestion by id.
func (m *FileMutation) SetSurveyQuestionID(id int) {
	m.survey_question = &id
}

// ClearSurveyQuestion clears the survey_question edge to SurveyQuestion.
func (m *FileMutation) ClearSurveyQuestion() {
	m.clearedsurvey_question = true
}

// SurveyQuestionCleared returns if the edge survey_question was cleared.
func (m *FileMutation) SurveyQuestionCleared() bool {
	return m.clearedsurvey_question
}

// SurveyQuestionID returns the survey_question id in the mutation.
func (m *FileMutation) SurveyQuestionID() (id int, exists bool) {
	if m.survey_question != nil {
		return *m.survey_question, true
	}
	return
}

// SurveyQuestionIDs returns the survey_question ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SurveyQuestionID instead. It exists only for internal usage by the builders.
func (m *FileMutation) SurveyQuestionIDs() (ids []int) {
	if id := m.survey_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurveyQuestion reset all changes of the "survey_question" edge.
func (m *FileMutation) ResetSurveyQuestion() {
	m.survey_question = nil
	m.clearedsurvey_question = false
}

// SetDocumentCategoryID sets the document_category edge to DocumentCategory by id.
func (m *FileMutation) SetDocumentCategoryID(id int) {
	m.document_category = &id
}

// ClearDocumentCategory clears the document_category edge to DocumentCategory.
func (m *FileMutation) ClearDocumentCategory() {
	m.cleareddocument_category = true
}

// DocumentCategoryCleared returns if the edge document_category was cleared.
func (m *FileMutation) DocumentCategoryCleared() bool {
	return m.cleareddocument_category
}

// DocumentCategoryID returns the document_category id in the mutation.
func (m *FileMutation) DocumentCategoryID() (id int, exists bool) {
	if m.document_category != nil {
		return *m.document_category, true
	}
	return
}

// DocumentCategoryIDs returns the document_category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DocumentCategoryID instead. It exists only for internal usage by the builders.
func (m *FileMutation) DocumentCategoryIDs() (ids []int) {
	if id := m.document_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocumentCategory reset all changes of the "document_category" edge.
func (m *FileMutation) ResetDocumentCategory() {
	m.document_category = nil
	m.cleareddocument_category = false
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, file.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, file.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.modified_at != nil {
		fields = append(fields, file.FieldModifiedAt)
	}
	if m.uploaded_at != nil {
		fields = append(fields, file.FieldUploadedAt)
	}
	if m.content_type != nil {
		fields = append(fields, file.FieldContentType)
	}
	if m.store_key != nil {
		fields = append(fields, file.FieldStoreKey)
	}
	if m.category != nil {
		fields = append(fields, file.FieldCategory)
	}
	if m.annotation != nil {
		fields = append(fields, file.FieldAnnotation)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreateTime:
		return m.CreateTime()
	case file.FieldUpdateTime:
		return m.UpdateTime()
	case file.FieldType:
		return m.GetType()
	case file.FieldName:
		return m.Name()
	case file.FieldSize:
		return m.Size()
	case file.FieldModifiedAt:
		return m.ModifiedAt()
	case file.FieldUploadedAt:
		return m.UploadedAt()
	case file.FieldContentType:
		return m.ContentType()
	case file.FieldStoreKey:
		return m.StoreKey()
	case file.FieldCategory:
		return m.Category()
	case file.FieldAnnotation:
		return m.Annotation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case file.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	case file.FieldUploadedAt:
		return m.OldUploadedAt(ctx)
	case file.FieldContentType:
		return m.OldContentType(ctx)
	case file.FieldStoreKey:
		return m.OldStoreKey(ctx)
	case file.FieldCategory:
		return m.OldCategory(ctx)
	case file.FieldAnnotation:
		return m.OldAnnotation(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case file.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case file.FieldType:
		v, ok := value.(file.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case file.FieldUploadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedAt(v)
		return nil
	case file.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case file.FieldStoreKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreKey(v)
		return nil
	case file.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case file.FieldAnnotation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotation(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldSize) {
		fields = append(fields, file.FieldSize)
	}
	if m.FieldCleared(file.FieldModifiedAt) {
		fields = append(fields, file.FieldModifiedAt)
	}
	if m.FieldCleared(file.FieldUploadedAt) {
		fields = append(fields, file.FieldUploadedAt)
	}
	if m.FieldCleared(file.FieldCategory) {
		fields = append(fields, file.FieldCategory)
	}
	if m.FieldCleared(file.FieldAnnotation) {
		fields = append(fields, file.FieldAnnotation)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldSize:
		m.ClearSize()
		return nil
	case file.FieldModifiedAt:
		m.ClearModifiedAt()
		return nil
	case file.FieldUploadedAt:
		m.ClearUploadedAt()
		return nil
	case file.FieldCategory:
		m.ClearCategory()
		return nil
	case file.FieldAnnotation:
		m.ClearAnnotation()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case file.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case file.FieldUploadedAt:
		m.ResetUploadedAt()
		return nil
	case file.FieldContentType:
		m.ResetContentType()
		return nil
	case file.FieldStoreKey:
		m.ResetStoreKey()
		return nil
	case file.FieldCategory:
		m.ResetCategory()
		return nil
	case file.FieldAnnotation:
		m.ResetAnnotation()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.location != nil {
		edges = append(edges, file.EdgeLocation)
	}
	if m.equipment != nil {
		edges = append(edges, file.EdgeEquipment)
	}
	if m.user != nil {
		edges = append(edges, file.EdgeUser)
	}
	if m.work_order != nil {
		edges = append(edges, file.EdgeWorkOrder)
	}
	if m.checklist_item != nil {
		edges = append(edges, file.EdgeChecklistItem)
	}
	if m.survey != nil {
		edges = append(edges, file.EdgeSurvey)
	}
	if m.floor_plan != nil {
		edges = append(edges, file.EdgeFloorPlan)
	}
	if m.photo_survey_question != nil {
		edges = append(edges, file.EdgePhotoSurveyQuestion)
	}
	if m.survey_question != nil {
		edges = append(edges, file.EdgeSurveyQuestion)
	}
	if m.document_category != nil {
		edges = append(edges, file.EdgeDocumentCategory)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeChecklistItem:
		if id := m.checklist_item; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeFloorPlan:
		if id := m.floor_plan; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgePhotoSurveyQuestion:
		if id := m.photo_survey_question; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeSurveyQuestion:
		if id := m.survey_question; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeDocumentCategory:
		if id := m.document_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedlocation {
		edges = append(edges, file.EdgeLocation)
	}
	if m.clearedequipment {
		edges = append(edges, file.EdgeEquipment)
	}
	if m.cleareduser {
		edges = append(edges, file.EdgeUser)
	}
	if m.clearedwork_order {
		edges = append(edges, file.EdgeWorkOrder)
	}
	if m.clearedchecklist_item {
		edges = append(edges, file.EdgeChecklistItem)
	}
	if m.clearedsurvey {
		edges = append(edges, file.EdgeSurvey)
	}
	if m.clearedfloor_plan {
		edges = append(edges, file.EdgeFloorPlan)
	}
	if m.clearedphoto_survey_question {
		edges = append(edges, file.EdgePhotoSurveyQuestion)
	}
	if m.clearedsurvey_question {
		edges = append(edges, file.EdgeSurveyQuestion)
	}
	if m.cleareddocument_category {
		edges = append(edges, file.EdgeDocumentCategory)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeLocation:
		return m.clearedlocation
	case file.EdgeEquipment:
		return m.clearedequipment
	case file.EdgeUser:
		return m.cleareduser
	case file.EdgeWorkOrder:
		return m.clearedwork_order
	case file.EdgeChecklistItem:
		return m.clearedchecklist_item
	case file.EdgeSurvey:
		return m.clearedsurvey
	case file.EdgeFloorPlan:
		return m.clearedfloor_plan
	case file.EdgePhotoSurveyQuestion:
		return m.clearedphoto_survey_question
	case file.EdgeSurveyQuestion:
		return m.clearedsurvey_question
	case file.EdgeDocumentCategory:
		return m.cleareddocument_category
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeLocation:
		m.ClearLocation()
		return nil
	case file.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case file.EdgeUser:
		m.ClearUser()
		return nil
	case file.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	case file.EdgeChecklistItem:
		m.ClearChecklistItem()
		return nil
	case file.EdgeSurvey:
		m.ClearSurvey()
		return nil
	case file.EdgeFloorPlan:
		m.ClearFloorPlan()
		return nil
	case file.EdgePhotoSurveyQuestion:
		m.ClearPhotoSurveyQuestion()
		return nil
	case file.EdgeSurveyQuestion:
		m.ClearSurveyQuestion()
		return nil
	case file.EdgeDocumentCategory:
		m.ClearDocumentCategory()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeLocation:
		m.ResetLocation()
		return nil
	case file.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case file.EdgeUser:
		m.ResetUser()
		return nil
	case file.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	case file.EdgeChecklistItem:
		m.ResetChecklistItem()
		return nil
	case file.EdgeSurvey:
		m.ResetSurvey()
		return nil
	case file.EdgeFloorPlan:
		m.ResetFloorPlan()
		return nil
	case file.EdgePhotoSurveyQuestion:
		m.ResetPhotoSurveyQuestion()
		return nil
	case file.EdgeSurveyQuestion:
		m.ResetSurveyQuestion()
		return nil
	case file.EdgeDocumentCategory:
		m.ResetDocumentCategory()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FloorPlanMutation represents an operation that mutate the FloorPlans
// nodes in the graph.
type FloorPlanMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	name                   *string
	clearedFields          map[string]struct{}
	location               *int
	clearedlocation        bool
	reference_point        *int
	clearedreference_point bool
	scale                  *int
	clearedscale           bool
	image                  *int
	clearedimage           bool
	done                   bool
	oldValue               func(context.Context) (*FloorPlan, error)
	predicates             []predicate.FloorPlan
}

var _ ent.Mutation = (*FloorPlanMutation)(nil)

// floorplanOption allows to manage the mutation configuration using functional options.
type floorplanOption func(*FloorPlanMutation)

// newFloorPlanMutation creates new mutation for FloorPlan.
func newFloorPlanMutation(c config, op Op, opts ...floorplanOption) *FloorPlanMutation {
	m := &FloorPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeFloorPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFloorPlanID sets the id field of the mutation.
func withFloorPlanID(id int) floorplanOption {
	return func(m *FloorPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *FloorPlan
		)
		m.oldValue = func(ctx context.Context) (*FloorPlan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FloorPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFloorPlan sets the old FloorPlan of the mutation.
func withFloorPlan(node *FloorPlan) floorplanOption {
	return func(m *FloorPlanMutation) {
		m.oldValue = func(context.Context) (*FloorPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FloorPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FloorPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FloorPlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FloorPlanMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FloorPlanMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the FloorPlan.
// If the FloorPlan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FloorPlanMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FloorPlanMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FloorPlanMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the FloorPlan.
// If the FloorPlan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FloorPlanMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *FloorPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FloorPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the FloorPlan.
// If the FloorPlan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FloorPlanMutation) ResetName() {
	m.name = nil
}

// SetLocationID sets the location edge to Location by id.
func (m *FloorPlanMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *FloorPlanMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *FloorPlanMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *FloorPlanMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *FloorPlanMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *FloorPlanMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetReferencePointID sets the reference_point edge to FloorPlanReferencePoint by id.
func (m *FloorPlanMutation) SetReferencePointID(id int) {
	m.reference_point = &id
}

// ClearReferencePoint clears the reference_point edge to FloorPlanReferencePoint.
func (m *FloorPlanMutation) ClearReferencePoint() {
	m.clearedreference_point = true
}

// ReferencePointCleared returns if the edge reference_point was cleared.
func (m *FloorPlanMutation) ReferencePointCleared() bool {
	return m.clearedreference_point
}

// ReferencePointID returns the reference_point id in the mutation.
func (m *FloorPlanMutation) ReferencePointID() (id int, exists bool) {
	if m.reference_point != nil {
		return *m.reference_point, true
	}
	return
}

// ReferencePointIDs returns the reference_point ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ReferencePointID instead. It exists only for internal usage by the builders.
func (m *FloorPlanMutation) ReferencePointIDs() (ids []int) {
	if id := m.reference_point; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferencePoint reset all changes of the "reference_point" edge.
func (m *FloorPlanMutation) ResetReferencePoint() {
	m.reference_point = nil
	m.clearedreference_point = false
}

// SetScaleID sets the scale edge to FloorPlanScale by id.
func (m *FloorPlanMutation) SetScaleID(id int) {
	m.scale = &id
}

// ClearScale clears the scale edge to FloorPlanScale.
func (m *FloorPlanMutation) ClearScale() {
	m.clearedscale = true
}

// ScaleCleared returns if the edge scale was cleared.
func (m *FloorPlanMutation) ScaleCleared() bool {
	return m.clearedscale
}

// ScaleID returns the scale id in the mutation.
func (m *FloorPlanMutation) ScaleID() (id int, exists bool) {
	if m.scale != nil {
		return *m.scale, true
	}
	return
}

// ScaleIDs returns the scale ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ScaleID instead. It exists only for internal usage by the builders.
func (m *FloorPlanMutation) ScaleIDs() (ids []int) {
	if id := m.scale; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScale reset all changes of the "scale" edge.
func (m *FloorPlanMutation) ResetScale() {
	m.scale = nil
	m.clearedscale = false
}

// SetImageID sets the image edge to File by id.
func (m *FloorPlanMutation) SetImageID(id int) {
	m.image = &id
}

// ClearImage clears the image edge to File.
func (m *FloorPlanMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared returns if the edge image was cleared.
func (m *FloorPlanMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the image id in the mutation.
func (m *FloorPlanMutation) ImageID() (id int, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the image ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *FloorPlanMutation) ImageIDs() (ids []int) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage reset all changes of the "image" edge.
func (m *FloorPlanMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// Op returns the operation name.
func (m *FloorPlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FloorPlan).
func (m *FloorPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FloorPlanMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, floorplan.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, floorplan.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, floorplan.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FloorPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case floorplan.FieldCreateTime:
		return m.CreateTime()
	case floorplan.FieldUpdateTime:
		return m.UpdateTime()
	case floorplan.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FloorPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case floorplan.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case floorplan.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case floorplan.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown FloorPlan field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FloorPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case floorplan.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case floorplan.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case floorplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown FloorPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FloorPlanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FloorPlanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FloorPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FloorPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FloorPlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FloorPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FloorPlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FloorPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FloorPlanMutation) ResetField(name string) error {
	switch name {
	case floorplan.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case floorplan.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case floorplan.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown FloorPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FloorPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.location != nil {
		edges = append(edges, floorplan.EdgeLocation)
	}
	if m.reference_point != nil {
		edges = append(edges, floorplan.EdgeReferencePoint)
	}
	if m.scale != nil {
		edges = append(edges, floorplan.EdgeScale)
	}
	if m.image != nil {
		edges = append(edges, floorplan.EdgeImage)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FloorPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case floorplan.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case floorplan.EdgeReferencePoint:
		if id := m.reference_point; id != nil {
			return []ent.Value{*id}
		}
	case floorplan.EdgeScale:
		if id := m.scale; id != nil {
			return []ent.Value{*id}
		}
	case floorplan.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FloorPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FloorPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FloorPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedlocation {
		edges = append(edges, floorplan.EdgeLocation)
	}
	if m.clearedreference_point {
		edges = append(edges, floorplan.EdgeReferencePoint)
	}
	if m.clearedscale {
		edges = append(edges, floorplan.EdgeScale)
	}
	if m.clearedimage {
		edges = append(edges, floorplan.EdgeImage)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FloorPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case floorplan.EdgeLocation:
		return m.clearedlocation
	case floorplan.EdgeReferencePoint:
		return m.clearedreference_point
	case floorplan.EdgeScale:
		return m.clearedscale
	case floorplan.EdgeImage:
		return m.clearedimage
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FloorPlanMutation) ClearEdge(name string) error {
	switch name {
	case floorplan.EdgeLocation:
		m.ClearLocation()
		return nil
	case floorplan.EdgeReferencePoint:
		m.ClearReferencePoint()
		return nil
	case floorplan.EdgeScale:
		m.ClearScale()
		return nil
	case floorplan.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown FloorPlan unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FloorPlanMutation) ResetEdge(name string) error {
	switch name {
	case floorplan.EdgeLocation:
		m.ResetLocation()
		return nil
	case floorplan.EdgeReferencePoint:
		m.ResetReferencePoint()
		return nil
	case floorplan.EdgeScale:
		m.ResetScale()
		return nil
	case floorplan.EdgeImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown FloorPlan edge %s", name)
}

// FloorPlanReferencePointMutation represents an operation that mutate the FloorPlanReferencePoints
// nodes in the graph.
type FloorPlanReferencePointMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	x             *int
	addx          *int
	y             *int
	addy          *int
	latitude      *float64
	addlatitude   *float64
	longitude     *float64
	addlongitude  *float64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FloorPlanReferencePoint, error)
	predicates    []predicate.FloorPlanReferencePoint
}

var _ ent.Mutation = (*FloorPlanReferencePointMutation)(nil)

// floorplanreferencepointOption allows to manage the mutation configuration using functional options.
type floorplanreferencepointOption func(*FloorPlanReferencePointMutation)

// newFloorPlanReferencePointMutation creates new mutation for FloorPlanReferencePoint.
func newFloorPlanReferencePointMutation(c config, op Op, opts ...floorplanreferencepointOption) *FloorPlanReferencePointMutation {
	m := &FloorPlanReferencePointMutation{
		config:        c,
		op:            op,
		typ:           TypeFloorPlanReferencePoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFloorPlanReferencePointID sets the id field of the mutation.
func withFloorPlanReferencePointID(id int) floorplanreferencepointOption {
	return func(m *FloorPlanReferencePointMutation) {
		var (
			err   error
			once  sync.Once
			value *FloorPlanReferencePoint
		)
		m.oldValue = func(ctx context.Context) (*FloorPlanReferencePoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FloorPlanReferencePoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFloorPlanReferencePoint sets the old FloorPlanReferencePoint of the mutation.
func withFloorPlanReferencePoint(node *FloorPlanReferencePoint) floorplanreferencepointOption {
	return func(m *FloorPlanReferencePointMutation) {
		m.oldValue = func(context.Context) (*FloorPlanReferencePoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FloorPlanReferencePointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FloorPlanReferencePointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FloorPlanReferencePointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FloorPlanReferencePointMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FloorPlanReferencePointMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the FloorPlanReferencePoint.
// If the FloorPlanReferencePoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanReferencePointMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FloorPlanReferencePointMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FloorPlanReferencePointMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FloorPlanReferencePointMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the FloorPlanReferencePoint.
// If the FloorPlanReferencePoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanReferencePointMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FloorPlanReferencePointMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetX sets the x field.
func (m *FloorPlanReferencePointMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the x value in the mutation.
func (m *FloorPlanReferencePointMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old x value of the FloorPlanReferencePoint.
// If the FloorPlanReferencePoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanReferencePointMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldX is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to x.
func (m *FloorPlanReferencePointMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the x field in this mutation.
func (m *FloorPlanReferencePointMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX reset all changes of the "x" field.
func (m *FloorPlanReferencePointMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the y field.
func (m *FloorPlanReferencePointMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the y value in the mutation.
func (m *FloorPlanReferencePointMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old y value of the FloorPlanReferencePoint.
// If the FloorPlanReferencePoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanReferencePointMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to y.
func (m *FloorPlanReferencePointMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the y field in this mutation.
func (m *FloorPlanReferencePointMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY reset all changes of the "y" field.
func (m *FloorPlanReferencePointMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetLatitude sets the latitude field.
func (m *FloorPlanReferencePointMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the latitude value in the mutation.
func (m *FloorPlanReferencePointMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old latitude value of the FloorPlanReferencePoint.
// If the FloorPlanReferencePoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanReferencePointMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to latitude.
func (m *FloorPlanReferencePointMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the latitude field in this mutation.
func (m *FloorPlanReferencePointMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude reset all changes of the "latitude" field.
func (m *FloorPlanReferencePointMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the longitude field.
func (m *FloorPlanReferencePointMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the longitude value in the mutation.
func (m *FloorPlanReferencePointMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old longitude value of the FloorPlanReferencePoint.
// If the FloorPlanReferencePoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanReferencePointMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to longitude.
func (m *FloorPlanReferencePointMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the longitude field in this mutation.
func (m *FloorPlanReferencePointMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude reset all changes of the "longitude" field.
func (m *FloorPlanReferencePointMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// Op returns the operation name.
func (m *FloorPlanReferencePointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FloorPlanReferencePoint).
func (m *FloorPlanReferencePointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FloorPlanReferencePointMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, floorplanreferencepoint.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, floorplanreferencepoint.FieldUpdateTime)
	}
	if m.x != nil {
		fields = append(fields, floorplanreferencepoint.FieldX)
	}
	if m.y != nil {
		fields = append(fields, floorplanreferencepoint.FieldY)
	}
	if m.latitude != nil {
		fields = append(fields, floorplanreferencepoint.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, floorplanreferencepoint.FieldLongitude)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FloorPlanReferencePointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case floorplanreferencepoint.FieldCreateTime:
		return m.CreateTime()
	case floorplanreferencepoint.FieldUpdateTime:
		return m.UpdateTime()
	case floorplanreferencepoint.FieldX:
		return m.X()
	case floorplanreferencepoint.FieldY:
		return m.Y()
	case floorplanreferencepoint.FieldLatitude:
		return m.Latitude()
	case floorplanreferencepoint.FieldLongitude:
		return m.Longitude()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FloorPlanReferencePointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case floorplanreferencepoint.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case floorplanreferencepoint.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case floorplanreferencepoint.FieldX:
		return m.OldX(ctx)
	case floorplanreferencepoint.FieldY:
		return m.OldY(ctx)
	case floorplanreferencepoint.FieldLatitude:
		return m.OldLatitude(ctx)
	case floorplanreferencepoint.FieldLongitude:
		return m.OldLongitude(ctx)
	}
	return nil, fmt.Errorf("unknown FloorPlanReferencePoint field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FloorPlanReferencePointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case floorplanreferencepoint.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case floorplanreferencepoint.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case floorplanreferencepoint.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case floorplanreferencepoint.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case floorplanreferencepoint.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case floorplanreferencepoint.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown FloorPlanReferencePoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FloorPlanReferencePointMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, floorplanreferencepoint.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, floorplanreferencepoint.FieldY)
	}
	if m.addlatitude != nil {
		fields = append(fields, floorplanreferencepoint.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, floorplanreferencepoint.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FloorPlanReferencePointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case floorplanreferencepoint.FieldX:
		return m.AddedX()
	case floorplanreferencepoint.FieldY:
		return m.AddedY()
	case floorplanreferencepoint.FieldLatitude:
		return m.AddedLatitude()
	case floorplanreferencepoint.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FloorPlanReferencePointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case floorplanreferencepoint.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case floorplanreferencepoint.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case floorplanreferencepoint.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case floorplanreferencepoint.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown FloorPlanReferencePoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FloorPlanReferencePointMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FloorPlanReferencePointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FloorPlanReferencePointMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FloorPlanReferencePoint nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FloorPlanReferencePointMutation) ResetField(name string) error {
	switch name {
	case floorplanreferencepoint.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case floorplanreferencepoint.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case floorplanreferencepoint.FieldX:
		m.ResetX()
		return nil
	case floorplanreferencepoint.FieldY:
		m.ResetY()
		return nil
	case floorplanreferencepoint.FieldLatitude:
		m.ResetLatitude()
		return nil
	case floorplanreferencepoint.FieldLongitude:
		m.ResetLongitude()
		return nil
	}
	return fmt.Errorf("unknown FloorPlanReferencePoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FloorPlanReferencePointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FloorPlanReferencePointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FloorPlanReferencePointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FloorPlanReferencePointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FloorPlanReferencePointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FloorPlanReferencePointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FloorPlanReferencePointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FloorPlanReferencePoint unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FloorPlanReferencePointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FloorPlanReferencePoint edge %s", name)
}

// FloorPlanScaleMutation represents an operation that mutate the FloorPlanScales
// nodes in the graph.
type FloorPlanScaleMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	reference_point1_x    *int
	addreference_point1_x *int
	reference_point1_y    *int
	addreference_point1_y *int
	reference_point2_x    *int
	addreference_point2_x *int
	reference_point2_y    *int
	addreference_point2_y *int
	scale_in_meters       *float64
	addscale_in_meters    *float64
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*FloorPlanScale, error)
	predicates            []predicate.FloorPlanScale
}

var _ ent.Mutation = (*FloorPlanScaleMutation)(nil)

// floorplanscaleOption allows to manage the mutation configuration using functional options.
type floorplanscaleOption func(*FloorPlanScaleMutation)

// newFloorPlanScaleMutation creates new mutation for FloorPlanScale.
func newFloorPlanScaleMutation(c config, op Op, opts ...floorplanscaleOption) *FloorPlanScaleMutation {
	m := &FloorPlanScaleMutation{
		config:        c,
		op:            op,
		typ:           TypeFloorPlanScale,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFloorPlanScaleID sets the id field of the mutation.
func withFloorPlanScaleID(id int) floorplanscaleOption {
	return func(m *FloorPlanScaleMutation) {
		var (
			err   error
			once  sync.Once
			value *FloorPlanScale
		)
		m.oldValue = func(ctx context.Context) (*FloorPlanScale, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FloorPlanScale.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFloorPlanScale sets the old FloorPlanScale of the mutation.
func withFloorPlanScale(node *FloorPlanScale) floorplanscaleOption {
	return func(m *FloorPlanScaleMutation) {
		m.oldValue = func(context.Context) (*FloorPlanScale, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FloorPlanScaleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FloorPlanScaleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FloorPlanScaleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FloorPlanScaleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FloorPlanScaleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the FloorPlanScale.
// If the FloorPlanScale object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanScaleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FloorPlanScaleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FloorPlanScaleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FloorPlanScaleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the FloorPlanScale.
// If the FloorPlanScale object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanScaleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FloorPlanScaleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetReferencePoint1X sets the reference_point1_x field.
func (m *FloorPlanScaleMutation) SetReferencePoint1X(i int) {
	m.reference_point1_x = &i
	m.addreference_point1_x = nil
}

// ReferencePoint1X returns the reference_point1_x value in the mutation.
func (m *FloorPlanScaleMutation) ReferencePoint1X() (r int, exists bool) {
	v := m.reference_point1_x
	if v == nil {
		return
	}
	return *v, true
}

// OldReferencePoint1X returns the old reference_point1_x value of the FloorPlanScale.
// If the FloorPlanScale object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanScaleMutation) OldReferencePoint1X(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReferencePoint1X is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReferencePoint1X requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferencePoint1X: %w", err)
	}
	return oldValue.ReferencePoint1X, nil
}

// AddReferencePoint1X adds i to reference_point1_x.
func (m *FloorPlanScaleMutation) AddReferencePoint1X(i int) {
	if m.addreference_point1_x != nil {
		*m.addreference_point1_x += i
	} else {
		m.addreference_point1_x = &i
	}
}

// AddedReferencePoint1X returns the value that was added to the reference_point1_x field in this mutation.
func (m *FloorPlanScaleMutation) AddedReferencePoint1X() (r int, exists bool) {
	v := m.addreference_point1_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferencePoint1X reset all changes of the "reference_point1_x" field.
func (m *FloorPlanScaleMutation) ResetReferencePoint1X() {
	m.reference_point1_x = nil
	m.addreference_point1_x = nil
}

// SetReferencePoint1Y sets the reference_point1_y field.
func (m *FloorPlanScaleMutation) SetReferencePoint1Y(i int) {
	m.reference_point1_y = &i
	m.addreference_point1_y = nil
}

// ReferencePoint1Y returns the reference_point1_y value in the mutation.
func (m *FloorPlanScaleMutation) ReferencePoint1Y() (r int, exists bool) {
	v := m.reference_point1_y
	if v == nil {
		return
	}
	return *v, true
}

// OldReferencePoint1Y returns the old reference_point1_y value of the FloorPlanScale.
// If the FloorPlanScale object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanScaleMutation) OldReferencePoint1Y(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReferencePoint1Y is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReferencePoint1Y requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferencePoint1Y: %w", err)
	}
	return oldValue.ReferencePoint1Y, nil
}

// AddReferencePoint1Y adds i to reference_point1_y.
func (m *FloorPlanScaleMutation) AddReferencePoint1Y(i int) {
	if m.addreference_point1_y != nil {
		*m.addreference_point1_y += i
	} else {
		m.addreference_point1_y = &i
	}
}

// AddedReferencePoint1Y returns the value that was added to the reference_point1_y field in this mutation.
func (m *FloorPlanScaleMutation) AddedReferencePoint1Y() (r int, exists bool) {
	v := m.addreference_point1_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferencePoint1Y reset all changes of the "reference_point1_y" field.
func (m *FloorPlanScaleMutation) ResetReferencePoint1Y() {
	m.reference_point1_y = nil
	m.addreference_point1_y = nil
}

// SetReferencePoint2X sets the reference_point2_x field.
func (m *FloorPlanScaleMutation) SetReferencePoint2X(i int) {
	m.reference_point2_x = &i
	m.addreference_point2_x = nil
}

// ReferencePoint2X returns the reference_point2_x value in the mutation.
func (m *FloorPlanScaleMutation) ReferencePoint2X() (r int, exists bool) {
	v := m.reference_point2_x
	if v == nil {
		return
	}
	return *v, true
}

// OldReferencePoint2X returns the old reference_point2_x value of the FloorPlanScale.
// If the FloorPlanScale object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanScaleMutation) OldReferencePoint2X(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReferencePoint2X is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReferencePoint2X requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferencePoint2X: %w", err)
	}
	return oldValue.ReferencePoint2X, nil
}

// AddReferencePoint2X adds i to reference_point2_x.
func (m *FloorPlanScaleMutation) AddReferencePoint2X(i int) {
	if m.addreference_point2_x != nil {
		*m.addreference_point2_x += i
	} else {
		m.addreference_point2_x = &i
	}
}

// AddedReferencePoint2X returns the value that was added to the reference_point2_x field in this mutation.
func (m *FloorPlanScaleMutation) AddedReferencePoint2X() (r int, exists bool) {
	v := m.addreference_point2_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferencePoint2X reset all changes of the "reference_point2_x" field.
func (m *FloorPlanScaleMutation) ResetReferencePoint2X() {
	m.reference_point2_x = nil
	m.addreference_point2_x = nil
}

// SetReferencePoint2Y sets the reference_point2_y field.
func (m *FloorPlanScaleMutation) SetReferencePoint2Y(i int) {
	m.reference_point2_y = &i
	m.addreference_point2_y = nil
}

// ReferencePoint2Y returns the reference_point2_y value in the mutation.
func (m *FloorPlanScaleMutation) ReferencePoint2Y() (r int, exists bool) {
	v := m.reference_point2_y
	if v == nil {
		return
	}
	return *v, true
}

// OldReferencePoint2Y returns the old reference_point2_y value of the FloorPlanScale.
// If the FloorPlanScale object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanScaleMutation) OldReferencePoint2Y(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReferencePoint2Y is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReferencePoint2Y requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferencePoint2Y: %w", err)
	}
	return oldValue.ReferencePoint2Y, nil
}

// AddReferencePoint2Y adds i to reference_point2_y.
func (m *FloorPlanScaleMutation) AddReferencePoint2Y(i int) {
	if m.addreference_point2_y != nil {
		*m.addreference_point2_y += i
	} else {
		m.addreference_point2_y = &i
	}
}

// AddedReferencePoint2Y returns the value that was added to the reference_point2_y field in this mutation.
func (m *FloorPlanScaleMutation) AddedReferencePoint2Y() (r int, exists bool) {
	v := m.addreference_point2_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferencePoint2Y reset all changes of the "reference_point2_y" field.
func (m *FloorPlanScaleMutation) ResetReferencePoint2Y() {
	m.reference_point2_y = nil
	m.addreference_point2_y = nil
}

// SetScaleInMeters sets the scale_in_meters field.
func (m *FloorPlanScaleMutation) SetScaleInMeters(f float64) {
	m.scale_in_meters = &f
	m.addscale_in_meters = nil
}

// ScaleInMeters returns the scale_in_meters value in the mutation.
func (m *FloorPlanScaleMutation) ScaleInMeters() (r float64, exists bool) {
	v := m.scale_in_meters
	if v == nil {
		return
	}
	return *v, true
}

// OldScaleInMeters returns the old scale_in_meters value of the FloorPlanScale.
// If the FloorPlanScale object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FloorPlanScaleMutation) OldScaleInMeters(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScaleInMeters is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScaleInMeters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScaleInMeters: %w", err)
	}
	return oldValue.ScaleInMeters, nil
}

// AddScaleInMeters adds f to scale_in_meters.
func (m *FloorPlanScaleMutation) AddScaleInMeters(f float64) {
	if m.addscale_in_meters != nil {
		*m.addscale_in_meters += f
	} else {
		m.addscale_in_meters = &f
	}
}

// AddedScaleInMeters returns the value that was added to the scale_in_meters field in this mutation.
func (m *FloorPlanScaleMutation) AddedScaleInMeters() (r float64, exists bool) {
	v := m.addscale_in_meters
	if v == nil {
		return
	}
	return *v, true
}

// ResetScaleInMeters reset all changes of the "scale_in_meters" field.
func (m *FloorPlanScaleMutation) ResetScaleInMeters() {
	m.scale_in_meters = nil
	m.addscale_in_meters = nil
}

// Op returns the operation name.
func (m *FloorPlanScaleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FloorPlanScale).
func (m *FloorPlanScaleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FloorPlanScaleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, floorplanscale.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, floorplanscale.FieldUpdateTime)
	}
	if m.reference_point1_x != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint1X)
	}
	if m.reference_point1_y != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint1Y)
	}
	if m.reference_point2_x != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint2X)
	}
	if m.reference_point2_y != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint2Y)
	}
	if m.scale_in_meters != nil {
		fields = append(fields, floorplanscale.FieldScaleInMeters)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FloorPlanScaleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case floorplanscale.FieldCreateTime:
		return m.CreateTime()
	case floorplanscale.FieldUpdateTime:
		return m.UpdateTime()
	case floorplanscale.FieldReferencePoint1X:
		return m.ReferencePoint1X()
	case floorplanscale.FieldReferencePoint1Y:
		return m.ReferencePoint1Y()
	case floorplanscale.FieldReferencePoint2X:
		return m.ReferencePoint2X()
	case floorplanscale.FieldReferencePoint2Y:
		return m.ReferencePoint2Y()
	case floorplanscale.FieldScaleInMeters:
		return m.ScaleInMeters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FloorPlanScaleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case floorplanscale.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case floorplanscale.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case floorplanscale.FieldReferencePoint1X:
		return m.OldReferencePoint1X(ctx)
	case floorplanscale.FieldReferencePoint1Y:
		return m.OldReferencePoint1Y(ctx)
	case floorplanscale.FieldReferencePoint2X:
		return m.OldReferencePoint2X(ctx)
	case floorplanscale.FieldReferencePoint2Y:
		return m.OldReferencePoint2Y(ctx)
	case floorplanscale.FieldScaleInMeters:
		return m.OldScaleInMeters(ctx)
	}
	return nil, fmt.Errorf("unknown FloorPlanScale field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FloorPlanScaleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case floorplanscale.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case floorplanscale.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case floorplanscale.FieldReferencePoint1X:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferencePoint1X(v)
		return nil
	case floorplanscale.FieldReferencePoint1Y:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferencePoint1Y(v)
		return nil
	case floorplanscale.FieldReferencePoint2X:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferencePoint2X(v)
		return nil
	case floorplanscale.FieldReferencePoint2Y:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferencePoint2Y(v)
		return nil
	case floorplanscale.FieldScaleInMeters:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScaleInMeters(v)
		return nil
	}
	return fmt.Errorf("unknown FloorPlanScale field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FloorPlanScaleMutation) AddedFields() []string {
	var fields []string
	if m.addreference_point1_x != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint1X)
	}
	if m.addreference_point1_y != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint1Y)
	}
	if m.addreference_point2_x != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint2X)
	}
	if m.addreference_point2_y != nil {
		fields = append(fields, floorplanscale.FieldReferencePoint2Y)
	}
	if m.addscale_in_meters != nil {
		fields = append(fields, floorplanscale.FieldScaleInMeters)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FloorPlanScaleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case floorplanscale.FieldReferencePoint1X:
		return m.AddedReferencePoint1X()
	case floorplanscale.FieldReferencePoint1Y:
		return m.AddedReferencePoint1Y()
	case floorplanscale.FieldReferencePoint2X:
		return m.AddedReferencePoint2X()
	case floorplanscale.FieldReferencePoint2Y:
		return m.AddedReferencePoint2Y()
	case floorplanscale.FieldScaleInMeters:
		return m.AddedScaleInMeters()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FloorPlanScaleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case floorplanscale.FieldReferencePoint1X:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferencePoint1X(v)
		return nil
	case floorplanscale.FieldReferencePoint1Y:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferencePoint1Y(v)
		return nil
	case floorplanscale.FieldReferencePoint2X:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferencePoint2X(v)
		return nil
	case floorplanscale.FieldReferencePoint2Y:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferencePoint2Y(v)
		return nil
	case floorplanscale.FieldScaleInMeters:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScaleInMeters(v)
		return nil
	}
	return fmt.Errorf("unknown FloorPlanScale numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FloorPlanScaleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FloorPlanScaleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FloorPlanScaleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FloorPlanScale nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FloorPlanScaleMutation) ResetField(name string) error {
	switch name {
	case floorplanscale.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case floorplanscale.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case floorplanscale.FieldReferencePoint1X:
		m.ResetReferencePoint1X()
		return nil
	case floorplanscale.FieldReferencePoint1Y:
		m.ResetReferencePoint1Y()
		return nil
	case floorplanscale.FieldReferencePoint2X:
		m.ResetReferencePoint2X()
		return nil
	case floorplanscale.FieldReferencePoint2Y:
		m.ResetReferencePoint2Y()
		return nil
	case floorplanscale.FieldScaleInMeters:
		m.ResetScaleInMeters()
		return nil
	}
	return fmt.Errorf("unknown FloorPlanScale field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FloorPlanScaleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FloorPlanScaleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FloorPlanScaleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FloorPlanScaleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FloorPlanScaleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FloorPlanScaleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FloorPlanScaleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FloorPlanScale unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FloorPlanScaleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FloorPlanScale edge %s", name)
}

// FlowMutation represents an operation that mutate the Flows
// nodes in the graph.
type FlowMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	description           *string
	end_param_definitions *[]*flowschema.VariableDefinition
	status                *flow.Status
	newInstancesPolicy    *flow.NewInstancesPolicy
	clearedFields         map[string]struct{}
	blocks                map[int]struct{}
	removedblocks         map[int]struct{}
	clearedblocks         bool
	draft                 *int
	cleareddraft          bool
	done                  bool
	oldValue              func(context.Context) (*Flow, error)
	predicates            []predicate.Flow
}

var _ ent.Mutation = (*FlowMutation)(nil)

// flowOption allows to manage the mutation configuration using functional options.
type flowOption func(*FlowMutation)

// newFlowMutation creates new mutation for Flow.
func newFlowMutation(c config, op Op, opts ...flowOption) *FlowMutation {
	m := &FlowMutation{
		config:        c,
		op:            op,
		typ:           TypeFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowID sets the id field of the mutation.
func withFlowID(id int) flowOption {
	return func(m *FlowMutation) {
		var (
			err   error
			once  sync.Once
			value *Flow
		)
		m.oldValue = func(ctx context.Context) (*Flow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Flow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlow sets the old Flow of the mutation.
func withFlow(node *Flow) flowOption {
	return func(m *FlowMutation) {
		m.oldValue = func(context.Context) (*Flow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FlowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FlowMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FlowMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Flow.
// If the Flow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FlowMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FlowMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FlowMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Flow.
// If the Flow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FlowMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *FlowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FlowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Flow.
// If the Flow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FlowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *FlowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *FlowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Flow.
// If the Flow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *FlowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[flow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *FlowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[flow.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *FlowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, flow.FieldDescription)
}

// SetEndParamDefinitions sets the end_param_definitions field.
func (m *FlowMutation) SetEndParamDefinitions(fd []*flowschema.VariableDefinition) {
	m.end_param_definitions = &fd
}

// EndParamDefinitions returns the end_param_definitions value in the mutation.
func (m *FlowMutation) EndParamDefinitions() (r []*flowschema.VariableDefinition, exists bool) {
	v := m.end_param_definitions
	if v == nil {
		return
	}
	return *v, true
}

// OldEndParamDefinitions returns the old end_param_definitions value of the Flow.
// If the Flow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowMutation) OldEndParamDefinitions(ctx context.Context) (v []*flowschema.VariableDefinition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndParamDefinitions is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndParamDefinitions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndParamDefinitions: %w", err)
	}
	return oldValue.EndParamDefinitions, nil
}

// ClearEndParamDefinitions clears the value of end_param_definitions.
func (m *FlowMutation) ClearEndParamDefinitions() {
	m.end_param_definitions = nil
	m.clearedFields[flow.FieldEndParamDefinitions] = struct{}{}
}

// EndParamDefinitionsCleared returns if the field end_param_definitions was cleared in this mutation.
func (m *FlowMutation) EndParamDefinitionsCleared() bool {
	_, ok := m.clearedFields[flow.FieldEndParamDefinitions]
	return ok
}

// ResetEndParamDefinitions reset all changes of the "end_param_definitions" field.
func (m *FlowMutation) ResetEndParamDefinitions() {
	m.end_param_definitions = nil
	delete(m.clearedFields, flow.FieldEndParamDefinitions)
}

// SetStatus sets the status field.
func (m *FlowMutation) SetStatus(f flow.Status) {
	m.status = &f
}

// Status returns the status value in the mutation.
func (m *FlowMutation) Status() (r flow.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Flow.
// If the Flow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowMutation) OldStatus(ctx context.Context) (v flow.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *FlowMutation) ResetStatus() {
	m.status = nil
}

// SetNewInstancesPolicy sets the newInstancesPolicy field.
func (m *FlowMutation) SetNewInstancesPolicy(fip flow.NewInstancesPolicy) {
	m.newInstancesPolicy = &fip
}

// NewInstancesPolicy returns the newInstancesPolicy value in the mutation.
func (m *FlowMutation) NewInstancesPolicy() (r flow.NewInstancesPolicy, exists bool) {
	v := m.newInstancesPolicy
	if v == nil {
		return
	}
	return *v, true
}

// OldNewInstancesPolicy returns the old newInstancesPolicy value of the Flow.
// If the Flow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowMutation) OldNewInstancesPolicy(ctx context.Context) (v flow.NewInstancesPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNewInstancesPolicy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNewInstancesPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewInstancesPolicy: %w", err)
	}
	return oldValue.NewInstancesPolicy, nil
}

// ResetNewInstancesPolicy reset all changes of the "newInstancesPolicy" field.
func (m *FlowMutation) ResetNewInstancesPolicy() {
	m.newInstancesPolicy = nil
}

// AddBlockIDs adds the blocks edge to Block by ids.
func (m *FlowMutation) AddBlockIDs(ids ...int) {
	if m.blocks == nil {
		m.blocks = make(map[int]struct{})
	}
	for i := range ids {
		m.blocks[ids[i]] = struct{}{}
	}
}

// ClearBlocks clears the blocks edge to Block.
func (m *FlowMutation) ClearBlocks() {
	m.clearedblocks = true
}

// BlocksCleared returns if the edge blocks was cleared.
func (m *FlowMutation) BlocksCleared() bool {
	return m.clearedblocks
}

// RemoveBlockIDs removes the blocks edge to Block by ids.
func (m *FlowMutation) RemoveBlockIDs(ids ...int) {
	if m.removedblocks == nil {
		m.removedblocks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedblocks[ids[i]] = struct{}{}
	}
}

// RemovedBlocks returns the removed ids of blocks.
func (m *FlowMutation) RemovedBlocksIDs() (ids []int) {
	for id := range m.removedblocks {
		ids = append(ids, id)
	}
	return
}

// BlocksIDs returns the blocks ids in the mutation.
func (m *FlowMutation) BlocksIDs() (ids []int) {
	for id := range m.blocks {
		ids = append(ids, id)
	}
	return
}

// ResetBlocks reset all changes of the "blocks" edge.
func (m *FlowMutation) ResetBlocks() {
	m.blocks = nil
	m.clearedblocks = false
	m.removedblocks = nil
}

// SetDraftID sets the draft edge to FlowDraft by id.
func (m *FlowMutation) SetDraftID(id int) {
	m.draft = &id
}

// ClearDraft clears the draft edge to FlowDraft.
func (m *FlowMutation) ClearDraft() {
	m.cleareddraft = true
}

// DraftCleared returns if the edge draft was cleared.
func (m *FlowMutation) DraftCleared() bool {
	return m.cleareddraft
}

// DraftID returns the draft id in the mutation.
func (m *FlowMutation) DraftID() (id int, exists bool) {
	if m.draft != nil {
		return *m.draft, true
	}
	return
}

// DraftIDs returns the draft ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DraftID instead. It exists only for internal usage by the builders.
func (m *FlowMutation) DraftIDs() (ids []int) {
	if id := m.draft; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDraft reset all changes of the "draft" edge.
func (m *FlowMutation) ResetDraft() {
	m.draft = nil
	m.cleareddraft = false
}

// Op returns the operation name.
func (m *FlowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Flow).
func (m *FlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FlowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, flow.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, flow.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, flow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, flow.FieldDescription)
	}
	if m.end_param_definitions != nil {
		fields = append(fields, flow.FieldEndParamDefinitions)
	}
	if m.status != nil {
		fields = append(fields, flow.FieldStatus)
	}
	if m.newInstancesPolicy != nil {
		fields = append(fields, flow.FieldNewInstancesPolicy)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flow.FieldCreateTime:
		return m.CreateTime()
	case flow.FieldUpdateTime:
		return m.UpdateTime()
	case flow.FieldName:
		return m.Name()
	case flow.FieldDescription:
		return m.Description()
	case flow.FieldEndParamDefinitions:
		return m.EndParamDefinitions()
	case flow.FieldStatus:
		return m.Status()
	case flow.FieldNewInstancesPolicy:
		return m.NewInstancesPolicy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flow.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case flow.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case flow.FieldName:
		return m.OldName(ctx)
	case flow.FieldDescription:
		return m.OldDescription(ctx)
	case flow.FieldEndParamDefinitions:
		return m.OldEndParamDefinitions(ctx)
	case flow.FieldStatus:
		return m.OldStatus(ctx)
	case flow.FieldNewInstancesPolicy:
		return m.OldNewInstancesPolicy(ctx)
	}
	return nil, fmt.Errorf("unknown Flow field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flow.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case flow.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case flow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case flow.FieldEndParamDefinitions:
		v, ok := value.([]*flowschema.VariableDefinition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndParamDefinitions(v)
		return nil
	case flow.FieldStatus:
		v, ok := value.(flow.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flow.FieldNewInstancesPolicy:
		v, ok := value.(flow.NewInstancesPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewInstancesPolicy(v)
		return nil
	}
	return fmt.Errorf("unknown Flow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Flow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flow.FieldDescription) {
		fields = append(fields, flow.FieldDescription)
	}
	if m.FieldCleared(flow.FieldEndParamDefinitions) {
		fields = append(fields, flow.FieldEndParamDefinitions)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowMutation) ClearField(name string) error {
	switch name {
	case flow.FieldDescription:
		m.ClearDescription()
		return nil
	case flow.FieldEndParamDefinitions:
		m.ClearEndParamDefinitions()
		return nil
	}
	return fmt.Errorf("unknown Flow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FlowMutation) ResetField(name string) error {
	switch name {
	case flow.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case flow.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case flow.FieldName:
		m.ResetName()
		return nil
	case flow.FieldDescription:
		m.ResetDescription()
		return nil
	case flow.FieldEndParamDefinitions:
		m.ResetEndParamDefinitions()
		return nil
	case flow.FieldStatus:
		m.ResetStatus()
		return nil
	case flow.FieldNewInstancesPolicy:
		m.ResetNewInstancesPolicy()
		return nil
	}
	return fmt.Errorf("unknown Flow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blocks != nil {
		edges = append(edges, flow.EdgeBlocks)
	}
	if m.draft != nil {
		edges = append(edges, flow.EdgeDraft)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flow.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.blocks))
		for id := range m.blocks {
			ids = append(ids, id)
		}
		return ids
	case flow.EdgeDraft:
		if id := m.draft; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedblocks != nil {
		edges = append(edges, flow.EdgeBlocks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FlowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flow.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.removedblocks))
		for id := range m.removedblocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblocks {
		edges = append(edges, flow.EdgeBlocks)
	}
	if m.cleareddraft {
		edges = append(edges, flow.EdgeDraft)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FlowMutation) EdgeCleared(name string) bool {
	switch name {
	case flow.EdgeBlocks:
		return m.clearedblocks
	case flow.EdgeDraft:
		return m.cleareddraft
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FlowMutation) ClearEdge(name string) error {
	switch name {
	case flow.EdgeDraft:
		m.ClearDraft()
		return nil
	}
	return fmt.Errorf("unknown Flow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FlowMutation) ResetEdge(name string) error {
	switch name {
	case flow.EdgeBlocks:
		m.ResetBlocks()
		return nil
	case flow.EdgeDraft:
		m.ResetDraft()
		return nil
	}
	return fmt.Errorf("unknown Flow edge %s", name)
}

// FlowDraftMutation represents an operation that mutate the FlowDrafts
// nodes in the graph.
type FlowDraftMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	description           *string
	end_param_definitions *[]*flowschema.VariableDefinition
	sameAsFlow            *bool
	clearedFields         map[string]struct{}
	blocks                map[int]struct{}
	removedblocks         map[int]struct{}
	clearedblocks         bool
	flow                  *int
	clearedflow           bool
	done                  bool
	oldValue              func(context.Context) (*FlowDraft, error)
	predicates            []predicate.FlowDraft
}

var _ ent.Mutation = (*FlowDraftMutation)(nil)

// flowdraftOption allows to manage the mutation configuration using functional options.
type flowdraftOption func(*FlowDraftMutation)

// newFlowDraftMutation creates new mutation for FlowDraft.
func newFlowDraftMutation(c config, op Op, opts ...flowdraftOption) *FlowDraftMutation {
	m := &FlowDraftMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowDraft,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowDraftID sets the id field of the mutation.
func withFlowDraftID(id int) flowdraftOption {
	return func(m *FlowDraftMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowDraft
		)
		m.oldValue = func(ctx context.Context) (*FlowDraft, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowDraft.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowDraft sets the old FlowDraft of the mutation.
func withFlowDraft(node *FlowDraft) flowdraftOption {
	return func(m *FlowDraftMutation) {
		m.oldValue = func(context.Context) (*FlowDraft, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowDraftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowDraftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FlowDraftMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FlowDraftMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FlowDraftMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the FlowDraft.
// If the FlowDraft object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowDraftMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FlowDraftMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FlowDraftMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FlowDraftMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the FlowDraft.
// If the FlowDraft object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowDraftMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FlowDraftMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *FlowDraftMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FlowDraftMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the FlowDraft.
// If the FlowDraft object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowDraftMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FlowDraftMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *FlowDraftMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *FlowDraftMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the FlowDraft.
// If the FlowDraft object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowDraftMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *FlowDraftMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[flowdraft.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *FlowDraftMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[flowdraft.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *FlowDraftMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, flowdraft.FieldDescription)
}

// SetEndParamDefinitions sets the end_param_definitions field.
func (m *FlowDraftMutation) SetEndParamDefinitions(fd []*flowschema.VariableDefinition) {
	m.end_param_definitions = &fd
}

// EndParamDefinitions returns the end_param_definitions value in the mutation.
func (m *FlowDraftMutation) EndParamDefinitions() (r []*flowschema.VariableDefinition, exists bool) {
	v := m.end_param_definitions
	if v == nil {
		return
	}
	return *v, true
}

// OldEndParamDefinitions returns the old end_param_definitions value of the FlowDraft.
// If the FlowDraft object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowDraftMutation) OldEndParamDefinitions(ctx context.Context) (v []*flowschema.VariableDefinition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndParamDefinitions is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndParamDefinitions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndParamDefinitions: %w", err)
	}
	return oldValue.EndParamDefinitions, nil
}

// ClearEndParamDefinitions clears the value of end_param_definitions.
func (m *FlowDraftMutation) ClearEndParamDefinitions() {
	m.end_param_definitions = nil
	m.clearedFields[flowdraft.FieldEndParamDefinitions] = struct{}{}
}

// EndParamDefinitionsCleared returns if the field end_param_definitions was cleared in this mutation.
func (m *FlowDraftMutation) EndParamDefinitionsCleared() bool {
	_, ok := m.clearedFields[flowdraft.FieldEndParamDefinitions]
	return ok
}

// ResetEndParamDefinitions reset all changes of the "end_param_definitions" field.
func (m *FlowDraftMutation) ResetEndParamDefinitions() {
	m.end_param_definitions = nil
	delete(m.clearedFields, flowdraft.FieldEndParamDefinitions)
}

// SetSameAsFlow sets the sameAsFlow field.
func (m *FlowDraftMutation) SetSameAsFlow(b bool) {
	m.sameAsFlow = &b
}

// SameAsFlow returns the sameAsFlow value in the mutation.
func (m *FlowDraftMutation) SameAsFlow() (r bool, exists bool) {
	v := m.sameAsFlow
	if v == nil {
		return
	}
	return *v, true
}

// OldSameAsFlow returns the old sameAsFlow value of the FlowDraft.
// If the FlowDraft object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowDraftMutation) OldSameAsFlow(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSameAsFlow is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSameAsFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSameAsFlow: %w", err)
	}
	return oldValue.SameAsFlow, nil
}

// ResetSameAsFlow reset all changes of the "sameAsFlow" field.
func (m *FlowDraftMutation) ResetSameAsFlow() {
	m.sameAsFlow = nil
}

// AddBlockIDs adds the blocks edge to Block by ids.
func (m *FlowDraftMutation) AddBlockIDs(ids ...int) {
	if m.blocks == nil {
		m.blocks = make(map[int]struct{})
	}
	for i := range ids {
		m.blocks[ids[i]] = struct{}{}
	}
}

// ClearBlocks clears the blocks edge to Block.
func (m *FlowDraftMutation) ClearBlocks() {
	m.clearedblocks = true
}

// BlocksCleared returns if the edge blocks was cleared.
func (m *FlowDraftMutation) BlocksCleared() bool {
	return m.clearedblocks
}

// RemoveBlockIDs removes the blocks edge to Block by ids.
func (m *FlowDraftMutation) RemoveBlockIDs(ids ...int) {
	if m.removedblocks == nil {
		m.removedblocks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedblocks[ids[i]] = struct{}{}
	}
}

// RemovedBlocks returns the removed ids of blocks.
func (m *FlowDraftMutation) RemovedBlocksIDs() (ids []int) {
	for id := range m.removedblocks {
		ids = append(ids, id)
	}
	return
}

// BlocksIDs returns the blocks ids in the mutation.
func (m *FlowDraftMutation) BlocksIDs() (ids []int) {
	for id := range m.blocks {
		ids = append(ids, id)
	}
	return
}

// ResetBlocks reset all changes of the "blocks" edge.
func (m *FlowDraftMutation) ResetBlocks() {
	m.blocks = nil
	m.clearedblocks = false
	m.removedblocks = nil
}

// SetFlowID sets the flow edge to Flow by id.
func (m *FlowDraftMutation) SetFlowID(id int) {
	m.flow = &id
}

// ClearFlow clears the flow edge to Flow.
func (m *FlowDraftMutation) ClearFlow() {
	m.clearedflow = true
}

// FlowCleared returns if the edge flow was cleared.
func (m *FlowDraftMutation) FlowCleared() bool {
	return m.clearedflow
}

// FlowID returns the flow id in the mutation.
func (m *FlowDraftMutation) FlowID() (id int, exists bool) {
	if m.flow != nil {
		return *m.flow, true
	}
	return
}

// FlowIDs returns the flow ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowID instead. It exists only for internal usage by the builders.
func (m *FlowDraftMutation) FlowIDs() (ids []int) {
	if id := m.flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlow reset all changes of the "flow" edge.
func (m *FlowDraftMutation) ResetFlow() {
	m.flow = nil
	m.clearedflow = false
}

// Op returns the operation name.
func (m *FlowDraftMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowDraft).
func (m *FlowDraftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FlowDraftMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, flowdraft.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, flowdraft.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, flowdraft.FieldName)
	}
	if m.description != nil {
		fields = append(fields, flowdraft.FieldDescription)
	}
	if m.end_param_definitions != nil {
		fields = append(fields, flowdraft.FieldEndParamDefinitions)
	}
	if m.sameAsFlow != nil {
		fields = append(fields, flowdraft.FieldSameAsFlow)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FlowDraftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowdraft.FieldCreateTime:
		return m.CreateTime()
	case flowdraft.FieldUpdateTime:
		return m.UpdateTime()
	case flowdraft.FieldName:
		return m.Name()
	case flowdraft.FieldDescription:
		return m.Description()
	case flowdraft.FieldEndParamDefinitions:
		return m.EndParamDefinitions()
	case flowdraft.FieldSameAsFlow:
		return m.SameAsFlow()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FlowDraftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowdraft.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case flowdraft.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case flowdraft.FieldName:
		return m.OldName(ctx)
	case flowdraft.FieldDescription:
		return m.OldDescription(ctx)
	case flowdraft.FieldEndParamDefinitions:
		return m.OldEndParamDefinitions(ctx)
	case flowdraft.FieldSameAsFlow:
		return m.OldSameAsFlow(ctx)
	}
	return nil, fmt.Errorf("unknown FlowDraft field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowDraftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowdraft.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case flowdraft.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case flowdraft.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flowdraft.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case flowdraft.FieldEndParamDefinitions:
		v, ok := value.([]*flowschema.VariableDefinition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndParamDefinitions(v)
		return nil
	case flowdraft.FieldSameAsFlow:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSameAsFlow(v)
		return nil
	}
	return fmt.Errorf("unknown FlowDraft field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FlowDraftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FlowDraftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowDraftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowDraft numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FlowDraftMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flowdraft.FieldDescription) {
		fields = append(fields, flowdraft.FieldDescription)
	}
	if m.FieldCleared(flowdraft.FieldEndParamDefinitions) {
		fields = append(fields, flowdraft.FieldEndParamDefinitions)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FlowDraftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowDraftMutation) ClearField(name string) error {
	switch name {
	case flowdraft.FieldDescription:
		m.ClearDescription()
		return nil
	case flowdraft.FieldEndParamDefinitions:
		m.ClearEndParamDefinitions()
		return nil
	}
	return fmt.Errorf("unknown FlowDraft nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FlowDraftMutation) ResetField(name string) error {
	switch name {
	case flowdraft.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case flowdraft.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case flowdraft.FieldName:
		m.ResetName()
		return nil
	case flowdraft.FieldDescription:
		m.ResetDescription()
		return nil
	case flowdraft.FieldEndParamDefinitions:
		m.ResetEndParamDefinitions()
		return nil
	case flowdraft.FieldSameAsFlow:
		m.ResetSameAsFlow()
		return nil
	}
	return fmt.Errorf("unknown FlowDraft field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FlowDraftMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blocks != nil {
		edges = append(edges, flowdraft.EdgeBlocks)
	}
	if m.flow != nil {
		edges = append(edges, flowdraft.EdgeFlow)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FlowDraftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowdraft.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.blocks))
		for id := range m.blocks {
			ids = append(ids, id)
		}
		return ids
	case flowdraft.EdgeFlow:
		if id := m.flow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FlowDraftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedblocks != nil {
		edges = append(edges, flowdraft.EdgeBlocks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FlowDraftMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowdraft.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.removedblocks))
		for id := range m.removedblocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FlowDraftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblocks {
		edges = append(edges, flowdraft.EdgeBlocks)
	}
	if m.clearedflow {
		edges = append(edges, flowdraft.EdgeFlow)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FlowDraftMutation) EdgeCleared(name string) bool {
	switch name {
	case flowdraft.EdgeBlocks:
		return m.clearedblocks
	case flowdraft.EdgeFlow:
		return m.clearedflow
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FlowDraftMutation) ClearEdge(name string) error {
	switch name {
	case flowdraft.EdgeFlow:
		m.ClearFlow()
		return nil
	}
	return fmt.Errorf("unknown FlowDraft unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FlowDraftMutation) ResetEdge(name string) error {
	switch name {
	case flowdraft.EdgeBlocks:
		m.ResetBlocks()
		return nil
	case flowdraft.EdgeFlow:
		m.ResetFlow()
		return nil
	}
	return fmt.Errorf("unknown FlowDraft edge %s", name)
}

// FlowExecutionTemplateMutation represents an operation that mutate the FlowExecutionTemplates
// nodes in the graph.
type FlowExecutionTemplateMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	description           *string
	end_param_definitions *[]*flowschema.VariableDefinition
	clearedFields         map[string]struct{}
	blocks                map[int]struct{}
	removedblocks         map[int]struct{}
	clearedblocks         bool
	done                  bool
	oldValue              func(context.Context) (*FlowExecutionTemplate, error)
	predicates            []predicate.FlowExecutionTemplate
}

var _ ent.Mutation = (*FlowExecutionTemplateMutation)(nil)

// flowexecutiontemplateOption allows to manage the mutation configuration using functional options.
type flowexecutiontemplateOption func(*FlowExecutionTemplateMutation)

// newFlowExecutionTemplateMutation creates new mutation for FlowExecutionTemplate.
func newFlowExecutionTemplateMutation(c config, op Op, opts ...flowexecutiontemplateOption) *FlowExecutionTemplateMutation {
	m := &FlowExecutionTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowExecutionTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowExecutionTemplateID sets the id field of the mutation.
func withFlowExecutionTemplateID(id int) flowexecutiontemplateOption {
	return func(m *FlowExecutionTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowExecutionTemplate
		)
		m.oldValue = func(ctx context.Context) (*FlowExecutionTemplate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowExecutionTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowExecutionTemplate sets the old FlowExecutionTemplate of the mutation.
func withFlowExecutionTemplate(node *FlowExecutionTemplate) flowexecutiontemplateOption {
	return func(m *FlowExecutionTemplateMutation) {
		m.oldValue = func(context.Context) (*FlowExecutionTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowExecutionTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowExecutionTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FlowExecutionTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FlowExecutionTemplateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FlowExecutionTemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the FlowExecutionTemplate.
// If the FlowExecutionTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowExecutionTemplateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FlowExecutionTemplateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FlowExecutionTemplateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FlowExecutionTemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the FlowExecutionTemplate.
// If the FlowExecutionTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowExecutionTemplateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FlowExecutionTemplateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *FlowExecutionTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FlowExecutionTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the FlowExecutionTemplate.
// If the FlowExecutionTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowExecutionTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FlowExecutionTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *FlowExecutionTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *FlowExecutionTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the FlowExecutionTemplate.
// If the FlowExecutionTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowExecutionTemplateMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *FlowExecutionTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[flowexecutiontemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *FlowExecutionTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[flowexecutiontemplate.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *FlowExecutionTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, flowexecutiontemplate.FieldDescription)
}

// SetEndParamDefinitions sets the end_param_definitions field.
func (m *FlowExecutionTemplateMutation) SetEndParamDefinitions(fd []*flowschema.VariableDefinition) {
	m.end_param_definitions = &fd
}

// EndParamDefinitions returns the end_param_definitions value in the mutation.
func (m *FlowExecutionTemplateMutation) EndParamDefinitions() (r []*flowschema.VariableDefinition, exists bool) {
	v := m.end_param_definitions
	if v == nil {
		return
	}
	return *v, true
}

// OldEndParamDefinitions returns the old end_param_definitions value of the FlowExecutionTemplate.
// If the FlowExecutionTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowExecutionTemplateMutation) OldEndParamDefinitions(ctx context.Context) (v []*flowschema.VariableDefinition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndParamDefinitions is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndParamDefinitions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndParamDefinitions: %w", err)
	}
	return oldValue.EndParamDefinitions, nil
}

// ClearEndParamDefinitions clears the value of end_param_definitions.
func (m *FlowExecutionTemplateMutation) ClearEndParamDefinitions() {
	m.end_param_definitions = nil
	m.clearedFields[flowexecutiontemplate.FieldEndParamDefinitions] = struct{}{}
}

// EndParamDefinitionsCleared returns if the field end_param_definitions was cleared in this mutation.
func (m *FlowExecutionTemplateMutation) EndParamDefinitionsCleared() bool {
	_, ok := m.clearedFields[flowexecutiontemplate.FieldEndParamDefinitions]
	return ok
}

// ResetEndParamDefinitions reset all changes of the "end_param_definitions" field.
func (m *FlowExecutionTemplateMutation) ResetEndParamDefinitions() {
	m.end_param_definitions = nil
	delete(m.clearedFields, flowexecutiontemplate.FieldEndParamDefinitions)
}

// AddBlockIDs adds the blocks edge to Block by ids.
func (m *FlowExecutionTemplateMutation) AddBlockIDs(ids ...int) {
	if m.blocks == nil {
		m.blocks = make(map[int]struct{})
	}
	for i := range ids {
		m.blocks[ids[i]] = struct{}{}
	}
}

// ClearBlocks clears the blocks edge to Block.
func (m *FlowExecutionTemplateMutation) ClearBlocks() {
	m.clearedblocks = true
}

// BlocksCleared returns if the edge blocks was cleared.
func (m *FlowExecutionTemplateMutation) BlocksCleared() bool {
	return m.clearedblocks
}

// RemoveBlockIDs removes the blocks edge to Block by ids.
func (m *FlowExecutionTemplateMutation) RemoveBlockIDs(ids ...int) {
	if m.removedblocks == nil {
		m.removedblocks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedblocks[ids[i]] = struct{}{}
	}
}

// RemovedBlocks returns the removed ids of blocks.
func (m *FlowExecutionTemplateMutation) RemovedBlocksIDs() (ids []int) {
	for id := range m.removedblocks {
		ids = append(ids, id)
	}
	return
}

// BlocksIDs returns the blocks ids in the mutation.
func (m *FlowExecutionTemplateMutation) BlocksIDs() (ids []int) {
	for id := range m.blocks {
		ids = append(ids, id)
	}
	return
}

// ResetBlocks reset all changes of the "blocks" edge.
func (m *FlowExecutionTemplateMutation) ResetBlocks() {
	m.blocks = nil
	m.clearedblocks = false
	m.removedblocks = nil
}

// Op returns the operation name.
func (m *FlowExecutionTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowExecutionTemplate).
func (m *FlowExecutionTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FlowExecutionTemplateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, flowexecutiontemplate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, flowexecutiontemplate.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, flowexecutiontemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, flowexecutiontemplate.FieldDescription)
	}
	if m.end_param_definitions != nil {
		fields = append(fields, flowexecutiontemplate.FieldEndParamDefinitions)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FlowExecutionTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowexecutiontemplate.FieldCreateTime:
		return m.CreateTime()
	case flowexecutiontemplate.FieldUpdateTime:
		return m.UpdateTime()
	case flowexecutiontemplate.FieldName:
		return m.Name()
	case flowexecutiontemplate.FieldDescription:
		return m.Description()
	case flowexecutiontemplate.FieldEndParamDefinitions:
		return m.EndParamDefinitions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FlowExecutionTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowexecutiontemplate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case flowexecutiontemplate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case flowexecutiontemplate.FieldName:
		return m.OldName(ctx)
	case flowexecutiontemplate.FieldDescription:
		return m.OldDescription(ctx)
	case flowexecutiontemplate.FieldEndParamDefinitions:
		return m.OldEndParamDefinitions(ctx)
	}
	return nil, fmt.Errorf("unknown FlowExecutionTemplate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowExecutionTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowexecutiontemplate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case flowexecutiontemplate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case flowexecutiontemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flowexecutiontemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case flowexecutiontemplate.FieldEndParamDefinitions:
		v, ok := value.([]*flowschema.VariableDefinition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndParamDefinitions(v)
		return nil
	}
	return fmt.Errorf("unknown FlowExecutionTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FlowExecutionTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FlowExecutionTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowExecutionTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowExecutionTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FlowExecutionTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flowexecutiontemplate.FieldDescription) {
		fields = append(fields, flowexecutiontemplate.FieldDescription)
	}
	if m.FieldCleared(flowexecutiontemplate.FieldEndParamDefinitions) {
		fields = append(fields, flowexecutiontemplate.FieldEndParamDefinitions)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FlowExecutionTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowExecutionTemplateMutation) ClearField(name string) error {
	switch name {
	case flowexecutiontemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case flowexecutiontemplate.FieldEndParamDefinitions:
		m.ClearEndParamDefinitions()
		return nil
	}
	return fmt.Errorf("unknown FlowExecutionTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FlowExecutionTemplateMutation) ResetField(name string) error {
	switch name {
	case flowexecutiontemplate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case flowexecutiontemplate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case flowexecutiontemplate.FieldName:
		m.ResetName()
		return nil
	case flowexecutiontemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case flowexecutiontemplate.FieldEndParamDefinitions:
		m.ResetEndParamDefinitions()
		return nil
	}
	return fmt.Errorf("unknown FlowExecutionTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FlowExecutionTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.blocks != nil {
		edges = append(edges, flowexecutiontemplate.EdgeBlocks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FlowExecutionTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowexecutiontemplate.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.blocks))
		for id := range m.blocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FlowExecutionTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedblocks != nil {
		edges = append(edges, flowexecutiontemplate.EdgeBlocks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FlowExecutionTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowexecutiontemplate.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.removedblocks))
		for id := range m.removedblocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FlowExecutionTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblocks {
		edges = append(edges, flowexecutiontemplate.EdgeBlocks)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FlowExecutionTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case flowexecutiontemplate.EdgeBlocks:
		return m.clearedblocks
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FlowExecutionTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowExecutionTemplate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FlowExecutionTemplateMutation) ResetEdge(name string) error {
	switch name {
	case flowexecutiontemplate.EdgeBlocks:
		m.ResetBlocks()
		return nil
	}
	return fmt.Errorf("unknown FlowExecutionTemplate edge %s", name)
}

// FlowInstanceMutation represents an operation that mutate the FlowInstances
// nodes in the graph.
type FlowInstanceMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	status                      *flowinstance.Status
	output_params               *[]*flowschema.VariableValue
	incompletion_reason         *string
	bss_code                    *string
	service_instance_code       *string
	start_date                  *time.Time
	end_date                    *time.Time
	clearedFields               map[string]struct{}
	flow                        *int
	clearedflow                 bool
	template                    *int
	clearedtemplate             bool
	blocks                      map[int]struct{}
	removedblocks               map[int]struct{}
	clearedblocks               bool
	parent_subflow_block        *int
	clearedparent_subflow_block bool
	done                        bool
	oldValue                    func(context.Context) (*FlowInstance, error)
	predicates                  []predicate.FlowInstance
}

var _ ent.Mutation = (*FlowInstanceMutation)(nil)

// flowinstanceOption allows to manage the mutation configuration using functional options.
type flowinstanceOption func(*FlowInstanceMutation)

// newFlowInstanceMutation creates new mutation for FlowInstance.
func newFlowInstanceMutation(c config, op Op, opts ...flowinstanceOption) *FlowInstanceMutation {
	m := &FlowInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowInstanceID sets the id field of the mutation.
func withFlowInstanceID(id int) flowinstanceOption {
	return func(m *FlowInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowInstance
		)
		m.oldValue = func(ctx context.Context) (*FlowInstance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowInstance sets the old FlowInstance of the mutation.
func withFlowInstance(node *FlowInstance) flowinstanceOption {
	return func(m *FlowInstanceMutation) {
		m.oldValue = func(context.Context) (*FlowInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FlowInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FlowInstanceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FlowInstanceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FlowInstanceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FlowInstanceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FlowInstanceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FlowInstanceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the status field.
func (m *FlowInstanceMutation) SetStatus(f flowinstance.Status) {
	m.status = &f
}

// Status returns the status value in the mutation.
func (m *FlowInstanceMutation) Status() (r flowinstance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldStatus(ctx context.Context) (v flowinstance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *FlowInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetOutputParams sets the output_params field.
func (m *FlowInstanceMutation) SetOutputParams(fv []*flowschema.VariableValue) {
	m.output_params = &fv
}

// OutputParams returns the output_params value in the mutation.
func (m *FlowInstanceMutation) OutputParams() (r []*flowschema.VariableValue, exists bool) {
	v := m.output_params
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputParams returns the old output_params value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldOutputParams(ctx context.Context) (v []*flowschema.VariableValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutputParams is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutputParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputParams: %w", err)
	}
	return oldValue.OutputParams, nil
}

// ClearOutputParams clears the value of output_params.
func (m *FlowInstanceMutation) ClearOutputParams() {
	m.output_params = nil
	m.clearedFields[flowinstance.FieldOutputParams] = struct{}{}
}

// OutputParamsCleared returns if the field output_params was cleared in this mutation.
func (m *FlowInstanceMutation) OutputParamsCleared() bool {
	_, ok := m.clearedFields[flowinstance.FieldOutputParams]
	return ok
}

// ResetOutputParams reset all changes of the "output_params" field.
func (m *FlowInstanceMutation) ResetOutputParams() {
	m.output_params = nil
	delete(m.clearedFields, flowinstance.FieldOutputParams)
}

// SetIncompletionReason sets the incompletion_reason field.
func (m *FlowInstanceMutation) SetIncompletionReason(s string) {
	m.incompletion_reason = &s
}

// IncompletionReason returns the incompletion_reason value in the mutation.
func (m *FlowInstanceMutation) IncompletionReason() (r string, exists bool) {
	v := m.incompletion_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldIncompletionReason returns the old incompletion_reason value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldIncompletionReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIncompletionReason is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIncompletionReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncompletionReason: %w", err)
	}
	return oldValue.IncompletionReason, nil
}

// ClearIncompletionReason clears the value of incompletion_reason.
func (m *FlowInstanceMutation) ClearIncompletionReason() {
	m.incompletion_reason = nil
	m.clearedFields[flowinstance.FieldIncompletionReason] = struct{}{}
}

// IncompletionReasonCleared returns if the field incompletion_reason was cleared in this mutation.
func (m *FlowInstanceMutation) IncompletionReasonCleared() bool {
	_, ok := m.clearedFields[flowinstance.FieldIncompletionReason]
	return ok
}

// ResetIncompletionReason reset all changes of the "incompletion_reason" field.
func (m *FlowInstanceMutation) ResetIncompletionReason() {
	m.incompletion_reason = nil
	delete(m.clearedFields, flowinstance.FieldIncompletionReason)
}

// SetBssCode sets the bss_code field.
func (m *FlowInstanceMutation) SetBssCode(s string) {
	m.bss_code = &s
}

// BssCode returns the bss_code value in the mutation.
func (m *FlowInstanceMutation) BssCode() (r string, exists bool) {
	v := m.bss_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBssCode returns the old bss_code value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldBssCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBssCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBssCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBssCode: %w", err)
	}
	return oldValue.BssCode, nil
}

// ResetBssCode reset all changes of the "bss_code" field.
func (m *FlowInstanceMutation) ResetBssCode() {
	m.bss_code = nil
}

// SetServiceInstanceCode sets the service_instance_code field.
func (m *FlowInstanceMutation) SetServiceInstanceCode(s string) {
	m.service_instance_code = &s
}

// ServiceInstanceCode returns the service_instance_code value in the mutation.
func (m *FlowInstanceMutation) ServiceInstanceCode() (r string, exists bool) {
	v := m.service_instance_code
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceInstanceCode returns the old service_instance_code value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldServiceInstanceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceInstanceCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceInstanceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceInstanceCode: %w", err)
	}
	return oldValue.ServiceInstanceCode, nil
}

// ClearServiceInstanceCode clears the value of service_instance_code.
func (m *FlowInstanceMutation) ClearServiceInstanceCode() {
	m.service_instance_code = nil
	m.clearedFields[flowinstance.FieldServiceInstanceCode] = struct{}{}
}

// ServiceInstanceCodeCleared returns if the field service_instance_code was cleared in this mutation.
func (m *FlowInstanceMutation) ServiceInstanceCodeCleared() bool {
	_, ok := m.clearedFields[flowinstance.FieldServiceInstanceCode]
	return ok
}

// ResetServiceInstanceCode reset all changes of the "service_instance_code" field.
func (m *FlowInstanceMutation) ResetServiceInstanceCode() {
	m.service_instance_code = nil
	delete(m.clearedFields, flowinstance.FieldServiceInstanceCode)
}

// SetStartDate sets the start_date field.
func (m *FlowInstanceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the start_date value in the mutation.
func (m *FlowInstanceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old start_date value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate reset all changes of the "start_date" field.
func (m *FlowInstanceMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the end_date field.
func (m *FlowInstanceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the end_date value in the mutation.
func (m *FlowInstanceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old end_date value of the FlowInstance.
// If the FlowInstance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FlowInstanceMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of end_date.
func (m *FlowInstanceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[flowinstance.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the field end_date was cleared in this mutation.
func (m *FlowInstanceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[flowinstance.FieldEndDate]
	return ok
}

// ResetEndDate reset all changes of the "end_date" field.
func (m *FlowInstanceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, flowinstance.FieldEndDate)
}

// SetFlowID sets the flow edge to Flow by id.
func (m *FlowInstanceMutation) SetFlowID(id int) {
	m.flow = &id
}

// ClearFlow clears the flow edge to Flow.
func (m *FlowInstanceMutation) ClearFlow() {
	m.clearedflow = true
}

// FlowCleared returns if the edge flow was cleared.
func (m *FlowInstanceMutation) FlowCleared() bool {
	return m.clearedflow
}

// FlowID returns the flow id in the mutation.
func (m *FlowInstanceMutation) FlowID() (id int, exists bool) {
	if m.flow != nil {
		return *m.flow, true
	}
	return
}

// FlowIDs returns the flow ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FlowID instead. It exists only for internal usage by the builders.
func (m *FlowInstanceMutation) FlowIDs() (ids []int) {
	if id := m.flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlow reset all changes of the "flow" edge.
func (m *FlowInstanceMutation) ResetFlow() {
	m.flow = nil
	m.clearedflow = false
}

// SetTemplateID sets the template edge to FlowExecutionTemplate by id.
func (m *FlowInstanceMutation) SetTemplateID(id int) {
	m.template = &id
}

// ClearTemplate clears the template edge to FlowExecutionTemplate.
func (m *FlowInstanceMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared returns if the edge template was cleared.
func (m *FlowInstanceMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateID returns the template id in the mutation.
func (m *FlowInstanceMutation) TemplateID() (id int, exists bool) {
	if m.template != nil {
		return *m.template, true
	}
	return
}

// TemplateIDs returns the template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *FlowInstanceMutation) TemplateIDs() (ids []int) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate reset all changes of the "template" edge.
func (m *FlowInstanceMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// AddBlockIDs adds the blocks edge to BlockInstance by ids.
func (m *FlowInstanceMutation) AddBlockIDs(ids ...int) {
	if m.blocks == nil {
		m.blocks = make(map[int]struct{})
	}
	for i := range ids {
		m.blocks[ids[i]] = struct{}{}
	}
}

// ClearBlocks clears the blocks edge to BlockInstance.
func (m *FlowInstanceMutation) ClearBlocks() {
	m.clearedblocks = true
}

// BlocksCleared returns if the edge blocks was cleared.
func (m *FlowInstanceMutation) BlocksCleared() bool {
	return m.clearedblocks
}

// RemoveBlockIDs removes the blocks edge to BlockInstance by ids.
func (m *FlowInstanceMutation) RemoveBlockIDs(ids ...int) {
	if m.removedblocks == nil {
		m.removedblocks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedblocks[ids[i]] = struct{}{}
	}
}

// RemovedBlocks returns the removed ids of blocks.
func (m *FlowInstanceMutation) RemovedBlocksIDs() (ids []int) {
	for id := range m.removedblocks {
		ids = append(ids, id)
	}
	return
}

// BlocksIDs returns the blocks ids in the mutation.
func (m *FlowInstanceMutation) BlocksIDs() (ids []int) {
	for id := range m.blocks {
		ids = append(ids, id)
	}
	return
}

// ResetBlocks reset all changes of the "blocks" edge.
func (m *FlowInstanceMutation) ResetBlocks() {
	m.blocks = nil
	m.clearedblocks = false
	m.removedblocks = nil
}

// SetParentSubflowBlockID sets the parent_subflow_block edge to BlockInstance by id.
func (m *FlowInstanceMutation) SetParentSubflowBlockID(id int) {
	m.parent_subflow_block = &id
}

// ClearParentSubflowBlock clears the parent_subflow_block edge to BlockInstance.
func (m *FlowInstanceMutation) ClearParentSubflowBlock() {
	m.clearedparent_subflow_block = true
}

// ParentSubflowBlockCleared returns if the edge parent_subflow_block was cleared.
func (m *FlowInstanceMutation) ParentSubflowBlockCleared() bool {
	return m.clearedparent_subflow_block
}

// ParentSubflowBlockID returns the parent_subflow_block id in the mutation.
func (m *FlowInstanceMutation) ParentSubflowBlockID() (id int, exists bool) {
	if m.parent_subflow_block != nil {
		return *m.parent_subflow_block, true
	}
	return
}

// ParentSubflowBlockIDs returns the parent_subflow_block ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentSubflowBlockID instead. It exists only for internal usage by the builders.
func (m *FlowInstanceMutation) ParentSubflowBlockIDs() (ids []int) {
	if id := m.parent_subflow_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentSubflowBlock reset all changes of the "parent_subflow_block" edge.
func (m *FlowInstanceMutation) ResetParentSubflowBlock() {
	m.parent_subflow_block = nil
	m.clearedparent_subflow_block = false
}

// Op returns the operation name.
func (m *FlowInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowInstance).
func (m *FlowInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FlowInstanceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, flowinstance.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, flowinstance.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, flowinstance.FieldStatus)
	}
	if m.output_params != nil {
		fields = append(fields, flowinstance.FieldOutputParams)
	}
	if m.incompletion_reason != nil {
		fields = append(fields, flowinstance.FieldIncompletionReason)
	}
	if m.bss_code != nil {
		fields = append(fields, flowinstance.FieldBssCode)
	}
	if m.service_instance_code != nil {
		fields = append(fields, flowinstance.FieldServiceInstanceCode)
	}
	if m.start_date != nil {
		fields = append(fields, flowinstance.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, flowinstance.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FlowInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowinstance.FieldCreateTime:
		return m.CreateTime()
	case flowinstance.FieldUpdateTime:
		return m.UpdateTime()
	case flowinstance.FieldStatus:
		return m.Status()
	case flowinstance.FieldOutputParams:
		return m.OutputParams()
	case flowinstance.FieldIncompletionReason:
		return m.IncompletionReason()
	case flowinstance.FieldBssCode:
		return m.BssCode()
	case flowinstance.FieldServiceInstanceCode:
		return m.ServiceInstanceCode()
	case flowinstance.FieldStartDate:
		return m.StartDate()
	case flowinstance.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FlowInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowinstance.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case flowinstance.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case flowinstance.FieldStatus:
		return m.OldStatus(ctx)
	case flowinstance.FieldOutputParams:
		return m.OldOutputParams(ctx)
	case flowinstance.FieldIncompletionReason:
		return m.OldIncompletionReason(ctx)
	case flowinstance.FieldBssCode:
		return m.OldBssCode(ctx)
	case flowinstance.FieldServiceInstanceCode:
		return m.OldServiceInstanceCode(ctx)
	case flowinstance.FieldStartDate:
		return m.OldStartDate(ctx)
	case flowinstance.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown FlowInstance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowinstance.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case flowinstance.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case flowinstance.FieldStatus:
		v, ok := value.(flowinstance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flowinstance.FieldOutputParams:
		v, ok := value.([]*flowschema.VariableValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputParams(v)
		return nil
	case flowinstance.FieldIncompletionReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncompletionReason(v)
		return nil
	case flowinstance.FieldBssCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBssCode(v)
		return nil
	case flowinstance.FieldServiceInstanceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceInstanceCode(v)
		return nil
	case flowinstance.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case flowinstance.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown FlowInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FlowInstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FlowInstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FlowInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FlowInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flowinstance.FieldOutputParams) {
		fields = append(fields, flowinstance.FieldOutputParams)
	}
	if m.FieldCleared(flowinstance.FieldIncompletionReason) {
		fields = append(fields, flowinstance.FieldIncompletionReason)
	}
	if m.FieldCleared(flowinstance.FieldServiceInstanceCode) {
		fields = append(fields, flowinstance.FieldServiceInstanceCode)
	}
	if m.FieldCleared(flowinstance.FieldEndDate) {
		fields = append(fields, flowinstance.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FlowInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowInstanceMutation) ClearField(name string) error {
	switch name {
	case flowinstance.FieldOutputParams:
		m.ClearOutputParams()
		return nil
	case flowinstance.FieldIncompletionReason:
		m.ClearIncompletionReason()
		return nil
	case flowinstance.FieldServiceInstanceCode:
		m.ClearServiceInstanceCode()
		return nil
	case flowinstance.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FlowInstanceMutation) ResetField(name string) error {
	switch name {
	case flowinstance.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case flowinstance.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case flowinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case flowinstance.FieldOutputParams:
		m.ResetOutputParams()
		return nil
	case flowinstance.FieldIncompletionReason:
		m.ResetIncompletionReason()
		return nil
	case flowinstance.FieldBssCode:
		m.ResetBssCode()
		return nil
	case flowinstance.FieldServiceInstanceCode:
		m.ResetServiceInstanceCode()
		return nil
	case flowinstance.FieldStartDate:
		m.ResetStartDate()
		return nil
	case flowinstance.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FlowInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.flow != nil {
		edges = append(edges, flowinstance.EdgeFlow)
	}
	if m.template != nil {
		edges = append(edges, flowinstance.EdgeTemplate)
	}
	if m.blocks != nil {
		edges = append(edges, flowinstance.EdgeBlocks)
	}
	if m.parent_subflow_block != nil {
		edges = append(edges, flowinstance.EdgeParentSubflowBlock)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FlowInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowinstance.EdgeFlow:
		if id := m.flow; id != nil {
			return []ent.Value{*id}
		}
	case flowinstance.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case flowinstance.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.blocks))
		for id := range m.blocks {
			ids = append(ids, id)
		}
		return ids
	case flowinstance.EdgeParentSubflowBlock:
		if id := m.parent_subflow_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FlowInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedblocks != nil {
		edges = append(edges, flowinstance.EdgeBlocks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FlowInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowinstance.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.removedblocks))
		for id := range m.removedblocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FlowInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedflow {
		edges = append(edges, flowinstance.EdgeFlow)
	}
	if m.clearedtemplate {
		edges = append(edges, flowinstance.EdgeTemplate)
	}
	if m.clearedblocks {
		edges = append(edges, flowinstance.EdgeBlocks)
	}
	if m.clearedparent_subflow_block {
		edges = append(edges, flowinstance.EdgeParentSubflowBlock)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FlowInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case flowinstance.EdgeFlow:
		return m.clearedflow
	case flowinstance.EdgeTemplate:
		return m.clearedtemplate
	case flowinstance.EdgeBlocks:
		return m.clearedblocks
	case flowinstance.EdgeParentSubflowBlock:
		return m.clearedparent_subflow_block
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FlowInstanceMutation) ClearEdge(name string) error {
	switch name {
	case flowinstance.EdgeFlow:
		m.ClearFlow()
		return nil
	case flowinstance.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case flowinstance.EdgeParentSubflowBlock:
		m.ClearParentSubflowBlock()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FlowInstanceMutation) ResetEdge(name string) error {
	switch name {
	case flowinstance.EdgeFlow:
		m.ResetFlow()
		return nil
	case flowinstance.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case flowinstance.EdgeBlocks:
		m.ResetBlocks()
		return nil
	case flowinstance.EdgeParentSubflowBlock:
		m.ResetParentSubflowBlock()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance edge %s", name)
}

// FormulaMutation represents an operation that mutate the Formulas
// nodes in the graph.
type FormulaMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	textFormula           *string
	status                *bool
	clearedFields         map[string]struct{}
	networkType           *int
	clearednetworkType    bool
	tech                  *int
	clearedtech           bool
	kpi                   *int
	clearedkpi            bool
	counterformula        map[int]struct{}
	removedcounterformula map[int]struct{}
	clearedcounterformula bool
	done                  bool
	oldValue              func(context.Context) (*Formula, error)
	predicates            []predicate.Formula
}

var _ ent.Mutation = (*FormulaMutation)(nil)

// formulaOption allows to manage the mutation configuration using functional options.
type formulaOption func(*FormulaMutation)

// newFormulaMutation creates new mutation for Formula.
func newFormulaMutation(c config, op Op, opts ...formulaOption) *FormulaMutation {
	m := &FormulaMutation{
		config:        c,
		op:            op,
		typ:           TypeFormula,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFormulaID sets the id field of the mutation.
func withFormulaID(id int) formulaOption {
	return func(m *FormulaMutation) {
		var (
			err   error
			once  sync.Once
			value *Formula
		)
		m.oldValue = func(ctx context.Context) (*Formula, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Formula.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFormula sets the old Formula of the mutation.
func withFormula(node *Formula) formulaOption {
	return func(m *FormulaMutation) {
		m.oldValue = func(context.Context) (*Formula, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FormulaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FormulaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FormulaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *FormulaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *FormulaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Formula.
// If the Formula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FormulaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *FormulaMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *FormulaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *FormulaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Formula.
// If the Formula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FormulaMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *FormulaMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTextFormula sets the textFormula field.
func (m *FormulaMutation) SetTextFormula(s string) {
	m.textFormula = &s
}

// TextFormula returns the textFormula value in the mutation.
func (m *FormulaMutation) TextFormula() (r string, exists bool) {
	v := m.textFormula
	if v == nil {
		return
	}
	return *v, true
}

// OldTextFormula returns the old textFormula value of the Formula.
// If the Formula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FormulaMutation) OldTextFormula(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTextFormula is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTextFormula requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextFormula: %w", err)
	}
	return oldValue.TextFormula, nil
}

// ResetTextFormula reset all changes of the "textFormula" field.
func (m *FormulaMutation) ResetTextFormula() {
	m.textFormula = nil
}

// SetStatus sets the status field.
func (m *FormulaMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the status value in the mutation.
func (m *FormulaMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Formula.
// If the Formula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FormulaMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *FormulaMutation) ResetStatus() {
	m.status = nil
}

// SetNetworkTypeID sets the networkType edge to NetworkType by id.
func (m *FormulaMutation) SetNetworkTypeID(id int) {
	m.networkType = &id
}

// ClearNetworkType clears the networkType edge to NetworkType.
func (m *FormulaMutation) ClearNetworkType() {
	m.clearednetworkType = true
}

// NetworkTypeCleared returns if the edge networkType was cleared.
func (m *FormulaMutation) NetworkTypeCleared() bool {
	return m.clearednetworkType
}

// NetworkTypeID returns the networkType id in the mutation.
func (m *FormulaMutation) NetworkTypeID() (id int, exists bool) {
	if m.networkType != nil {
		return *m.networkType, true
	}
	return
}

// NetworkTypeIDs returns the networkType ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NetworkTypeID instead. It exists only for internal usage by the builders.
func (m *FormulaMutation) NetworkTypeIDs() (ids []int) {
	if id := m.networkType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkType reset all changes of the "networkType" edge.
func (m *FormulaMutation) ResetNetworkType() {
	m.networkType = nil
	m.clearednetworkType = false
}

// SetTechID sets the tech edge to Tech by id.
func (m *FormulaMutation) SetTechID(id int) {
	m.tech = &id
}

// ClearTech clears the tech edge to Tech.
func (m *FormulaMutation) ClearTech() {
	m.clearedtech = true
}

// TechCleared returns if the edge tech was cleared.
func (m *FormulaMutation) TechCleared() bool {
	return m.clearedtech
}

// TechID returns the tech id in the mutation.
func (m *FormulaMutation) TechID() (id int, exists bool) {
	if m.tech != nil {
		return *m.tech, true
	}
	return
}

// TechIDs returns the tech ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TechID instead. It exists only for internal usage by the builders.
func (m *FormulaMutation) TechIDs() (ids []int) {
	if id := m.tech; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTech reset all changes of the "tech" edge.
func (m *FormulaMutation) ResetTech() {
	m.tech = nil
	m.clearedtech = false
}

// SetKpiID sets the kpi edge to Kpi by id.
func (m *FormulaMutation) SetKpiID(id int) {
	m.kpi = &id
}

// ClearKpi clears the kpi edge to Kpi.
func (m *FormulaMutation) ClearKpi() {
	m.clearedkpi = true
}

// KpiCleared returns if the edge kpi was cleared.
func (m *FormulaMutation) KpiCleared() bool {
	return m.clearedkpi
}

// KpiID returns the kpi id in the mutation.
func (m *FormulaMutation) KpiID() (id int, exists bool) {
	if m.kpi != nil {
		return *m.kpi, true
	}
	return
}

// KpiIDs returns the kpi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KpiID instead. It exists only for internal usage by the builders.
func (m *FormulaMutation) KpiIDs() (ids []int) {
	if id := m.kpi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKpi reset all changes of the "kpi" edge.
func (m *FormulaMutation) ResetKpi() {
	m.kpi = nil
	m.clearedkpi = false
}

// AddCounterformulaIDs adds the counterformula edge to CounterFormula by ids.
func (m *FormulaMutation) AddCounterformulaIDs(ids ...int) {
	if m.counterformula == nil {
		m.counterformula = make(map[int]struct{})
	}
	for i := range ids {
		m.counterformula[ids[i]] = struct{}{}
	}
}

// ClearCounterformula clears the counterformula edge to CounterFormula.
func (m *FormulaMutation) ClearCounterformula() {
	m.clearedcounterformula = true
}

// CounterformulaCleared returns if the edge counterformula was cleared.
func (m *FormulaMutation) CounterformulaCleared() bool {
	return m.clearedcounterformula
}

// RemoveCounterformulaIDs removes the counterformula edge to CounterFormula by ids.
func (m *FormulaMutation) RemoveCounterformulaIDs(ids ...int) {
	if m.removedcounterformula == nil {
		m.removedcounterformula = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcounterformula[ids[i]] = struct{}{}
	}
}

// RemovedCounterformula returns the removed ids of counterformula.
func (m *FormulaMutation) RemovedCounterformulaIDs() (ids []int) {
	for id := range m.removedcounterformula {
		ids = append(ids, id)
	}
	return
}

// CounterformulaIDs returns the counterformula ids in the mutation.
func (m *FormulaMutation) CounterformulaIDs() (ids []int) {
	for id := range m.counterformula {
		ids = append(ids, id)
	}
	return
}

// ResetCounterformula reset all changes of the "counterformula" edge.
func (m *FormulaMutation) ResetCounterformula() {
	m.counterformula = nil
	m.clearedcounterformula = false
	m.removedcounterformula = nil
}

// Op returns the operation name.
func (m *FormulaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Formula).
func (m *FormulaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FormulaMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, formula.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, formula.FieldUpdateTime)
	}
	if m.textFormula != nil {
		fields = append(fields, formula.FieldTextFormula)
	}
	if m.status != nil {
		fields = append(fields, formula.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FormulaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case formula.FieldCreateTime:
		return m.CreateTime()
	case formula.FieldUpdateTime:
		return m.UpdateTime()
	case formula.FieldTextFormula:
		return m.TextFormula()
	case formula.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FormulaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case formula.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case formula.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case formula.FieldTextFormula:
		return m.OldTextFormula(ctx)
	case formula.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Formula field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FormulaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case formula.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case formula.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case formula.FieldTextFormula:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextFormula(v)
		return nil
	case formula.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Formula field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FormulaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FormulaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FormulaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Formula numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FormulaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FormulaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FormulaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Formula nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FormulaMutation) ResetField(name string) error {
	switch name {
	case formula.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case formula.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case formula.FieldTextFormula:
		m.ResetTextFormula()
		return nil
	case formula.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Formula field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FormulaMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.networkType != nil {
		edges = append(edges, formula.EdgeNetworkType)
	}
	if m.tech != nil {
		edges = append(edges, formula.EdgeTech)
	}
	if m.kpi != nil {
		edges = append(edges, formula.EdgeKpi)
	}
	if m.counterformula != nil {
		edges = append(edges, formula.EdgeCounterformula)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FormulaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case formula.EdgeNetworkType:
		if id := m.networkType; id != nil {
			return []ent.Value{*id}
		}
	case formula.EdgeTech:
		if id := m.tech; id != nil {
			return []ent.Value{*id}
		}
	case formula.EdgeKpi:
		if id := m.kpi; id != nil {
			return []ent.Value{*id}
		}
	case formula.EdgeCounterformula:
		ids := make([]ent.Value, 0, len(m.counterformula))
		for id := range m.counterformula {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FormulaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcounterformula != nil {
		edges = append(edges, formula.EdgeCounterformula)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FormulaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case formula.EdgeCounterformula:
		ids := make([]ent.Value, 0, len(m.removedcounterformula))
		for id := range m.removedcounterformula {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FormulaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednetworkType {
		edges = append(edges, formula.EdgeNetworkType)
	}
	if m.clearedtech {
		edges = append(edges, formula.EdgeTech)
	}
	if m.clearedkpi {
		edges = append(edges, formula.EdgeKpi)
	}
	if m.clearedcounterformula {
		edges = append(edges, formula.EdgeCounterformula)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FormulaMutation) EdgeCleared(name string) bool {
	switch name {
	case formula.EdgeNetworkType:
		return m.clearednetworkType
	case formula.EdgeTech:
		return m.clearedtech
	case formula.EdgeKpi:
		return m.clearedkpi
	case formula.EdgeCounterformula:
		return m.clearedcounterformula
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FormulaMutation) ClearEdge(name string) error {
	switch name {
	case formula.EdgeNetworkType:
		m.ClearNetworkType()
		return nil
	case formula.EdgeTech:
		m.ClearTech()
		return nil
	case formula.EdgeKpi:
		m.ClearKpi()
		return nil
	}
	return fmt.Errorf("unknown Formula unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FormulaMutation) ResetEdge(name string) error {
	switch name {
	case formula.EdgeNetworkType:
		m.ResetNetworkType()
		return nil
	case formula.EdgeTech:
		m.ResetTech()
		return nil
	case formula.EdgeKpi:
		m.ResetKpi()
		return nil
	case formula.EdgeCounterformula:
		m.ResetCounterformula()
		return nil
	}
	return fmt.Errorf("unknown Formula edge %s", name)
}

// HyperlinkMutation represents an operation that mutate the Hyperlinks
// nodes in the graph.
type HyperlinkMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	create_time              *time.Time
	update_time              *time.Time
	url                      *string
	name                     *string
	category                 *string
	clearedFields            map[string]struct{}
	equipment                *int
	clearedequipment         bool
	location                 *int
	clearedlocation          bool
	work_order               *int
	clearedwork_order        bool
	document_category        *int
	cleareddocument_category bool
	done                     bool
	oldValue                 func(context.Context) (*Hyperlink, error)
	predicates               []predicate.Hyperlink
}

var _ ent.Mutation = (*HyperlinkMutation)(nil)

// hyperlinkOption allows to manage the mutation configuration using functional options.
type hyperlinkOption func(*HyperlinkMutation)

// newHyperlinkMutation creates new mutation for Hyperlink.
func newHyperlinkMutation(c config, op Op, opts ...hyperlinkOption) *HyperlinkMutation {
	m := &HyperlinkMutation{
		config:        c,
		op:            op,
		typ:           TypeHyperlink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHyperlinkID sets the id field of the mutation.
func withHyperlinkID(id int) hyperlinkOption {
	return func(m *HyperlinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Hyperlink
		)
		m.oldValue = func(ctx context.Context) (*Hyperlink, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hyperlink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHyperlink sets the old Hyperlink of the mutation.
func withHyperlink(node *Hyperlink) hyperlinkOption {
	return func(m *HyperlinkMutation) {
		m.oldValue = func(context.Context) (*Hyperlink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HyperlinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HyperlinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HyperlinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *HyperlinkMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *HyperlinkMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Hyperlink.
// If the Hyperlink object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HyperlinkMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *HyperlinkMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *HyperlinkMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *HyperlinkMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Hyperlink.
// If the Hyperlink object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HyperlinkMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *HyperlinkMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetURL sets the url field.
func (m *HyperlinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the url value in the mutation.
func (m *HyperlinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old url value of the Hyperlink.
// If the Hyperlink object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HyperlinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL reset all changes of the "url" field.
func (m *HyperlinkMutation) ResetURL() {
	m.url = nil
}

// SetName sets the name field.
func (m *HyperlinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *HyperlinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Hyperlink.
// If the Hyperlink object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HyperlinkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *HyperlinkMutation) ClearName() {
	m.name = nil
	m.clearedFields[hyperlink.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *HyperlinkMutation) NameCleared() bool {
	_, ok := m.clearedFields[hyperlink.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *HyperlinkMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, hyperlink.FieldName)
}

// SetCategory sets the category field.
func (m *HyperlinkMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the category value in the mutation.
func (m *HyperlinkMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old category value of the Hyperlink.
// If the Hyperlink object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HyperlinkMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of category.
func (m *HyperlinkMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[hyperlink.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the field category was cleared in this mutation.
func (m *HyperlinkMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[hyperlink.FieldCategory]
	return ok
}

// ResetCategory reset all changes of the "category" field.
func (m *HyperlinkMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, hyperlink.FieldCategory)
}

// SetEquipmentID sets the equipment edge to Equipment by id.
func (m *HyperlinkMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *HyperlinkMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *HyperlinkMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the equipment id in the mutation.
func (m *HyperlinkMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *HyperlinkMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *HyperlinkMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetLocationID sets the location edge to Location by id.
func (m *HyperlinkMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *HyperlinkMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *HyperlinkMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *HyperlinkMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *HyperlinkMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *HyperlinkMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *HyperlinkMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *HyperlinkMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *HyperlinkMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *HyperlinkMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *HyperlinkMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *HyperlinkMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// SetDocumentCategoryID sets the document_category edge to DocumentCategory by id.
func (m *HyperlinkMutation) SetDocumentCategoryID(id int) {
	m.document_category = &id
}

// ClearDocumentCategory clears the document_category edge to DocumentCategory.
func (m *HyperlinkMutation) ClearDocumentCategory() {
	m.cleareddocument_category = true
}

// DocumentCategoryCleared returns if the edge document_category was cleared.
func (m *HyperlinkMutation) DocumentCategoryCleared() bool {
	return m.cleareddocument_category
}

// DocumentCategoryID returns the document_category id in the mutation.
func (m *HyperlinkMutation) DocumentCategoryID() (id int, exists bool) {
	if m.document_category != nil {
		return *m.document_category, true
	}
	return
}

// DocumentCategoryIDs returns the document_category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DocumentCategoryID instead. It exists only for internal usage by the builders.
func (m *HyperlinkMutation) DocumentCategoryIDs() (ids []int) {
	if id := m.document_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocumentCategory reset all changes of the "document_category" edge.
func (m *HyperlinkMutation) ResetDocumentCategory() {
	m.document_category = nil
	m.cleareddocument_category = false
}

// Op returns the operation name.
func (m *HyperlinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hyperlink).
func (m *HyperlinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HyperlinkMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, hyperlink.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, hyperlink.FieldUpdateTime)
	}
	if m.url != nil {
		fields = append(fields, hyperlink.FieldURL)
	}
	if m.name != nil {
		fields = append(fields, hyperlink.FieldName)
	}
	if m.category != nil {
		fields = append(fields, hyperlink.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HyperlinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hyperlink.FieldCreateTime:
		return m.CreateTime()
	case hyperlink.FieldUpdateTime:
		return m.UpdateTime()
	case hyperlink.FieldURL:
		return m.URL()
	case hyperlink.FieldName:
		return m.Name()
	case hyperlink.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HyperlinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hyperlink.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case hyperlink.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case hyperlink.FieldURL:
		return m.OldURL(ctx)
	case hyperlink.FieldName:
		return m.OldName(ctx)
	case hyperlink.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Hyperlink field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HyperlinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hyperlink.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case hyperlink.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case hyperlink.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case hyperlink.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hyperlink.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Hyperlink field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HyperlinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HyperlinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HyperlinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hyperlink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HyperlinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hyperlink.FieldName) {
		fields = append(fields, hyperlink.FieldName)
	}
	if m.FieldCleared(hyperlink.FieldCategory) {
		fields = append(fields, hyperlink.FieldCategory)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HyperlinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HyperlinkMutation) ClearField(name string) error {
	switch name {
	case hyperlink.FieldName:
		m.ClearName()
		return nil
	case hyperlink.FieldCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Hyperlink nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HyperlinkMutation) ResetField(name string) error {
	switch name {
	case hyperlink.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case hyperlink.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case hyperlink.FieldURL:
		m.ResetURL()
		return nil
	case hyperlink.FieldName:
		m.ResetName()
		return nil
	case hyperlink.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Hyperlink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HyperlinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.equipment != nil {
		edges = append(edges, hyperlink.EdgeEquipment)
	}
	if m.location != nil {
		edges = append(edges, hyperlink.EdgeLocation)
	}
	if m.work_order != nil {
		edges = append(edges, hyperlink.EdgeWorkOrder)
	}
	if m.document_category != nil {
		edges = append(edges, hyperlink.EdgeDocumentCategory)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HyperlinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hyperlink.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case hyperlink.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case hyperlink.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	case hyperlink.EdgeDocumentCategory:
		if id := m.document_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HyperlinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HyperlinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HyperlinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedequipment {
		edges = append(edges, hyperlink.EdgeEquipment)
	}
	if m.clearedlocation {
		edges = append(edges, hyperlink.EdgeLocation)
	}
	if m.clearedwork_order {
		edges = append(edges, hyperlink.EdgeWorkOrder)
	}
	if m.cleareddocument_category {
		edges = append(edges, hyperlink.EdgeDocumentCategory)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HyperlinkMutation) EdgeCleared(name string) bool {
	switch name {
	case hyperlink.EdgeEquipment:
		return m.clearedequipment
	case hyperlink.EdgeLocation:
		return m.clearedlocation
	case hyperlink.EdgeWorkOrder:
		return m.clearedwork_order
	case hyperlink.EdgeDocumentCategory:
		return m.cleareddocument_category
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HyperlinkMutation) ClearEdge(name string) error {
	switch name {
	case hyperlink.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case hyperlink.EdgeLocation:
		m.ClearLocation()
		return nil
	case hyperlink.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	case hyperlink.EdgeDocumentCategory:
		m.ClearDocumentCategory()
		return nil
	}
	return fmt.Errorf("unknown Hyperlink unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HyperlinkMutation) ResetEdge(name string) error {
	switch name {
	case hyperlink.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case hyperlink.EdgeLocation:
		m.ResetLocation()
		return nil
	case hyperlink.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	case hyperlink.EdgeDocumentCategory:
		m.ResetDocumentCategory()
		return nil
	}
	return fmt.Errorf("unknown Hyperlink edge %s", name)
}

// KpiMutation represents an operation that mutate the Kpis
// nodes in the graph.
type KpiMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	description         *string
	status              *bool
	clearedFields       map[string]struct{}
	domain              *int
	cleareddomain       bool
	_KpiCategory        *int
	cleared_KpiCategory bool
	formulakpi          map[int]struct{}
	removedformulakpi   map[int]struct{}
	clearedformulakpi   bool
	thresholdkpi        *int
	clearedthresholdkpi bool
	done                bool
	oldValue            func(context.Context) (*Kpi, error)
	predicates          []predicate.Kpi
}

var _ ent.Mutation = (*KpiMutation)(nil)

// kpiOption allows to manage the mutation configuration using functional options.
type kpiOption func(*KpiMutation)

// newKpiMutation creates new mutation for Kpi.
func newKpiMutation(c config, op Op, opts ...kpiOption) *KpiMutation {
	m := &KpiMutation{
		config:        c,
		op:            op,
		typ:           TypeKpi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKpiID sets the id field of the mutation.
func withKpiID(id int) kpiOption {
	return func(m *KpiMutation) {
		var (
			err   error
			once  sync.Once
			value *Kpi
		)
		m.oldValue = func(ctx context.Context) (*Kpi, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kpi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKpi sets the old Kpi of the mutation.
func withKpi(node *Kpi) kpiOption {
	return func(m *KpiMutation) {
		m.oldValue = func(context.Context) (*Kpi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KpiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KpiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KpiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KpiMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KpiMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Kpi.
// If the Kpi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KpiMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KpiMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KpiMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Kpi.
// If the Kpi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KpiMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KpiMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KpiMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Kpi.
// If the Kpi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KpiMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *KpiMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *KpiMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Kpi.
// If the Kpi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *KpiMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the status field.
func (m *KpiMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the status value in the mutation.
func (m *KpiMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Kpi.
// If the Kpi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *KpiMutation) ResetStatus() {
	m.status = nil
}

// SetDomainID sets the domain edge to Domain by id.
func (m *KpiMutation) SetDomainID(id int) {
	m.domain = &id
}

// ClearDomain clears the domain edge to Domain.
func (m *KpiMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared returns if the edge domain was cleared.
func (m *KpiMutation) DomainCleared() bool {
	return m.cleareddomain
}

// DomainID returns the domain id in the mutation.
func (m *KpiMutation) DomainID() (id int, exists bool) {
	if m.domain != nil {
		return *m.domain, true
	}
	return
}

// DomainIDs returns the domain ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DomainID instead. It exists only for internal usage by the builders.
func (m *KpiMutation) DomainIDs() (ids []int) {
	if id := m.domain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomain reset all changes of the "domain" edge.
func (m *KpiMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
}

// SetKpiCategoryID sets the KpiCategory edge to KpiCategory by id.
func (m *KpiMutation) SetKpiCategoryID(id int) {
	m._KpiCategory = &id
}

// ClearKpiCategory clears the KpiCategory edge to KpiCategory.
func (m *KpiMutation) ClearKpiCategory() {
	m.cleared_KpiCategory = true
}

// KpiCategoryCleared returns if the edge KpiCategory was cleared.
func (m *KpiMutation) KpiCategoryCleared() bool {
	return m.cleared_KpiCategory
}

// KpiCategoryID returns the KpiCategory id in the mutation.
func (m *KpiMutation) KpiCategoryID() (id int, exists bool) {
	if m._KpiCategory != nil {
		return *m._KpiCategory, true
	}
	return
}

// KpiCategoryIDs returns the KpiCategory ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KpiCategoryID instead. It exists only for internal usage by the builders.
func (m *KpiMutation) KpiCategoryIDs() (ids []int) {
	if id := m._KpiCategory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKpiCategory reset all changes of the "KpiCategory" edge.
func (m *KpiMutation) ResetKpiCategory() {
	m._KpiCategory = nil
	m.cleared_KpiCategory = false
}

// AddFormulakpiIDs adds the formulakpi edge to Formula by ids.
func (m *KpiMutation) AddFormulakpiIDs(ids ...int) {
	if m.formulakpi == nil {
		m.formulakpi = make(map[int]struct{})
	}
	for i := range ids {
		m.formulakpi[ids[i]] = struct{}{}
	}
}

// ClearFormulakpi clears the formulakpi edge to Formula.
func (m *KpiMutation) ClearFormulakpi() {
	m.clearedformulakpi = true
}

// FormulakpiCleared returns if the edge formulakpi was cleared.
func (m *KpiMutation) FormulakpiCleared() bool {
	return m.clearedformulakpi
}

// RemoveFormulakpiIDs removes the formulakpi edge to Formula by ids.
func (m *KpiMutation) RemoveFormulakpiIDs(ids ...int) {
	if m.removedformulakpi == nil {
		m.removedformulakpi = make(map[int]struct{})
	}
	for i := range ids {
		m.removedformulakpi[ids[i]] = struct{}{}
	}
}

// RemovedFormulakpi returns the removed ids of formulakpi.
func (m *KpiMutation) RemovedFormulakpiIDs() (ids []int) {
	for id := range m.removedformulakpi {
		ids = append(ids, id)
	}
	return
}

// FormulakpiIDs returns the formulakpi ids in the mutation.
func (m *KpiMutation) FormulakpiIDs() (ids []int) {
	for id := range m.formulakpi {
		ids = append(ids, id)
	}
	return
}

// ResetFormulakpi reset all changes of the "formulakpi" edge.
func (m *KpiMutation) ResetFormulakpi() {
	m.formulakpi = nil
	m.clearedformulakpi = false
	m.removedformulakpi = nil
}

// SetThresholdkpiID sets the thresholdkpi edge to Threshold by id.
func (m *KpiMutation) SetThresholdkpiID(id int) {
	m.thresholdkpi = &id
}

// ClearThresholdkpi clears the thresholdkpi edge to Threshold.
func (m *KpiMutation) ClearThresholdkpi() {
	m.clearedthresholdkpi = true
}

// ThresholdkpiCleared returns if the edge thresholdkpi was cleared.
func (m *KpiMutation) ThresholdkpiCleared() bool {
	return m.clearedthresholdkpi
}

// ThresholdkpiID returns the thresholdkpi id in the mutation.
func (m *KpiMutation) ThresholdkpiID() (id int, exists bool) {
	if m.thresholdkpi != nil {
		return *m.thresholdkpi, true
	}
	return
}

// ThresholdkpiIDs returns the thresholdkpi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ThresholdkpiID instead. It exists only for internal usage by the builders.
func (m *KpiMutation) ThresholdkpiIDs() (ids []int) {
	if id := m.thresholdkpi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThresholdkpi reset all changes of the "thresholdkpi" edge.
func (m *KpiMutation) ResetThresholdkpi() {
	m.thresholdkpi = nil
	m.clearedthresholdkpi = false
}

// Op returns the operation name.
func (m *KpiMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Kpi).
func (m *KpiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KpiMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, kpi.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kpi.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kpi.FieldName)
	}
	if m.description != nil {
		fields = append(fields, kpi.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, kpi.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KpiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kpi.FieldCreateTime:
		return m.CreateTime()
	case kpi.FieldUpdateTime:
		return m.UpdateTime()
	case kpi.FieldName:
		return m.Name()
	case kpi.FieldDescription:
		return m.Description()
	case kpi.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KpiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kpi.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kpi.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kpi.FieldName:
		return m.OldName(ctx)
	case kpi.FieldDescription:
		return m.OldDescription(ctx)
	case kpi.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Kpi field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KpiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kpi.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kpi.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kpi.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case kpi.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case kpi.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Kpi field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KpiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KpiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KpiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Kpi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KpiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KpiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KpiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Kpi nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KpiMutation) ResetField(name string) error {
	switch name {
	case kpi.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kpi.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kpi.FieldName:
		m.ResetName()
		return nil
	case kpi.FieldDescription:
		m.ResetDescription()
		return nil
	case kpi.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Kpi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KpiMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.domain != nil {
		edges = append(edges, kpi.EdgeDomain)
	}
	if m._KpiCategory != nil {
		edges = append(edges, kpi.EdgeKpiCategory)
	}
	if m.formulakpi != nil {
		edges = append(edges, kpi.EdgeFormulakpi)
	}
	if m.thresholdkpi != nil {
		edges = append(edges, kpi.EdgeThresholdkpi)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KpiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kpi.EdgeDomain:
		if id := m.domain; id != nil {
			return []ent.Value{*id}
		}
	case kpi.EdgeKpiCategory:
		if id := m._KpiCategory; id != nil {
			return []ent.Value{*id}
		}
	case kpi.EdgeFormulakpi:
		ids := make([]ent.Value, 0, len(m.formulakpi))
		for id := range m.formulakpi {
			ids = append(ids, id)
		}
		return ids
	case kpi.EdgeThresholdkpi:
		if id := m.thresholdkpi; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KpiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedformulakpi != nil {
		edges = append(edges, kpi.EdgeFormulakpi)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KpiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kpi.EdgeFormulakpi:
		ids := make([]ent.Value, 0, len(m.removedformulakpi))
		for id := range m.removedformulakpi {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KpiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddomain {
		edges = append(edges, kpi.EdgeDomain)
	}
	if m.cleared_KpiCategory {
		edges = append(edges, kpi.EdgeKpiCategory)
	}
	if m.clearedformulakpi {
		edges = append(edges, kpi.EdgeFormulakpi)
	}
	if m.clearedthresholdkpi {
		edges = append(edges, kpi.EdgeThresholdkpi)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KpiMutation) EdgeCleared(name string) bool {
	switch name {
	case kpi.EdgeDomain:
		return m.cleareddomain
	case kpi.EdgeKpiCategory:
		return m.cleared_KpiCategory
	case kpi.EdgeFormulakpi:
		return m.clearedformulakpi
	case kpi.EdgeThresholdkpi:
		return m.clearedthresholdkpi
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KpiMutation) ClearEdge(name string) error {
	switch name {
	case kpi.EdgeDomain:
		m.ClearDomain()
		return nil
	case kpi.EdgeKpiCategory:
		m.ClearKpiCategory()
		return nil
	case kpi.EdgeThresholdkpi:
		m.ClearThresholdkpi()
		return nil
	}
	return fmt.Errorf("unknown Kpi unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KpiMutation) ResetEdge(name string) error {
	switch name {
	case kpi.EdgeDomain:
		m.ResetDomain()
		return nil
	case kpi.EdgeKpiCategory:
		m.ResetKpiCategory()
		return nil
	case kpi.EdgeFormulakpi:
		m.ResetFormulakpi()
		return nil
	case kpi.EdgeThresholdkpi:
		m.ResetThresholdkpi()
		return nil
	}
	return fmt.Errorf("unknown Kpi edge %s", name)
}

// KpiCategoryMutation represents an operation that mutate the KpiCategories
// nodes in the graph.
type KpiCategoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	clearedFields      map[string]struct{}
	kpicategory        map[int]struct{}
	removedkpicategory map[int]struct{}
	clearedkpicategory bool
	done               bool
	oldValue           func(context.Context) (*KpiCategory, error)
	predicates         []predicate.KpiCategory
}

var _ ent.Mutation = (*KpiCategoryMutation)(nil)

// kpicategoryOption allows to manage the mutation configuration using functional options.
type kpicategoryOption func(*KpiCategoryMutation)

// newKpiCategoryMutation creates new mutation for KpiCategory.
func newKpiCategoryMutation(c config, op Op, opts ...kpicategoryOption) *KpiCategoryMutation {
	m := &KpiCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeKpiCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKpiCategoryID sets the id field of the mutation.
func withKpiCategoryID(id int) kpicategoryOption {
	return func(m *KpiCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *KpiCategory
		)
		m.oldValue = func(ctx context.Context) (*KpiCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KpiCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKpiCategory sets the old KpiCategory of the mutation.
func withKpiCategory(node *KpiCategory) kpicategoryOption {
	return func(m *KpiCategoryMutation) {
		m.oldValue = func(context.Context) (*KpiCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KpiCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KpiCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KpiCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KpiCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KpiCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the KpiCategory.
// If the KpiCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KpiCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KpiCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KpiCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the KpiCategory.
// If the KpiCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KpiCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KpiCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KpiCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the KpiCategory.
// If the KpiCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KpiCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KpiCategoryMutation) ResetName() {
	m.name = nil
}

// AddKpicategoryIDs adds the kpicategory edge to Kpi by ids.
func (m *KpiCategoryMutation) AddKpicategoryIDs(ids ...int) {
	if m.kpicategory == nil {
		m.kpicategory = make(map[int]struct{})
	}
	for i := range ids {
		m.kpicategory[ids[i]] = struct{}{}
	}
}

// ClearKpicategory clears the kpicategory edge to Kpi.
func (m *KpiCategoryMutation) ClearKpicategory() {
	m.clearedkpicategory = true
}

// KpicategoryCleared returns if the edge kpicategory was cleared.
func (m *KpiCategoryMutation) KpicategoryCleared() bool {
	return m.clearedkpicategory
}

// RemoveKpicategoryIDs removes the kpicategory edge to Kpi by ids.
func (m *KpiCategoryMutation) RemoveKpicategoryIDs(ids ...int) {
	if m.removedkpicategory == nil {
		m.removedkpicategory = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkpicategory[ids[i]] = struct{}{}
	}
}

// RemovedKpicategory returns the removed ids of kpicategory.
func (m *KpiCategoryMutation) RemovedKpicategoryIDs() (ids []int) {
	for id := range m.removedkpicategory {
		ids = append(ids, id)
	}
	return
}

// KpicategoryIDs returns the kpicategory ids in the mutation.
func (m *KpiCategoryMutation) KpicategoryIDs() (ids []int) {
	for id := range m.kpicategory {
		ids = append(ids, id)
	}
	return
}

// ResetKpicategory reset all changes of the "kpicategory" edge.
func (m *KpiCategoryMutation) ResetKpicategory() {
	m.kpicategory = nil
	m.clearedkpicategory = false
	m.removedkpicategory = nil
}

// Op returns the operation name.
func (m *KpiCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KpiCategory).
func (m *KpiCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KpiCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, kpicategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kpicategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kpicategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KpiCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kpicategory.FieldCreateTime:
		return m.CreateTime()
	case kpicategory.FieldUpdateTime:
		return m.UpdateTime()
	case kpicategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KpiCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kpicategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kpicategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kpicategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown KpiCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KpiCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kpicategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kpicategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kpicategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown KpiCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KpiCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KpiCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KpiCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KpiCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KpiCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KpiCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KpiCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KpiCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KpiCategoryMutation) ResetField(name string) error {
	switch name {
	case kpicategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kpicategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kpicategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown KpiCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KpiCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.kpicategory != nil {
		edges = append(edges, kpicategory.EdgeKpicategory)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KpiCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kpicategory.EdgeKpicategory:
		ids := make([]ent.Value, 0, len(m.kpicategory))
		for id := range m.kpicategory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KpiCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedkpicategory != nil {
		edges = append(edges, kpicategory.EdgeKpicategory)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KpiCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kpicategory.EdgeKpicategory:
		ids := make([]ent.Value, 0, len(m.removedkpicategory))
		for id := range m.removedkpicategory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KpiCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkpicategory {
		edges = append(edges, kpicategory.EdgeKpicategory)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KpiCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case kpicategory.EdgeKpicategory:
		return m.clearedkpicategory
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KpiCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown KpiCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KpiCategoryMutation) ResetEdge(name string) error {
	switch name {
	case kpicategory.EdgeKpicategory:
		m.ResetKpicategory()
		return nil
	}
	return fmt.Errorf("unknown KpiCategory edge %s", name)
}

// KqiMutation represents an operation that mutate the Kqis
// nodes in the graph.
type KqiMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	name                          *string
	description                   *string
	startDateTime                 *time.Time
	endDateTime                   *time.Time
	formula                       *string
	clearedFields                 map[string]struct{}
	kqiCategoryFk                 *int
	clearedkqiCategoryFk          bool
	kqiPerspectiveFk              *int
	clearedkqiPerspectiveFk       bool
	kqiSourceFk                   *int
	clearedkqiSourceFk            bool
	kqiTemporalFrequencyFk        *int
	clearedkqiTemporalFrequencyFk bool
	kqiTargetFk                   map[int]struct{}
	removedkqiTargetFk            map[int]struct{}
	clearedkqiTargetFk            bool
	done                          bool
	oldValue                      func(context.Context) (*Kqi, error)
	predicates                    []predicate.Kqi
}

var _ ent.Mutation = (*KqiMutation)(nil)

// kqiOption allows to manage the mutation configuration using functional options.
type kqiOption func(*KqiMutation)

// newKqiMutation creates new mutation for Kqi.
func newKqiMutation(c config, op Op, opts ...kqiOption) *KqiMutation {
	m := &KqiMutation{
		config:        c,
		op:            op,
		typ:           TypeKqi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKqiID sets the id field of the mutation.
func withKqiID(id int) kqiOption {
	return func(m *KqiMutation) {
		var (
			err   error
			once  sync.Once
			value *Kqi
		)
		m.oldValue = func(ctx context.Context) (*Kqi, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kqi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKqi sets the old Kqi of the mutation.
func withKqi(node *Kqi) kqiOption {
	return func(m *KqiMutation) {
		m.oldValue = func(context.Context) (*Kqi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KqiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KqiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KqiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KqiMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KqiMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Kqi.
// If the Kqi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KqiMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KqiMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KqiMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Kqi.
// If the Kqi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KqiMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KqiMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KqiMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Kqi.
// If the Kqi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KqiMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *KqiMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *KqiMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Kqi.
// If the Kqi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *KqiMutation) ResetDescription() {
	m.description = nil
}

// SetStartDateTime sets the startDateTime field.
func (m *KqiMutation) SetStartDateTime(t time.Time) {
	m.startDateTime = &t
}

// StartDateTime returns the startDateTime value in the mutation.
func (m *KqiMutation) StartDateTime() (r time.Time, exists bool) {
	v := m.startDateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDateTime returns the old startDateTime value of the Kqi.
// If the Kqi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiMutation) OldStartDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDateTime: %w", err)
	}
	return oldValue.StartDateTime, nil
}

// ResetStartDateTime reset all changes of the "startDateTime" field.
func (m *KqiMutation) ResetStartDateTime() {
	m.startDateTime = nil
}

// SetEndDateTime sets the endDateTime field.
func (m *KqiMutation) SetEndDateTime(t time.Time) {
	m.endDateTime = &t
}

// EndDateTime returns the endDateTime value in the mutation.
func (m *KqiMutation) EndDateTime() (r time.Time, exists bool) {
	v := m.endDateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDateTime returns the old endDateTime value of the Kqi.
// If the Kqi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiMutation) OldEndDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndDateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDateTime: %w", err)
	}
	return oldValue.EndDateTime, nil
}

// ResetEndDateTime reset all changes of the "endDateTime" field.
func (m *KqiMutation) ResetEndDateTime() {
	m.endDateTime = nil
}

// SetFormula sets the formula field.
func (m *KqiMutation) SetFormula(s string) {
	m.formula = &s
}

// Formula returns the formula value in the mutation.
func (m *KqiMutation) Formula() (r string, exists bool) {
	v := m.formula
	if v == nil {
		return
	}
	return *v, true
}

// OldFormula returns the old formula value of the Kqi.
// If the Kqi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiMutation) OldFormula(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormula is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormula requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormula: %w", err)
	}
	return oldValue.Formula, nil
}

// ResetFormula reset all changes of the "formula" field.
func (m *KqiMutation) ResetFormula() {
	m.formula = nil
}

// SetKqiCategoryFkID sets the kqiCategoryFk edge to KqiCategory by id.
func (m *KqiMutation) SetKqiCategoryFkID(id int) {
	m.kqiCategoryFk = &id
}

// ClearKqiCategoryFk clears the kqiCategoryFk edge to KqiCategory.
func (m *KqiMutation) ClearKqiCategoryFk() {
	m.clearedkqiCategoryFk = true
}

// KqiCategoryFkCleared returns if the edge kqiCategoryFk was cleared.
func (m *KqiMutation) KqiCategoryFkCleared() bool {
	return m.clearedkqiCategoryFk
}

// KqiCategoryFkID returns the kqiCategoryFk id in the mutation.
func (m *KqiMutation) KqiCategoryFkID() (id int, exists bool) {
	if m.kqiCategoryFk != nil {
		return *m.kqiCategoryFk, true
	}
	return
}

// KqiCategoryFkIDs returns the kqiCategoryFk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KqiCategoryFkID instead. It exists only for internal usage by the builders.
func (m *KqiMutation) KqiCategoryFkIDs() (ids []int) {
	if id := m.kqiCategoryFk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKqiCategoryFk reset all changes of the "kqiCategoryFk" edge.
func (m *KqiMutation) ResetKqiCategoryFk() {
	m.kqiCategoryFk = nil
	m.clearedkqiCategoryFk = false
}

// SetKqiPerspectiveFkID sets the kqiPerspectiveFk edge to KqiPerspective by id.
func (m *KqiMutation) SetKqiPerspectiveFkID(id int) {
	m.kqiPerspectiveFk = &id
}

// ClearKqiPerspectiveFk clears the kqiPerspectiveFk edge to KqiPerspective.
func (m *KqiMutation) ClearKqiPerspectiveFk() {
	m.clearedkqiPerspectiveFk = true
}

// KqiPerspectiveFkCleared returns if the edge kqiPerspectiveFk was cleared.
func (m *KqiMutation) KqiPerspectiveFkCleared() bool {
	return m.clearedkqiPerspectiveFk
}

// KqiPerspectiveFkID returns the kqiPerspectiveFk id in the mutation.
func (m *KqiMutation) KqiPerspectiveFkID() (id int, exists bool) {
	if m.kqiPerspectiveFk != nil {
		return *m.kqiPerspectiveFk, true
	}
	return
}

// KqiPerspectiveFkIDs returns the kqiPerspectiveFk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KqiPerspectiveFkID instead. It exists only for internal usage by the builders.
func (m *KqiMutation) KqiPerspectiveFkIDs() (ids []int) {
	if id := m.kqiPerspectiveFk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKqiPerspectiveFk reset all changes of the "kqiPerspectiveFk" edge.
func (m *KqiMutation) ResetKqiPerspectiveFk() {
	m.kqiPerspectiveFk = nil
	m.clearedkqiPerspectiveFk = false
}

// SetKqiSourceFkID sets the kqiSourceFk edge to KqiSource by id.
func (m *KqiMutation) SetKqiSourceFkID(id int) {
	m.kqiSourceFk = &id
}

// ClearKqiSourceFk clears the kqiSourceFk edge to KqiSource.
func (m *KqiMutation) ClearKqiSourceFk() {
	m.clearedkqiSourceFk = true
}

// KqiSourceFkCleared returns if the edge kqiSourceFk was cleared.
func (m *KqiMutation) KqiSourceFkCleared() bool {
	return m.clearedkqiSourceFk
}

// KqiSourceFkID returns the kqiSourceFk id in the mutation.
func (m *KqiMutation) KqiSourceFkID() (id int, exists bool) {
	if m.kqiSourceFk != nil {
		return *m.kqiSourceFk, true
	}
	return
}

// KqiSourceFkIDs returns the kqiSourceFk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KqiSourceFkID instead. It exists only for internal usage by the builders.
func (m *KqiMutation) KqiSourceFkIDs() (ids []int) {
	if id := m.kqiSourceFk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKqiSourceFk reset all changes of the "kqiSourceFk" edge.
func (m *KqiMutation) ResetKqiSourceFk() {
	m.kqiSourceFk = nil
	m.clearedkqiSourceFk = false
}

// SetKqiTemporalFrequencyFkID sets the kqiTemporalFrequencyFk edge to KqiTemporalFrequency by id.
func (m *KqiMutation) SetKqiTemporalFrequencyFkID(id int) {
	m.kqiTemporalFrequencyFk = &id
}

// ClearKqiTemporalFrequencyFk clears the kqiTemporalFrequencyFk edge to KqiTemporalFrequency.
func (m *KqiMutation) ClearKqiTemporalFrequencyFk() {
	m.clearedkqiTemporalFrequencyFk = true
}

// KqiTemporalFrequencyFkCleared returns if the edge kqiTemporalFrequencyFk was cleared.
func (m *KqiMutation) KqiTemporalFrequencyFkCleared() bool {
	return m.clearedkqiTemporalFrequencyFk
}

// KqiTemporalFrequencyFkID returns the kqiTemporalFrequencyFk id in the mutation.
func (m *KqiMutation) KqiTemporalFrequencyFkID() (id int, exists bool) {
	if m.kqiTemporalFrequencyFk != nil {
		return *m.kqiTemporalFrequencyFk, true
	}
	return
}

// KqiTemporalFrequencyFkIDs returns the kqiTemporalFrequencyFk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KqiTemporalFrequencyFkID instead. It exists only for internal usage by the builders.
func (m *KqiMutation) KqiTemporalFrequencyFkIDs() (ids []int) {
	if id := m.kqiTemporalFrequencyFk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKqiTemporalFrequencyFk reset all changes of the "kqiTemporalFrequencyFk" edge.
func (m *KqiMutation) ResetKqiTemporalFrequencyFk() {
	m.kqiTemporalFrequencyFk = nil
	m.clearedkqiTemporalFrequencyFk = false
}

// AddKqiTargetFkIDs adds the kqiTargetFk edge to KqiTarget by ids.
func (m *KqiMutation) AddKqiTargetFkIDs(ids ...int) {
	if m.kqiTargetFk == nil {
		m.kqiTargetFk = make(map[int]struct{})
	}
	for i := range ids {
		m.kqiTargetFk[ids[i]] = struct{}{}
	}
}

// ClearKqiTargetFk clears the kqiTargetFk edge to KqiTarget.
func (m *KqiMutation) ClearKqiTargetFk() {
	m.clearedkqiTargetFk = true
}

// KqiTargetFkCleared returns if the edge kqiTargetFk was cleared.
func (m *KqiMutation) KqiTargetFkCleared() bool {
	return m.clearedkqiTargetFk
}

// RemoveKqiTargetFkIDs removes the kqiTargetFk edge to KqiTarget by ids.
func (m *KqiMutation) RemoveKqiTargetFkIDs(ids ...int) {
	if m.removedkqiTargetFk == nil {
		m.removedkqiTargetFk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkqiTargetFk[ids[i]] = struct{}{}
	}
}

// RemovedKqiTargetFk returns the removed ids of kqiTargetFk.
func (m *KqiMutation) RemovedKqiTargetFkIDs() (ids []int) {
	for id := range m.removedkqiTargetFk {
		ids = append(ids, id)
	}
	return
}

// KqiTargetFkIDs returns the kqiTargetFk ids in the mutation.
func (m *KqiMutation) KqiTargetFkIDs() (ids []int) {
	for id := range m.kqiTargetFk {
		ids = append(ids, id)
	}
	return
}

// ResetKqiTargetFk reset all changes of the "kqiTargetFk" edge.
func (m *KqiMutation) ResetKqiTargetFk() {
	m.kqiTargetFk = nil
	m.clearedkqiTargetFk = false
	m.removedkqiTargetFk = nil
}

// Op returns the operation name.
func (m *KqiMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Kqi).
func (m *KqiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KqiMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, kqi.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kqi.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kqi.FieldName)
	}
	if m.description != nil {
		fields = append(fields, kqi.FieldDescription)
	}
	if m.startDateTime != nil {
		fields = append(fields, kqi.FieldStartDateTime)
	}
	if m.endDateTime != nil {
		fields = append(fields, kqi.FieldEndDateTime)
	}
	if m.formula != nil {
		fields = append(fields, kqi.FieldFormula)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KqiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kqi.FieldCreateTime:
		return m.CreateTime()
	case kqi.FieldUpdateTime:
		return m.UpdateTime()
	case kqi.FieldName:
		return m.Name()
	case kqi.FieldDescription:
		return m.Description()
	case kqi.FieldStartDateTime:
		return m.StartDateTime()
	case kqi.FieldEndDateTime:
		return m.EndDateTime()
	case kqi.FieldFormula:
		return m.Formula()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KqiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kqi.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kqi.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kqi.FieldName:
		return m.OldName(ctx)
	case kqi.FieldDescription:
		return m.OldDescription(ctx)
	case kqi.FieldStartDateTime:
		return m.OldStartDateTime(ctx)
	case kqi.FieldEndDateTime:
		return m.OldEndDateTime(ctx)
	case kqi.FieldFormula:
		return m.OldFormula(ctx)
	}
	return nil, fmt.Errorf("unknown Kqi field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kqi.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kqi.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kqi.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case kqi.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case kqi.FieldStartDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDateTime(v)
		return nil
	case kqi.FieldEndDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDateTime(v)
		return nil
	case kqi.FieldFormula:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormula(v)
		return nil
	}
	return fmt.Errorf("unknown Kqi field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KqiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KqiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Kqi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KqiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KqiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KqiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Kqi nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KqiMutation) ResetField(name string) error {
	switch name {
	case kqi.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kqi.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kqi.FieldName:
		m.ResetName()
		return nil
	case kqi.FieldDescription:
		m.ResetDescription()
		return nil
	case kqi.FieldStartDateTime:
		m.ResetStartDateTime()
		return nil
	case kqi.FieldEndDateTime:
		m.ResetEndDateTime()
		return nil
	case kqi.FieldFormula:
		m.ResetFormula()
		return nil
	}
	return fmt.Errorf("unknown Kqi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KqiMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.kqiCategoryFk != nil {
		edges = append(edges, kqi.EdgeKqiCategoryFk)
	}
	if m.kqiPerspectiveFk != nil {
		edges = append(edges, kqi.EdgeKqiPerspectiveFk)
	}
	if m.kqiSourceFk != nil {
		edges = append(edges, kqi.EdgeKqiSourceFk)
	}
	if m.kqiTemporalFrequencyFk != nil {
		edges = append(edges, kqi.EdgeKqiTemporalFrequencyFk)
	}
	if m.kqiTargetFk != nil {
		edges = append(edges, kqi.EdgeKqiTargetFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KqiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kqi.EdgeKqiCategoryFk:
		if id := m.kqiCategoryFk; id != nil {
			return []ent.Value{*id}
		}
	case kqi.EdgeKqiPerspectiveFk:
		if id := m.kqiPerspectiveFk; id != nil {
			return []ent.Value{*id}
		}
	case kqi.EdgeKqiSourceFk:
		if id := m.kqiSourceFk; id != nil {
			return []ent.Value{*id}
		}
	case kqi.EdgeKqiTemporalFrequencyFk:
		if id := m.kqiTemporalFrequencyFk; id != nil {
			return []ent.Value{*id}
		}
	case kqi.EdgeKqiTargetFk:
		ids := make([]ent.Value, 0, len(m.kqiTargetFk))
		for id := range m.kqiTargetFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KqiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedkqiTargetFk != nil {
		edges = append(edges, kqi.EdgeKqiTargetFk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KqiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kqi.EdgeKqiTargetFk:
		ids := make([]ent.Value, 0, len(m.removedkqiTargetFk))
		for id := range m.removedkqiTargetFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KqiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedkqiCategoryFk {
		edges = append(edges, kqi.EdgeKqiCategoryFk)
	}
	if m.clearedkqiPerspectiveFk {
		edges = append(edges, kqi.EdgeKqiPerspectiveFk)
	}
	if m.clearedkqiSourceFk {
		edges = append(edges, kqi.EdgeKqiSourceFk)
	}
	if m.clearedkqiTemporalFrequencyFk {
		edges = append(edges, kqi.EdgeKqiTemporalFrequencyFk)
	}
	if m.clearedkqiTargetFk {
		edges = append(edges, kqi.EdgeKqiTargetFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KqiMutation) EdgeCleared(name string) bool {
	switch name {
	case kqi.EdgeKqiCategoryFk:
		return m.clearedkqiCategoryFk
	case kqi.EdgeKqiPerspectiveFk:
		return m.clearedkqiPerspectiveFk
	case kqi.EdgeKqiSourceFk:
		return m.clearedkqiSourceFk
	case kqi.EdgeKqiTemporalFrequencyFk:
		return m.clearedkqiTemporalFrequencyFk
	case kqi.EdgeKqiTargetFk:
		return m.clearedkqiTargetFk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KqiMutation) ClearEdge(name string) error {
	switch name {
	case kqi.EdgeKqiCategoryFk:
		m.ClearKqiCategoryFk()
		return nil
	case kqi.EdgeKqiPerspectiveFk:
		m.ClearKqiPerspectiveFk()
		return nil
	case kqi.EdgeKqiSourceFk:
		m.ClearKqiSourceFk()
		return nil
	case kqi.EdgeKqiTemporalFrequencyFk:
		m.ClearKqiTemporalFrequencyFk()
		return nil
	}
	return fmt.Errorf("unknown Kqi unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KqiMutation) ResetEdge(name string) error {
	switch name {
	case kqi.EdgeKqiCategoryFk:
		m.ResetKqiCategoryFk()
		return nil
	case kqi.EdgeKqiPerspectiveFk:
		m.ResetKqiPerspectiveFk()
		return nil
	case kqi.EdgeKqiSourceFk:
		m.ResetKqiSourceFk()
		return nil
	case kqi.EdgeKqiTemporalFrequencyFk:
		m.ResetKqiTemporalFrequencyFk()
		return nil
	case kqi.EdgeKqiTargetFk:
		m.ResetKqiTargetFk()
		return nil
	}
	return fmt.Errorf("unknown Kqi edge %s", name)
}

// KqiCategoryMutation represents an operation that mutate the KqiCategories
// nodes in the graph.
type KqiCategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	clearedFields        map[string]struct{}
	kqiCategoryFk        map[int]struct{}
	removedkqiCategoryFk map[int]struct{}
	clearedkqiCategoryFk bool
	done                 bool
	oldValue             func(context.Context) (*KqiCategory, error)
	predicates           []predicate.KqiCategory
}

var _ ent.Mutation = (*KqiCategoryMutation)(nil)

// kqicategoryOption allows to manage the mutation configuration using functional options.
type kqicategoryOption func(*KqiCategoryMutation)

// newKqiCategoryMutation creates new mutation for KqiCategory.
func newKqiCategoryMutation(c config, op Op, opts ...kqicategoryOption) *KqiCategoryMutation {
	m := &KqiCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeKqiCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKqiCategoryID sets the id field of the mutation.
func withKqiCategoryID(id int) kqicategoryOption {
	return func(m *KqiCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *KqiCategory
		)
		m.oldValue = func(ctx context.Context) (*KqiCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KqiCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKqiCategory sets the old KqiCategory of the mutation.
func withKqiCategory(node *KqiCategory) kqicategoryOption {
	return func(m *KqiCategoryMutation) {
		m.oldValue = func(context.Context) (*KqiCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KqiCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KqiCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KqiCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KqiCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KqiCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the KqiCategory.
// If the KqiCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KqiCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KqiCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KqiCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the KqiCategory.
// If the KqiCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KqiCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KqiCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KqiCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the KqiCategory.
// If the KqiCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KqiCategoryMutation) ResetName() {
	m.name = nil
}

// AddKqiCategoryFkIDs adds the kqiCategoryFk edge to Kqi by ids.
func (m *KqiCategoryMutation) AddKqiCategoryFkIDs(ids ...int) {
	if m.kqiCategoryFk == nil {
		m.kqiCategoryFk = make(map[int]struct{})
	}
	for i := range ids {
		m.kqiCategoryFk[ids[i]] = struct{}{}
	}
}

// ClearKqiCategoryFk clears the kqiCategoryFk edge to Kqi.
func (m *KqiCategoryMutation) ClearKqiCategoryFk() {
	m.clearedkqiCategoryFk = true
}

// KqiCategoryFkCleared returns if the edge kqiCategoryFk was cleared.
func (m *KqiCategoryMutation) KqiCategoryFkCleared() bool {
	return m.clearedkqiCategoryFk
}

// RemoveKqiCategoryFkIDs removes the kqiCategoryFk edge to Kqi by ids.
func (m *KqiCategoryMutation) RemoveKqiCategoryFkIDs(ids ...int) {
	if m.removedkqiCategoryFk == nil {
		m.removedkqiCategoryFk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkqiCategoryFk[ids[i]] = struct{}{}
	}
}

// RemovedKqiCategoryFk returns the removed ids of kqiCategoryFk.
func (m *KqiCategoryMutation) RemovedKqiCategoryFkIDs() (ids []int) {
	for id := range m.removedkqiCategoryFk {
		ids = append(ids, id)
	}
	return
}

// KqiCategoryFkIDs returns the kqiCategoryFk ids in the mutation.
func (m *KqiCategoryMutation) KqiCategoryFkIDs() (ids []int) {
	for id := range m.kqiCategoryFk {
		ids = append(ids, id)
	}
	return
}

// ResetKqiCategoryFk reset all changes of the "kqiCategoryFk" edge.
func (m *KqiCategoryMutation) ResetKqiCategoryFk() {
	m.kqiCategoryFk = nil
	m.clearedkqiCategoryFk = false
	m.removedkqiCategoryFk = nil
}

// Op returns the operation name.
func (m *KqiCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KqiCategory).
func (m *KqiCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KqiCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, kqicategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kqicategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kqicategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KqiCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kqicategory.FieldCreateTime:
		return m.CreateTime()
	case kqicategory.FieldUpdateTime:
		return m.UpdateTime()
	case kqicategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KqiCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kqicategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kqicategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kqicategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown KqiCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kqicategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kqicategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kqicategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown KqiCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KqiCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KqiCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KqiCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KqiCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KqiCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KqiCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KqiCategoryMutation) ResetField(name string) error {
	switch name {
	case kqicategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kqicategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kqicategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown KqiCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KqiCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.kqiCategoryFk != nil {
		edges = append(edges, kqicategory.EdgeKqiCategoryFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KqiCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kqicategory.EdgeKqiCategoryFk:
		ids := make([]ent.Value, 0, len(m.kqiCategoryFk))
		for id := range m.kqiCategoryFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KqiCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedkqiCategoryFk != nil {
		edges = append(edges, kqicategory.EdgeKqiCategoryFk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KqiCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kqicategory.EdgeKqiCategoryFk:
		ids := make([]ent.Value, 0, len(m.removedkqiCategoryFk))
		for id := range m.removedkqiCategoryFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KqiCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkqiCategoryFk {
		edges = append(edges, kqicategory.EdgeKqiCategoryFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KqiCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case kqicategory.EdgeKqiCategoryFk:
		return m.clearedkqiCategoryFk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KqiCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KqiCategoryMutation) ResetEdge(name string) error {
	switch name {
	case kqicategory.EdgeKqiCategoryFk:
		m.ResetKqiCategoryFk()
		return nil
	}
	return fmt.Errorf("unknown KqiCategory edge %s", name)
}

// KqiComparatorMutation represents an operation that mutate the KqiComparators
// nodes in the graph.
type KqiComparatorMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	number                       *float64
	addnumber                    *float64
	comparatorType               *string
	clearedFields                map[string]struct{}
	comparatorkqitargetfk        *int
	clearedcomparatorkqitargetfk bool
	kqitargetcomparatorfk        *int
	clearedkqitargetcomparatorfk bool
	done                         bool
	oldValue                     func(context.Context) (*KqiComparator, error)
	predicates                   []predicate.KqiComparator
}

var _ ent.Mutation = (*KqiComparatorMutation)(nil)

// kqicomparatorOption allows to manage the mutation configuration using functional options.
type kqicomparatorOption func(*KqiComparatorMutation)

// newKqiComparatorMutation creates new mutation for KqiComparator.
func newKqiComparatorMutation(c config, op Op, opts ...kqicomparatorOption) *KqiComparatorMutation {
	m := &KqiComparatorMutation{
		config:        c,
		op:            op,
		typ:           TypeKqiComparator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKqiComparatorID sets the id field of the mutation.
func withKqiComparatorID(id int) kqicomparatorOption {
	return func(m *KqiComparatorMutation) {
		var (
			err   error
			once  sync.Once
			value *KqiComparator
		)
		m.oldValue = func(ctx context.Context) (*KqiComparator, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KqiComparator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKqiComparator sets the old KqiComparator of the mutation.
func withKqiComparator(node *KqiComparator) kqicomparatorOption {
	return func(m *KqiComparatorMutation) {
		m.oldValue = func(context.Context) (*KqiComparator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KqiComparatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KqiComparatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KqiComparatorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KqiComparatorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KqiComparatorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the KqiComparator.
// If the KqiComparator object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiComparatorMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KqiComparatorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KqiComparatorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KqiComparatorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the KqiComparator.
// If the KqiComparator object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiComparatorMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KqiComparatorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNumber sets the number field.
func (m *KqiComparatorMutation) SetNumber(f float64) {
	m.number = &f
	m.addnumber = nil
}

// Number returns the number value in the mutation.
func (m *KqiComparatorMutation) Number() (r float64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old number value of the KqiComparator.
// If the KqiComparator object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiComparatorMutation) OldNumber(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds f to number.
func (m *KqiComparatorMutation) AddNumber(f float64) {
	if m.addnumber != nil {
		*m.addnumber += f
	} else {
		m.addnumber = &f
	}
}

// AddedNumber returns the value that was added to the number field in this mutation.
func (m *KqiComparatorMutation) AddedNumber() (r float64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber reset all changes of the "number" field.
func (m *KqiComparatorMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetComparatorType sets the comparatorType field.
func (m *KqiComparatorMutation) SetComparatorType(s string) {
	m.comparatorType = &s
}

// ComparatorType returns the comparatorType value in the mutation.
func (m *KqiComparatorMutation) ComparatorType() (r string, exists bool) {
	v := m.comparatorType
	if v == nil {
		return
	}
	return *v, true
}

// OldComparatorType returns the old comparatorType value of the KqiComparator.
// If the KqiComparator object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiComparatorMutation) OldComparatorType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComparatorType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComparatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComparatorType: %w", err)
	}
	return oldValue.ComparatorType, nil
}

// ResetComparatorType reset all changes of the "comparatorType" field.
func (m *KqiComparatorMutation) ResetComparatorType() {
	m.comparatorType = nil
}

// SetComparatorkqitargetfkID sets the comparatorkqitargetfk edge to Comparator by id.
func (m *KqiComparatorMutation) SetComparatorkqitargetfkID(id int) {
	m.comparatorkqitargetfk = &id
}

// ClearComparatorkqitargetfk clears the comparatorkqitargetfk edge to Comparator.
func (m *KqiComparatorMutation) ClearComparatorkqitargetfk() {
	m.clearedcomparatorkqitargetfk = true
}

// ComparatorkqitargetfkCleared returns if the edge comparatorkqitargetfk was cleared.
func (m *KqiComparatorMutation) ComparatorkqitargetfkCleared() bool {
	return m.clearedcomparatorkqitargetfk
}

// ComparatorkqitargetfkID returns the comparatorkqitargetfk id in the mutation.
func (m *KqiComparatorMutation) ComparatorkqitargetfkID() (id int, exists bool) {
	if m.comparatorkqitargetfk != nil {
		return *m.comparatorkqitargetfk, true
	}
	return
}

// ComparatorkqitargetfkIDs returns the comparatorkqitargetfk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ComparatorkqitargetfkID instead. It exists only for internal usage by the builders.
func (m *KqiComparatorMutation) ComparatorkqitargetfkIDs() (ids []int) {
	if id := m.comparatorkqitargetfk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComparatorkqitargetfk reset all changes of the "comparatorkqitargetfk" edge.
func (m *KqiComparatorMutation) ResetComparatorkqitargetfk() {
	m.comparatorkqitargetfk = nil
	m.clearedcomparatorkqitargetfk = false
}

// SetKqitargetcomparatorfkID sets the kqitargetcomparatorfk edge to KqiTarget by id.
func (m *KqiComparatorMutation) SetKqitargetcomparatorfkID(id int) {
	m.kqitargetcomparatorfk = &id
}

// ClearKqitargetcomparatorfk clears the kqitargetcomparatorfk edge to KqiTarget.
func (m *KqiComparatorMutation) ClearKqitargetcomparatorfk() {
	m.clearedkqitargetcomparatorfk = true
}

// KqitargetcomparatorfkCleared returns if the edge kqitargetcomparatorfk was cleared.
func (m *KqiComparatorMutation) KqitargetcomparatorfkCleared() bool {
	return m.clearedkqitargetcomparatorfk
}

// KqitargetcomparatorfkID returns the kqitargetcomparatorfk id in the mutation.
func (m *KqiComparatorMutation) KqitargetcomparatorfkID() (id int, exists bool) {
	if m.kqitargetcomparatorfk != nil {
		return *m.kqitargetcomparatorfk, true
	}
	return
}

// KqitargetcomparatorfkIDs returns the kqitargetcomparatorfk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KqitargetcomparatorfkID instead. It exists only for internal usage by the builders.
func (m *KqiComparatorMutation) KqitargetcomparatorfkIDs() (ids []int) {
	if id := m.kqitargetcomparatorfk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKqitargetcomparatorfk reset all changes of the "kqitargetcomparatorfk" edge.
func (m *KqiComparatorMutation) ResetKqitargetcomparatorfk() {
	m.kqitargetcomparatorfk = nil
	m.clearedkqitargetcomparatorfk = false
}

// Op returns the operation name.
func (m *KqiComparatorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KqiComparator).
func (m *KqiComparatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KqiComparatorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, kqicomparator.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kqicomparator.FieldUpdateTime)
	}
	if m.number != nil {
		fields = append(fields, kqicomparator.FieldNumber)
	}
	if m.comparatorType != nil {
		fields = append(fields, kqicomparator.FieldComparatorType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KqiComparatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kqicomparator.FieldCreateTime:
		return m.CreateTime()
	case kqicomparator.FieldUpdateTime:
		return m.UpdateTime()
	case kqicomparator.FieldNumber:
		return m.Number()
	case kqicomparator.FieldComparatorType:
		return m.ComparatorType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KqiComparatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kqicomparator.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kqicomparator.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kqicomparator.FieldNumber:
		return m.OldNumber(ctx)
	case kqicomparator.FieldComparatorType:
		return m.OldComparatorType(ctx)
	}
	return nil, fmt.Errorf("unknown KqiComparator field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiComparatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kqicomparator.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kqicomparator.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kqicomparator.FieldNumber:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case kqicomparator.FieldComparatorType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComparatorType(v)
		return nil
	}
	return fmt.Errorf("unknown KqiComparator field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KqiComparatorMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, kqicomparator.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KqiComparatorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kqicomparator.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiComparatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kqicomparator.FieldNumber:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown KqiComparator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KqiComparatorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KqiComparatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KqiComparatorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KqiComparator nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KqiComparatorMutation) ResetField(name string) error {
	switch name {
	case kqicomparator.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kqicomparator.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kqicomparator.FieldNumber:
		m.ResetNumber()
		return nil
	case kqicomparator.FieldComparatorType:
		m.ResetComparatorType()
		return nil
	}
	return fmt.Errorf("unknown KqiComparator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KqiComparatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.comparatorkqitargetfk != nil {
		edges = append(edges, kqicomparator.EdgeComparatorkqitargetfk)
	}
	if m.kqitargetcomparatorfk != nil {
		edges = append(edges, kqicomparator.EdgeKqitargetcomparatorfk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KqiComparatorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kqicomparator.EdgeComparatorkqitargetfk:
		if id := m.comparatorkqitargetfk; id != nil {
			return []ent.Value{*id}
		}
	case kqicomparator.EdgeKqitargetcomparatorfk:
		if id := m.kqitargetcomparatorfk; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KqiComparatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KqiComparatorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KqiComparatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomparatorkqitargetfk {
		edges = append(edges, kqicomparator.EdgeComparatorkqitargetfk)
	}
	if m.clearedkqitargetcomparatorfk {
		edges = append(edges, kqicomparator.EdgeKqitargetcomparatorfk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KqiComparatorMutation) EdgeCleared(name string) bool {
	switch name {
	case kqicomparator.EdgeComparatorkqitargetfk:
		return m.clearedcomparatorkqitargetfk
	case kqicomparator.EdgeKqitargetcomparatorfk:
		return m.clearedkqitargetcomparatorfk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KqiComparatorMutation) ClearEdge(name string) error {
	switch name {
	case kqicomparator.EdgeComparatorkqitargetfk:
		m.ClearComparatorkqitargetfk()
		return nil
	case kqicomparator.EdgeKqitargetcomparatorfk:
		m.ClearKqitargetcomparatorfk()
		return nil
	}
	return fmt.Errorf("unknown KqiComparator unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KqiComparatorMutation) ResetEdge(name string) error {
	switch name {
	case kqicomparator.EdgeComparatorkqitargetfk:
		m.ResetComparatorkqitargetfk()
		return nil
	case kqicomparator.EdgeKqitargetcomparatorfk:
		m.ResetKqitargetcomparatorfk()
		return nil
	}
	return fmt.Errorf("unknown KqiComparator edge %s", name)
}

// KqiPerspectiveMutation represents an operation that mutate the KqiPerspectives
// nodes in the graph.
type KqiPerspectiveMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	name                    *string
	clearedFields           map[string]struct{}
	kqiPerspectiveFk        map[int]struct{}
	removedkqiPerspectiveFk map[int]struct{}
	clearedkqiPerspectiveFk bool
	done                    bool
	oldValue                func(context.Context) (*KqiPerspective, error)
	predicates              []predicate.KqiPerspective
}

var _ ent.Mutation = (*KqiPerspectiveMutation)(nil)

// kqiperspectiveOption allows to manage the mutation configuration using functional options.
type kqiperspectiveOption func(*KqiPerspectiveMutation)

// newKqiPerspectiveMutation creates new mutation for KqiPerspective.
func newKqiPerspectiveMutation(c config, op Op, opts ...kqiperspectiveOption) *KqiPerspectiveMutation {
	m := &KqiPerspectiveMutation{
		config:        c,
		op:            op,
		typ:           TypeKqiPerspective,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKqiPerspectiveID sets the id field of the mutation.
func withKqiPerspectiveID(id int) kqiperspectiveOption {
	return func(m *KqiPerspectiveMutation) {
		var (
			err   error
			once  sync.Once
			value *KqiPerspective
		)
		m.oldValue = func(ctx context.Context) (*KqiPerspective, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KqiPerspective.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKqiPerspective sets the old KqiPerspective of the mutation.
func withKqiPerspective(node *KqiPerspective) kqiperspectiveOption {
	return func(m *KqiPerspectiveMutation) {
		m.oldValue = func(context.Context) (*KqiPerspective, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KqiPerspectiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KqiPerspectiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KqiPerspectiveMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KqiPerspectiveMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KqiPerspectiveMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the KqiPerspective.
// If the KqiPerspective object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiPerspectiveMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KqiPerspectiveMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KqiPerspectiveMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KqiPerspectiveMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the KqiPerspective.
// If the KqiPerspective object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiPerspectiveMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KqiPerspectiveMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KqiPerspectiveMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KqiPerspectiveMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the KqiPerspective.
// If the KqiPerspective object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiPerspectiveMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KqiPerspectiveMutation) ResetName() {
	m.name = nil
}

// AddKqiPerspectiveFkIDs adds the kqiPerspectiveFk edge to Kqi by ids.
func (m *KqiPerspectiveMutation) AddKqiPerspectiveFkIDs(ids ...int) {
	if m.kqiPerspectiveFk == nil {
		m.kqiPerspectiveFk = make(map[int]struct{})
	}
	for i := range ids {
		m.kqiPerspectiveFk[ids[i]] = struct{}{}
	}
}

// ClearKqiPerspectiveFk clears the kqiPerspectiveFk edge to Kqi.
func (m *KqiPerspectiveMutation) ClearKqiPerspectiveFk() {
	m.clearedkqiPerspectiveFk = true
}

// KqiPerspectiveFkCleared returns if the edge kqiPerspectiveFk was cleared.
func (m *KqiPerspectiveMutation) KqiPerspectiveFkCleared() bool {
	return m.clearedkqiPerspectiveFk
}

// RemoveKqiPerspectiveFkIDs removes the kqiPerspectiveFk edge to Kqi by ids.
func (m *KqiPerspectiveMutation) RemoveKqiPerspectiveFkIDs(ids ...int) {
	if m.removedkqiPerspectiveFk == nil {
		m.removedkqiPerspectiveFk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkqiPerspectiveFk[ids[i]] = struct{}{}
	}
}

// RemovedKqiPerspectiveFk returns the removed ids of kqiPerspectiveFk.
func (m *KqiPerspectiveMutation) RemovedKqiPerspectiveFkIDs() (ids []int) {
	for id := range m.removedkqiPerspectiveFk {
		ids = append(ids, id)
	}
	return
}

// KqiPerspectiveFkIDs returns the kqiPerspectiveFk ids in the mutation.
func (m *KqiPerspectiveMutation) KqiPerspectiveFkIDs() (ids []int) {
	for id := range m.kqiPerspectiveFk {
		ids = append(ids, id)
	}
	return
}

// ResetKqiPerspectiveFk reset all changes of the "kqiPerspectiveFk" edge.
func (m *KqiPerspectiveMutation) ResetKqiPerspectiveFk() {
	m.kqiPerspectiveFk = nil
	m.clearedkqiPerspectiveFk = false
	m.removedkqiPerspectiveFk = nil
}

// Op returns the operation name.
func (m *KqiPerspectiveMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KqiPerspective).
func (m *KqiPerspectiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KqiPerspectiveMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, kqiperspective.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kqiperspective.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kqiperspective.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KqiPerspectiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kqiperspective.FieldCreateTime:
		return m.CreateTime()
	case kqiperspective.FieldUpdateTime:
		return m.UpdateTime()
	case kqiperspective.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KqiPerspectiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kqiperspective.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kqiperspective.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kqiperspective.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown KqiPerspective field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiPerspectiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kqiperspective.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kqiperspective.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kqiperspective.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown KqiPerspective field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KqiPerspectiveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KqiPerspectiveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiPerspectiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiPerspective numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KqiPerspectiveMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KqiPerspectiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KqiPerspectiveMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KqiPerspective nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KqiPerspectiveMutation) ResetField(name string) error {
	switch name {
	case kqiperspective.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kqiperspective.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kqiperspective.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown KqiPerspective field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KqiPerspectiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.kqiPerspectiveFk != nil {
		edges = append(edges, kqiperspective.EdgeKqiPerspectiveFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KqiPerspectiveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kqiperspective.EdgeKqiPerspectiveFk:
		ids := make([]ent.Value, 0, len(m.kqiPerspectiveFk))
		for id := range m.kqiPerspectiveFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KqiPerspectiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedkqiPerspectiveFk != nil {
		edges = append(edges, kqiperspective.EdgeKqiPerspectiveFk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KqiPerspectiveMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kqiperspective.EdgeKqiPerspectiveFk:
		ids := make([]ent.Value, 0, len(m.removedkqiPerspectiveFk))
		for id := range m.removedkqiPerspectiveFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KqiPerspectiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkqiPerspectiveFk {
		edges = append(edges, kqiperspective.EdgeKqiPerspectiveFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KqiPerspectiveMutation) EdgeCleared(name string) bool {
	switch name {
	case kqiperspective.EdgeKqiPerspectiveFk:
		return m.clearedkqiPerspectiveFk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KqiPerspectiveMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiPerspective unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KqiPerspectiveMutation) ResetEdge(name string) error {
	switch name {
	case kqiperspective.EdgeKqiPerspectiveFk:
		m.ResetKqiPerspectiveFk()
		return nil
	}
	return fmt.Errorf("unknown KqiPerspective edge %s", name)
}

// KqiSourceMutation represents an operation that mutate the KqiSources
// nodes in the graph.
type KqiSourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	clearedFields      map[string]struct{}
	kqiSourceFk        map[int]struct{}
	removedkqiSourceFk map[int]struct{}
	clearedkqiSourceFk bool
	done               bool
	oldValue           func(context.Context) (*KqiSource, error)
	predicates         []predicate.KqiSource
}

var _ ent.Mutation = (*KqiSourceMutation)(nil)

// kqisourceOption allows to manage the mutation configuration using functional options.
type kqisourceOption func(*KqiSourceMutation)

// newKqiSourceMutation creates new mutation for KqiSource.
func newKqiSourceMutation(c config, op Op, opts ...kqisourceOption) *KqiSourceMutation {
	m := &KqiSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeKqiSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKqiSourceID sets the id field of the mutation.
func withKqiSourceID(id int) kqisourceOption {
	return func(m *KqiSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *KqiSource
		)
		m.oldValue = func(ctx context.Context) (*KqiSource, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KqiSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKqiSource sets the old KqiSource of the mutation.
func withKqiSource(node *KqiSource) kqisourceOption {
	return func(m *KqiSourceMutation) {
		m.oldValue = func(context.Context) (*KqiSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KqiSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KqiSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KqiSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KqiSourceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KqiSourceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the KqiSource.
// If the KqiSource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiSourceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KqiSourceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KqiSourceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KqiSourceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the KqiSource.
// If the KqiSource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiSourceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KqiSourceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KqiSourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KqiSourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the KqiSource.
// If the KqiSource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiSourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KqiSourceMutation) ResetName() {
	m.name = nil
}

// AddKqiSourceFkIDs adds the kqiSourceFk edge to Kqi by ids.
func (m *KqiSourceMutation) AddKqiSourceFkIDs(ids ...int) {
	if m.kqiSourceFk == nil {
		m.kqiSourceFk = make(map[int]struct{})
	}
	for i := range ids {
		m.kqiSourceFk[ids[i]] = struct{}{}
	}
}

// ClearKqiSourceFk clears the kqiSourceFk edge to Kqi.
func (m *KqiSourceMutation) ClearKqiSourceFk() {
	m.clearedkqiSourceFk = true
}

// KqiSourceFkCleared returns if the edge kqiSourceFk was cleared.
func (m *KqiSourceMutation) KqiSourceFkCleared() bool {
	return m.clearedkqiSourceFk
}

// RemoveKqiSourceFkIDs removes the kqiSourceFk edge to Kqi by ids.
func (m *KqiSourceMutation) RemoveKqiSourceFkIDs(ids ...int) {
	if m.removedkqiSourceFk == nil {
		m.removedkqiSourceFk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkqiSourceFk[ids[i]] = struct{}{}
	}
}

// RemovedKqiSourceFk returns the removed ids of kqiSourceFk.
func (m *KqiSourceMutation) RemovedKqiSourceFkIDs() (ids []int) {
	for id := range m.removedkqiSourceFk {
		ids = append(ids, id)
	}
	return
}

// KqiSourceFkIDs returns the kqiSourceFk ids in the mutation.
func (m *KqiSourceMutation) KqiSourceFkIDs() (ids []int) {
	for id := range m.kqiSourceFk {
		ids = append(ids, id)
	}
	return
}

// ResetKqiSourceFk reset all changes of the "kqiSourceFk" edge.
func (m *KqiSourceMutation) ResetKqiSourceFk() {
	m.kqiSourceFk = nil
	m.clearedkqiSourceFk = false
	m.removedkqiSourceFk = nil
}

// Op returns the operation name.
func (m *KqiSourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KqiSource).
func (m *KqiSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KqiSourceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, kqisource.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kqisource.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kqisource.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KqiSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kqisource.FieldCreateTime:
		return m.CreateTime()
	case kqisource.FieldUpdateTime:
		return m.UpdateTime()
	case kqisource.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KqiSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kqisource.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kqisource.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kqisource.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown KqiSource field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kqisource.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kqisource.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kqisource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown KqiSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KqiSourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KqiSourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KqiSourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KqiSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KqiSourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KqiSource nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KqiSourceMutation) ResetField(name string) error {
	switch name {
	case kqisource.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kqisource.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kqisource.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown KqiSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KqiSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.kqiSourceFk != nil {
		edges = append(edges, kqisource.EdgeKqiSourceFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KqiSourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kqisource.EdgeKqiSourceFk:
		ids := make([]ent.Value, 0, len(m.kqiSourceFk))
		for id := range m.kqiSourceFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KqiSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedkqiSourceFk != nil {
		edges = append(edges, kqisource.EdgeKqiSourceFk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KqiSourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kqisource.EdgeKqiSourceFk:
		ids := make([]ent.Value, 0, len(m.removedkqiSourceFk))
		for id := range m.removedkqiSourceFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KqiSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkqiSourceFk {
		edges = append(edges, kqisource.EdgeKqiSourceFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KqiSourceMutation) EdgeCleared(name string) bool {
	switch name {
	case kqisource.EdgeKqiSourceFk:
		return m.clearedkqiSourceFk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KqiSourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiSource unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KqiSourceMutation) ResetEdge(name string) error {
	switch name {
	case kqisource.EdgeKqiSourceFk:
		m.ResetKqiSourceFk()
		return nil
	}
	return fmt.Errorf("unknown KqiSource edge %s", name)
}

// KqiTargetMutation represents an operation that mutate the KqiTargets
// nodes in the graph.
type KqiTargetMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	name                         *string
	period                       *float64
	addperiod                    *float64
	allowedVariation             *float64
	addallowedVariation          *float64
	initTime                     *time.Time
	endTime                      *time.Time
	impact                       *string
	status                       *bool
	clearedFields                map[string]struct{}
	kqiTargetFk                  *int
	clearedkqiTargetFk           bool
	kqitargetcomparatorfk        map[int]struct{}
	removedkqitargetcomparatorfk map[int]struct{}
	clearedkqitargetcomparatorfk bool
	done                         bool
	oldValue                     func(context.Context) (*KqiTarget, error)
	predicates                   []predicate.KqiTarget
}

var _ ent.Mutation = (*KqiTargetMutation)(nil)

// kqitargetOption allows to manage the mutation configuration using functional options.
type kqitargetOption func(*KqiTargetMutation)

// newKqiTargetMutation creates new mutation for KqiTarget.
func newKqiTargetMutation(c config, op Op, opts ...kqitargetOption) *KqiTargetMutation {
	m := &KqiTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeKqiTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKqiTargetID sets the id field of the mutation.
func withKqiTargetID(id int) kqitargetOption {
	return func(m *KqiTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *KqiTarget
		)
		m.oldValue = func(ctx context.Context) (*KqiTarget, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KqiTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKqiTarget sets the old KqiTarget of the mutation.
func withKqiTarget(node *KqiTarget) kqitargetOption {
	return func(m *KqiTargetMutation) {
		m.oldValue = func(context.Context) (*KqiTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KqiTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KqiTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KqiTargetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KqiTargetMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KqiTargetMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KqiTargetMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KqiTargetMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KqiTargetMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KqiTargetMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KqiTargetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KqiTargetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KqiTargetMutation) ResetName() {
	m.name = nil
}

// SetPeriod sets the period field.
func (m *KqiTargetMutation) SetPeriod(f float64) {
	m.period = &f
	m.addperiod = nil
}

// Period returns the period value in the mutation.
func (m *KqiTargetMutation) Period() (r float64, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old period value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldPeriod(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPeriod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds f to period.
func (m *KqiTargetMutation) AddPeriod(f float64) {
	if m.addperiod != nil {
		*m.addperiod += f
	} else {
		m.addperiod = &f
	}
}

// AddedPeriod returns the value that was added to the period field in this mutation.
func (m *KqiTargetMutation) AddedPeriod() (r float64, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod reset all changes of the "period" field.
func (m *KqiTargetMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetAllowedVariation sets the allowedVariation field.
func (m *KqiTargetMutation) SetAllowedVariation(f float64) {
	m.allowedVariation = &f
	m.addallowedVariation = nil
}

// AllowedVariation returns the allowedVariation value in the mutation.
func (m *KqiTargetMutation) AllowedVariation() (r float64, exists bool) {
	v := m.allowedVariation
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedVariation returns the old allowedVariation value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldAllowedVariation(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllowedVariation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllowedVariation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedVariation: %w", err)
	}
	return oldValue.AllowedVariation, nil
}

// AddAllowedVariation adds f to allowedVariation.
func (m *KqiTargetMutation) AddAllowedVariation(f float64) {
	if m.addallowedVariation != nil {
		*m.addallowedVariation += f
	} else {
		m.addallowedVariation = &f
	}
}

// AddedAllowedVariation returns the value that was added to the allowedVariation field in this mutation.
func (m *KqiTargetMutation) AddedAllowedVariation() (r float64, exists bool) {
	v := m.addallowedVariation
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllowedVariation reset all changes of the "allowedVariation" field.
func (m *KqiTargetMutation) ResetAllowedVariation() {
	m.allowedVariation = nil
	m.addallowedVariation = nil
}

// SetInitTime sets the initTime field.
func (m *KqiTargetMutation) SetInitTime(t time.Time) {
	m.initTime = &t
}

// InitTime returns the initTime value in the mutation.
func (m *KqiTargetMutation) InitTime() (r time.Time, exists bool) {
	v := m.initTime
	if v == nil {
		return
	}
	return *v, true
}

// OldInitTime returns the old initTime value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldInitTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInitTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInitTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitTime: %w", err)
	}
	return oldValue.InitTime, nil
}

// ResetInitTime reset all changes of the "initTime" field.
func (m *KqiTargetMutation) ResetInitTime() {
	m.initTime = nil
}

// SetEndTime sets the endTime field.
func (m *KqiTargetMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the endTime value in the mutation.
func (m *KqiTargetMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old endTime value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime reset all changes of the "endTime" field.
func (m *KqiTargetMutation) ResetEndTime() {
	m.endTime = nil
}

// SetImpact sets the impact field.
func (m *KqiTargetMutation) SetImpact(s string) {
	m.impact = &s
}

// Impact returns the impact value in the mutation.
func (m *KqiTargetMutation) Impact() (r string, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old impact value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldImpact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImpact is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// ResetImpact reset all changes of the "impact" field.
func (m *KqiTargetMutation) ResetImpact() {
	m.impact = nil
}

// SetStatus sets the status field.
func (m *KqiTargetMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the status value in the mutation.
func (m *KqiTargetMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the KqiTarget.
// If the KqiTarget object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTargetMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *KqiTargetMutation) ResetStatus() {
	m.status = nil
}

// SetKqiTargetFkID sets the kqiTargetFk edge to Kqi by id.
func (m *KqiTargetMutation) SetKqiTargetFkID(id int) {
	m.kqiTargetFk = &id
}

// ClearKqiTargetFk clears the kqiTargetFk edge to Kqi.
func (m *KqiTargetMutation) ClearKqiTargetFk() {
	m.clearedkqiTargetFk = true
}

// KqiTargetFkCleared returns if the edge kqiTargetFk was cleared.
func (m *KqiTargetMutation) KqiTargetFkCleared() bool {
	return m.clearedkqiTargetFk
}

// KqiTargetFkID returns the kqiTargetFk id in the mutation.
func (m *KqiTargetMutation) KqiTargetFkID() (id int, exists bool) {
	if m.kqiTargetFk != nil {
		return *m.kqiTargetFk, true
	}
	return
}

// KqiTargetFkIDs returns the kqiTargetFk ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KqiTargetFkID instead. It exists only for internal usage by the builders.
func (m *KqiTargetMutation) KqiTargetFkIDs() (ids []int) {
	if id := m.kqiTargetFk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKqiTargetFk reset all changes of the "kqiTargetFk" edge.
func (m *KqiTargetMutation) ResetKqiTargetFk() {
	m.kqiTargetFk = nil
	m.clearedkqiTargetFk = false
}

// AddKqitargetcomparatorfkIDs adds the kqitargetcomparatorfk edge to KqiComparator by ids.
func (m *KqiTargetMutation) AddKqitargetcomparatorfkIDs(ids ...int) {
	if m.kqitargetcomparatorfk == nil {
		m.kqitargetcomparatorfk = make(map[int]struct{})
	}
	for i := range ids {
		m.kqitargetcomparatorfk[ids[i]] = struct{}{}
	}
}

// ClearKqitargetcomparatorfk clears the kqitargetcomparatorfk edge to KqiComparator.
func (m *KqiTargetMutation) ClearKqitargetcomparatorfk() {
	m.clearedkqitargetcomparatorfk = true
}

// KqitargetcomparatorfkCleared returns if the edge kqitargetcomparatorfk was cleared.
func (m *KqiTargetMutation) KqitargetcomparatorfkCleared() bool {
	return m.clearedkqitargetcomparatorfk
}

// RemoveKqitargetcomparatorfkIDs removes the kqitargetcomparatorfk edge to KqiComparator by ids.
func (m *KqiTargetMutation) RemoveKqitargetcomparatorfkIDs(ids ...int) {
	if m.removedkqitargetcomparatorfk == nil {
		m.removedkqitargetcomparatorfk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkqitargetcomparatorfk[ids[i]] = struct{}{}
	}
}

// RemovedKqitargetcomparatorfk returns the removed ids of kqitargetcomparatorfk.
func (m *KqiTargetMutation) RemovedKqitargetcomparatorfkIDs() (ids []int) {
	for id := range m.removedkqitargetcomparatorfk {
		ids = append(ids, id)
	}
	return
}

// KqitargetcomparatorfkIDs returns the kqitargetcomparatorfk ids in the mutation.
func (m *KqiTargetMutation) KqitargetcomparatorfkIDs() (ids []int) {
	for id := range m.kqitargetcomparatorfk {
		ids = append(ids, id)
	}
	return
}

// ResetKqitargetcomparatorfk reset all changes of the "kqitargetcomparatorfk" edge.
func (m *KqiTargetMutation) ResetKqitargetcomparatorfk() {
	m.kqitargetcomparatorfk = nil
	m.clearedkqitargetcomparatorfk = false
	m.removedkqitargetcomparatorfk = nil
}

// Op returns the operation name.
func (m *KqiTargetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KqiTarget).
func (m *KqiTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KqiTargetMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, kqitarget.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kqitarget.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kqitarget.FieldName)
	}
	if m.period != nil {
		fields = append(fields, kqitarget.FieldPeriod)
	}
	if m.allowedVariation != nil {
		fields = append(fields, kqitarget.FieldAllowedVariation)
	}
	if m.initTime != nil {
		fields = append(fields, kqitarget.FieldInitTime)
	}
	if m.endTime != nil {
		fields = append(fields, kqitarget.FieldEndTime)
	}
	if m.impact != nil {
		fields = append(fields, kqitarget.FieldImpact)
	}
	if m.status != nil {
		fields = append(fields, kqitarget.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KqiTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kqitarget.FieldCreateTime:
		return m.CreateTime()
	case kqitarget.FieldUpdateTime:
		return m.UpdateTime()
	case kqitarget.FieldName:
		return m.Name()
	case kqitarget.FieldPeriod:
		return m.Period()
	case kqitarget.FieldAllowedVariation:
		return m.AllowedVariation()
	case kqitarget.FieldInitTime:
		return m.InitTime()
	case kqitarget.FieldEndTime:
		return m.EndTime()
	case kqitarget.FieldImpact:
		return m.Impact()
	case kqitarget.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KqiTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kqitarget.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kqitarget.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kqitarget.FieldName:
		return m.OldName(ctx)
	case kqitarget.FieldPeriod:
		return m.OldPeriod(ctx)
	case kqitarget.FieldAllowedVariation:
		return m.OldAllowedVariation(ctx)
	case kqitarget.FieldInitTime:
		return m.OldInitTime(ctx)
	case kqitarget.FieldEndTime:
		return m.OldEndTime(ctx)
	case kqitarget.FieldImpact:
		return m.OldImpact(ctx)
	case kqitarget.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown KqiTarget field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kqitarget.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kqitarget.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kqitarget.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case kqitarget.FieldPeriod:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case kqitarget.FieldAllowedVariation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedVariation(v)
		return nil
	case kqitarget.FieldInitTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitTime(v)
		return nil
	case kqitarget.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case kqitarget.FieldImpact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case kqitarget.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown KqiTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KqiTargetMutation) AddedFields() []string {
	var fields []string
	if m.addperiod != nil {
		fields = append(fields, kqitarget.FieldPeriod)
	}
	if m.addallowedVariation != nil {
		fields = append(fields, kqitarget.FieldAllowedVariation)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KqiTargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kqitarget.FieldPeriod:
		return m.AddedPeriod()
	case kqitarget.FieldAllowedVariation:
		return m.AddedAllowedVariation()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kqitarget.FieldPeriod:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case kqitarget.FieldAllowedVariation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllowedVariation(v)
		return nil
	}
	return fmt.Errorf("unknown KqiTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KqiTargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KqiTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KqiTargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KqiTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KqiTargetMutation) ResetField(name string) error {
	switch name {
	case kqitarget.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kqitarget.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kqitarget.FieldName:
		m.ResetName()
		return nil
	case kqitarget.FieldPeriod:
		m.ResetPeriod()
		return nil
	case kqitarget.FieldAllowedVariation:
		m.ResetAllowedVariation()
		return nil
	case kqitarget.FieldInitTime:
		m.ResetInitTime()
		return nil
	case kqitarget.FieldEndTime:
		m.ResetEndTime()
		return nil
	case kqitarget.FieldImpact:
		m.ResetImpact()
		return nil
	case kqitarget.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown KqiTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KqiTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.kqiTargetFk != nil {
		edges = append(edges, kqitarget.EdgeKqiTargetFk)
	}
	if m.kqitargetcomparatorfk != nil {
		edges = append(edges, kqitarget.EdgeKqitargetcomparatorfk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KqiTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kqitarget.EdgeKqiTargetFk:
		if id := m.kqiTargetFk; id != nil {
			return []ent.Value{*id}
		}
	case kqitarget.EdgeKqitargetcomparatorfk:
		ids := make([]ent.Value, 0, len(m.kqitargetcomparatorfk))
		for id := range m.kqitargetcomparatorfk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KqiTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedkqitargetcomparatorfk != nil {
		edges = append(edges, kqitarget.EdgeKqitargetcomparatorfk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KqiTargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kqitarget.EdgeKqitargetcomparatorfk:
		ids := make([]ent.Value, 0, len(m.removedkqitargetcomparatorfk))
		for id := range m.removedkqitargetcomparatorfk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KqiTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedkqiTargetFk {
		edges = append(edges, kqitarget.EdgeKqiTargetFk)
	}
	if m.clearedkqitargetcomparatorfk {
		edges = append(edges, kqitarget.EdgeKqitargetcomparatorfk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KqiTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case kqitarget.EdgeKqiTargetFk:
		return m.clearedkqiTargetFk
	case kqitarget.EdgeKqitargetcomparatorfk:
		return m.clearedkqitargetcomparatorfk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KqiTargetMutation) ClearEdge(name string) error {
	switch name {
	case kqitarget.EdgeKqiTargetFk:
		m.ClearKqiTargetFk()
		return nil
	}
	return fmt.Errorf("unknown KqiTarget unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KqiTargetMutation) ResetEdge(name string) error {
	switch name {
	case kqitarget.EdgeKqiTargetFk:
		m.ResetKqiTargetFk()
		return nil
	case kqitarget.EdgeKqitargetcomparatorfk:
		m.ResetKqitargetcomparatorfk()
		return nil
	}
	return fmt.Errorf("unknown KqiTarget edge %s", name)
}

// KqiTemporalFrequencyMutation represents an operation that mutate the KqiTemporalFrequencies
// nodes in the graph.
type KqiTemporalFrequencyMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	name                          *string
	clearedFields                 map[string]struct{}
	kqiTemporalFrequencyFk        map[int]struct{}
	removedkqiTemporalFrequencyFk map[int]struct{}
	clearedkqiTemporalFrequencyFk bool
	done                          bool
	oldValue                      func(context.Context) (*KqiTemporalFrequency, error)
	predicates                    []predicate.KqiTemporalFrequency
}

var _ ent.Mutation = (*KqiTemporalFrequencyMutation)(nil)

// kqitemporalfrequencyOption allows to manage the mutation configuration using functional options.
type kqitemporalfrequencyOption func(*KqiTemporalFrequencyMutation)

// newKqiTemporalFrequencyMutation creates new mutation for KqiTemporalFrequency.
func newKqiTemporalFrequencyMutation(c config, op Op, opts ...kqitemporalfrequencyOption) *KqiTemporalFrequencyMutation {
	m := &KqiTemporalFrequencyMutation{
		config:        c,
		op:            op,
		typ:           TypeKqiTemporalFrequency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKqiTemporalFrequencyID sets the id field of the mutation.
func withKqiTemporalFrequencyID(id int) kqitemporalfrequencyOption {
	return func(m *KqiTemporalFrequencyMutation) {
		var (
			err   error
			once  sync.Once
			value *KqiTemporalFrequency
		)
		m.oldValue = func(ctx context.Context) (*KqiTemporalFrequency, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KqiTemporalFrequency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKqiTemporalFrequency sets the old KqiTemporalFrequency of the mutation.
func withKqiTemporalFrequency(node *KqiTemporalFrequency) kqitemporalfrequencyOption {
	return func(m *KqiTemporalFrequencyMutation) {
		m.oldValue = func(context.Context) (*KqiTemporalFrequency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KqiTemporalFrequencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KqiTemporalFrequencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KqiTemporalFrequencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *KqiTemporalFrequencyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *KqiTemporalFrequencyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the KqiTemporalFrequency.
// If the KqiTemporalFrequency object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTemporalFrequencyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *KqiTemporalFrequencyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *KqiTemporalFrequencyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *KqiTemporalFrequencyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the KqiTemporalFrequency.
// If the KqiTemporalFrequency object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTemporalFrequencyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *KqiTemporalFrequencyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *KqiTemporalFrequencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *KqiTemporalFrequencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the KqiTemporalFrequency.
// If the KqiTemporalFrequency object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KqiTemporalFrequencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *KqiTemporalFrequencyMutation) ResetName() {
	m.name = nil
}

// AddKqiTemporalFrequencyFkIDs adds the kqiTemporalFrequencyFk edge to Kqi by ids.
func (m *KqiTemporalFrequencyMutation) AddKqiTemporalFrequencyFkIDs(ids ...int) {
	if m.kqiTemporalFrequencyFk == nil {
		m.kqiTemporalFrequencyFk = make(map[int]struct{})
	}
	for i := range ids {
		m.kqiTemporalFrequencyFk[ids[i]] = struct{}{}
	}
}

// ClearKqiTemporalFrequencyFk clears the kqiTemporalFrequencyFk edge to Kqi.
func (m *KqiTemporalFrequencyMutation) ClearKqiTemporalFrequencyFk() {
	m.clearedkqiTemporalFrequencyFk = true
}

// KqiTemporalFrequencyFkCleared returns if the edge kqiTemporalFrequencyFk was cleared.
func (m *KqiTemporalFrequencyMutation) KqiTemporalFrequencyFkCleared() bool {
	return m.clearedkqiTemporalFrequencyFk
}

// RemoveKqiTemporalFrequencyFkIDs removes the kqiTemporalFrequencyFk edge to Kqi by ids.
func (m *KqiTemporalFrequencyMutation) RemoveKqiTemporalFrequencyFkIDs(ids ...int) {
	if m.removedkqiTemporalFrequencyFk == nil {
		m.removedkqiTemporalFrequencyFk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkqiTemporalFrequencyFk[ids[i]] = struct{}{}
	}
}

// RemovedKqiTemporalFrequencyFk returns the removed ids of kqiTemporalFrequencyFk.
func (m *KqiTemporalFrequencyMutation) RemovedKqiTemporalFrequencyFkIDs() (ids []int) {
	for id := range m.removedkqiTemporalFrequencyFk {
		ids = append(ids, id)
	}
	return
}

// KqiTemporalFrequencyFkIDs returns the kqiTemporalFrequencyFk ids in the mutation.
func (m *KqiTemporalFrequencyMutation) KqiTemporalFrequencyFkIDs() (ids []int) {
	for id := range m.kqiTemporalFrequencyFk {
		ids = append(ids, id)
	}
	return
}

// ResetKqiTemporalFrequencyFk reset all changes of the "kqiTemporalFrequencyFk" edge.
func (m *KqiTemporalFrequencyMutation) ResetKqiTemporalFrequencyFk() {
	m.kqiTemporalFrequencyFk = nil
	m.clearedkqiTemporalFrequencyFk = false
	m.removedkqiTemporalFrequencyFk = nil
}

// Op returns the operation name.
func (m *KqiTemporalFrequencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KqiTemporalFrequency).
func (m *KqiTemporalFrequencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KqiTemporalFrequencyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, kqitemporalfrequency.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, kqitemporalfrequency.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, kqitemporalfrequency.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KqiTemporalFrequencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kqitemporalfrequency.FieldCreateTime:
		return m.CreateTime()
	case kqitemporalfrequency.FieldUpdateTime:
		return m.UpdateTime()
	case kqitemporalfrequency.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KqiTemporalFrequencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kqitemporalfrequency.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case kqitemporalfrequency.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case kqitemporalfrequency.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown KqiTemporalFrequency field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiTemporalFrequencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kqitemporalfrequency.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case kqitemporalfrequency.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case kqitemporalfrequency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown KqiTemporalFrequency field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KqiTemporalFrequencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KqiTemporalFrequencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KqiTemporalFrequencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiTemporalFrequency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KqiTemporalFrequencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KqiTemporalFrequencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KqiTemporalFrequencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KqiTemporalFrequency nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KqiTemporalFrequencyMutation) ResetField(name string) error {
	switch name {
	case kqitemporalfrequency.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case kqitemporalfrequency.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case kqitemporalfrequency.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown KqiTemporalFrequency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KqiTemporalFrequencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.kqiTemporalFrequencyFk != nil {
		edges = append(edges, kqitemporalfrequency.EdgeKqiTemporalFrequencyFk)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KqiTemporalFrequencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kqitemporalfrequency.EdgeKqiTemporalFrequencyFk:
		ids := make([]ent.Value, 0, len(m.kqiTemporalFrequencyFk))
		for id := range m.kqiTemporalFrequencyFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KqiTemporalFrequencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedkqiTemporalFrequencyFk != nil {
		edges = append(edges, kqitemporalfrequency.EdgeKqiTemporalFrequencyFk)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KqiTemporalFrequencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kqitemporalfrequency.EdgeKqiTemporalFrequencyFk:
		ids := make([]ent.Value, 0, len(m.removedkqiTemporalFrequencyFk))
		for id := range m.removedkqiTemporalFrequencyFk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KqiTemporalFrequencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkqiTemporalFrequencyFk {
		edges = append(edges, kqitemporalfrequency.EdgeKqiTemporalFrequencyFk)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KqiTemporalFrequencyMutation) EdgeCleared(name string) bool {
	switch name {
	case kqitemporalfrequency.EdgeKqiTemporalFrequencyFk:
		return m.clearedkqiTemporalFrequencyFk
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KqiTemporalFrequencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown KqiTemporalFrequency unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KqiTemporalFrequencyMutation) ResetEdge(name string) error {
	switch name {
	case kqitemporalfrequency.EdgeKqiTemporalFrequencyFk:
		m.ResetKqiTemporalFrequencyFk()
		return nil
	}
	return fmt.Errorf("unknown KqiTemporalFrequency edge %s", name)
}

// LinkMutation represents an operation that mutate the Links
// nodes in the graph.
type LinkMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	future_state      *enum.FutureState
	clearedFields     map[string]struct{}
	ports             map[int]struct{}
	removedports      map[int]struct{}
	clearedports      bool
	work_order        *int
	clearedwork_order bool
	properties        map[int]struct{}
	removedproperties map[int]struct{}
	clearedproperties bool
	service           map[int]struct{}
	removedservice    map[int]struct{}
	clearedservice    bool
	done              bool
	oldValue          func(context.Context) (*Link, error)
	predicates        []predicate.Link
}

var _ ent.Mutation = (*LinkMutation)(nil)

// linkOption allows to manage the mutation configuration using functional options.
type linkOption func(*LinkMutation)

// newLinkMutation creates new mutation for Link.
func newLinkMutation(c config, op Op, opts ...linkOption) *LinkMutation {
	m := &LinkMutation{
		config:        c,
		op:            op,
		typ:           TypeLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLinkID sets the id field of the mutation.
func withLinkID(id int) linkOption {
	return func(m *LinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Link
		)
		m.oldValue = func(ctx context.Context) (*Link, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Link.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLink sets the old Link of the mutation.
func withLink(node *Link) linkOption {
	return func(m *LinkMutation) {
		m.oldValue = func(context.Context) (*Link, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *LinkMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *LinkMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Link.
// If the Link object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LinkMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *LinkMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *LinkMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *LinkMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Link.
// If the Link object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LinkMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *LinkMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFutureState sets the future_state field.
func (m *LinkMutation) SetFutureState(es enum.FutureState) {
	m.future_state = &es
}

// FutureState returns the future_state value in the mutation.
func (m *LinkMutation) FutureState() (r enum.FutureState, exists bool) {
	v := m.future_state
	if v == nil {
		return
	}
	return *v, true
}

// OldFutureState returns the old future_state value of the Link.
// If the Link object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LinkMutation) OldFutureState(ctx context.Context) (v *enum.FutureState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFutureState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFutureState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFutureState: %w", err)
	}
	return oldValue.FutureState, nil
}

// ClearFutureState clears the value of future_state.
func (m *LinkMutation) ClearFutureState() {
	m.future_state = nil
	m.clearedFields[link.FieldFutureState] = struct{}{}
}

// FutureStateCleared returns if the field future_state was cleared in this mutation.
func (m *LinkMutation) FutureStateCleared() bool {
	_, ok := m.clearedFields[link.FieldFutureState]
	return ok
}

// ResetFutureState reset all changes of the "future_state" field.
func (m *LinkMutation) ResetFutureState() {
	m.future_state = nil
	delete(m.clearedFields, link.FieldFutureState)
}

// AddPortIDs adds the ports edge to EquipmentPort by ids.
func (m *LinkMutation) AddPortIDs(ids ...int) {
	if m.ports == nil {
		m.ports = make(map[int]struct{})
	}
	for i := range ids {
		m.ports[ids[i]] = struct{}{}
	}
}

// ClearPorts clears the ports edge to EquipmentPort.
func (m *LinkMutation) ClearPorts() {
	m.clearedports = true
}

// PortsCleared returns if the edge ports was cleared.
func (m *LinkMutation) PortsCleared() bool {
	return m.clearedports
}

// RemovePortIDs removes the ports edge to EquipmentPort by ids.
func (m *LinkMutation) RemovePortIDs(ids ...int) {
	if m.removedports == nil {
		m.removedports = make(map[int]struct{})
	}
	for i := range ids {
		m.removedports[ids[i]] = struct{}{}
	}
}

// RemovedPorts returns the removed ids of ports.
func (m *LinkMutation) RemovedPortsIDs() (ids []int) {
	for id := range m.removedports {
		ids = append(ids, id)
	}
	return
}

// PortsIDs returns the ports ids in the mutation.
func (m *LinkMutation) PortsIDs() (ids []int) {
	for id := range m.ports {
		ids = append(ids, id)
	}
	return
}

// ResetPorts reset all changes of the "ports" edge.
func (m *LinkMutation) ResetPorts() {
	m.ports = nil
	m.clearedports = false
	m.removedports = nil
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *LinkMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *LinkMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *LinkMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *LinkMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *LinkMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *LinkMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *LinkMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *LinkMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *LinkMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *LinkMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *LinkMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *LinkMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *LinkMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddServiceIDs adds the service edge to Service by ids.
func (m *LinkMutation) AddServiceIDs(ids ...int) {
	if m.service == nil {
		m.service = make(map[int]struct{})
	}
	for i := range ids {
		m.service[ids[i]] = struct{}{}
	}
}

// ClearService clears the service edge to Service.
func (m *LinkMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared returns if the edge service was cleared.
func (m *LinkMutation) ServiceCleared() bool {
	return m.clearedservice
}

// RemoveServiceIDs removes the service edge to Service by ids.
func (m *LinkMutation) RemoveServiceIDs(ids ...int) {
	if m.removedservice == nil {
		m.removedservice = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservice[ids[i]] = struct{}{}
	}
}

// RemovedService returns the removed ids of service.
func (m *LinkMutation) RemovedServiceIDs() (ids []int) {
	for id := range m.removedservice {
		ids = append(ids, id)
	}
	return
}

// ServiceIDs returns the service ids in the mutation.
func (m *LinkMutation) ServiceIDs() (ids []int) {
	for id := range m.service {
		ids = append(ids, id)
	}
	return
}

// ResetService reset all changes of the "service" edge.
func (m *LinkMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
	m.removedservice = nil
}

// Op returns the operation name.
func (m *LinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Link).
func (m *LinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LinkMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, link.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, link.FieldUpdateTime)
	}
	if m.future_state != nil {
		fields = append(fields, link.FieldFutureState)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case link.FieldCreateTime:
		return m.CreateTime()
	case link.FieldUpdateTime:
		return m.UpdateTime()
	case link.FieldFutureState:
		return m.FutureState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case link.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case link.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case link.FieldFutureState:
		return m.OldFutureState(ctx)
	}
	return nil, fmt.Errorf("unknown Link field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case link.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case link.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case link.FieldFutureState:
		v, ok := value.(enum.FutureState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFutureState(v)
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Link numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(link.FieldFutureState) {
		fields = append(fields, link.FieldFutureState)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LinkMutation) ClearField(name string) error {
	switch name {
	case link.FieldFutureState:
		m.ClearFutureState()
		return nil
	}
	return fmt.Errorf("unknown Link nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LinkMutation) ResetField(name string) error {
	switch name {
	case link.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case link.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case link.FieldFutureState:
		m.ResetFutureState()
		return nil
	}
	return fmt.Errorf("unknown Link field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.ports != nil {
		edges = append(edges, link.EdgePorts)
	}
	if m.work_order != nil {
		edges = append(edges, link.EdgeWorkOrder)
	}
	if m.properties != nil {
		edges = append(edges, link.EdgeProperties)
	}
	if m.service != nil {
		edges = append(edges, link.EdgeService)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case link.EdgePorts:
		ids := make([]ent.Value, 0, len(m.ports))
		for id := range m.ports {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	case link.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeService:
		ids := make([]ent.Value, 0, len(m.service))
		for id := range m.service {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedports != nil {
		edges = append(edges, link.EdgePorts)
	}
	if m.removedproperties != nil {
		edges = append(edges, link.EdgeProperties)
	}
	if m.removedservice != nil {
		edges = append(edges, link.EdgeService)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case link.EdgePorts:
		ids := make([]ent.Value, 0, len(m.removedports))
		for id := range m.removedports {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case link.EdgeService:
		ids := make([]ent.Value, 0, len(m.removedservice))
		for id := range m.removedservice {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedports {
		edges = append(edges, link.EdgePorts)
	}
	if m.clearedwork_order {
		edges = append(edges, link.EdgeWorkOrder)
	}
	if m.clearedproperties {
		edges = append(edges, link.EdgeProperties)
	}
	if m.clearedservice {
		edges = append(edges, link.EdgeService)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LinkMutation) EdgeCleared(name string) bool {
	switch name {
	case link.EdgePorts:
		return m.clearedports
	case link.EdgeWorkOrder:
		return m.clearedwork_order
	case link.EdgeProperties:
		return m.clearedproperties
	case link.EdgeService:
		return m.clearedservice
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LinkMutation) ClearEdge(name string) error {
	switch name {
	case link.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	}
	return fmt.Errorf("unknown Link unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LinkMutation) ResetEdge(name string) error {
	switch name {
	case link.EdgePorts:
		m.ResetPorts()
		return nil
	case link.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	case link.EdgeProperties:
		m.ResetProperties()
		return nil
	case link.EdgeService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown Link edge %s", name)
}

// LocationMutation represents an operation that mutate the Locations
// nodes in the graph.
type LocationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	external_id        *string
	latitude           *float64
	addlatitude        *float64
	longitude          *float64
	addlongitude       *float64
	site_survey_needed *bool
	clearedFields      map[string]struct{}
	_type              *int
	cleared_type       bool
	parent             *int
	clearedparent      bool
	children           map[int]struct{}
	removedchildren    map[int]struct{}
	clearedchildren    bool
	files              map[int]struct{}
	removedfiles       map[int]struct{}
	clearedfiles       bool
	hyperlinks         map[int]struct{}
	removedhyperlinks  map[int]struct{}
	clearedhyperlinks  bool
	equipment          map[int]struct{}
	removedequipment   map[int]struct{}
	clearedequipment   bool
	properties         map[int]struct{}
	removedproperties  map[int]struct{}
	clearedproperties  bool
	survey             map[int]struct{}
	removedsurvey      map[int]struct{}
	clearedsurvey      bool
	wifi_scan          map[int]struct{}
	removedwifi_scan   map[int]struct{}
	clearedwifi_scan   bool
	cell_scan          map[int]struct{}
	removedcell_scan   map[int]struct{}
	clearedcell_scan   bool
	work_orders        map[int]struct{}
	removedwork_orders map[int]struct{}
	clearedwork_orders bool
	floor_plans        map[int]struct{}
	removedfloor_plans map[int]struct{}
	clearedfloor_plans bool
	done               bool
	oldValue           func(context.Context) (*Location, error)
	predicates         []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows to manage the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for Location.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the id field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *LocationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *LocationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *LocationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *LocationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *LocationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *LocationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetExternalID sets the external_id field.
func (m *LocationMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the external_id value in the mutation.
func (m *LocationMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old external_id value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of external_id.
func (m *LocationMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[location.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the field external_id was cleared in this mutation.
func (m *LocationMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[location.FieldExternalID]
	return ok
}

// ResetExternalID reset all changes of the "external_id" field.
func (m *LocationMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, location.FieldExternalID)
}

// SetLatitude sets the latitude field.
func (m *LocationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the latitude value in the mutation.
func (m *LocationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old latitude value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to latitude.
func (m *LocationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the latitude field in this mutation.
func (m *LocationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude reset all changes of the "latitude" field.
func (m *LocationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the longitude field.
func (m *LocationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the longitude value in the mutation.
func (m *LocationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old longitude value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to longitude.
func (m *LocationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the longitude field in this mutation.
func (m *LocationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude reset all changes of the "longitude" field.
func (m *LocationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetSiteSurveyNeeded sets the site_survey_needed field.
func (m *LocationMutation) SetSiteSurveyNeeded(b bool) {
	m.site_survey_needed = &b
}

// SiteSurveyNeeded returns the site_survey_needed value in the mutation.
func (m *LocationMutation) SiteSurveyNeeded() (r bool, exists bool) {
	v := m.site_survey_needed
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteSurveyNeeded returns the old site_survey_needed value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldSiteSurveyNeeded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSiteSurveyNeeded is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSiteSurveyNeeded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteSurveyNeeded: %w", err)
	}
	return oldValue.SiteSurveyNeeded, nil
}

// ClearSiteSurveyNeeded clears the value of site_survey_needed.
func (m *LocationMutation) ClearSiteSurveyNeeded() {
	m.site_survey_needed = nil
	m.clearedFields[location.FieldSiteSurveyNeeded] = struct{}{}
}

// SiteSurveyNeededCleared returns if the field site_survey_needed was cleared in this mutation.
func (m *LocationMutation) SiteSurveyNeededCleared() bool {
	_, ok := m.clearedFields[location.FieldSiteSurveyNeeded]
	return ok
}

// ResetSiteSurveyNeeded reset all changes of the "site_survey_needed" field.
func (m *LocationMutation) ResetSiteSurveyNeeded() {
	m.site_survey_needed = nil
	delete(m.clearedFields, location.FieldSiteSurveyNeeded)
}

// SetTypeID sets the type edge to LocationType by id.
func (m *LocationMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to LocationType.
func (m *LocationMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *LocationMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *LocationMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *LocationMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetParentID sets the parent edge to Location by id.
func (m *LocationMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the parent edge to Location.
func (m *LocationMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *LocationMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *LocationMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the "parent" edge.
func (m *LocationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the children edge to Location by ids.
func (m *LocationMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the children edge to Location.
func (m *LocationMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared returns if the edge children was cleared.
func (m *LocationMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the children edge to Location by ids.
func (m *LocationMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed ids of children.
func (m *LocationMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the children ids in the mutation.
func (m *LocationMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren reset all changes of the "children" edge.
func (m *LocationMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddFileIDs adds the files edge to File by ids.
func (m *LocationMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the files edge to File.
func (m *LocationMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared returns if the edge files was cleared.
func (m *LocationMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the files edge to File by ids.
func (m *LocationMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed ids of files.
func (m *LocationMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the files ids in the mutation.
func (m *LocationMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles reset all changes of the "files" edge.
func (m *LocationMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddHyperlinkIDs adds the hyperlinks edge to Hyperlink by ids.
func (m *LocationMutation) AddHyperlinkIDs(ids ...int) {
	if m.hyperlinks == nil {
		m.hyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.hyperlinks[ids[i]] = struct{}{}
	}
}

// ClearHyperlinks clears the hyperlinks edge to Hyperlink.
func (m *LocationMutation) ClearHyperlinks() {
	m.clearedhyperlinks = true
}

// HyperlinksCleared returns if the edge hyperlinks was cleared.
func (m *LocationMutation) HyperlinksCleared() bool {
	return m.clearedhyperlinks
}

// RemoveHyperlinkIDs removes the hyperlinks edge to Hyperlink by ids.
func (m *LocationMutation) RemoveHyperlinkIDs(ids ...int) {
	if m.removedhyperlinks == nil {
		m.removedhyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhyperlinks[ids[i]] = struct{}{}
	}
}

// RemovedHyperlinks returns the removed ids of hyperlinks.
func (m *LocationMutation) RemovedHyperlinksIDs() (ids []int) {
	for id := range m.removedhyperlinks {
		ids = append(ids, id)
	}
	return
}

// HyperlinksIDs returns the hyperlinks ids in the mutation.
func (m *LocationMutation) HyperlinksIDs() (ids []int) {
	for id := range m.hyperlinks {
		ids = append(ids, id)
	}
	return
}

// ResetHyperlinks reset all changes of the "hyperlinks" edge.
func (m *LocationMutation) ResetHyperlinks() {
	m.hyperlinks = nil
	m.clearedhyperlinks = false
	m.removedhyperlinks = nil
}

// AddEquipmentIDs adds the equipment edge to Equipment by ids.
func (m *LocationMutation) AddEquipmentIDs(ids ...int) {
	if m.equipment == nil {
		m.equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *LocationMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *LocationMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// RemoveEquipmentIDs removes the equipment edge to Equipment by ids.
func (m *LocationMutation) RemoveEquipmentIDs(ids ...int) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed ids of equipment.
func (m *LocationMutation) RemovedEquipmentIDs() (ids []int) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
func (m *LocationMutation) EquipmentIDs() (ids []int) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *LocationMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
	m.removedequipment = nil
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *LocationMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *LocationMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *LocationMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *LocationMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *LocationMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *LocationMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *LocationMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddSurveyIDs adds the survey edge to Survey by ids.
func (m *LocationMutation) AddSurveyIDs(ids ...int) {
	if m.survey == nil {
		m.survey = make(map[int]struct{})
	}
	for i := range ids {
		m.survey[ids[i]] = struct{}{}
	}
}

// ClearSurvey clears the survey edge to Survey.
func (m *LocationMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared returns if the edge survey was cleared.
func (m *LocationMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// RemoveSurveyIDs removes the survey edge to Survey by ids.
func (m *LocationMutation) RemoveSurveyIDs(ids ...int) {
	if m.removedsurvey == nil {
		m.removedsurvey = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsurvey[ids[i]] = struct{}{}
	}
}

// RemovedSurvey returns the removed ids of survey.
func (m *LocationMutation) RemovedSurveyIDs() (ids []int) {
	for id := range m.removedsurvey {
		ids = append(ids, id)
	}
	return
}

// SurveyIDs returns the survey ids in the mutation.
func (m *LocationMutation) SurveyIDs() (ids []int) {
	for id := range m.survey {
		ids = append(ids, id)
	}
	return
}

// ResetSurvey reset all changes of the "survey" edge.
func (m *LocationMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
	m.removedsurvey = nil
}

// AddWifiScanIDs adds the wifi_scan edge to SurveyWiFiScan by ids.
func (m *LocationMutation) AddWifiScanIDs(ids ...int) {
	if m.wifi_scan == nil {
		m.wifi_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.wifi_scan[ids[i]] = struct{}{}
	}
}

// ClearWifiScan clears the wifi_scan edge to SurveyWiFiScan.
func (m *LocationMutation) ClearWifiScan() {
	m.clearedwifi_scan = true
}

// WifiScanCleared returns if the edge wifi_scan was cleared.
func (m *LocationMutation) WifiScanCleared() bool {
	return m.clearedwifi_scan
}

// RemoveWifiScanIDs removes the wifi_scan edge to SurveyWiFiScan by ids.
func (m *LocationMutation) RemoveWifiScanIDs(ids ...int) {
	if m.removedwifi_scan == nil {
		m.removedwifi_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwifi_scan[ids[i]] = struct{}{}
	}
}

// RemovedWifiScan returns the removed ids of wifi_scan.
func (m *LocationMutation) RemovedWifiScanIDs() (ids []int) {
	for id := range m.removedwifi_scan {
		ids = append(ids, id)
	}
	return
}

// WifiScanIDs returns the wifi_scan ids in the mutation.
func (m *LocationMutation) WifiScanIDs() (ids []int) {
	for id := range m.wifi_scan {
		ids = append(ids, id)
	}
	return
}

// ResetWifiScan reset all changes of the "wifi_scan" edge.
func (m *LocationMutation) ResetWifiScan() {
	m.wifi_scan = nil
	m.clearedwifi_scan = false
	m.removedwifi_scan = nil
}

// AddCellScanIDs adds the cell_scan edge to SurveyCellScan by ids.
func (m *LocationMutation) AddCellScanIDs(ids ...int) {
	if m.cell_scan == nil {
		m.cell_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.cell_scan[ids[i]] = struct{}{}
	}
}

// ClearCellScan clears the cell_scan edge to SurveyCellScan.
func (m *LocationMutation) ClearCellScan() {
	m.clearedcell_scan = true
}

// CellScanCleared returns if the edge cell_scan was cleared.
func (m *LocationMutation) CellScanCleared() bool {
	return m.clearedcell_scan
}

// RemoveCellScanIDs removes the cell_scan edge to SurveyCellScan by ids.
func (m *LocationMutation) RemoveCellScanIDs(ids ...int) {
	if m.removedcell_scan == nil {
		m.removedcell_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcell_scan[ids[i]] = struct{}{}
	}
}

// RemovedCellScan returns the removed ids of cell_scan.
func (m *LocationMutation) RemovedCellScanIDs() (ids []int) {
	for id := range m.removedcell_scan {
		ids = append(ids, id)
	}
	return
}

// CellScanIDs returns the cell_scan ids in the mutation.
func (m *LocationMutation) CellScanIDs() (ids []int) {
	for id := range m.cell_scan {
		ids = append(ids, id)
	}
	return
}

// ResetCellScan reset all changes of the "cell_scan" edge.
func (m *LocationMutation) ResetCellScan() {
	m.cell_scan = nil
	m.clearedcell_scan = false
	m.removedcell_scan = nil
}

// AddWorkOrderIDs adds the work_orders edge to WorkOrder by ids.
func (m *LocationMutation) AddWorkOrderIDs(ids ...int) {
	if m.work_orders == nil {
		m.work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.work_orders[ids[i]] = struct{}{}
	}
}

// ClearWorkOrders clears the work_orders edge to WorkOrder.
func (m *LocationMutation) ClearWorkOrders() {
	m.clearedwork_orders = true
}

// WorkOrdersCleared returns if the edge work_orders was cleared.
func (m *LocationMutation) WorkOrdersCleared() bool {
	return m.clearedwork_orders
}

// RemoveWorkOrderIDs removes the work_orders edge to WorkOrder by ids.
func (m *LocationMutation) RemoveWorkOrderIDs(ids ...int) {
	if m.removedwork_orders == nil {
		m.removedwork_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_orders[ids[i]] = struct{}{}
	}
}

// RemovedWorkOrders returns the removed ids of work_orders.
func (m *LocationMutation) RemovedWorkOrdersIDs() (ids []int) {
	for id := range m.removedwork_orders {
		ids = append(ids, id)
	}
	return
}

// WorkOrdersIDs returns the work_orders ids in the mutation.
func (m *LocationMutation) WorkOrdersIDs() (ids []int) {
	for id := range m.work_orders {
		ids = append(ids, id)
	}
	return
}

// ResetWorkOrders reset all changes of the "work_orders" edge.
func (m *LocationMutation) ResetWorkOrders() {
	m.work_orders = nil
	m.clearedwork_orders = false
	m.removedwork_orders = nil
}

// AddFloorPlanIDs adds the floor_plans edge to FloorPlan by ids.
func (m *LocationMutation) AddFloorPlanIDs(ids ...int) {
	if m.floor_plans == nil {
		m.floor_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.floor_plans[ids[i]] = struct{}{}
	}
}

// ClearFloorPlans clears the floor_plans edge to FloorPlan.
func (m *LocationMutation) ClearFloorPlans() {
	m.clearedfloor_plans = true
}

// FloorPlansCleared returns if the edge floor_plans was cleared.
func (m *LocationMutation) FloorPlansCleared() bool {
	return m.clearedfloor_plans
}

// RemoveFloorPlanIDs removes the floor_plans edge to FloorPlan by ids.
func (m *LocationMutation) RemoveFloorPlanIDs(ids ...int) {
	if m.removedfloor_plans == nil {
		m.removedfloor_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfloor_plans[ids[i]] = struct{}{}
	}
}

// RemovedFloorPlans returns the removed ids of floor_plans.
func (m *LocationMutation) RemovedFloorPlansIDs() (ids []int) {
	for id := range m.removedfloor_plans {
		ids = append(ids, id)
	}
	return
}

// FloorPlansIDs returns the floor_plans ids in the mutation.
func (m *LocationMutation) FloorPlansIDs() (ids []int) {
	for id := range m.floor_plans {
		ids = append(ids, id)
	}
	return
}

// ResetFloorPlans reset all changes of the "floor_plans" edge.
func (m *LocationMutation) ResetFloorPlans() {
	m.floor_plans = nil
	m.clearedfloor_plans = false
	m.removedfloor_plans = nil
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, location.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, location.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.external_id != nil {
		fields = append(fields, location.FieldExternalID)
	}
	if m.latitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.site_survey_needed != nil {
		fields = append(fields, location.FieldSiteSurveyNeeded)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreateTime:
		return m.CreateTime()
	case location.FieldUpdateTime:
		return m.UpdateTime()
	case location.FieldName:
		return m.Name()
	case location.FieldExternalID:
		return m.ExternalID()
	case location.FieldLatitude:
		return m.Latitude()
	case location.FieldLongitude:
		return m.Longitude()
	case location.FieldSiteSurveyNeeded:
		return m.SiteSurveyNeeded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case location.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldExternalID:
		return m.OldExternalID(ctx)
	case location.FieldLatitude:
		return m.OldLatitude(ctx)
	case location.FieldLongitude:
		return m.OldLongitude(ctx)
	case location.FieldSiteSurveyNeeded:
		return m.OldSiteSurveyNeeded(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case location.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case location.FieldSiteSurveyNeeded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteSurveyNeeded(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLatitude:
		return m.AddedLatitude()
	case location.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldExternalID) {
		fields = append(fields, location.FieldExternalID)
	}
	if m.FieldCleared(location.FieldSiteSurveyNeeded) {
		fields = append(fields, location.FieldSiteSurveyNeeded)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldExternalID:
		m.ClearExternalID()
		return nil
	case location.FieldSiteSurveyNeeded:
		m.ClearSiteSurveyNeeded()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case location.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldExternalID:
		m.ResetExternalID()
		return nil
	case location.FieldLatitude:
		m.ResetLatitude()
		return nil
	case location.FieldLongitude:
		m.ResetLongitude()
		return nil
	case location.FieldSiteSurveyNeeded:
		m.ResetSiteSurveyNeeded()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m._type != nil {
		edges = append(edges, location.EdgeType)
	}
	if m.parent != nil {
		edges = append(edges, location.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, location.EdgeChildren)
	}
	if m.files != nil {
		edges = append(edges, location.EdgeFiles)
	}
	if m.hyperlinks != nil {
		edges = append(edges, location.EdgeHyperlinks)
	}
	if m.equipment != nil {
		edges = append(edges, location.EdgeEquipment)
	}
	if m.properties != nil {
		edges = append(edges, location.EdgeProperties)
	}
	if m.survey != nil {
		edges = append(edges, location.EdgeSurvey)
	}
	if m.wifi_scan != nil {
		edges = append(edges, location.EdgeWifiScan)
	}
	if m.cell_scan != nil {
		edges = append(edges, location.EdgeCellScan)
	}
	if m.work_orders != nil {
		edges = append(edges, location.EdgeWorkOrders)
	}
	if m.floor_plans != nil {
		edges = append(edges, location.EdgeFloorPlans)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.hyperlinks))
		for id := range m.hyperlinks {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSurvey:
		ids := make([]ent.Value, 0, len(m.survey))
		for id := range m.survey {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeWifiScan:
		ids := make([]ent.Value, 0, len(m.wifi_scan))
		for id := range m.wifi_scan {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeCellScan:
		ids := make([]ent.Value, 0, len(m.cell_scan))
		for id := range m.cell_scan {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.work_orders))
		for id := range m.work_orders {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeFloorPlans:
		ids := make([]ent.Value, 0, len(m.floor_plans))
		for id := range m.floor_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedchildren != nil {
		edges = append(edges, location.EdgeChildren)
	}
	if m.removedfiles != nil {
		edges = append(edges, location.EdgeFiles)
	}
	if m.removedhyperlinks != nil {
		edges = append(edges, location.EdgeHyperlinks)
	}
	if m.removedequipment != nil {
		edges = append(edges, location.EdgeEquipment)
	}
	if m.removedproperties != nil {
		edges = append(edges, location.EdgeProperties)
	}
	if m.removedsurvey != nil {
		edges = append(edges, location.EdgeSurvey)
	}
	if m.removedwifi_scan != nil {
		edges = append(edges, location.EdgeWifiScan)
	}
	if m.removedcell_scan != nil {
		edges = append(edges, location.EdgeCellScan)
	}
	if m.removedwork_orders != nil {
		edges = append(edges, location.EdgeWorkOrders)
	}
	if m.removedfloor_plans != nil {
		edges = append(edges, location.EdgeFloorPlans)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.removedhyperlinks))
		for id := range m.removedhyperlinks {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSurvey:
		ids := make([]ent.Value, 0, len(m.removedsurvey))
		for id := range m.removedsurvey {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeWifiScan:
		ids := make([]ent.Value, 0, len(m.removedwifi_scan))
		for id := range m.removedwifi_scan {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeCellScan:
		ids := make([]ent.Value, 0, len(m.removedcell_scan))
		for id := range m.removedcell_scan {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.removedwork_orders))
		for id := range m.removedwork_orders {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeFloorPlans:
		ids := make([]ent.Value, 0, len(m.removedfloor_plans))
		for id := range m.removedfloor_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.cleared_type {
		edges = append(edges, location.EdgeType)
	}
	if m.clearedparent {
		edges = append(edges, location.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, location.EdgeChildren)
	}
	if m.clearedfiles {
		edges = append(edges, location.EdgeFiles)
	}
	if m.clearedhyperlinks {
		edges = append(edges, location.EdgeHyperlinks)
	}
	if m.clearedequipment {
		edges = append(edges, location.EdgeEquipment)
	}
	if m.clearedproperties {
		edges = append(edges, location.EdgeProperties)
	}
	if m.clearedsurvey {
		edges = append(edges, location.EdgeSurvey)
	}
	if m.clearedwifi_scan {
		edges = append(edges, location.EdgeWifiScan)
	}
	if m.clearedcell_scan {
		edges = append(edges, location.EdgeCellScan)
	}
	if m.clearedwork_orders {
		edges = append(edges, location.EdgeWorkOrders)
	}
	if m.clearedfloor_plans {
		edges = append(edges, location.EdgeFloorPlans)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeType:
		return m.cleared_type
	case location.EdgeParent:
		return m.clearedparent
	case location.EdgeChildren:
		return m.clearedchildren
	case location.EdgeFiles:
		return m.clearedfiles
	case location.EdgeHyperlinks:
		return m.clearedhyperlinks
	case location.EdgeEquipment:
		return m.clearedequipment
	case location.EdgeProperties:
		return m.clearedproperties
	case location.EdgeSurvey:
		return m.clearedsurvey
	case location.EdgeWifiScan:
		return m.clearedwifi_scan
	case location.EdgeCellScan:
		return m.clearedcell_scan
	case location.EdgeWorkOrders:
		return m.clearedwork_orders
	case location.EdgeFloorPlans:
		return m.clearedfloor_plans
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeType:
		m.ClearType()
		return nil
	case location.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeType:
		m.ResetType()
		return nil
	case location.EdgeParent:
		m.ResetParent()
		return nil
	case location.EdgeChildren:
		m.ResetChildren()
		return nil
	case location.EdgeFiles:
		m.ResetFiles()
		return nil
	case location.EdgeHyperlinks:
		m.ResetHyperlinks()
		return nil
	case location.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case location.EdgeProperties:
		m.ResetProperties()
		return nil
	case location.EdgeSurvey:
		m.ResetSurvey()
		return nil
	case location.EdgeWifiScan:
		m.ResetWifiScan()
		return nil
	case location.EdgeCellScan:
		m.ResetCellScan()
		return nil
	case location.EdgeWorkOrders:
		m.ResetWorkOrders()
		return nil
	case location.EdgeFloorPlans:
		m.ResetFloorPlans()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// LocationTypeMutation represents an operation that mutate the LocationTypes
// nodes in the graph.
type LocationTypeMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	create_time                       *time.Time
	update_time                       *time.Time
	site                              *bool
	name                              *string
	map_type                          *string
	map_zoom_level                    *int
	addmap_zoom_level                 *int
	index                             *int
	addindex                          *int
	clearedFields                     map[string]struct{}
	locations                         map[int]struct{}
	removedlocations                  map[int]struct{}
	clearedlocations                  bool
	property_types                    map[int]struct{}
	removedproperty_types             map[int]struct{}
	clearedproperty_types             bool
	survey_template_categories        map[int]struct{}
	removedsurvey_template_categories map[int]struct{}
	clearedsurvey_template_categories bool
	document_category                 map[int]struct{}
	removeddocument_category          map[int]struct{}
	cleareddocument_category          bool
	done                              bool
	oldValue                          func(context.Context) (*LocationType, error)
	predicates                        []predicate.LocationType
}

var _ ent.Mutation = (*LocationTypeMutation)(nil)

// locationtypeOption allows to manage the mutation configuration using functional options.
type locationtypeOption func(*LocationTypeMutation)

// newLocationTypeMutation creates new mutation for LocationType.
func newLocationTypeMutation(c config, op Op, opts ...locationtypeOption) *LocationTypeMutation {
	m := &LocationTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeLocationType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationTypeID sets the id field of the mutation.
func withLocationTypeID(id int) locationtypeOption {
	return func(m *LocationTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *LocationType
		)
		m.oldValue = func(ctx context.Context) (*LocationType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocationType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocationType sets the old LocationType of the mutation.
func withLocationType(node *LocationType) locationtypeOption {
	return func(m *LocationTypeMutation) {
		m.oldValue = func(context.Context) (*LocationType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LocationTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *LocationTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *LocationTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the LocationType.
// If the LocationType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *LocationTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *LocationTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *LocationTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the LocationType.
// If the LocationType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *LocationTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSite sets the site field.
func (m *LocationTypeMutation) SetSite(b bool) {
	m.site = &b
}

// Site returns the site value in the mutation.
func (m *LocationTypeMutation) Site() (r bool, exists bool) {
	v := m.site
	if v == nil {
		return
	}
	return *v, true
}

// OldSite returns the old site value of the LocationType.
// If the LocationType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationTypeMutation) OldSite(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSite is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSite: %w", err)
	}
	return oldValue.Site, nil
}

// ResetSite reset all changes of the "site" field.
func (m *LocationTypeMutation) ResetSite() {
	m.site = nil
}

// SetName sets the name field.
func (m *LocationTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *LocationTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the LocationType.
// If the LocationType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *LocationTypeMutation) ResetName() {
	m.name = nil
}

// SetMapType sets the map_type field.
func (m *LocationTypeMutation) SetMapType(s string) {
	m.map_type = &s
}

// MapType returns the map_type value in the mutation.
func (m *LocationTypeMutation) MapType() (r string, exists bool) {
	v := m.map_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMapType returns the old map_type value of the LocationType.
// If the LocationType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationTypeMutation) OldMapType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMapType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMapType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapType: %w", err)
	}
	return oldValue.MapType, nil
}

// ClearMapType clears the value of map_type.
func (m *LocationTypeMutation) ClearMapType() {
	m.map_type = nil
	m.clearedFields[locationtype.FieldMapType] = struct{}{}
}

// MapTypeCleared returns if the field map_type was cleared in this mutation.
func (m *LocationTypeMutation) MapTypeCleared() bool {
	_, ok := m.clearedFields[locationtype.FieldMapType]
	return ok
}

// ResetMapType reset all changes of the "map_type" field.
func (m *LocationTypeMutation) ResetMapType() {
	m.map_type = nil
	delete(m.clearedFields, locationtype.FieldMapType)
}

// SetMapZoomLevel sets the map_zoom_level field.
func (m *LocationTypeMutation) SetMapZoomLevel(i int) {
	m.map_zoom_level = &i
	m.addmap_zoom_level = nil
}

// MapZoomLevel returns the map_zoom_level value in the mutation.
func (m *LocationTypeMutation) MapZoomLevel() (r int, exists bool) {
	v := m.map_zoom_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMapZoomLevel returns the old map_zoom_level value of the LocationType.
// If the LocationType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationTypeMutation) OldMapZoomLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMapZoomLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMapZoomLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapZoomLevel: %w", err)
	}
	return oldValue.MapZoomLevel, nil
}

// AddMapZoomLevel adds i to map_zoom_level.
func (m *LocationTypeMutation) AddMapZoomLevel(i int) {
	if m.addmap_zoom_level != nil {
		*m.addmap_zoom_level += i
	} else {
		m.addmap_zoom_level = &i
	}
}

// AddedMapZoomLevel returns the value that was added to the map_zoom_level field in this mutation.
func (m *LocationTypeMutation) AddedMapZoomLevel() (r int, exists bool) {
	v := m.addmap_zoom_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearMapZoomLevel clears the value of map_zoom_level.
func (m *LocationTypeMutation) ClearMapZoomLevel() {
	m.map_zoom_level = nil
	m.addmap_zoom_level = nil
	m.clearedFields[locationtype.FieldMapZoomLevel] = struct{}{}
}

// MapZoomLevelCleared returns if the field map_zoom_level was cleared in this mutation.
func (m *LocationTypeMutation) MapZoomLevelCleared() bool {
	_, ok := m.clearedFields[locationtype.FieldMapZoomLevel]
	return ok
}

// ResetMapZoomLevel reset all changes of the "map_zoom_level" field.
func (m *LocationTypeMutation) ResetMapZoomLevel() {
	m.map_zoom_level = nil
	m.addmap_zoom_level = nil
	delete(m.clearedFields, locationtype.FieldMapZoomLevel)
}

// SetIndex sets the index field.
func (m *LocationTypeMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *LocationTypeMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the LocationType.
// If the LocationType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationTypeMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *LocationTypeMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *LocationTypeMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *LocationTypeMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// AddLocationIDs adds the locations edge to Location by ids.
func (m *LocationTypeMutation) AddLocationIDs(ids ...int) {
	if m.locations == nil {
		m.locations = make(map[int]struct{})
	}
	for i := range ids {
		m.locations[ids[i]] = struct{}{}
	}
}

// ClearLocations clears the locations edge to Location.
func (m *LocationTypeMutation) ClearLocations() {
	m.clearedlocations = true
}

// LocationsCleared returns if the edge locations was cleared.
func (m *LocationTypeMutation) LocationsCleared() bool {
	return m.clearedlocations
}

// RemoveLocationIDs removes the locations edge to Location by ids.
func (m *LocationTypeMutation) RemoveLocationIDs(ids ...int) {
	if m.removedlocations == nil {
		m.removedlocations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlocations[ids[i]] = struct{}{}
	}
}

// RemovedLocations returns the removed ids of locations.
func (m *LocationTypeMutation) RemovedLocationsIDs() (ids []int) {
	for id := range m.removedlocations {
		ids = append(ids, id)
	}
	return
}

// LocationsIDs returns the locations ids in the mutation.
func (m *LocationTypeMutation) LocationsIDs() (ids []int) {
	for id := range m.locations {
		ids = append(ids, id)
	}
	return
}

// ResetLocations reset all changes of the "locations" edge.
func (m *LocationTypeMutation) ResetLocations() {
	m.locations = nil
	m.clearedlocations = false
	m.removedlocations = nil
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *LocationTypeMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// ClearPropertyTypes clears the property_types edge to PropertyType.
func (m *LocationTypeMutation) ClearPropertyTypes() {
	m.clearedproperty_types = true
}

// PropertyTypesCleared returns if the edge property_types was cleared.
func (m *LocationTypeMutation) PropertyTypesCleared() bool {
	return m.clearedproperty_types
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *LocationTypeMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *LocationTypeMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *LocationTypeMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *LocationTypeMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.clearedproperty_types = false
	m.removedproperty_types = nil
}

// AddSurveyTemplateCategoryIDs adds the survey_template_categories edge to SurveyTemplateCategory by ids.
func (m *LocationTypeMutation) AddSurveyTemplateCategoryIDs(ids ...int) {
	if m.survey_template_categories == nil {
		m.survey_template_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.survey_template_categories[ids[i]] = struct{}{}
	}
}

// ClearSurveyTemplateCategories clears the survey_template_categories edge to SurveyTemplateCategory.
func (m *LocationTypeMutation) ClearSurveyTemplateCategories() {
	m.clearedsurvey_template_categories = true
}

// SurveyTemplateCategoriesCleared returns if the edge survey_template_categories was cleared.
func (m *LocationTypeMutation) SurveyTemplateCategoriesCleared() bool {
	return m.clearedsurvey_template_categories
}

// RemoveSurveyTemplateCategoryIDs removes the survey_template_categories edge to SurveyTemplateCategory by ids.
func (m *LocationTypeMutation) RemoveSurveyTemplateCategoryIDs(ids ...int) {
	if m.removedsurvey_template_categories == nil {
		m.removedsurvey_template_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsurvey_template_categories[ids[i]] = struct{}{}
	}
}

// RemovedSurveyTemplateCategories returns the removed ids of survey_template_categories.
func (m *LocationTypeMutation) RemovedSurveyTemplateCategoriesIDs() (ids []int) {
	for id := range m.removedsurvey_template_categories {
		ids = append(ids, id)
	}
	return
}

// SurveyTemplateCategoriesIDs returns the survey_template_categories ids in the mutation.
func (m *LocationTypeMutation) SurveyTemplateCategoriesIDs() (ids []int) {
	for id := range m.survey_template_categories {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyTemplateCategories reset all changes of the "survey_template_categories" edge.
func (m *LocationTypeMutation) ResetSurveyTemplateCategories() {
	m.survey_template_categories = nil
	m.clearedsurvey_template_categories = false
	m.removedsurvey_template_categories = nil
}

// AddDocumentCategoryIDs adds the document_category edge to DocumentCategory by ids.
func (m *LocationTypeMutation) AddDocumentCategoryIDs(ids ...int) {
	if m.document_category == nil {
		m.document_category = make(map[int]struct{})
	}
	for i := range ids {
		m.document_category[ids[i]] = struct{}{}
	}
}

// ClearDocumentCategory clears the document_category edge to DocumentCategory.
func (m *LocationTypeMutation) ClearDocumentCategory() {
	m.cleareddocument_category = true
}

// DocumentCategoryCleared returns if the edge document_category was cleared.
func (m *LocationTypeMutation) DocumentCategoryCleared() bool {
	return m.cleareddocument_category
}

// RemoveDocumentCategoryIDs removes the document_category edge to DocumentCategory by ids.
func (m *LocationTypeMutation) RemoveDocumentCategoryIDs(ids ...int) {
	if m.removeddocument_category == nil {
		m.removeddocument_category = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddocument_category[ids[i]] = struct{}{}
	}
}

// RemovedDocumentCategory returns the removed ids of document_category.
func (m *LocationTypeMutation) RemovedDocumentCategoryIDs() (ids []int) {
	for id := range m.removeddocument_category {
		ids = append(ids, id)
	}
	return
}

// DocumentCategoryIDs returns the document_category ids in the mutation.
func (m *LocationTypeMutation) DocumentCategoryIDs() (ids []int) {
	for id := range m.document_category {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentCategory reset all changes of the "document_category" edge.
func (m *LocationTypeMutation) ResetDocumentCategory() {
	m.document_category = nil
	m.cleareddocument_category = false
	m.removeddocument_category = nil
}

// Op returns the operation name.
func (m *LocationTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LocationType).
func (m *LocationTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LocationTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, locationtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, locationtype.FieldUpdateTime)
	}
	if m.site != nil {
		fields = append(fields, locationtype.FieldSite)
	}
	if m.name != nil {
		fields = append(fields, locationtype.FieldName)
	}
	if m.map_type != nil {
		fields = append(fields, locationtype.FieldMapType)
	}
	if m.map_zoom_level != nil {
		fields = append(fields, locationtype.FieldMapZoomLevel)
	}
	if m.index != nil {
		fields = append(fields, locationtype.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LocationTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case locationtype.FieldCreateTime:
		return m.CreateTime()
	case locationtype.FieldUpdateTime:
		return m.UpdateTime()
	case locationtype.FieldSite:
		return m.Site()
	case locationtype.FieldName:
		return m.Name()
	case locationtype.FieldMapType:
		return m.MapType()
	case locationtype.FieldMapZoomLevel:
		return m.MapZoomLevel()
	case locationtype.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LocationTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case locationtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case locationtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case locationtype.FieldSite:
		return m.OldSite(ctx)
	case locationtype.FieldName:
		return m.OldName(ctx)
	case locationtype.FieldMapType:
		return m.OldMapType(ctx)
	case locationtype.FieldMapZoomLevel:
		return m.OldMapZoomLevel(ctx)
	case locationtype.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown LocationType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LocationTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case locationtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case locationtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case locationtype.FieldSite:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSite(v)
		return nil
	case locationtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case locationtype.FieldMapType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapType(v)
		return nil
	case locationtype.FieldMapZoomLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapZoomLevel(v)
		return nil
	case locationtype.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown LocationType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LocationTypeMutation) AddedFields() []string {
	var fields []string
	if m.addmap_zoom_level != nil {
		fields = append(fields, locationtype.FieldMapZoomLevel)
	}
	if m.addindex != nil {
		fields = append(fields, locationtype.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LocationTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case locationtype.FieldMapZoomLevel:
		return m.AddedMapZoomLevel()
	case locationtype.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LocationTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case locationtype.FieldMapZoomLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMapZoomLevel(v)
		return nil
	case locationtype.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown LocationType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LocationTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(locationtype.FieldMapType) {
		fields = append(fields, locationtype.FieldMapType)
	}
	if m.FieldCleared(locationtype.FieldMapZoomLevel) {
		fields = append(fields, locationtype.FieldMapZoomLevel)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LocationTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationTypeMutation) ClearField(name string) error {
	switch name {
	case locationtype.FieldMapType:
		m.ClearMapType()
		return nil
	case locationtype.FieldMapZoomLevel:
		m.ClearMapZoomLevel()
		return nil
	}
	return fmt.Errorf("unknown LocationType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LocationTypeMutation) ResetField(name string) error {
	switch name {
	case locationtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case locationtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case locationtype.FieldSite:
		m.ResetSite()
		return nil
	case locationtype.FieldName:
		m.ResetName()
		return nil
	case locationtype.FieldMapType:
		m.ResetMapType()
		return nil
	case locationtype.FieldMapZoomLevel:
		m.ResetMapZoomLevel()
		return nil
	case locationtype.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown LocationType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LocationTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.locations != nil {
		edges = append(edges, locationtype.EdgeLocations)
	}
	if m.property_types != nil {
		edges = append(edges, locationtype.EdgePropertyTypes)
	}
	if m.survey_template_categories != nil {
		edges = append(edges, locationtype.EdgeSurveyTemplateCategories)
	}
	if m.document_category != nil {
		edges = append(edges, locationtype.EdgeDocumentCategory)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LocationTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locationtype.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.locations))
		for id := range m.locations {
			ids = append(ids, id)
		}
		return ids
	case locationtype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	case locationtype.EdgeSurveyTemplateCategories:
		ids := make([]ent.Value, 0, len(m.survey_template_categories))
		for id := range m.survey_template_categories {
			ids = append(ids, id)
		}
		return ids
	case locationtype.EdgeDocumentCategory:
		ids := make([]ent.Value, 0, len(m.document_category))
		for id := range m.document_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LocationTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedlocations != nil {
		edges = append(edges, locationtype.EdgeLocations)
	}
	if m.removedproperty_types != nil {
		edges = append(edges, locationtype.EdgePropertyTypes)
	}
	if m.removedsurvey_template_categories != nil {
		edges = append(edges, locationtype.EdgeSurveyTemplateCategories)
	}
	if m.removeddocument_category != nil {
		edges = append(edges, locationtype.EdgeDocumentCategory)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LocationTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case locationtype.EdgeLocations:
		ids := make([]ent.Value, 0, len(m.removedlocations))
		for id := range m.removedlocations {
			ids = append(ids, id)
		}
		return ids
	case locationtype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	case locationtype.EdgeSurveyTemplateCategories:
		ids := make([]ent.Value, 0, len(m.removedsurvey_template_categories))
		for id := range m.removedsurvey_template_categories {
			ids = append(ids, id)
		}
		return ids
	case locationtype.EdgeDocumentCategory:
		ids := make([]ent.Value, 0, len(m.removeddocument_category))
		for id := range m.removeddocument_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LocationTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedlocations {
		edges = append(edges, locationtype.EdgeLocations)
	}
	if m.clearedproperty_types {
		edges = append(edges, locationtype.EdgePropertyTypes)
	}
	if m.clearedsurvey_template_categories {
		edges = append(edges, locationtype.EdgeSurveyTemplateCategories)
	}
	if m.cleareddocument_category {
		edges = append(edges, locationtype.EdgeDocumentCategory)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LocationTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case locationtype.EdgeLocations:
		return m.clearedlocations
	case locationtype.EdgePropertyTypes:
		return m.clearedproperty_types
	case locationtype.EdgeSurveyTemplateCategories:
		return m.clearedsurvey_template_categories
	case locationtype.EdgeDocumentCategory:
		return m.cleareddocument_category
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LocationTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LocationType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LocationTypeMutation) ResetEdge(name string) error {
	switch name {
	case locationtype.EdgeLocations:
		m.ResetLocations()
		return nil
	case locationtype.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	case locationtype.EdgeSurveyTemplateCategories:
		m.ResetSurveyTemplateCategories()
		return nil
	case locationtype.EdgeDocumentCategory:
		m.ResetDocumentCategory()
		return nil
	}
	return fmt.Errorf("unknown LocationType edge %s", name)
}

// NetworkTypeMutation represents an operation that mutate the NetworkTypes
// nodes in the graph.
type NetworkTypeMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	name                         *string
	clearedFields                map[string]struct{}
	formulaNetworkType_FK        map[int]struct{}
	removedformulaNetworkType_FK map[int]struct{}
	clearedformulaNetworkType_FK bool
	done                         bool
	oldValue                     func(context.Context) (*NetworkType, error)
	predicates                   []predicate.NetworkType
}

var _ ent.Mutation = (*NetworkTypeMutation)(nil)

// networktypeOption allows to manage the mutation configuration using functional options.
type networktypeOption func(*NetworkTypeMutation)

// newNetworkTypeMutation creates new mutation for NetworkType.
func newNetworkTypeMutation(c config, op Op, opts ...networktypeOption) *NetworkTypeMutation {
	m := &NetworkTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkTypeID sets the id field of the mutation.
func withNetworkTypeID(id int) networktypeOption {
	return func(m *NetworkTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkType
		)
		m.oldValue = func(ctx context.Context) (*NetworkType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkType sets the old NetworkType of the mutation.
func withNetworkType(node *NetworkType) networktypeOption {
	return func(m *NetworkTypeMutation) {
		m.oldValue = func(context.Context) (*NetworkType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NetworkTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *NetworkTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *NetworkTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the NetworkType.
// If the NetworkType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NetworkTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *NetworkTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *NetworkTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *NetworkTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the NetworkType.
// If the NetworkType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NetworkTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *NetworkTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *NetworkTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *NetworkTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the NetworkType.
// If the NetworkType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NetworkTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *NetworkTypeMutation) ResetName() {
	m.name = nil
}

// AddFormulaNetworkTypeFKIDs adds the formulaNetworkType_FK edge to Formula by ids.
func (m *NetworkTypeMutation) AddFormulaNetworkTypeFKIDs(ids ...int) {
	if m.formulaNetworkType_FK == nil {
		m.formulaNetworkType_FK = make(map[int]struct{})
	}
	for i := range ids {
		m.formulaNetworkType_FK[ids[i]] = struct{}{}
	}
}

// ClearFormulaNetworkTypeFK clears the formulaNetworkType_FK edge to Formula.
func (m *NetworkTypeMutation) ClearFormulaNetworkTypeFK() {
	m.clearedformulaNetworkType_FK = true
}

// FormulaNetworkTypeFKCleared returns if the edge formulaNetworkType_FK was cleared.
func (m *NetworkTypeMutation) FormulaNetworkTypeFKCleared() bool {
	return m.clearedformulaNetworkType_FK
}

// RemoveFormulaNetworkTypeFKIDs removes the formulaNetworkType_FK edge to Formula by ids.
func (m *NetworkTypeMutation) RemoveFormulaNetworkTypeFKIDs(ids ...int) {
	if m.removedformulaNetworkType_FK == nil {
		m.removedformulaNetworkType_FK = make(map[int]struct{})
	}
	for i := range ids {
		m.removedformulaNetworkType_FK[ids[i]] = struct{}{}
	}
}

// RemovedFormulaNetworkTypeFK returns the removed ids of formulaNetworkType_FK.
func (m *NetworkTypeMutation) RemovedFormulaNetworkTypeFKIDs() (ids []int) {
	for id := range m.removedformulaNetworkType_FK {
		ids = append(ids, id)
	}
	return
}

// FormulaNetworkTypeFKIDs returns the formulaNetworkType_FK ids in the mutation.
func (m *NetworkTypeMutation) FormulaNetworkTypeFKIDs() (ids []int) {
	for id := range m.formulaNetworkType_FK {
		ids = append(ids, id)
	}
	return
}

// ResetFormulaNetworkTypeFK reset all changes of the "formulaNetworkType_FK" edge.
func (m *NetworkTypeMutation) ResetFormulaNetworkTypeFK() {
	m.formulaNetworkType_FK = nil
	m.clearedformulaNetworkType_FK = false
	m.removedformulaNetworkType_FK = nil
}

// Op returns the operation name.
func (m *NetworkTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetworkType).
func (m *NetworkTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NetworkTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, networktype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, networktype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, networktype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NetworkTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networktype.FieldCreateTime:
		return m.CreateTime()
	case networktype.FieldUpdateTime:
		return m.UpdateTime()
	case networktype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NetworkTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networktype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case networktype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case networktype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NetworkTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networktype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case networktype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case networktype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NetworkTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NetworkTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NetworkTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NetworkTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NetworkTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetworkType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NetworkTypeMutation) ResetField(name string) error {
	switch name {
	case networktype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case networktype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case networktype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown NetworkType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NetworkTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.formulaNetworkType_FK != nil {
		edges = append(edges, networktype.EdgeFormulaNetworkTypeFK)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NetworkTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networktype.EdgeFormulaNetworkTypeFK:
		ids := make([]ent.Value, 0, len(m.formulaNetworkType_FK))
		for id := range m.formulaNetworkType_FK {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NetworkTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedformulaNetworkType_FK != nil {
		edges = append(edges, networktype.EdgeFormulaNetworkTypeFK)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NetworkTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case networktype.EdgeFormulaNetworkTypeFK:
		ids := make([]ent.Value, 0, len(m.removedformulaNetworkType_FK))
		for id := range m.removedformulaNetworkType_FK {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NetworkTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedformulaNetworkType_FK {
		edges = append(edges, networktype.EdgeFormulaNetworkTypeFK)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NetworkTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case networktype.EdgeFormulaNetworkTypeFK:
		return m.clearedformulaNetworkType_FK
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NetworkTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NetworkTypeMutation) ResetEdge(name string) error {
	switch name {
	case networktype.EdgeFormulaNetworkTypeFK:
		m.ResetFormulaNetworkTypeFK()
		return nil
	}
	return fmt.Errorf("unknown NetworkType edge %s", name)
}

// OrganizationMutation represents an operation that mutate the Organizations
// nodes in the graph.
type OrganizationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	description          *string
	clearedFields        map[string]struct{}
	user_fk              map[int]struct{}
	removeduser_fk       map[int]struct{}
	cleareduser_fk       bool
	work_order_fk        map[int]struct{}
	removedwork_order_fk map[int]struct{}
	clearedwork_order_fk bool
	policies             map[int]struct{}
	removedpolicies      map[int]struct{}
	clearedpolicies      bool
	done                 bool
	oldValue             func(context.Context) (*Organization, error)
	predicates           []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows to manage the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for Organization.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the id field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *OrganizationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *OrganizationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Organization.
// If the Organization object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrganizationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *OrganizationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *OrganizationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *OrganizationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Organization.
// If the Organization object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrganizationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *OrganizationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Organization.
// If the Organization object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *OrganizationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *OrganizationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Organization.
// If the Organization object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrganizationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *OrganizationMutation) ResetDescription() {
	m.description = nil
}

// AddUserFkIDs adds the user_fk edge to User by ids.
func (m *OrganizationMutation) AddUserFkIDs(ids ...int) {
	if m.user_fk == nil {
		m.user_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.user_fk[ids[i]] = struct{}{}
	}
}

// ClearUserFk clears the user_fk edge to User.
func (m *OrganizationMutation) ClearUserFk() {
	m.cleareduser_fk = true
}

// UserFkCleared returns if the edge user_fk was cleared.
func (m *OrganizationMutation) UserFkCleared() bool {
	return m.cleareduser_fk
}

// RemoveUserFkIDs removes the user_fk edge to User by ids.
func (m *OrganizationMutation) RemoveUserFkIDs(ids ...int) {
	if m.removeduser_fk == nil {
		m.removeduser_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_fk[ids[i]] = struct{}{}
	}
}

// RemovedUserFk returns the removed ids of user_fk.
func (m *OrganizationMutation) RemovedUserFkIDs() (ids []int) {
	for id := range m.removeduser_fk {
		ids = append(ids, id)
	}
	return
}

// UserFkIDs returns the user_fk ids in the mutation.
func (m *OrganizationMutation) UserFkIDs() (ids []int) {
	for id := range m.user_fk {
		ids = append(ids, id)
	}
	return
}

// ResetUserFk reset all changes of the "user_fk" edge.
func (m *OrganizationMutation) ResetUserFk() {
	m.user_fk = nil
	m.cleareduser_fk = false
	m.removeduser_fk = nil
}

// AddWorkOrderFkIDs adds the work_order_fk edge to WorkOrder by ids.
func (m *OrganizationMutation) AddWorkOrderFkIDs(ids ...int) {
	if m.work_order_fk == nil {
		m.work_order_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.work_order_fk[ids[i]] = struct{}{}
	}
}

// ClearWorkOrderFk clears the work_order_fk edge to WorkOrder.
func (m *OrganizationMutation) ClearWorkOrderFk() {
	m.clearedwork_order_fk = true
}

// WorkOrderFkCleared returns if the edge work_order_fk was cleared.
func (m *OrganizationMutation) WorkOrderFkCleared() bool {
	return m.clearedwork_order_fk
}

// RemoveWorkOrderFkIDs removes the work_order_fk edge to WorkOrder by ids.
func (m *OrganizationMutation) RemoveWorkOrderFkIDs(ids ...int) {
	if m.removedwork_order_fk == nil {
		m.removedwork_order_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_order_fk[ids[i]] = struct{}{}
	}
}

// RemovedWorkOrderFk returns the removed ids of work_order_fk.
func (m *OrganizationMutation) RemovedWorkOrderFkIDs() (ids []int) {
	for id := range m.removedwork_order_fk {
		ids = append(ids, id)
	}
	return
}

// WorkOrderFkIDs returns the work_order_fk ids in the mutation.
func (m *OrganizationMutation) WorkOrderFkIDs() (ids []int) {
	for id := range m.work_order_fk {
		ids = append(ids, id)
	}
	return
}

// ResetWorkOrderFk reset all changes of the "work_order_fk" edge.
func (m *OrganizationMutation) ResetWorkOrderFk() {
	m.work_order_fk = nil
	m.clearedwork_order_fk = false
	m.removedwork_order_fk = nil
}

// AddPolicyIDs adds the policies edge to PermissionsPolicy by ids.
func (m *OrganizationMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the policies edge to PermissionsPolicy.
func (m *OrganizationMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared returns if the edge policies was cleared.
func (m *OrganizationMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the policies edge to PermissionsPolicy by ids.
func (m *OrganizationMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed ids of policies.
func (m *OrganizationMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the policies ids in the mutation.
func (m *OrganizationMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies reset all changes of the "policies" edge.
func (m *OrganizationMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, organization.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, organization.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.description != nil {
		fields = append(fields, organization.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreateTime:
		return m.CreateTime()
	case organization.FieldUpdateTime:
		return m.UpdateTime()
	case organization.FieldName:
		return m.Name()
	case organization.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case organization.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case organization.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case organization.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user_fk != nil {
		edges = append(edges, organization.EdgeUserFk)
	}
	if m.work_order_fk != nil {
		edges = append(edges, organization.EdgeWorkOrderFk)
	}
	if m.policies != nil {
		edges = append(edges, organization.EdgePolicies)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUserFk:
		ids := make([]ent.Value, 0, len(m.user_fk))
		for id := range m.user_fk {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWorkOrderFk:
		ids := make([]ent.Value, 0, len(m.work_order_fk))
		for id := range m.work_order_fk {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_fk != nil {
		edges = append(edges, organization.EdgeUserFk)
	}
	if m.removedwork_order_fk != nil {
		edges = append(edges, organization.EdgeWorkOrderFk)
	}
	if m.removedpolicies != nil {
		edges = append(edges, organization.EdgePolicies)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUserFk:
		ids := make([]ent.Value, 0, len(m.removeduser_fk))
		for id := range m.removeduser_fk {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWorkOrderFk:
		ids := make([]ent.Value, 0, len(m.removedwork_order_fk))
		for id := range m.removedwork_order_fk {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser_fk {
		edges = append(edges, organization.EdgeUserFk)
	}
	if m.clearedwork_order_fk {
		edges = append(edges, organization.EdgeWorkOrderFk)
	}
	if m.clearedpolicies {
		edges = append(edges, organization.EdgePolicies)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeUserFk:
		return m.cleareduser_fk
	case organization.EdgeWorkOrderFk:
		return m.clearedwork_order_fk
	case organization.EdgePolicies:
		return m.clearedpolicies
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeUserFk:
		m.ResetUserFk()
		return nil
	case organization.EdgeWorkOrderFk:
		m.ResetWorkOrderFk()
		return nil
	case organization.EdgePolicies:
		m.ResetPolicies()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// ParameterCatalogMutation represents an operation that mutate the ParameterCatalogs
// nodes in the graph.
type ParameterCatalogMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	name                       *string
	index                      *int
	addindex                   *int
	disabled                   *bool
	clearedFields              map[string]struct{}
	property_categories        map[int]struct{}
	removedproperty_categories map[int]struct{}
	clearedproperty_categories bool
	done                       bool
	oldValue                   func(context.Context) (*ParameterCatalog, error)
	predicates                 []predicate.ParameterCatalog
}

var _ ent.Mutation = (*ParameterCatalogMutation)(nil)

// parametercatalogOption allows to manage the mutation configuration using functional options.
type parametercatalogOption func(*ParameterCatalogMutation)

// newParameterCatalogMutation creates new mutation for ParameterCatalog.
func newParameterCatalogMutation(c config, op Op, opts ...parametercatalogOption) *ParameterCatalogMutation {
	m := &ParameterCatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeParameterCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParameterCatalogID sets the id field of the mutation.
func withParameterCatalogID(id int) parametercatalogOption {
	return func(m *ParameterCatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *ParameterCatalog
		)
		m.oldValue = func(ctx context.Context) (*ParameterCatalog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParameterCatalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParameterCatalog sets the old ParameterCatalog of the mutation.
func withParameterCatalog(node *ParameterCatalog) parametercatalogOption {
	return func(m *ParameterCatalogMutation) {
		m.oldValue = func(context.Context) (*ParameterCatalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParameterCatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParameterCatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ParameterCatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ParameterCatalogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ParameterCatalogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ParameterCatalog.
// If the ParameterCatalog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParameterCatalogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ParameterCatalogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ParameterCatalogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ParameterCatalogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ParameterCatalog.
// If the ParameterCatalog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParameterCatalogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ParameterCatalogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ParameterCatalogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ParameterCatalogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ParameterCatalog.
// If the ParameterCatalog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParameterCatalogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ParameterCatalogMutation) ResetName() {
	m.name = nil
}

// SetIndex sets the index field.
func (m *ParameterCatalogMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *ParameterCatalogMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the ParameterCatalog.
// If the ParameterCatalog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParameterCatalogMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *ParameterCatalogMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *ParameterCatalogMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *ParameterCatalogMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetDisabled sets the disabled field.
func (m *ParameterCatalogMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the disabled value in the mutation.
func (m *ParameterCatalogMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old disabled value of the ParameterCatalog.
// If the ParameterCatalog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ParameterCatalogMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled reset all changes of the "disabled" field.
func (m *ParameterCatalogMutation) ResetDisabled() {
	m.disabled = nil
}

// AddPropertyCategoryIDs adds the property_categories edge to PropertyCategory by ids.
func (m *ParameterCatalogMutation) AddPropertyCategoryIDs(ids ...int) {
	if m.property_categories == nil {
		m.property_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.property_categories[ids[i]] = struct{}{}
	}
}

// ClearPropertyCategories clears the property_categories edge to PropertyCategory.
func (m *ParameterCatalogMutation) ClearPropertyCategories() {
	m.clearedproperty_categories = true
}

// PropertyCategoriesCleared returns if the edge property_categories was cleared.
func (m *ParameterCatalogMutation) PropertyCategoriesCleared() bool {
	return m.clearedproperty_categories
}

// RemovePropertyCategoryIDs removes the property_categories edge to PropertyCategory by ids.
func (m *ParameterCatalogMutation) RemovePropertyCategoryIDs(ids ...int) {
	if m.removedproperty_categories == nil {
		m.removedproperty_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_categories[ids[i]] = struct{}{}
	}
}

// RemovedPropertyCategories returns the removed ids of property_categories.
func (m *ParameterCatalogMutation) RemovedPropertyCategoriesIDs() (ids []int) {
	for id := range m.removedproperty_categories {
		ids = append(ids, id)
	}
	return
}

// PropertyCategoriesIDs returns the property_categories ids in the mutation.
func (m *ParameterCatalogMutation) PropertyCategoriesIDs() (ids []int) {
	for id := range m.property_categories {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyCategories reset all changes of the "property_categories" edge.
func (m *ParameterCatalogMutation) ResetPropertyCategories() {
	m.property_categories = nil
	m.clearedproperty_categories = false
	m.removedproperty_categories = nil
}

// Op returns the operation name.
func (m *ParameterCatalogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ParameterCatalog).
func (m *ParameterCatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ParameterCatalogMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, parametercatalog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, parametercatalog.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, parametercatalog.FieldName)
	}
	if m.index != nil {
		fields = append(fields, parametercatalog.FieldIndex)
	}
	if m.disabled != nil {
		fields = append(fields, parametercatalog.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ParameterCatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parametercatalog.FieldCreateTime:
		return m.CreateTime()
	case parametercatalog.FieldUpdateTime:
		return m.UpdateTime()
	case parametercatalog.FieldName:
		return m.Name()
	case parametercatalog.FieldIndex:
		return m.Index()
	case parametercatalog.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ParameterCatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parametercatalog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case parametercatalog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case parametercatalog.FieldName:
		return m.OldName(ctx)
	case parametercatalog.FieldIndex:
		return m.OldIndex(ctx)
	case parametercatalog.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown ParameterCatalog field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ParameterCatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parametercatalog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case parametercatalog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case parametercatalog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case parametercatalog.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case parametercatalog.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown ParameterCatalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ParameterCatalogMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, parametercatalog.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ParameterCatalogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case parametercatalog.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ParameterCatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case parametercatalog.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown ParameterCatalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ParameterCatalogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ParameterCatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParameterCatalogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ParameterCatalog nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ParameterCatalogMutation) ResetField(name string) error {
	switch name {
	case parametercatalog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case parametercatalog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case parametercatalog.FieldName:
		m.ResetName()
		return nil
	case parametercatalog.FieldIndex:
		m.ResetIndex()
		return nil
	case parametercatalog.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown ParameterCatalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ParameterCatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.property_categories != nil {
		edges = append(edges, parametercatalog.EdgePropertyCategories)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ParameterCatalogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parametercatalog.EdgePropertyCategories:
		ids := make([]ent.Value, 0, len(m.property_categories))
		for id := range m.property_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ParameterCatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproperty_categories != nil {
		edges = append(edges, parametercatalog.EdgePropertyCategories)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ParameterCatalogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case parametercatalog.EdgePropertyCategories:
		ids := make([]ent.Value, 0, len(m.removedproperty_categories))
		for id := range m.removedproperty_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ParameterCatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproperty_categories {
		edges = append(edges, parametercatalog.EdgePropertyCategories)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ParameterCatalogMutation) EdgeCleared(name string) bool {
	switch name {
	case parametercatalog.EdgePropertyCategories:
		return m.clearedproperty_categories
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ParameterCatalogMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ParameterCatalog unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ParameterCatalogMutation) ResetEdge(name string) error {
	switch name {
	case parametercatalog.EdgePropertyCategories:
		m.ResetPropertyCategories()
		return nil
	}
	return fmt.Errorf("unknown ParameterCatalog edge %s", name)
}

// PermissionsPolicyMutation represents an operation that mutate the PermissionsPolicies
// nodes in the graph.
type PermissionsPolicyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	description         *string
	is_global           *bool
	inventory_policy    **models.InventoryPolicyInput
	workforce_policy    **models.WorkforcePolicyInput
	automation_policy   **models.AutomationPolicyInput
	assurance_policy    **models.AssurancePolicyInput
	clearedFields       map[string]struct{}
	groups              map[int]struct{}
	removedgroups       map[int]struct{}
	clearedgroups       bool
	organization        map[int]struct{}
	removedorganization map[int]struct{}
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*PermissionsPolicy, error)
	predicates          []predicate.PermissionsPolicy
}

var _ ent.Mutation = (*PermissionsPolicyMutation)(nil)

// permissionspolicyOption allows to manage the mutation configuration using functional options.
type permissionspolicyOption func(*PermissionsPolicyMutation)

// newPermissionsPolicyMutation creates new mutation for PermissionsPolicy.
func newPermissionsPolicyMutation(c config, op Op, opts ...permissionspolicyOption) *PermissionsPolicyMutation {
	m := &PermissionsPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionsPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionsPolicyID sets the id field of the mutation.
func withPermissionsPolicyID(id int) permissionspolicyOption {
	return func(m *PermissionsPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionsPolicy
		)
		m.oldValue = func(ctx context.Context) (*PermissionsPolicy, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionsPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionsPolicy sets the old PermissionsPolicy of the mutation.
func withPermissionsPolicy(node *PermissionsPolicy) permissionspolicyOption {
	return func(m *PermissionsPolicyMutation) {
		m.oldValue = func(context.Context) (*PermissionsPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionsPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionsPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PermissionsPolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *PermissionsPolicyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *PermissionsPolicyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *PermissionsPolicyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *PermissionsPolicyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *PermissionsPolicyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *PermissionsPolicyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *PermissionsPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PermissionsPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PermissionsPolicyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *PermissionsPolicyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *PermissionsPolicyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *PermissionsPolicyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permissionspolicy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *PermissionsPolicyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permissionspolicy.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *PermissionsPolicyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permissionspolicy.FieldDescription)
}

// SetIsGlobal sets the is_global field.
func (m *PermissionsPolicyMutation) SetIsGlobal(b bool) {
	m.is_global = &b
}

// IsGlobal returns the is_global value in the mutation.
func (m *PermissionsPolicyMutation) IsGlobal() (r bool, exists bool) {
	v := m.is_global
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGlobal returns the old is_global value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldIsGlobal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsGlobal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsGlobal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGlobal: %w", err)
	}
	return oldValue.IsGlobal, nil
}

// ClearIsGlobal clears the value of is_global.
func (m *PermissionsPolicyMutation) ClearIsGlobal() {
	m.is_global = nil
	m.clearedFields[permissionspolicy.FieldIsGlobal] = struct{}{}
}

// IsGlobalCleared returns if the field is_global was cleared in this mutation.
func (m *PermissionsPolicyMutation) IsGlobalCleared() bool {
	_, ok := m.clearedFields[permissionspolicy.FieldIsGlobal]
	return ok
}

// ResetIsGlobal reset all changes of the "is_global" field.
func (m *PermissionsPolicyMutation) ResetIsGlobal() {
	m.is_global = nil
	delete(m.clearedFields, permissionspolicy.FieldIsGlobal)
}

// SetInventoryPolicy sets the inventory_policy field.
func (m *PermissionsPolicyMutation) SetInventoryPolicy(mpi *models.InventoryPolicyInput) {
	m.inventory_policy = &mpi
}

// InventoryPolicy returns the inventory_policy value in the mutation.
func (m *PermissionsPolicyMutation) InventoryPolicy() (r *models.InventoryPolicyInput, exists bool) {
	v := m.inventory_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryPolicy returns the old inventory_policy value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldInventoryPolicy(ctx context.Context) (v *models.InventoryPolicyInput, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInventoryPolicy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInventoryPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryPolicy: %w", err)
	}
	return oldValue.InventoryPolicy, nil
}

// ClearInventoryPolicy clears the value of inventory_policy.
func (m *PermissionsPolicyMutation) ClearInventoryPolicy() {
	m.inventory_policy = nil
	m.clearedFields[permissionspolicy.FieldInventoryPolicy] = struct{}{}
}

// InventoryPolicyCleared returns if the field inventory_policy was cleared in this mutation.
func (m *PermissionsPolicyMutation) InventoryPolicyCleared() bool {
	_, ok := m.clearedFields[permissionspolicy.FieldInventoryPolicy]
	return ok
}

// ResetInventoryPolicy reset all changes of the "inventory_policy" field.
func (m *PermissionsPolicyMutation) ResetInventoryPolicy() {
	m.inventory_policy = nil
	delete(m.clearedFields, permissionspolicy.FieldInventoryPolicy)
}

// SetWorkforcePolicy sets the workforce_policy field.
func (m *PermissionsPolicyMutation) SetWorkforcePolicy(mpi *models.WorkforcePolicyInput) {
	m.workforce_policy = &mpi
}

// WorkforcePolicy returns the workforce_policy value in the mutation.
func (m *PermissionsPolicyMutation) WorkforcePolicy() (r *models.WorkforcePolicyInput, exists bool) {
	v := m.workforce_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkforcePolicy returns the old workforce_policy value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldWorkforcePolicy(ctx context.Context) (v *models.WorkforcePolicyInput, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkforcePolicy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkforcePolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkforcePolicy: %w", err)
	}
	return oldValue.WorkforcePolicy, nil
}

// ClearWorkforcePolicy clears the value of workforce_policy.
func (m *PermissionsPolicyMutation) ClearWorkforcePolicy() {
	m.workforce_policy = nil
	m.clearedFields[permissionspolicy.FieldWorkforcePolicy] = struct{}{}
}

// WorkforcePolicyCleared returns if the field workforce_policy was cleared in this mutation.
func (m *PermissionsPolicyMutation) WorkforcePolicyCleared() bool {
	_, ok := m.clearedFields[permissionspolicy.FieldWorkforcePolicy]
	return ok
}

// ResetWorkforcePolicy reset all changes of the "workforce_policy" field.
func (m *PermissionsPolicyMutation) ResetWorkforcePolicy() {
	m.workforce_policy = nil
	delete(m.clearedFields, permissionspolicy.FieldWorkforcePolicy)
}

// SetAutomationPolicy sets the automation_policy field.
func (m *PermissionsPolicyMutation) SetAutomationPolicy(mpi *models.AutomationPolicyInput) {
	m.automation_policy = &mpi
}

// AutomationPolicy returns the automation_policy value in the mutation.
func (m *PermissionsPolicyMutation) AutomationPolicy() (r *models.AutomationPolicyInput, exists bool) {
	v := m.automation_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldAutomationPolicy returns the old automation_policy value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldAutomationPolicy(ctx context.Context) (v *models.AutomationPolicyInput, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutomationPolicy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutomationPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutomationPolicy: %w", err)
	}
	return oldValue.AutomationPolicy, nil
}

// ClearAutomationPolicy clears the value of automation_policy.
func (m *PermissionsPolicyMutation) ClearAutomationPolicy() {
	m.automation_policy = nil
	m.clearedFields[permissionspolicy.FieldAutomationPolicy] = struct{}{}
}

// AutomationPolicyCleared returns if the field automation_policy was cleared in this mutation.
func (m *PermissionsPolicyMutation) AutomationPolicyCleared() bool {
	_, ok := m.clearedFields[permissionspolicy.FieldAutomationPolicy]
	return ok
}

// ResetAutomationPolicy reset all changes of the "automation_policy" field.
func (m *PermissionsPolicyMutation) ResetAutomationPolicy() {
	m.automation_policy = nil
	delete(m.clearedFields, permissionspolicy.FieldAutomationPolicy)
}

// SetAssurancePolicy sets the assurance_policy field.
func (m *PermissionsPolicyMutation) SetAssurancePolicy(mpi *models.AssurancePolicyInput) {
	m.assurance_policy = &mpi
}

// AssurancePolicy returns the assurance_policy value in the mutation.
func (m *PermissionsPolicyMutation) AssurancePolicy() (r *models.AssurancePolicyInput, exists bool) {
	v := m.assurance_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldAssurancePolicy returns the old assurance_policy value of the PermissionsPolicy.
// If the PermissionsPolicy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PermissionsPolicyMutation) OldAssurancePolicy(ctx context.Context) (v *models.AssurancePolicyInput, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAssurancePolicy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAssurancePolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssurancePolicy: %w", err)
	}
	return oldValue.AssurancePolicy, nil
}

// ClearAssurancePolicy clears the value of assurance_policy.
func (m *PermissionsPolicyMutation) ClearAssurancePolicy() {
	m.assurance_policy = nil
	m.clearedFields[permissionspolicy.FieldAssurancePolicy] = struct{}{}
}

// AssurancePolicyCleared returns if the field assurance_policy was cleared in this mutation.
func (m *PermissionsPolicyMutation) AssurancePolicyCleared() bool {
	_, ok := m.clearedFields[permissionspolicy.FieldAssurancePolicy]
	return ok
}

// ResetAssurancePolicy reset all changes of the "assurance_policy" field.
func (m *PermissionsPolicyMutation) ResetAssurancePolicy() {
	m.assurance_policy = nil
	delete(m.clearedFields, permissionspolicy.FieldAssurancePolicy)
}

// AddGroupIDs adds the groups edge to UsersGroup by ids.
func (m *PermissionsPolicyMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the groups edge to UsersGroup.
func (m *PermissionsPolicyMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared returns if the edge groups was cleared.
func (m *PermissionsPolicyMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the groups edge to UsersGroup by ids.
func (m *PermissionsPolicyMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed ids of groups.
func (m *PermissionsPolicyMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the groups ids in the mutation.
func (m *PermissionsPolicyMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups reset all changes of the "groups" edge.
func (m *PermissionsPolicyMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddOrganizationIDs adds the organization edge to Organization by ids.
func (m *PermissionsPolicyMutation) AddOrganizationIDs(ids ...int) {
	if m.organization == nil {
		m.organization = make(map[int]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the organization edge to Organization.
func (m *PermissionsPolicyMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the edge organization was cleared.
func (m *PermissionsPolicyMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the organization edge to Organization by ids.
func (m *PermissionsPolicyMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed ids of organization.
func (m *PermissionsPolicyMutation) RemovedOrganizationIDs() (ids []int) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the organization ids in the mutation.
func (m *PermissionsPolicyMutation) OrganizationIDs() (ids []int) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization reset all changes of the "organization" edge.
func (m *PermissionsPolicyMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// Op returns the operation name.
func (m *PermissionsPolicyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PermissionsPolicy).
func (m *PermissionsPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PermissionsPolicyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, permissionspolicy.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, permissionspolicy.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, permissionspolicy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, permissionspolicy.FieldDescription)
	}
	if m.is_global != nil {
		fields = append(fields, permissionspolicy.FieldIsGlobal)
	}
	if m.inventory_policy != nil {
		fields = append(fields, permissionspolicy.FieldInventoryPolicy)
	}
	if m.workforce_policy != nil {
		fields = append(fields, permissionspolicy.FieldWorkforcePolicy)
	}
	if m.automation_policy != nil {
		fields = append(fields, permissionspolicy.FieldAutomationPolicy)
	}
	if m.assurance_policy != nil {
		fields = append(fields, permissionspolicy.FieldAssurancePolicy)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PermissionsPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionspolicy.FieldCreateTime:
		return m.CreateTime()
	case permissionspolicy.FieldUpdateTime:
		return m.UpdateTime()
	case permissionspolicy.FieldName:
		return m.Name()
	case permissionspolicy.FieldDescription:
		return m.Description()
	case permissionspolicy.FieldIsGlobal:
		return m.IsGlobal()
	case permissionspolicy.FieldInventoryPolicy:
		return m.InventoryPolicy()
	case permissionspolicy.FieldWorkforcePolicy:
		return m.WorkforcePolicy()
	case permissionspolicy.FieldAutomationPolicy:
		return m.AutomationPolicy()
	case permissionspolicy.FieldAssurancePolicy:
		return m.AssurancePolicy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PermissionsPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionspolicy.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case permissionspolicy.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case permissionspolicy.FieldName:
		return m.OldName(ctx)
	case permissionspolicy.FieldDescription:
		return m.OldDescription(ctx)
	case permissionspolicy.FieldIsGlobal:
		return m.OldIsGlobal(ctx)
	case permissionspolicy.FieldInventoryPolicy:
		return m.OldInventoryPolicy(ctx)
	case permissionspolicy.FieldWorkforcePolicy:
		return m.OldWorkforcePolicy(ctx)
	case permissionspolicy.FieldAutomationPolicy:
		return m.OldAutomationPolicy(ctx)
	case permissionspolicy.FieldAssurancePolicy:
		return m.OldAssurancePolicy(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionsPolicy field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PermissionsPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionspolicy.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case permissionspolicy.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case permissionspolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permissionspolicy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permissionspolicy.FieldIsGlobal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGlobal(v)
		return nil
	case permissionspolicy.FieldInventoryPolicy:
		v, ok := value.(*models.InventoryPolicyInput)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryPolicy(v)
		return nil
	case permissionspolicy.FieldWorkforcePolicy:
		v, ok := value.(*models.WorkforcePolicyInput)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkforcePolicy(v)
		return nil
	case permissionspolicy.FieldAutomationPolicy:
		v, ok := value.(*models.AutomationPolicyInput)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutomationPolicy(v)
		return nil
	case permissionspolicy.FieldAssurancePolicy:
		v, ok := value.(*models.AssurancePolicyInput)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssurancePolicy(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionsPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PermissionsPolicyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PermissionsPolicyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PermissionsPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PermissionsPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PermissionsPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissionspolicy.FieldDescription) {
		fields = append(fields, permissionspolicy.FieldDescription)
	}
	if m.FieldCleared(permissionspolicy.FieldIsGlobal) {
		fields = append(fields, permissionspolicy.FieldIsGlobal)
	}
	if m.FieldCleared(permissionspolicy.FieldInventoryPolicy) {
		fields = append(fields, permissionspolicy.FieldInventoryPolicy)
	}
	if m.FieldCleared(permissionspolicy.FieldWorkforcePolicy) {
		fields = append(fields, permissionspolicy.FieldWorkforcePolicy)
	}
	if m.FieldCleared(permissionspolicy.FieldAutomationPolicy) {
		fields = append(fields, permissionspolicy.FieldAutomationPolicy)
	}
	if m.FieldCleared(permissionspolicy.FieldAssurancePolicy) {
		fields = append(fields, permissionspolicy.FieldAssurancePolicy)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PermissionsPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionsPolicyMutation) ClearField(name string) error {
	switch name {
	case permissionspolicy.FieldDescription:
		m.ClearDescription()
		return nil
	case permissionspolicy.FieldIsGlobal:
		m.ClearIsGlobal()
		return nil
	case permissionspolicy.FieldInventoryPolicy:
		m.ClearInventoryPolicy()
		return nil
	case permissionspolicy.FieldWorkforcePolicy:
		m.ClearWorkforcePolicy()
		return nil
	case permissionspolicy.FieldAutomationPolicy:
		m.ClearAutomationPolicy()
		return nil
	case permissionspolicy.FieldAssurancePolicy:
		m.ClearAssurancePolicy()
		return nil
	}
	return fmt.Errorf("unknown PermissionsPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PermissionsPolicyMutation) ResetField(name string) error {
	switch name {
	case permissionspolicy.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case permissionspolicy.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case permissionspolicy.FieldName:
		m.ResetName()
		return nil
	case permissionspolicy.FieldDescription:
		m.ResetDescription()
		return nil
	case permissionspolicy.FieldIsGlobal:
		m.ResetIsGlobal()
		return nil
	case permissionspolicy.FieldInventoryPolicy:
		m.ResetInventoryPolicy()
		return nil
	case permissionspolicy.FieldWorkforcePolicy:
		m.ResetWorkforcePolicy()
		return nil
	case permissionspolicy.FieldAutomationPolicy:
		m.ResetAutomationPolicy()
		return nil
	case permissionspolicy.FieldAssurancePolicy:
		m.ResetAssurancePolicy()
		return nil
	}
	return fmt.Errorf("unknown PermissionsPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PermissionsPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.groups != nil {
		edges = append(edges, permissionspolicy.EdgeGroups)
	}
	if m.organization != nil {
		edges = append(edges, permissionspolicy.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PermissionsPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permissionspolicy.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case permissionspolicy.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PermissionsPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgroups != nil {
		edges = append(edges, permissionspolicy.EdgeGroups)
	}
	if m.removedorganization != nil {
		edges = append(edges, permissionspolicy.EdgeOrganization)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PermissionsPolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permissionspolicy.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case permissionspolicy.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PermissionsPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroups {
		edges = append(edges, permissionspolicy.EdgeGroups)
	}
	if m.clearedorganization {
		edges = append(edges, permissionspolicy.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PermissionsPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case permissionspolicy.EdgeGroups:
		return m.clearedgroups
	case permissionspolicy.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PermissionsPolicyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PermissionsPolicy unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PermissionsPolicyMutation) ResetEdge(name string) error {
	switch name {
	case permissionspolicy.EdgeGroups:
		m.ResetGroups()
		return nil
	case permissionspolicy.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown PermissionsPolicy edge %s", name)
}

// ProjectMutation represents an operation that mutate the Projects
// nodes in the graph.
type ProjectMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	description        *string
	priority           *project.Priority
	clearedFields      map[string]struct{}
	_type              *int
	cleared_type       bool
	template           *int
	clearedtemplate    bool
	location           *int
	clearedlocation    bool
	comments           map[int]struct{}
	removedcomments    map[int]struct{}
	clearedcomments    bool
	work_orders        map[int]struct{}
	removedwork_orders map[int]struct{}
	clearedwork_orders bool
	properties         map[int]struct{}
	removedproperties  map[int]struct{}
	clearedproperties  bool
	creator            *int
	clearedcreator     bool
	done               bool
	oldValue           func(context.Context) (*Project, error)
	predicates         []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows to manage the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for Project.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the id field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ProjectMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ProjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ProjectMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ProjectMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ProjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ProjectMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetPriority sets the priority field.
func (m *ProjectMutation) SetPriority(pr project.Priority) {
	m.priority = &pr
}

// Priority returns the priority value in the mutation.
func (m *ProjectMutation) Priority() (r project.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old priority value of the Project.
// If the Project object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectMutation) OldPriority(ctx context.Context) (v project.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriority is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority reset all changes of the "priority" field.
func (m *ProjectMutation) ResetPriority() {
	m.priority = nil
}

// SetTypeID sets the type edge to ProjectType by id.
func (m *ProjectMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to ProjectType.
func (m *ProjectMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *ProjectMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *ProjectMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *ProjectMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetTemplateID sets the template edge to ProjectTemplate by id.
func (m *ProjectMutation) SetTemplateID(id int) {
	m.template = &id
}

// ClearTemplate clears the template edge to ProjectTemplate.
func (m *ProjectMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared returns if the edge template was cleared.
func (m *ProjectMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateID returns the template id in the mutation.
func (m *ProjectMutation) TemplateID() (id int, exists bool) {
	if m.template != nil {
		return *m.template, true
	}
	return
}

// TemplateIDs returns the template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) TemplateIDs() (ids []int) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate reset all changes of the "template" edge.
func (m *ProjectMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// SetLocationID sets the location edge to Location by id.
func (m *ProjectMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *ProjectMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *ProjectMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *ProjectMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *ProjectMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// AddCommentIDs adds the comments edge to Comment by ids.
func (m *ProjectMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the comments edge to Comment.
func (m *ProjectMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared returns if the edge comments was cleared.
func (m *ProjectMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the comments edge to Comment by ids.
func (m *ProjectMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed ids of comments.
func (m *ProjectMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the comments ids in the mutation.
func (m *ProjectMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments reset all changes of the "comments" edge.
func (m *ProjectMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddWorkOrderIDs adds the work_orders edge to WorkOrder by ids.
func (m *ProjectMutation) AddWorkOrderIDs(ids ...int) {
	if m.work_orders == nil {
		m.work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.work_orders[ids[i]] = struct{}{}
	}
}

// ClearWorkOrders clears the work_orders edge to WorkOrder.
func (m *ProjectMutation) ClearWorkOrders() {
	m.clearedwork_orders = true
}

// WorkOrdersCleared returns if the edge work_orders was cleared.
func (m *ProjectMutation) WorkOrdersCleared() bool {
	return m.clearedwork_orders
}

// RemoveWorkOrderIDs removes the work_orders edge to WorkOrder by ids.
func (m *ProjectMutation) RemoveWorkOrderIDs(ids ...int) {
	if m.removedwork_orders == nil {
		m.removedwork_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_orders[ids[i]] = struct{}{}
	}
}

// RemovedWorkOrders returns the removed ids of work_orders.
func (m *ProjectMutation) RemovedWorkOrdersIDs() (ids []int) {
	for id := range m.removedwork_orders {
		ids = append(ids, id)
	}
	return
}

// WorkOrdersIDs returns the work_orders ids in the mutation.
func (m *ProjectMutation) WorkOrdersIDs() (ids []int) {
	for id := range m.work_orders {
		ids = append(ids, id)
	}
	return
}

// ResetWorkOrders reset all changes of the "work_orders" edge.
func (m *ProjectMutation) ResetWorkOrders() {
	m.work_orders = nil
	m.clearedwork_orders = false
	m.removedwork_orders = nil
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *ProjectMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *ProjectMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *ProjectMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *ProjectMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *ProjectMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *ProjectMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *ProjectMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// SetCreatorID sets the creator edge to User by id.
func (m *ProjectMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the creator edge to User.
func (m *ProjectMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared returns if the edge creator was cleared.
func (m *ProjectMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the creator id in the mutation.
func (m *ProjectMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the creator ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator reset all changes of the "creator" edge.
func (m *ProjectMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, project.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, project.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.priority != nil {
		fields = append(fields, project.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreateTime:
		return m.CreateTime()
	case project.FieldUpdateTime:
		return m.UpdateTime()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case project.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case project.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldPriority:
		v, ok := value.(project.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case project.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m._type != nil {
		edges = append(edges, project.EdgeType)
	}
	if m.template != nil {
		edges = append(edges, project.EdgeTemplate)
	}
	if m.location != nil {
		edges = append(edges, project.EdgeLocation)
	}
	if m.comments != nil {
		edges = append(edges, project.EdgeComments)
	}
	if m.work_orders != nil {
		edges = append(edges, project.EdgeWorkOrders)
	}
	if m.properties != nil {
		edges = append(edges, project.EdgeProperties)
	}
	if m.creator != nil {
		edges = append(edges, project.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.work_orders))
		for id := range m.work_orders {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedcomments != nil {
		edges = append(edges, project.EdgeComments)
	}
	if m.removedwork_orders != nil {
		edges = append(edges, project.EdgeWorkOrders)
	}
	if m.removedproperties != nil {
		edges = append(edges, project.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.removedwork_orders))
		for id := range m.removedwork_orders {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleared_type {
		edges = append(edges, project.EdgeType)
	}
	if m.clearedtemplate {
		edges = append(edges, project.EdgeTemplate)
	}
	if m.clearedlocation {
		edges = append(edges, project.EdgeLocation)
	}
	if m.clearedcomments {
		edges = append(edges, project.EdgeComments)
	}
	if m.clearedwork_orders {
		edges = append(edges, project.EdgeWorkOrders)
	}
	if m.clearedproperties {
		edges = append(edges, project.EdgeProperties)
	}
	if m.clearedcreator {
		edges = append(edges, project.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeType:
		return m.cleared_type
	case project.EdgeTemplate:
		return m.clearedtemplate
	case project.EdgeLocation:
		return m.clearedlocation
	case project.EdgeComments:
		return m.clearedcomments
	case project.EdgeWorkOrders:
		return m.clearedwork_orders
	case project.EdgeProperties:
		return m.clearedproperties
	case project.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeType:
		m.ClearType()
		return nil
	case project.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case project.EdgeLocation:
		m.ClearLocation()
		return nil
	case project.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeType:
		m.ResetType()
		return nil
	case project.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case project.EdgeLocation:
		m.ResetLocation()
		return nil
	case project.EdgeComments:
		m.ResetComments()
		return nil
	case project.EdgeWorkOrders:
		m.ResetWorkOrders()
		return nil
	case project.EdgeProperties:
		m.ResetProperties()
		return nil
	case project.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectTemplateMutation represents an operation that mutate the ProjectTemplates
// nodes in the graph.
type ProjectTemplateMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	description        *string
	clearedFields      map[string]struct{}
	properties         map[int]struct{}
	removedproperties  map[int]struct{}
	clearedproperties  bool
	work_orders        map[int]struct{}
	removedwork_orders map[int]struct{}
	clearedwork_orders bool
	_type              *int
	cleared_type       bool
	done               bool
	oldValue           func(context.Context) (*ProjectTemplate, error)
	predicates         []predicate.ProjectTemplate
}

var _ ent.Mutation = (*ProjectTemplateMutation)(nil)

// projecttemplateOption allows to manage the mutation configuration using functional options.
type projecttemplateOption func(*ProjectTemplateMutation)

// newProjectTemplateMutation creates new mutation for ProjectTemplate.
func newProjectTemplateMutation(c config, op Op, opts ...projecttemplateOption) *ProjectTemplateMutation {
	m := &ProjectTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTemplateID sets the id field of the mutation.
func withProjectTemplateID(id int) projecttemplateOption {
	return func(m *ProjectTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTemplate
		)
		m.oldValue = func(ctx context.Context) (*ProjectTemplate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTemplate sets the old ProjectTemplate of the mutation.
func withProjectTemplate(node *ProjectTemplate) projecttemplateOption {
	return func(m *ProjectTemplateMutation) {
		m.oldValue = func(context.Context) (*ProjectTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProjectTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ProjectTemplateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ProjectTemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ProjectTemplate.
// If the ProjectTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTemplateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ProjectTemplateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ProjectTemplateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ProjectTemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ProjectTemplate.
// If the ProjectTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTemplateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ProjectTemplateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ProjectTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProjectTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ProjectTemplate.
// If the ProjectTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProjectTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *ProjectTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ProjectTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the ProjectTemplate.
// If the ProjectTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTemplateMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *ProjectTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projecttemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *ProjectTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projecttemplate.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *ProjectTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projecttemplate.FieldDescription)
}

// AddPropertyIDs adds the properties edge to PropertyType by ids.
func (m *ProjectTemplateMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to PropertyType.
func (m *ProjectTemplateMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *ProjectTemplateMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to PropertyType by ids.
func (m *ProjectTemplateMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *ProjectTemplateMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *ProjectTemplateMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *ProjectTemplateMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddWorkOrderIDs adds the work_orders edge to WorkOrderDefinition by ids.
func (m *ProjectTemplateMutation) AddWorkOrderIDs(ids ...int) {
	if m.work_orders == nil {
		m.work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.work_orders[ids[i]] = struct{}{}
	}
}

// ClearWorkOrders clears the work_orders edge to WorkOrderDefinition.
func (m *ProjectTemplateMutation) ClearWorkOrders() {
	m.clearedwork_orders = true
}

// WorkOrdersCleared returns if the edge work_orders was cleared.
func (m *ProjectTemplateMutation) WorkOrdersCleared() bool {
	return m.clearedwork_orders
}

// RemoveWorkOrderIDs removes the work_orders edge to WorkOrderDefinition by ids.
func (m *ProjectTemplateMutation) RemoveWorkOrderIDs(ids ...int) {
	if m.removedwork_orders == nil {
		m.removedwork_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_orders[ids[i]] = struct{}{}
	}
}

// RemovedWorkOrders returns the removed ids of work_orders.
func (m *ProjectTemplateMutation) RemovedWorkOrdersIDs() (ids []int) {
	for id := range m.removedwork_orders {
		ids = append(ids, id)
	}
	return
}

// WorkOrdersIDs returns the work_orders ids in the mutation.
func (m *ProjectTemplateMutation) WorkOrdersIDs() (ids []int) {
	for id := range m.work_orders {
		ids = append(ids, id)
	}
	return
}

// ResetWorkOrders reset all changes of the "work_orders" edge.
func (m *ProjectTemplateMutation) ResetWorkOrders() {
	m.work_orders = nil
	m.clearedwork_orders = false
	m.removedwork_orders = nil
}

// SetTypeID sets the type edge to ProjectType by id.
func (m *ProjectTemplateMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to ProjectType.
func (m *ProjectTemplateMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *ProjectTemplateMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *ProjectTemplateMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *ProjectTemplateMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *ProjectTemplateMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Op returns the operation name.
func (m *ProjectTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectTemplate).
func (m *ProjectTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProjectTemplateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, projecttemplate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, projecttemplate.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, projecttemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, projecttemplate.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProjectTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttemplate.FieldCreateTime:
		return m.CreateTime()
	case projecttemplate.FieldUpdateTime:
		return m.UpdateTime()
	case projecttemplate.FieldName:
		return m.Name()
	case projecttemplate.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProjectTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttemplate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case projecttemplate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case projecttemplate.FieldName:
		return m.OldName(ctx)
	case projecttemplate.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTemplate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttemplate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case projecttemplate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case projecttemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case projecttemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProjectTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProjectTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProjectTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttemplate.FieldDescription) {
		fields = append(fields, projecttemplate.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProjectTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTemplateMutation) ClearField(name string) error {
	switch name {
	case projecttemplate.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProjectTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProjectTemplateMutation) ResetField(name string) error {
	switch name {
	case projecttemplate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case projecttemplate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case projecttemplate.FieldName:
		m.ResetName()
		return nil
	case projecttemplate.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProjectTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProjectTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.properties != nil {
		edges = append(edges, projecttemplate.EdgeProperties)
	}
	if m.work_orders != nil {
		edges = append(edges, projecttemplate.EdgeWorkOrders)
	}
	if m._type != nil {
		edges = append(edges, projecttemplate.EdgeType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProjectTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttemplate.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case projecttemplate.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.work_orders))
		for id := range m.work_orders {
			ids = append(ids, id)
		}
		return ids
	case projecttemplate.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProjectTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperties != nil {
		edges = append(edges, projecttemplate.EdgeProperties)
	}
	if m.removedwork_orders != nil {
		edges = append(edges, projecttemplate.EdgeWorkOrders)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProjectTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projecttemplate.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case projecttemplate.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.removedwork_orders))
		for id := range m.removedwork_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProjectTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproperties {
		edges = append(edges, projecttemplate.EdgeProperties)
	}
	if m.clearedwork_orders {
		edges = append(edges, projecttemplate.EdgeWorkOrders)
	}
	if m.cleared_type {
		edges = append(edges, projecttemplate.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProjectTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttemplate.EdgeProperties:
		return m.clearedproperties
	case projecttemplate.EdgeWorkOrders:
		return m.clearedwork_orders
	case projecttemplate.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProjectTemplateMutation) ClearEdge(name string) error {
	switch name {
	case projecttemplate.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown ProjectTemplate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProjectTemplateMutation) ResetEdge(name string) error {
	switch name {
	case projecttemplate.EdgeProperties:
		m.ResetProperties()
		return nil
	case projecttemplate.EdgeWorkOrders:
		m.ResetWorkOrders()
		return nil
	case projecttemplate.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ProjectTemplate edge %s", name)
}

// ProjectTypeMutation represents an operation that mutate the ProjectTypes
// nodes in the graph.
type ProjectTypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	description        *string
	clearedFields      map[string]struct{}
	properties         map[int]struct{}
	removedproperties  map[int]struct{}
	clearedproperties  bool
	work_orders        map[int]struct{}
	removedwork_orders map[int]struct{}
	clearedwork_orders bool
	projects           map[int]struct{}
	removedprojects    map[int]struct{}
	clearedprojects    bool
	done               bool
	oldValue           func(context.Context) (*ProjectType, error)
	predicates         []predicate.ProjectType
}

var _ ent.Mutation = (*ProjectTypeMutation)(nil)

// projecttypeOption allows to manage the mutation configuration using functional options.
type projecttypeOption func(*ProjectTypeMutation)

// newProjectTypeMutation creates new mutation for ProjectType.
func newProjectTypeMutation(c config, op Op, opts ...projecttypeOption) *ProjectTypeMutation {
	m := &ProjectTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTypeID sets the id field of the mutation.
func withProjectTypeID(id int) projecttypeOption {
	return func(m *ProjectTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectType
		)
		m.oldValue = func(ctx context.Context) (*ProjectType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectType sets the old ProjectType of the mutation.
func withProjectType(node *ProjectType) projecttypeOption {
	return func(m *ProjectTypeMutation) {
		m.oldValue = func(context.Context) (*ProjectType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ProjectTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ProjectTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ProjectTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ProjectType.
// If the ProjectType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ProjectTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ProjectTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ProjectTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ProjectType.
// If the ProjectType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ProjectTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ProjectTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ProjectTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ProjectType.
// If the ProjectType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ProjectTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *ProjectTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ProjectTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the ProjectType.
// If the ProjectType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ProjectTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *ProjectTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projecttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *ProjectTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projecttype.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *ProjectTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projecttype.FieldDescription)
}

// AddPropertyIDs adds the properties edge to PropertyType by ids.
func (m *ProjectTypeMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to PropertyType.
func (m *ProjectTypeMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *ProjectTypeMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to PropertyType by ids.
func (m *ProjectTypeMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *ProjectTypeMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *ProjectTypeMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *ProjectTypeMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddWorkOrderIDs adds the work_orders edge to WorkOrderDefinition by ids.
func (m *ProjectTypeMutation) AddWorkOrderIDs(ids ...int) {
	if m.work_orders == nil {
		m.work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.work_orders[ids[i]] = struct{}{}
	}
}

// ClearWorkOrders clears the work_orders edge to WorkOrderDefinition.
func (m *ProjectTypeMutation) ClearWorkOrders() {
	m.clearedwork_orders = true
}

// WorkOrdersCleared returns if the edge work_orders was cleared.
func (m *ProjectTypeMutation) WorkOrdersCleared() bool {
	return m.clearedwork_orders
}

// RemoveWorkOrderIDs removes the work_orders edge to WorkOrderDefinition by ids.
func (m *ProjectTypeMutation) RemoveWorkOrderIDs(ids ...int) {
	if m.removedwork_orders == nil {
		m.removedwork_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_orders[ids[i]] = struct{}{}
	}
}

// RemovedWorkOrders returns the removed ids of work_orders.
func (m *ProjectTypeMutation) RemovedWorkOrdersIDs() (ids []int) {
	for id := range m.removedwork_orders {
		ids = append(ids, id)
	}
	return
}

// WorkOrdersIDs returns the work_orders ids in the mutation.
func (m *ProjectTypeMutation) WorkOrdersIDs() (ids []int) {
	for id := range m.work_orders {
		ids = append(ids, id)
	}
	return
}

// ResetWorkOrders reset all changes of the "work_orders" edge.
func (m *ProjectTypeMutation) ResetWorkOrders() {
	m.work_orders = nil
	m.clearedwork_orders = false
	m.removedwork_orders = nil
}

// AddProjectIDs adds the projects edge to Project by ids.
func (m *ProjectTypeMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the projects edge to Project.
func (m *ProjectTypeMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared returns if the edge projects was cleared.
func (m *ProjectTypeMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the projects edge to Project by ids.
func (m *ProjectTypeMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed ids of projects.
func (m *ProjectTypeMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the projects ids in the mutation.
func (m *ProjectTypeMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects reset all changes of the "projects" edge.
func (m *ProjectTypeMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Op returns the operation name.
func (m *ProjectTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectType).
func (m *ProjectTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ProjectTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, projecttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, projecttype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, projecttype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, projecttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ProjectTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttype.FieldCreateTime:
		return m.CreateTime()
	case projecttype.FieldUpdateTime:
		return m.UpdateTime()
	case projecttype.FieldName:
		return m.Name()
	case projecttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ProjectTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case projecttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case projecttype.FieldName:
		return m.OldName(ctx)
	case projecttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case projecttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case projecttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case projecttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ProjectTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ProjectTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ProjectTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ProjectTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttype.FieldDescription) {
		fields = append(fields, projecttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ProjectTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTypeMutation) ClearField(name string) error {
	switch name {
	case projecttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProjectType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ProjectTypeMutation) ResetField(name string) error {
	switch name {
	case projecttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case projecttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case projecttype.FieldName:
		m.ResetName()
		return nil
	case projecttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProjectType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ProjectTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.properties != nil {
		edges = append(edges, projecttype.EdgeProperties)
	}
	if m.work_orders != nil {
		edges = append(edges, projecttype.EdgeWorkOrders)
	}
	if m.projects != nil {
		edges = append(edges, projecttype.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ProjectTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttype.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case projecttype.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.work_orders))
		for id := range m.work_orders {
			ids = append(ids, id)
		}
		return ids
	case projecttype.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ProjectTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperties != nil {
		edges = append(edges, projecttype.EdgeProperties)
	}
	if m.removedwork_orders != nil {
		edges = append(edges, projecttype.EdgeWorkOrders)
	}
	if m.removedprojects != nil {
		edges = append(edges, projecttype.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ProjectTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projecttype.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case projecttype.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.removedwork_orders))
		for id := range m.removedwork_orders {
			ids = append(ids, id)
		}
		return ids
	case projecttype.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ProjectTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproperties {
		edges = append(edges, projecttype.EdgeProperties)
	}
	if m.clearedwork_orders {
		edges = append(edges, projecttype.EdgeWorkOrders)
	}
	if m.clearedprojects {
		edges = append(edges, projecttype.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ProjectTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttype.EdgeProperties:
		return m.clearedproperties
	case projecttype.EdgeWorkOrders:
		return m.clearedwork_orders
	case projecttype.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ProjectTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ProjectTypeMutation) ResetEdge(name string) error {
	switch name {
	case projecttype.EdgeProperties:
		m.ResetProperties()
		return nil
	case projecttype.EdgeWorkOrders:
		m.ResetWorkOrders()
		return nil
	case projecttype.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown ProjectType edge %s", name)
}

// PropertyMutation represents an operation that mutate the Properties
// nodes in the graph.
type PropertyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	int_val                 *int
	addint_val              *int
	bool_val                *bool
	float_val               *float64
	addfloat_val            *float64
	latitude_val            *float64
	addlatitude_val         *float64
	longitude_val           *float64
	addlongitude_val        *float64
	range_from_val          *float64
	addrange_from_val       *float64
	range_to_val            *float64
	addrange_to_val         *float64
	string_val              *string
	clearedFields           map[string]struct{}
	_type                   *int
	cleared_type            bool
	location                *int
	clearedlocation         bool
	equipment               *int
	clearedequipment        bool
	service                 *int
	clearedservice          bool
	equipment_port          *int
	clearedequipment_port   bool
	link                    *int
	clearedlink             bool
	work_order              *int
	clearedwork_order       bool
	project                 *int
	clearedproject          bool
	equipment_value         *int
	clearedequipment_value  bool
	location_value          *int
	clearedlocation_value   bool
	service_value           *int
	clearedservice_value    bool
	work_order_value        *int
	clearedwork_order_value bool
	user_value              *int
	cleareduser_value       bool
	project_value           *int
	clearedproject_value    bool
	done                    bool
	oldValue                func(context.Context) (*Property, error)
	predicates              []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows to manage the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for Property.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the id field of the mutation.
func withPropertyID(id int) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PropertyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *PropertyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *PropertyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *PropertyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *PropertyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *PropertyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *PropertyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIntVal sets the int_val field.
func (m *PropertyMutation) SetIntVal(i int) {
	m.int_val = &i
	m.addint_val = nil
}

// IntVal returns the int_val value in the mutation.
func (m *PropertyMutation) IntVal() (r int, exists bool) {
	v := m.int_val
	if v == nil {
		return
	}
	return *v, true
}

// OldIntVal returns the old int_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldIntVal(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntVal: %w", err)
	}
	return oldValue.IntVal, nil
}

// AddIntVal adds i to int_val.
func (m *PropertyMutation) AddIntVal(i int) {
	if m.addint_val != nil {
		*m.addint_val += i
	} else {
		m.addint_val = &i
	}
}

// AddedIntVal returns the value that was added to the int_val field in this mutation.
func (m *PropertyMutation) AddedIntVal() (r int, exists bool) {
	v := m.addint_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntVal clears the value of int_val.
func (m *PropertyMutation) ClearIntVal() {
	m.int_val = nil
	m.addint_val = nil
	m.clearedFields[property.FieldIntVal] = struct{}{}
}

// IntValCleared returns if the field int_val was cleared in this mutation.
func (m *PropertyMutation) IntValCleared() bool {
	_, ok := m.clearedFields[property.FieldIntVal]
	return ok
}

// ResetIntVal reset all changes of the "int_val" field.
func (m *PropertyMutation) ResetIntVal() {
	m.int_val = nil
	m.addint_val = nil
	delete(m.clearedFields, property.FieldIntVal)
}

// SetBoolVal sets the bool_val field.
func (m *PropertyMutation) SetBoolVal(b bool) {
	m.bool_val = &b
}

// BoolVal returns the bool_val value in the mutation.
func (m *PropertyMutation) BoolVal() (r bool, exists bool) {
	v := m.bool_val
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolVal returns the old bool_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldBoolVal(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBoolVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBoolVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolVal: %w", err)
	}
	return oldValue.BoolVal, nil
}

// ClearBoolVal clears the value of bool_val.
func (m *PropertyMutation) ClearBoolVal() {
	m.bool_val = nil
	m.clearedFields[property.FieldBoolVal] = struct{}{}
}

// BoolValCleared returns if the field bool_val was cleared in this mutation.
func (m *PropertyMutation) BoolValCleared() bool {
	_, ok := m.clearedFields[property.FieldBoolVal]
	return ok
}

// ResetBoolVal reset all changes of the "bool_val" field.
func (m *PropertyMutation) ResetBoolVal() {
	m.bool_val = nil
	delete(m.clearedFields, property.FieldBoolVal)
}

// SetFloatVal sets the float_val field.
func (m *PropertyMutation) SetFloatVal(f float64) {
	m.float_val = &f
	m.addfloat_val = nil
}

// FloatVal returns the float_val value in the mutation.
func (m *PropertyMutation) FloatVal() (r float64, exists bool) {
	v := m.float_val
	if v == nil {
		return
	}
	return *v, true
}

// OldFloatVal returns the old float_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldFloatVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloatVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloatVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloatVal: %w", err)
	}
	return oldValue.FloatVal, nil
}

// AddFloatVal adds f to float_val.
func (m *PropertyMutation) AddFloatVal(f float64) {
	if m.addfloat_val != nil {
		*m.addfloat_val += f
	} else {
		m.addfloat_val = &f
	}
}

// AddedFloatVal returns the value that was added to the float_val field in this mutation.
func (m *PropertyMutation) AddedFloatVal() (r float64, exists bool) {
	v := m.addfloat_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloatVal clears the value of float_val.
func (m *PropertyMutation) ClearFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	m.clearedFields[property.FieldFloatVal] = struct{}{}
}

// FloatValCleared returns if the field float_val was cleared in this mutation.
func (m *PropertyMutation) FloatValCleared() bool {
	_, ok := m.clearedFields[property.FieldFloatVal]
	return ok
}

// ResetFloatVal reset all changes of the "float_val" field.
func (m *PropertyMutation) ResetFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	delete(m.clearedFields, property.FieldFloatVal)
}

// SetLatitudeVal sets the latitude_val field.
func (m *PropertyMutation) SetLatitudeVal(f float64) {
	m.latitude_val = &f
	m.addlatitude_val = nil
}

// LatitudeVal returns the latitude_val value in the mutation.
func (m *PropertyMutation) LatitudeVal() (r float64, exists bool) {
	v := m.latitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitudeVal returns the old latitude_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldLatitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitudeVal: %w", err)
	}
	return oldValue.LatitudeVal, nil
}

// AddLatitudeVal adds f to latitude_val.
func (m *PropertyMutation) AddLatitudeVal(f float64) {
	if m.addlatitude_val != nil {
		*m.addlatitude_val += f
	} else {
		m.addlatitude_val = &f
	}
}

// AddedLatitudeVal returns the value that was added to the latitude_val field in this mutation.
func (m *PropertyMutation) AddedLatitudeVal() (r float64, exists bool) {
	v := m.addlatitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitudeVal clears the value of latitude_val.
func (m *PropertyMutation) ClearLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	m.clearedFields[property.FieldLatitudeVal] = struct{}{}
}

// LatitudeValCleared returns if the field latitude_val was cleared in this mutation.
func (m *PropertyMutation) LatitudeValCleared() bool {
	_, ok := m.clearedFields[property.FieldLatitudeVal]
	return ok
}

// ResetLatitudeVal reset all changes of the "latitude_val" field.
func (m *PropertyMutation) ResetLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	delete(m.clearedFields, property.FieldLatitudeVal)
}

// SetLongitudeVal sets the longitude_val field.
func (m *PropertyMutation) SetLongitudeVal(f float64) {
	m.longitude_val = &f
	m.addlongitude_val = nil
}

// LongitudeVal returns the longitude_val value in the mutation.
func (m *PropertyMutation) LongitudeVal() (r float64, exists bool) {
	v := m.longitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitudeVal returns the old longitude_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldLongitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitudeVal: %w", err)
	}
	return oldValue.LongitudeVal, nil
}

// AddLongitudeVal adds f to longitude_val.
func (m *PropertyMutation) AddLongitudeVal(f float64) {
	if m.addlongitude_val != nil {
		*m.addlongitude_val += f
	} else {
		m.addlongitude_val = &f
	}
}

// AddedLongitudeVal returns the value that was added to the longitude_val field in this mutation.
func (m *PropertyMutation) AddedLongitudeVal() (r float64, exists bool) {
	v := m.addlongitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitudeVal clears the value of longitude_val.
func (m *PropertyMutation) ClearLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	m.clearedFields[property.FieldLongitudeVal] = struct{}{}
}

// LongitudeValCleared returns if the field longitude_val was cleared in this mutation.
func (m *PropertyMutation) LongitudeValCleared() bool {
	_, ok := m.clearedFields[property.FieldLongitudeVal]
	return ok
}

// ResetLongitudeVal reset all changes of the "longitude_val" field.
func (m *PropertyMutation) ResetLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	delete(m.clearedFields, property.FieldLongitudeVal)
}

// SetRangeFromVal sets the range_from_val field.
func (m *PropertyMutation) SetRangeFromVal(f float64) {
	m.range_from_val = &f
	m.addrange_from_val = nil
}

// RangeFromVal returns the range_from_val value in the mutation.
func (m *PropertyMutation) RangeFromVal() (r float64, exists bool) {
	v := m.range_from_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeFromVal returns the old range_from_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldRangeFromVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeFromVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeFromVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeFromVal: %w", err)
	}
	return oldValue.RangeFromVal, nil
}

// AddRangeFromVal adds f to range_from_val.
func (m *PropertyMutation) AddRangeFromVal(f float64) {
	if m.addrange_from_val != nil {
		*m.addrange_from_val += f
	} else {
		m.addrange_from_val = &f
	}
}

// AddedRangeFromVal returns the value that was added to the range_from_val field in this mutation.
func (m *PropertyMutation) AddedRangeFromVal() (r float64, exists bool) {
	v := m.addrange_from_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeFromVal clears the value of range_from_val.
func (m *PropertyMutation) ClearRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	m.clearedFields[property.FieldRangeFromVal] = struct{}{}
}

// RangeFromValCleared returns if the field range_from_val was cleared in this mutation.
func (m *PropertyMutation) RangeFromValCleared() bool {
	_, ok := m.clearedFields[property.FieldRangeFromVal]
	return ok
}

// ResetRangeFromVal reset all changes of the "range_from_val" field.
func (m *PropertyMutation) ResetRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	delete(m.clearedFields, property.FieldRangeFromVal)
}

// SetRangeToVal sets the range_to_val field.
func (m *PropertyMutation) SetRangeToVal(f float64) {
	m.range_to_val = &f
	m.addrange_to_val = nil
}

// RangeToVal returns the range_to_val value in the mutation.
func (m *PropertyMutation) RangeToVal() (r float64, exists bool) {
	v := m.range_to_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeToVal returns the old range_to_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldRangeToVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeToVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeToVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeToVal: %w", err)
	}
	return oldValue.RangeToVal, nil
}

// AddRangeToVal adds f to range_to_val.
func (m *PropertyMutation) AddRangeToVal(f float64) {
	if m.addrange_to_val != nil {
		*m.addrange_to_val += f
	} else {
		m.addrange_to_val = &f
	}
}

// AddedRangeToVal returns the value that was added to the range_to_val field in this mutation.
func (m *PropertyMutation) AddedRangeToVal() (r float64, exists bool) {
	v := m.addrange_to_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeToVal clears the value of range_to_val.
func (m *PropertyMutation) ClearRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	m.clearedFields[property.FieldRangeToVal] = struct{}{}
}

// RangeToValCleared returns if the field range_to_val was cleared in this mutation.
func (m *PropertyMutation) RangeToValCleared() bool {
	_, ok := m.clearedFields[property.FieldRangeToVal]
	return ok
}

// ResetRangeToVal reset all changes of the "range_to_val" field.
func (m *PropertyMutation) ResetRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	delete(m.clearedFields, property.FieldRangeToVal)
}

// SetStringVal sets the string_val field.
func (m *PropertyMutation) SetStringVal(s string) {
	m.string_val = &s
}

// StringVal returns the string_val value in the mutation.
func (m *PropertyMutation) StringVal() (r string, exists bool) {
	v := m.string_val
	if v == nil {
		return
	}
	return *v, true
}

// OldStringVal returns the old string_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldStringVal(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringVal: %w", err)
	}
	return oldValue.StringVal, nil
}

// ClearStringVal clears the value of string_val.
func (m *PropertyMutation) ClearStringVal() {
	m.string_val = nil
	m.clearedFields[property.FieldStringVal] = struct{}{}
}

// StringValCleared returns if the field string_val was cleared in this mutation.
func (m *PropertyMutation) StringValCleared() bool {
	_, ok := m.clearedFields[property.FieldStringVal]
	return ok
}

// ResetStringVal reset all changes of the "string_val" field.
func (m *PropertyMutation) ResetStringVal() {
	m.string_val = nil
	delete(m.clearedFields, property.FieldStringVal)
}

// SetTypeID sets the type edge to PropertyType by id.
func (m *PropertyMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to PropertyType.
func (m *PropertyMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *PropertyMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *PropertyMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *PropertyMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetLocationID sets the location edge to Location by id.
func (m *PropertyMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *PropertyMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *PropertyMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *PropertyMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *PropertyMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetEquipmentID sets the equipment edge to Equipment by id.
func (m *PropertyMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *PropertyMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *PropertyMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the equipment id in the mutation.
func (m *PropertyMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *PropertyMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetServiceID sets the service edge to Service by id.
func (m *PropertyMutation) SetServiceID(id int) {
	m.service = &id
}

// ClearService clears the service edge to Service.
func (m *PropertyMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared returns if the edge service was cleared.
func (m *PropertyMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the service id in the mutation.
func (m *PropertyMutation) ServiceID() (id int, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the service ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) ServiceIDs() (ids []int) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService reset all changes of the "service" edge.
func (m *PropertyMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// SetEquipmentPortID sets the equipment_port edge to EquipmentPort by id.
func (m *PropertyMutation) SetEquipmentPortID(id int) {
	m.equipment_port = &id
}

// ClearEquipmentPort clears the equipment_port edge to EquipmentPort.
func (m *PropertyMutation) ClearEquipmentPort() {
	m.clearedequipment_port = true
}

// EquipmentPortCleared returns if the edge equipment_port was cleared.
func (m *PropertyMutation) EquipmentPortCleared() bool {
	return m.clearedequipment_port
}

// EquipmentPortID returns the equipment_port id in the mutation.
func (m *PropertyMutation) EquipmentPortID() (id int, exists bool) {
	if m.equipment_port != nil {
		return *m.equipment_port, true
	}
	return
}

// EquipmentPortIDs returns the equipment_port ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentPortID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) EquipmentPortIDs() (ids []int) {
	if id := m.equipment_port; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentPort reset all changes of the "equipment_port" edge.
func (m *PropertyMutation) ResetEquipmentPort() {
	m.equipment_port = nil
	m.clearedequipment_port = false
}

// SetLinkID sets the link edge to Link by id.
func (m *PropertyMutation) SetLinkID(id int) {
	m.link = &id
}

// ClearLink clears the link edge to Link.
func (m *PropertyMutation) ClearLink() {
	m.clearedlink = true
}

// LinkCleared returns if the edge link was cleared.
func (m *PropertyMutation) LinkCleared() bool {
	return m.clearedlink
}

// LinkID returns the link id in the mutation.
func (m *PropertyMutation) LinkID() (id int, exists bool) {
	if m.link != nil {
		return *m.link, true
	}
	return
}

// LinkIDs returns the link ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) LinkIDs() (ids []int) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink reset all changes of the "link" edge.
func (m *PropertyMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// SetWorkOrderID sets the work_order edge to WorkOrder by id.
func (m *PropertyMutation) SetWorkOrderID(id int) {
	m.work_order = &id
}

// ClearWorkOrder clears the work_order edge to WorkOrder.
func (m *PropertyMutation) ClearWorkOrder() {
	m.clearedwork_order = true
}

// WorkOrderCleared returns if the edge work_order was cleared.
func (m *PropertyMutation) WorkOrderCleared() bool {
	return m.clearedwork_order
}

// WorkOrderID returns the work_order id in the mutation.
func (m *PropertyMutation) WorkOrderID() (id int, exists bool) {
	if m.work_order != nil {
		return *m.work_order, true
	}
	return
}

// WorkOrderIDs returns the work_order ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) WorkOrderIDs() (ids []int) {
	if id := m.work_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrder reset all changes of the "work_order" edge.
func (m *PropertyMutation) ResetWorkOrder() {
	m.work_order = nil
	m.clearedwork_order = false
}

// SetProjectID sets the project edge to Project by id.
func (m *PropertyMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the project edge to Project.
func (m *PropertyMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared returns if the edge project was cleared.
func (m *PropertyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the project id in the mutation.
func (m *PropertyMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the project ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject reset all changes of the "project" edge.
func (m *PropertyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetEquipmentValueID sets the equipment_value edge to Equipment by id.
func (m *PropertyMutation) SetEquipmentValueID(id int) {
	m.equipment_value = &id
}

// ClearEquipmentValue clears the equipment_value edge to Equipment.
func (m *PropertyMutation) ClearEquipmentValue() {
	m.clearedequipment_value = true
}

// EquipmentValueCleared returns if the edge equipment_value was cleared.
func (m *PropertyMutation) EquipmentValueCleared() bool {
	return m.clearedequipment_value
}

// EquipmentValueID returns the equipment_value id in the mutation.
func (m *PropertyMutation) EquipmentValueID() (id int, exists bool) {
	if m.equipment_value != nil {
		return *m.equipment_value, true
	}
	return
}

// EquipmentValueIDs returns the equipment_value ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentValueID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) EquipmentValueIDs() (ids []int) {
	if id := m.equipment_value; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentValue reset all changes of the "equipment_value" edge.
func (m *PropertyMutation) ResetEquipmentValue() {
	m.equipment_value = nil
	m.clearedequipment_value = false
}

// SetLocationValueID sets the location_value edge to Location by id.
func (m *PropertyMutation) SetLocationValueID(id int) {
	m.location_value = &id
}

// ClearLocationValue clears the location_value edge to Location.
func (m *PropertyMutation) ClearLocationValue() {
	m.clearedlocation_value = true
}

// LocationValueCleared returns if the edge location_value was cleared.
func (m *PropertyMutation) LocationValueCleared() bool {
	return m.clearedlocation_value
}

// LocationValueID returns the location_value id in the mutation.
func (m *PropertyMutation) LocationValueID() (id int, exists bool) {
	if m.location_value != nil {
		return *m.location_value, true
	}
	return
}

// LocationValueIDs returns the location_value ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationValueID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) LocationValueIDs() (ids []int) {
	if id := m.location_value; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocationValue reset all changes of the "location_value" edge.
func (m *PropertyMutation) ResetLocationValue() {
	m.location_value = nil
	m.clearedlocation_value = false
}

// SetServiceValueID sets the service_value edge to Service by id.
func (m *PropertyMutation) SetServiceValueID(id int) {
	m.service_value = &id
}

// ClearServiceValue clears the service_value edge to Service.
func (m *PropertyMutation) ClearServiceValue() {
	m.clearedservice_value = true
}

// ServiceValueCleared returns if the edge service_value was cleared.
func (m *PropertyMutation) ServiceValueCleared() bool {
	return m.clearedservice_value
}

// ServiceValueID returns the service_value id in the mutation.
func (m *PropertyMutation) ServiceValueID() (id int, exists bool) {
	if m.service_value != nil {
		return *m.service_value, true
	}
	return
}

// ServiceValueIDs returns the service_value ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServiceValueID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) ServiceValueIDs() (ids []int) {
	if id := m.service_value; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceValue reset all changes of the "service_value" edge.
func (m *PropertyMutation) ResetServiceValue() {
	m.service_value = nil
	m.clearedservice_value = false
}

// SetWorkOrderValueID sets the work_order_value edge to WorkOrder by id.
func (m *PropertyMutation) SetWorkOrderValueID(id int) {
	m.work_order_value = &id
}

// ClearWorkOrderValue clears the work_order_value edge to WorkOrder.
func (m *PropertyMutation) ClearWorkOrderValue() {
	m.clearedwork_order_value = true
}

// WorkOrderValueCleared returns if the edge work_order_value was cleared.
func (m *PropertyMutation) WorkOrderValueCleared() bool {
	return m.clearedwork_order_value
}

// WorkOrderValueID returns the work_order_value id in the mutation.
func (m *PropertyMutation) WorkOrderValueID() (id int, exists bool) {
	if m.work_order_value != nil {
		return *m.work_order_value, true
	}
	return
}

// WorkOrderValueIDs returns the work_order_value ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderValueID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) WorkOrderValueIDs() (ids []int) {
	if id := m.work_order_value; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrderValue reset all changes of the "work_order_value" edge.
func (m *PropertyMutation) ResetWorkOrderValue() {
	m.work_order_value = nil
	m.clearedwork_order_value = false
}

// SetUserValueID sets the user_value edge to User by id.
func (m *PropertyMutation) SetUserValueID(id int) {
	m.user_value = &id
}

// ClearUserValue clears the user_value edge to User.
func (m *PropertyMutation) ClearUserValue() {
	m.cleareduser_value = true
}

// UserValueCleared returns if the edge user_value was cleared.
func (m *PropertyMutation) UserValueCleared() bool {
	return m.cleareduser_value
}

// UserValueID returns the user_value id in the mutation.
func (m *PropertyMutation) UserValueID() (id int, exists bool) {
	if m.user_value != nil {
		return *m.user_value, true
	}
	return
}

// UserValueIDs returns the user_value ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserValueID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) UserValueIDs() (ids []int) {
	if id := m.user_value; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserValue reset all changes of the "user_value" edge.
func (m *PropertyMutation) ResetUserValue() {
	m.user_value = nil
	m.cleareduser_value = false
}

// SetProjectValueID sets the project_value edge to Project by id.
func (m *PropertyMutation) SetProjectValueID(id int) {
	m.project_value = &id
}

// ClearProjectValue clears the project_value edge to Project.
func (m *PropertyMutation) ClearProjectValue() {
	m.clearedproject_value = true
}

// ProjectValueCleared returns if the edge project_value was cleared.
func (m *PropertyMutation) ProjectValueCleared() bool {
	return m.clearedproject_value
}

// ProjectValueID returns the project_value id in the mutation.
func (m *PropertyMutation) ProjectValueID() (id int, exists bool) {
	if m.project_value != nil {
		return *m.project_value, true
	}
	return
}

// ProjectValueIDs returns the project_value ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectValueID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) ProjectValueIDs() (ids []int) {
	if id := m.project_value; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectValue reset all changes of the "project_value" edge.
func (m *PropertyMutation) ResetProjectValue() {
	m.project_value = nil
	m.clearedproject_value = false
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, property.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, property.FieldUpdateTime)
	}
	if m.int_val != nil {
		fields = append(fields, property.FieldIntVal)
	}
	if m.bool_val != nil {
		fields = append(fields, property.FieldBoolVal)
	}
	if m.float_val != nil {
		fields = append(fields, property.FieldFloatVal)
	}
	if m.latitude_val != nil {
		fields = append(fields, property.FieldLatitudeVal)
	}
	if m.longitude_val != nil {
		fields = append(fields, property.FieldLongitudeVal)
	}
	if m.range_from_val != nil {
		fields = append(fields, property.FieldRangeFromVal)
	}
	if m.range_to_val != nil {
		fields = append(fields, property.FieldRangeToVal)
	}
	if m.string_val != nil {
		fields = append(fields, property.FieldStringVal)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldCreateTime:
		return m.CreateTime()
	case property.FieldUpdateTime:
		return m.UpdateTime()
	case property.FieldIntVal:
		return m.IntVal()
	case property.FieldBoolVal:
		return m.BoolVal()
	case property.FieldFloatVal:
		return m.FloatVal()
	case property.FieldLatitudeVal:
		return m.LatitudeVal()
	case property.FieldLongitudeVal:
		return m.LongitudeVal()
	case property.FieldRangeFromVal:
		return m.RangeFromVal()
	case property.FieldRangeToVal:
		return m.RangeToVal()
	case property.FieldStringVal:
		return m.StringVal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case property.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case property.FieldIntVal:
		return m.OldIntVal(ctx)
	case property.FieldBoolVal:
		return m.OldBoolVal(ctx)
	case property.FieldFloatVal:
		return m.OldFloatVal(ctx)
	case property.FieldLatitudeVal:
		return m.OldLatitudeVal(ctx)
	case property.FieldLongitudeVal:
		return m.OldLongitudeVal(ctx)
	case property.FieldRangeFromVal:
		return m.OldRangeFromVal(ctx)
	case property.FieldRangeToVal:
		return m.OldRangeToVal(ctx)
	case property.FieldStringVal:
		return m.OldStringVal(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case property.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case property.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntVal(v)
		return nil
	case property.FieldBoolVal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolVal(v)
		return nil
	case property.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloatVal(v)
		return nil
	case property.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitudeVal(v)
		return nil
	case property.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitudeVal(v)
		return nil
	case property.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeFromVal(v)
		return nil
	case property.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeToVal(v)
		return nil
	case property.FieldStringVal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringVal(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PropertyMutation) AddedFields() []string {
	var fields []string
	if m.addint_val != nil {
		fields = append(fields, property.FieldIntVal)
	}
	if m.addfloat_val != nil {
		fields = append(fields, property.FieldFloatVal)
	}
	if m.addlatitude_val != nil {
		fields = append(fields, property.FieldLatitudeVal)
	}
	if m.addlongitude_val != nil {
		fields = append(fields, property.FieldLongitudeVal)
	}
	if m.addrange_from_val != nil {
		fields = append(fields, property.FieldRangeFromVal)
	}
	if m.addrange_to_val != nil {
		fields = append(fields, property.FieldRangeToVal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case property.FieldIntVal:
		return m.AddedIntVal()
	case property.FieldFloatVal:
		return m.AddedFloatVal()
	case property.FieldLatitudeVal:
		return m.AddedLatitudeVal()
	case property.FieldLongitudeVal:
		return m.AddedLongitudeVal()
	case property.FieldRangeFromVal:
		return m.AddedRangeFromVal()
	case property.FieldRangeToVal:
		return m.AddedRangeToVal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case property.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntVal(v)
		return nil
	case property.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloatVal(v)
		return nil
	case property.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitudeVal(v)
		return nil
	case property.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitudeVal(v)
		return nil
	case property.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeFromVal(v)
		return nil
	case property.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeToVal(v)
		return nil
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(property.FieldIntVal) {
		fields = append(fields, property.FieldIntVal)
	}
	if m.FieldCleared(property.FieldBoolVal) {
		fields = append(fields, property.FieldBoolVal)
	}
	if m.FieldCleared(property.FieldFloatVal) {
		fields = append(fields, property.FieldFloatVal)
	}
	if m.FieldCleared(property.FieldLatitudeVal) {
		fields = append(fields, property.FieldLatitudeVal)
	}
	if m.FieldCleared(property.FieldLongitudeVal) {
		fields = append(fields, property.FieldLongitudeVal)
	}
	if m.FieldCleared(property.FieldRangeFromVal) {
		fields = append(fields, property.FieldRangeFromVal)
	}
	if m.FieldCleared(property.FieldRangeToVal) {
		fields = append(fields, property.FieldRangeToVal)
	}
	if m.FieldCleared(property.FieldStringVal) {
		fields = append(fields, property.FieldStringVal)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	switch name {
	case property.FieldIntVal:
		m.ClearIntVal()
		return nil
	case property.FieldBoolVal:
		m.ClearBoolVal()
		return nil
	case property.FieldFloatVal:
		m.ClearFloatVal()
		return nil
	case property.FieldLatitudeVal:
		m.ClearLatitudeVal()
		return nil
	case property.FieldLongitudeVal:
		m.ClearLongitudeVal()
		return nil
	case property.FieldRangeFromVal:
		m.ClearRangeFromVal()
		return nil
	case property.FieldRangeToVal:
		m.ClearRangeToVal()
		return nil
	case property.FieldStringVal:
		m.ClearStringVal()
		return nil
	}
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case property.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case property.FieldIntVal:
		m.ResetIntVal()
		return nil
	case property.FieldBoolVal:
		m.ResetBoolVal()
		return nil
	case property.FieldFloatVal:
		m.ResetFloatVal()
		return nil
	case property.FieldLatitudeVal:
		m.ResetLatitudeVal()
		return nil
	case property.FieldLongitudeVal:
		m.ResetLongitudeVal()
		return nil
	case property.FieldRangeFromVal:
		m.ResetRangeFromVal()
		return nil
	case property.FieldRangeToVal:
		m.ResetRangeToVal()
		return nil
	case property.FieldStringVal:
		m.ResetStringVal()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m._type != nil {
		edges = append(edges, property.EdgeType)
	}
	if m.location != nil {
		edges = append(edges, property.EdgeLocation)
	}
	if m.equipment != nil {
		edges = append(edges, property.EdgeEquipment)
	}
	if m.service != nil {
		edges = append(edges, property.EdgeService)
	}
	if m.equipment_port != nil {
		edges = append(edges, property.EdgeEquipmentPort)
	}
	if m.link != nil {
		edges = append(edges, property.EdgeLink)
	}
	if m.work_order != nil {
		edges = append(edges, property.EdgeWorkOrder)
	}
	if m.project != nil {
		edges = append(edges, property.EdgeProject)
	}
	if m.equipment_value != nil {
		edges = append(edges, property.EdgeEquipmentValue)
	}
	if m.location_value != nil {
		edges = append(edges, property.EdgeLocationValue)
	}
	if m.service_value != nil {
		edges = append(edges, property.EdgeServiceValue)
	}
	if m.work_order_value != nil {
		edges = append(edges, property.EdgeWorkOrderValue)
	}
	if m.user_value != nil {
		edges = append(edges, property.EdgeUserValue)
	}
	if m.project_value != nil {
		edges = append(edges, property.EdgeProjectValue)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeEquipmentPort:
		if id := m.equipment_port; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeWorkOrder:
		if id := m.work_order; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeEquipmentValue:
		if id := m.equipment_value; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeLocationValue:
		if id := m.location_value; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeServiceValue:
		if id := m.service_value; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeWorkOrderValue:
		if id := m.work_order_value; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeUserValue:
		if id := m.user_value; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeProjectValue:
		if id := m.project_value; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.cleared_type {
		edges = append(edges, property.EdgeType)
	}
	if m.clearedlocation {
		edges = append(edges, property.EdgeLocation)
	}
	if m.clearedequipment {
		edges = append(edges, property.EdgeEquipment)
	}
	if m.clearedservice {
		edges = append(edges, property.EdgeService)
	}
	if m.clearedequipment_port {
		edges = append(edges, property.EdgeEquipmentPort)
	}
	if m.clearedlink {
		edges = append(edges, property.EdgeLink)
	}
	if m.clearedwork_order {
		edges = append(edges, property.EdgeWorkOrder)
	}
	if m.clearedproject {
		edges = append(edges, property.EdgeProject)
	}
	if m.clearedequipment_value {
		edges = append(edges, property.EdgeEquipmentValue)
	}
	if m.clearedlocation_value {
		edges = append(edges, property.EdgeLocationValue)
	}
	if m.clearedservice_value {
		edges = append(edges, property.EdgeServiceValue)
	}
	if m.clearedwork_order_value {
		edges = append(edges, property.EdgeWorkOrderValue)
	}
	if m.cleareduser_value {
		edges = append(edges, property.EdgeUserValue)
	}
	if m.clearedproject_value {
		edges = append(edges, property.EdgeProjectValue)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeType:
		return m.cleared_type
	case property.EdgeLocation:
		return m.clearedlocation
	case property.EdgeEquipment:
		return m.clearedequipment
	case property.EdgeService:
		return m.clearedservice
	case property.EdgeEquipmentPort:
		return m.clearedequipment_port
	case property.EdgeLink:
		return m.clearedlink
	case property.EdgeWorkOrder:
		return m.clearedwork_order
	case property.EdgeProject:
		return m.clearedproject
	case property.EdgeEquipmentValue:
		return m.clearedequipment_value
	case property.EdgeLocationValue:
		return m.clearedlocation_value
	case property.EdgeServiceValue:
		return m.clearedservice_value
	case property.EdgeWorkOrderValue:
		return m.clearedwork_order_value
	case property.EdgeUserValue:
		return m.cleareduser_value
	case property.EdgeProjectValue:
		return m.clearedproject_value
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeType:
		m.ClearType()
		return nil
	case property.EdgeLocation:
		m.ClearLocation()
		return nil
	case property.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case property.EdgeService:
		m.ClearService()
		return nil
	case property.EdgeEquipmentPort:
		m.ClearEquipmentPort()
		return nil
	case property.EdgeLink:
		m.ClearLink()
		return nil
	case property.EdgeWorkOrder:
		m.ClearWorkOrder()
		return nil
	case property.EdgeProject:
		m.ClearProject()
		return nil
	case property.EdgeEquipmentValue:
		m.ClearEquipmentValue()
		return nil
	case property.EdgeLocationValue:
		m.ClearLocationValue()
		return nil
	case property.EdgeServiceValue:
		m.ClearServiceValue()
		return nil
	case property.EdgeWorkOrderValue:
		m.ClearWorkOrderValue()
		return nil
	case property.EdgeUserValue:
		m.ClearUserValue()
		return nil
	case property.EdgeProjectValue:
		m.ClearProjectValue()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeType:
		m.ResetType()
		return nil
	case property.EdgeLocation:
		m.ResetLocation()
		return nil
	case property.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case property.EdgeService:
		m.ResetService()
		return nil
	case property.EdgeEquipmentPort:
		m.ResetEquipmentPort()
		return nil
	case property.EdgeLink:
		m.ResetLink()
		return nil
	case property.EdgeWorkOrder:
		m.ResetWorkOrder()
		return nil
	case property.EdgeProject:
		m.ResetProject()
		return nil
	case property.EdgeEquipmentValue:
		m.ResetEquipmentValue()
		return nil
	case property.EdgeLocationValue:
		m.ResetLocationValue()
		return nil
	case property.EdgeServiceValue:
		m.ResetServiceValue()
		return nil
	case property.EdgeWorkOrderValue:
		m.ResetWorkOrderValue()
		return nil
	case property.EdgeUserValue:
		m.ResetUserValue()
		return nil
	case property.EdgeProjectValue:
		m.ResetProjectValue()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// PropertyCategoryMutation represents an operation that mutate the PropertyCategories
// nodes in the graph.
type PropertyCategoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	create_time              *time.Time
	update_time              *time.Time
	name                     *string
	index                    *int
	addindex                 *int
	clearedFields            map[string]struct{}
	properties_type          map[int]struct{}
	removedproperties_type   map[int]struct{}
	clearedproperties_type   bool
	parameter_catalog        *int
	clearedparameter_catalog bool
	done                     bool
	oldValue                 func(context.Context) (*PropertyCategory, error)
	predicates               []predicate.PropertyCategory
}

var _ ent.Mutation = (*PropertyCategoryMutation)(nil)

// propertycategoryOption allows to manage the mutation configuration using functional options.
type propertycategoryOption func(*PropertyCategoryMutation)

// newPropertyCategoryMutation creates new mutation for PropertyCategory.
func newPropertyCategoryMutation(c config, op Op, opts ...propertycategoryOption) *PropertyCategoryMutation {
	m := &PropertyCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypePropertyCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyCategoryID sets the id field of the mutation.
func withPropertyCategoryID(id int) propertycategoryOption {
	return func(m *PropertyCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PropertyCategory
		)
		m.oldValue = func(ctx context.Context) (*PropertyCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PropertyCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPropertyCategory sets the old PropertyCategory of the mutation.
func withPropertyCategory(node *PropertyCategory) propertycategoryOption {
	return func(m *PropertyCategoryMutation) {
		m.oldValue = func(context.Context) (*PropertyCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PropertyCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *PropertyCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *PropertyCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the PropertyCategory.
// If the PropertyCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *PropertyCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *PropertyCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *PropertyCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the PropertyCategory.
// If the PropertyCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *PropertyCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *PropertyCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PropertyCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PropertyCategory.
// If the PropertyCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PropertyCategoryMutation) ResetName() {
	m.name = nil
}

// SetIndex sets the index field.
func (m *PropertyCategoryMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *PropertyCategoryMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the PropertyCategory.
// If the PropertyCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyCategoryMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *PropertyCategoryMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *PropertyCategoryMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *PropertyCategoryMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// AddPropertiesTypeIDs adds the properties_type edge to PropertyType by ids.
func (m *PropertyCategoryMutation) AddPropertiesTypeIDs(ids ...int) {
	if m.properties_type == nil {
		m.properties_type = make(map[int]struct{})
	}
	for i := range ids {
		m.properties_type[ids[i]] = struct{}{}
	}
}

// ClearPropertiesType clears the properties_type edge to PropertyType.
func (m *PropertyCategoryMutation) ClearPropertiesType() {
	m.clearedproperties_type = true
}

// PropertiesTypeCleared returns if the edge properties_type was cleared.
func (m *PropertyCategoryMutation) PropertiesTypeCleared() bool {
	return m.clearedproperties_type
}

// RemovePropertiesTypeIDs removes the properties_type edge to PropertyType by ids.
func (m *PropertyCategoryMutation) RemovePropertiesTypeIDs(ids ...int) {
	if m.removedproperties_type == nil {
		m.removedproperties_type = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties_type[ids[i]] = struct{}{}
	}
}

// RemovedPropertiesType returns the removed ids of properties_type.
func (m *PropertyCategoryMutation) RemovedPropertiesTypeIDs() (ids []int) {
	for id := range m.removedproperties_type {
		ids = append(ids, id)
	}
	return
}

// PropertiesTypeIDs returns the properties_type ids in the mutation.
func (m *PropertyCategoryMutation) PropertiesTypeIDs() (ids []int) {
	for id := range m.properties_type {
		ids = append(ids, id)
	}
	return
}

// ResetPropertiesType reset all changes of the "properties_type" edge.
func (m *PropertyCategoryMutation) ResetPropertiesType() {
	m.properties_type = nil
	m.clearedproperties_type = false
	m.removedproperties_type = nil
}

// SetParameterCatalogID sets the parameter_catalog edge to ParameterCatalog by id.
func (m *PropertyCategoryMutation) SetParameterCatalogID(id int) {
	m.parameter_catalog = &id
}

// ClearParameterCatalog clears the parameter_catalog edge to ParameterCatalog.
func (m *PropertyCategoryMutation) ClearParameterCatalog() {
	m.clearedparameter_catalog = true
}

// ParameterCatalogCleared returns if the edge parameter_catalog was cleared.
func (m *PropertyCategoryMutation) ParameterCatalogCleared() bool {
	return m.clearedparameter_catalog
}

// ParameterCatalogID returns the parameter_catalog id in the mutation.
func (m *PropertyCategoryMutation) ParameterCatalogID() (id int, exists bool) {
	if m.parameter_catalog != nil {
		return *m.parameter_catalog, true
	}
	return
}

// ParameterCatalogIDs returns the parameter_catalog ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParameterCatalogID instead. It exists only for internal usage by the builders.
func (m *PropertyCategoryMutation) ParameterCatalogIDs() (ids []int) {
	if id := m.parameter_catalog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParameterCatalog reset all changes of the "parameter_catalog" edge.
func (m *PropertyCategoryMutation) ResetParameterCatalog() {
	m.parameter_catalog = nil
	m.clearedparameter_catalog = false
}

// Op returns the operation name.
func (m *PropertyCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PropertyCategory).
func (m *PropertyCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PropertyCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, propertycategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, propertycategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, propertycategory.FieldName)
	}
	if m.index != nil {
		fields = append(fields, propertycategory.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PropertyCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case propertycategory.FieldCreateTime:
		return m.CreateTime()
	case propertycategory.FieldUpdateTime:
		return m.UpdateTime()
	case propertycategory.FieldName:
		return m.Name()
	case propertycategory.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PropertyCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case propertycategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case propertycategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case propertycategory.FieldName:
		return m.OldName(ctx)
	case propertycategory.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown PropertyCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case propertycategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case propertycategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case propertycategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case propertycategory.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PropertyCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, propertycategory.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PropertyCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case propertycategory.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case propertycategory.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PropertyCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PropertyCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PropertyCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PropertyCategoryMutation) ResetField(name string) error {
	switch name {
	case propertycategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case propertycategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case propertycategory.FieldName:
		m.ResetName()
		return nil
	case propertycategory.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown PropertyCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PropertyCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.properties_type != nil {
		edges = append(edges, propertycategory.EdgePropertiesType)
	}
	if m.parameter_catalog != nil {
		edges = append(edges, propertycategory.EdgeParameterCatalog)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PropertyCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case propertycategory.EdgePropertiesType:
		ids := make([]ent.Value, 0, len(m.properties_type))
		for id := range m.properties_type {
			ids = append(ids, id)
		}
		return ids
	case propertycategory.EdgeParameterCatalog:
		if id := m.parameter_catalog; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PropertyCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproperties_type != nil {
		edges = append(edges, propertycategory.EdgePropertiesType)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PropertyCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case propertycategory.EdgePropertiesType:
		ids := make([]ent.Value, 0, len(m.removedproperties_type))
		for id := range m.removedproperties_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PropertyCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproperties_type {
		edges = append(edges, propertycategory.EdgePropertiesType)
	}
	if m.clearedparameter_catalog {
		edges = append(edges, propertycategory.EdgeParameterCatalog)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PropertyCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case propertycategory.EdgePropertiesType:
		return m.clearedproperties_type
	case propertycategory.EdgeParameterCatalog:
		return m.clearedparameter_catalog
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PropertyCategoryMutation) ClearEdge(name string) error {
	switch name {
	case propertycategory.EdgeParameterCatalog:
		m.ClearParameterCatalog()
		return nil
	}
	return fmt.Errorf("unknown PropertyCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PropertyCategoryMutation) ResetEdge(name string) error {
	switch name {
	case propertycategory.EdgePropertiesType:
		m.ResetPropertiesType()
		return nil
	case propertycategory.EdgeParameterCatalog:
		m.ResetParameterCatalog()
		return nil
	}
	return fmt.Errorf("unknown PropertyCategory edge %s", name)
}

// PropertyTypeMutation represents an operation that mutate the PropertyTypes
// nodes in the graph.
type PropertyTypeMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	create_time                     *time.Time
	update_time                     *time.Time
	_type                           *propertytype.Type
	name                            *string
	external_id                     *string
	index                           *int
	addindex                        *int
	category                        *string
	int_val                         *int
	addint_val                      *int
	bool_val                        *bool
	float_val                       *float64
	addfloat_val                    *float64
	latitude_val                    *float64
	addlatitude_val                 *float64
	longitude_val                   *float64
	addlongitude_val                *float64
	string_val                      *string
	range_from_val                  *float64
	addrange_from_val               *float64
	range_to_val                    *float64
	addrange_to_val                 *float64
	is_instance_property            *bool
	editable                        *bool
	mandatory                       *bool
	deleted                         *bool
	listable                        *bool
	nodeType                        *string
	clearedFields                   map[string]struct{}
	properties                      map[int]struct{}
	removedproperties               map[int]struct{}
	clearedproperties               bool
	location_type                   *int
	clearedlocation_type            bool
	equipment_port_type             *int
	clearedequipment_port_type      bool
	link_equipment_port_type        *int
	clearedlink_equipment_port_type bool
	equipment_type                  *int
	clearedequipment_type           bool
	service_type                    *int
	clearedservice_type             bool
	work_order_type                 *int
	clearedwork_order_type          bool
	work_order_template             *int
	clearedwork_order_template      bool
	project_type                    *int
	clearedproject_type             bool
	project_template                *int
	clearedproject_template         bool
	worker_type                     *int
	clearedworker_type              bool
	property_category               *int
	clearedproperty_category        bool
	done                            bool
	oldValue                        func(context.Context) (*PropertyType, error)
	predicates                      []predicate.PropertyType
}

var _ ent.Mutation = (*PropertyTypeMutation)(nil)

// propertytypeOption allows to manage the mutation configuration using functional options.
type propertytypeOption func(*PropertyTypeMutation)

// newPropertyTypeMutation creates new mutation for PropertyType.
func newPropertyTypeMutation(c config, op Op, opts ...propertytypeOption) *PropertyTypeMutation {
	m := &PropertyTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePropertyType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyTypeID sets the id field of the mutation.
func withPropertyTypeID(id int) propertytypeOption {
	return func(m *PropertyTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PropertyType
		)
		m.oldValue = func(ctx context.Context) (*PropertyType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PropertyType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPropertyType sets the old PropertyType of the mutation.
func withPropertyType(node *PropertyType) propertytypeOption {
	return func(m *PropertyTypeMutation) {
		m.oldValue = func(context.Context) (*PropertyType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PropertyTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *PropertyTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *PropertyTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *PropertyTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *PropertyTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *PropertyTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *PropertyTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the type field.
func (m *PropertyTypeMutation) SetType(pr propertytype.Type) {
	m._type = &pr
}

// GetType returns the type value in the mutation.
func (m *PropertyTypeMutation) GetType() (r propertytype.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldType(ctx context.Context) (v propertytype.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *PropertyTypeMutation) ResetType() {
	m._type = nil
}

// SetName sets the name field.
func (m *PropertyTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PropertyTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PropertyTypeMutation) ResetName() {
	m.name = nil
}

// SetExternalID sets the external_id field.
func (m *PropertyTypeMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the external_id value in the mutation.
func (m *PropertyTypeMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old external_id value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of external_id.
func (m *PropertyTypeMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[propertytype.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the field external_id was cleared in this mutation.
func (m *PropertyTypeMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldExternalID]
	return ok
}

// ResetExternalID reset all changes of the "external_id" field.
func (m *PropertyTypeMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, propertytype.FieldExternalID)
}

// SetIndex sets the index field.
func (m *PropertyTypeMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *PropertyTypeMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *PropertyTypeMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *PropertyTypeMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *PropertyTypeMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[propertytype.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *PropertyTypeMutation) IndexCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *PropertyTypeMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, propertytype.FieldIndex)
}

// SetCategory sets the category field.
func (m *PropertyTypeMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the category value in the mutation.
func (m *PropertyTypeMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old category value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of category.
func (m *PropertyTypeMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[propertytype.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the field category was cleared in this mutation.
func (m *PropertyTypeMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldCategory]
	return ok
}

// ResetCategory reset all changes of the "category" field.
func (m *PropertyTypeMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, propertytype.FieldCategory)
}

// SetIntVal sets the int_val field.
func (m *PropertyTypeMutation) SetIntVal(i int) {
	m.int_val = &i
	m.addint_val = nil
}

// IntVal returns the int_val value in the mutation.
func (m *PropertyTypeMutation) IntVal() (r int, exists bool) {
	v := m.int_val
	if v == nil {
		return
	}
	return *v, true
}

// OldIntVal returns the old int_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldIntVal(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntVal: %w", err)
	}
	return oldValue.IntVal, nil
}

// AddIntVal adds i to int_val.
func (m *PropertyTypeMutation) AddIntVal(i int) {
	if m.addint_val != nil {
		*m.addint_val += i
	} else {
		m.addint_val = &i
	}
}

// AddedIntVal returns the value that was added to the int_val field in this mutation.
func (m *PropertyTypeMutation) AddedIntVal() (r int, exists bool) {
	v := m.addint_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntVal clears the value of int_val.
func (m *PropertyTypeMutation) ClearIntVal() {
	m.int_val = nil
	m.addint_val = nil
	m.clearedFields[propertytype.FieldIntVal] = struct{}{}
}

// IntValCleared returns if the field int_val was cleared in this mutation.
func (m *PropertyTypeMutation) IntValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldIntVal]
	return ok
}

// ResetIntVal reset all changes of the "int_val" field.
func (m *PropertyTypeMutation) ResetIntVal() {
	m.int_val = nil
	m.addint_val = nil
	delete(m.clearedFields, propertytype.FieldIntVal)
}

// SetBoolVal sets the bool_val field.
func (m *PropertyTypeMutation) SetBoolVal(b bool) {
	m.bool_val = &b
}

// BoolVal returns the bool_val value in the mutation.
func (m *PropertyTypeMutation) BoolVal() (r bool, exists bool) {
	v := m.bool_val
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolVal returns the old bool_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldBoolVal(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBoolVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBoolVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolVal: %w", err)
	}
	return oldValue.BoolVal, nil
}

// ClearBoolVal clears the value of bool_val.
func (m *PropertyTypeMutation) ClearBoolVal() {
	m.bool_val = nil
	m.clearedFields[propertytype.FieldBoolVal] = struct{}{}
}

// BoolValCleared returns if the field bool_val was cleared in this mutation.
func (m *PropertyTypeMutation) BoolValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldBoolVal]
	return ok
}

// ResetBoolVal reset all changes of the "bool_val" field.
func (m *PropertyTypeMutation) ResetBoolVal() {
	m.bool_val = nil
	delete(m.clearedFields, propertytype.FieldBoolVal)
}

// SetFloatVal sets the float_val field.
func (m *PropertyTypeMutation) SetFloatVal(f float64) {
	m.float_val = &f
	m.addfloat_val = nil
}

// FloatVal returns the float_val value in the mutation.
func (m *PropertyTypeMutation) FloatVal() (r float64, exists bool) {
	v := m.float_val
	if v == nil {
		return
	}
	return *v, true
}

// OldFloatVal returns the old float_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldFloatVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloatVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloatVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloatVal: %w", err)
	}
	return oldValue.FloatVal, nil
}

// AddFloatVal adds f to float_val.
func (m *PropertyTypeMutation) AddFloatVal(f float64) {
	if m.addfloat_val != nil {
		*m.addfloat_val += f
	} else {
		m.addfloat_val = &f
	}
}

// AddedFloatVal returns the value that was added to the float_val field in this mutation.
func (m *PropertyTypeMutation) AddedFloatVal() (r float64, exists bool) {
	v := m.addfloat_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloatVal clears the value of float_val.
func (m *PropertyTypeMutation) ClearFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	m.clearedFields[propertytype.FieldFloatVal] = struct{}{}
}

// FloatValCleared returns if the field float_val was cleared in this mutation.
func (m *PropertyTypeMutation) FloatValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldFloatVal]
	return ok
}

// ResetFloatVal reset all changes of the "float_val" field.
func (m *PropertyTypeMutation) ResetFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	delete(m.clearedFields, propertytype.FieldFloatVal)
}

// SetLatitudeVal sets the latitude_val field.
func (m *PropertyTypeMutation) SetLatitudeVal(f float64) {
	m.latitude_val = &f
	m.addlatitude_val = nil
}

// LatitudeVal returns the latitude_val value in the mutation.
func (m *PropertyTypeMutation) LatitudeVal() (r float64, exists bool) {
	v := m.latitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitudeVal returns the old latitude_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldLatitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitudeVal: %w", err)
	}
	return oldValue.LatitudeVal, nil
}

// AddLatitudeVal adds f to latitude_val.
func (m *PropertyTypeMutation) AddLatitudeVal(f float64) {
	if m.addlatitude_val != nil {
		*m.addlatitude_val += f
	} else {
		m.addlatitude_val = &f
	}
}

// AddedLatitudeVal returns the value that was added to the latitude_val field in this mutation.
func (m *PropertyTypeMutation) AddedLatitudeVal() (r float64, exists bool) {
	v := m.addlatitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitudeVal clears the value of latitude_val.
func (m *PropertyTypeMutation) ClearLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	m.clearedFields[propertytype.FieldLatitudeVal] = struct{}{}
}

// LatitudeValCleared returns if the field latitude_val was cleared in this mutation.
func (m *PropertyTypeMutation) LatitudeValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldLatitudeVal]
	return ok
}

// ResetLatitudeVal reset all changes of the "latitude_val" field.
func (m *PropertyTypeMutation) ResetLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	delete(m.clearedFields, propertytype.FieldLatitudeVal)
}

// SetLongitudeVal sets the longitude_val field.
func (m *PropertyTypeMutation) SetLongitudeVal(f float64) {
	m.longitude_val = &f
	m.addlongitude_val = nil
}

// LongitudeVal returns the longitude_val value in the mutation.
func (m *PropertyTypeMutation) LongitudeVal() (r float64, exists bool) {
	v := m.longitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitudeVal returns the old longitude_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldLongitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitudeVal: %w", err)
	}
	return oldValue.LongitudeVal, nil
}

// AddLongitudeVal adds f to longitude_val.
func (m *PropertyTypeMutation) AddLongitudeVal(f float64) {
	if m.addlongitude_val != nil {
		*m.addlongitude_val += f
	} else {
		m.addlongitude_val = &f
	}
}

// AddedLongitudeVal returns the value that was added to the longitude_val field in this mutation.
func (m *PropertyTypeMutation) AddedLongitudeVal() (r float64, exists bool) {
	v := m.addlongitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitudeVal clears the value of longitude_val.
func (m *PropertyTypeMutation) ClearLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	m.clearedFields[propertytype.FieldLongitudeVal] = struct{}{}
}

// LongitudeValCleared returns if the field longitude_val was cleared in this mutation.
func (m *PropertyTypeMutation) LongitudeValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldLongitudeVal]
	return ok
}

// ResetLongitudeVal reset all changes of the "longitude_val" field.
func (m *PropertyTypeMutation) ResetLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	delete(m.clearedFields, propertytype.FieldLongitudeVal)
}

// SetStringVal sets the string_val field.
func (m *PropertyTypeMutation) SetStringVal(s string) {
	m.string_val = &s
}

// StringVal returns the string_val value in the mutation.
func (m *PropertyTypeMutation) StringVal() (r string, exists bool) {
	v := m.string_val
	if v == nil {
		return
	}
	return *v, true
}

// OldStringVal returns the old string_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldStringVal(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringVal: %w", err)
	}
	return oldValue.StringVal, nil
}

// ClearStringVal clears the value of string_val.
func (m *PropertyTypeMutation) ClearStringVal() {
	m.string_val = nil
	m.clearedFields[propertytype.FieldStringVal] = struct{}{}
}

// StringValCleared returns if the field string_val was cleared in this mutation.
func (m *PropertyTypeMutation) StringValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldStringVal]
	return ok
}

// ResetStringVal reset all changes of the "string_val" field.
func (m *PropertyTypeMutation) ResetStringVal() {
	m.string_val = nil
	delete(m.clearedFields, propertytype.FieldStringVal)
}

// SetRangeFromVal sets the range_from_val field.
func (m *PropertyTypeMutation) SetRangeFromVal(f float64) {
	m.range_from_val = &f
	m.addrange_from_val = nil
}

// RangeFromVal returns the range_from_val value in the mutation.
func (m *PropertyTypeMutation) RangeFromVal() (r float64, exists bool) {
	v := m.range_from_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeFromVal returns the old range_from_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldRangeFromVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeFromVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeFromVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeFromVal: %w", err)
	}
	return oldValue.RangeFromVal, nil
}

// AddRangeFromVal adds f to range_from_val.
func (m *PropertyTypeMutation) AddRangeFromVal(f float64) {
	if m.addrange_from_val != nil {
		*m.addrange_from_val += f
	} else {
		m.addrange_from_val = &f
	}
}

// AddedRangeFromVal returns the value that was added to the range_from_val field in this mutation.
func (m *PropertyTypeMutation) AddedRangeFromVal() (r float64, exists bool) {
	v := m.addrange_from_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeFromVal clears the value of range_from_val.
func (m *PropertyTypeMutation) ClearRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	m.clearedFields[propertytype.FieldRangeFromVal] = struct{}{}
}

// RangeFromValCleared returns if the field range_from_val was cleared in this mutation.
func (m *PropertyTypeMutation) RangeFromValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldRangeFromVal]
	return ok
}

// ResetRangeFromVal reset all changes of the "range_from_val" field.
func (m *PropertyTypeMutation) ResetRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	delete(m.clearedFields, propertytype.FieldRangeFromVal)
}

// SetRangeToVal sets the range_to_val field.
func (m *PropertyTypeMutation) SetRangeToVal(f float64) {
	m.range_to_val = &f
	m.addrange_to_val = nil
}

// RangeToVal returns the range_to_val value in the mutation.
func (m *PropertyTypeMutation) RangeToVal() (r float64, exists bool) {
	v := m.range_to_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeToVal returns the old range_to_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldRangeToVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeToVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeToVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeToVal: %w", err)
	}
	return oldValue.RangeToVal, nil
}

// AddRangeToVal adds f to range_to_val.
func (m *PropertyTypeMutation) AddRangeToVal(f float64) {
	if m.addrange_to_val != nil {
		*m.addrange_to_val += f
	} else {
		m.addrange_to_val = &f
	}
}

// AddedRangeToVal returns the value that was added to the range_to_val field in this mutation.
func (m *PropertyTypeMutation) AddedRangeToVal() (r float64, exists bool) {
	v := m.addrange_to_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeToVal clears the value of range_to_val.
func (m *PropertyTypeMutation) ClearRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	m.clearedFields[propertytype.FieldRangeToVal] = struct{}{}
}

// RangeToValCleared returns if the field range_to_val was cleared in this mutation.
func (m *PropertyTypeMutation) RangeToValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldRangeToVal]
	return ok
}

// ResetRangeToVal reset all changes of the "range_to_val" field.
func (m *PropertyTypeMutation) ResetRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	delete(m.clearedFields, propertytype.FieldRangeToVal)
}

// SetIsInstanceProperty sets the is_instance_property field.
func (m *PropertyTypeMutation) SetIsInstanceProperty(b bool) {
	m.is_instance_property = &b
}

// IsInstanceProperty returns the is_instance_property value in the mutation.
func (m *PropertyTypeMutation) IsInstanceProperty() (r bool, exists bool) {
	v := m.is_instance_property
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInstanceProperty returns the old is_instance_property value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldIsInstanceProperty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsInstanceProperty is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsInstanceProperty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInstanceProperty: %w", err)
	}
	return oldValue.IsInstanceProperty, nil
}

// ResetIsInstanceProperty reset all changes of the "is_instance_property" field.
func (m *PropertyTypeMutation) ResetIsInstanceProperty() {
	m.is_instance_property = nil
}

// SetEditable sets the editable field.
func (m *PropertyTypeMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the editable value in the mutation.
func (m *PropertyTypeMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old editable value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEditable is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable reset all changes of the "editable" field.
func (m *PropertyTypeMutation) ResetEditable() {
	m.editable = nil
}

// SetMandatory sets the mandatory field.
func (m *PropertyTypeMutation) SetMandatory(b bool) {
	m.mandatory = &b
}

// Mandatory returns the mandatory value in the mutation.
func (m *PropertyTypeMutation) Mandatory() (r bool, exists bool) {
	v := m.mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldMandatory returns the old mandatory value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMandatory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMandatory: %w", err)
	}
	return oldValue.Mandatory, nil
}

// ResetMandatory reset all changes of the "mandatory" field.
func (m *PropertyTypeMutation) ResetMandatory() {
	m.mandatory = nil
}

// SetDeleted sets the deleted field.
func (m *PropertyTypeMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the deleted value in the mutation.
func (m *PropertyTypeMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *PropertyTypeMutation) ResetDeleted() {
	m.deleted = nil
}

// SetListable sets the listable field.
func (m *PropertyTypeMutation) SetListable(b bool) {
	m.listable = &b
}

// Listable returns the listable value in the mutation.
func (m *PropertyTypeMutation) Listable() (r bool, exists bool) {
	v := m.listable
	if v == nil {
		return
	}
	return *v, true
}

// OldListable returns the old listable value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldListable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldListable is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldListable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListable: %w", err)
	}
	return oldValue.Listable, nil
}

// ResetListable reset all changes of the "listable" field.
func (m *PropertyTypeMutation) ResetListable() {
	m.listable = nil
}

// SetNodeType sets the nodeType field.
func (m *PropertyTypeMutation) SetNodeType(s string) {
	m.nodeType = &s
}

// NodeType returns the nodeType value in the mutation.
func (m *PropertyTypeMutation) NodeType() (r string, exists bool) {
	v := m.nodeType
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old nodeType value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldNodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ClearNodeType clears the value of nodeType.
func (m *PropertyTypeMutation) ClearNodeType() {
	m.nodeType = nil
	m.clearedFields[propertytype.FieldNodeType] = struct{}{}
}

// NodeTypeCleared returns if the field nodeType was cleared in this mutation.
func (m *PropertyTypeMutation) NodeTypeCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldNodeType]
	return ok
}

// ResetNodeType reset all changes of the "nodeType" field.
func (m *PropertyTypeMutation) ResetNodeType() {
	m.nodeType = nil
	delete(m.clearedFields, propertytype.FieldNodeType)
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *PropertyTypeMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *PropertyTypeMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *PropertyTypeMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *PropertyTypeMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *PropertyTypeMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *PropertyTypeMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *PropertyTypeMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// SetLocationTypeID sets the location_type edge to LocationType by id.
func (m *PropertyTypeMutation) SetLocationTypeID(id int) {
	m.location_type = &id
}

// ClearLocationType clears the location_type edge to LocationType.
func (m *PropertyTypeMutation) ClearLocationType() {
	m.clearedlocation_type = true
}

// LocationTypeCleared returns if the edge location_type was cleared.
func (m *PropertyTypeMutation) LocationTypeCleared() bool {
	return m.clearedlocation_type
}

// LocationTypeID returns the location_type id in the mutation.
func (m *PropertyTypeMutation) LocationTypeID() (id int, exists bool) {
	if m.location_type != nil {
		return *m.location_type, true
	}
	return
}

// LocationTypeIDs returns the location_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) LocationTypeIDs() (ids []int) {
	if id := m.location_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocationType reset all changes of the "location_type" edge.
func (m *PropertyTypeMutation) ResetLocationType() {
	m.location_type = nil
	m.clearedlocation_type = false
}

// SetEquipmentPortTypeID sets the equipment_port_type edge to EquipmentPortType by id.
func (m *PropertyTypeMutation) SetEquipmentPortTypeID(id int) {
	m.equipment_port_type = &id
}

// ClearEquipmentPortType clears the equipment_port_type edge to EquipmentPortType.
func (m *PropertyTypeMutation) ClearEquipmentPortType() {
	m.clearedequipment_port_type = true
}

// EquipmentPortTypeCleared returns if the edge equipment_port_type was cleared.
func (m *PropertyTypeMutation) EquipmentPortTypeCleared() bool {
	return m.clearedequipment_port_type
}

// EquipmentPortTypeID returns the equipment_port_type id in the mutation.
func (m *PropertyTypeMutation) EquipmentPortTypeID() (id int, exists bool) {
	if m.equipment_port_type != nil {
		return *m.equipment_port_type, true
	}
	return
}

// EquipmentPortTypeIDs returns the equipment_port_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentPortTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) EquipmentPortTypeIDs() (ids []int) {
	if id := m.equipment_port_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentPortType reset all changes of the "equipment_port_type" edge.
func (m *PropertyTypeMutation) ResetEquipmentPortType() {
	m.equipment_port_type = nil
	m.clearedequipment_port_type = false
}

// SetLinkEquipmentPortTypeID sets the link_equipment_port_type edge to EquipmentPortType by id.
func (m *PropertyTypeMutation) SetLinkEquipmentPortTypeID(id int) {
	m.link_equipment_port_type = &id
}

// ClearLinkEquipmentPortType clears the link_equipment_port_type edge to EquipmentPortType.
func (m *PropertyTypeMutation) ClearLinkEquipmentPortType() {
	m.clearedlink_equipment_port_type = true
}

// LinkEquipmentPortTypeCleared returns if the edge link_equipment_port_type was cleared.
func (m *PropertyTypeMutation) LinkEquipmentPortTypeCleared() bool {
	return m.clearedlink_equipment_port_type
}

// LinkEquipmentPortTypeID returns the link_equipment_port_type id in the mutation.
func (m *PropertyTypeMutation) LinkEquipmentPortTypeID() (id int, exists bool) {
	if m.link_equipment_port_type != nil {
		return *m.link_equipment_port_type, true
	}
	return
}

// LinkEquipmentPortTypeIDs returns the link_equipment_port_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LinkEquipmentPortTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) LinkEquipmentPortTypeIDs() (ids []int) {
	if id := m.link_equipment_port_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLinkEquipmentPortType reset all changes of the "link_equipment_port_type" edge.
func (m *PropertyTypeMutation) ResetLinkEquipmentPortType() {
	m.link_equipment_port_type = nil
	m.clearedlink_equipment_port_type = false
}

// SetEquipmentTypeID sets the equipment_type edge to EquipmentType by id.
func (m *PropertyTypeMutation) SetEquipmentTypeID(id int) {
	m.equipment_type = &id
}

// ClearEquipmentType clears the equipment_type edge to EquipmentType.
func (m *PropertyTypeMutation) ClearEquipmentType() {
	m.clearedequipment_type = true
}

// EquipmentTypeCleared returns if the edge equipment_type was cleared.
func (m *PropertyTypeMutation) EquipmentTypeCleared() bool {
	return m.clearedequipment_type
}

// EquipmentTypeID returns the equipment_type id in the mutation.
func (m *PropertyTypeMutation) EquipmentTypeID() (id int, exists bool) {
	if m.equipment_type != nil {
		return *m.equipment_type, true
	}
	return
}

// EquipmentTypeIDs returns the equipment_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) EquipmentTypeIDs() (ids []int) {
	if id := m.equipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentType reset all changes of the "equipment_type" edge.
func (m *PropertyTypeMutation) ResetEquipmentType() {
	m.equipment_type = nil
	m.clearedequipment_type = false
}

// SetServiceTypeID sets the service_type edge to ServiceType by id.
func (m *PropertyTypeMutation) SetServiceTypeID(id int) {
	m.service_type = &id
}

// ClearServiceType clears the service_type edge to ServiceType.
func (m *PropertyTypeMutation) ClearServiceType() {
	m.clearedservice_type = true
}

// ServiceTypeCleared returns if the edge service_type was cleared.
func (m *PropertyTypeMutation) ServiceTypeCleared() bool {
	return m.clearedservice_type
}

// ServiceTypeID returns the service_type id in the mutation.
func (m *PropertyTypeMutation) ServiceTypeID() (id int, exists bool) {
	if m.service_type != nil {
		return *m.service_type, true
	}
	return
}

// ServiceTypeIDs returns the service_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServiceTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) ServiceTypeIDs() (ids []int) {
	if id := m.service_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceType reset all changes of the "service_type" edge.
func (m *PropertyTypeMutation) ResetServiceType() {
	m.service_type = nil
	m.clearedservice_type = false
}

// SetWorkOrderTypeID sets the work_order_type edge to WorkOrderType by id.
func (m *PropertyTypeMutation) SetWorkOrderTypeID(id int) {
	m.work_order_type = &id
}

// ClearWorkOrderType clears the work_order_type edge to WorkOrderType.
func (m *PropertyTypeMutation) ClearWorkOrderType() {
	m.clearedwork_order_type = true
}

// WorkOrderTypeCleared returns if the edge work_order_type was cleared.
func (m *PropertyTypeMutation) WorkOrderTypeCleared() bool {
	return m.clearedwork_order_type
}

// WorkOrderTypeID returns the work_order_type id in the mutation.
func (m *PropertyTypeMutation) WorkOrderTypeID() (id int, exists bool) {
	if m.work_order_type != nil {
		return *m.work_order_type, true
	}
	return
}

// WorkOrderTypeIDs returns the work_order_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) WorkOrderTypeIDs() (ids []int) {
	if id := m.work_order_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrderType reset all changes of the "work_order_type" edge.
func (m *PropertyTypeMutation) ResetWorkOrderType() {
	m.work_order_type = nil
	m.clearedwork_order_type = false
}

// SetWorkOrderTemplateID sets the work_order_template edge to WorkOrderTemplate by id.
func (m *PropertyTypeMutation) SetWorkOrderTemplateID(id int) {
	m.work_order_template = &id
}

// ClearWorkOrderTemplate clears the work_order_template edge to WorkOrderTemplate.
func (m *PropertyTypeMutation) ClearWorkOrderTemplate() {
	m.clearedwork_order_template = true
}

// WorkOrderTemplateCleared returns if the edge work_order_template was cleared.
func (m *PropertyTypeMutation) WorkOrderTemplateCleared() bool {
	return m.clearedwork_order_template
}

// WorkOrderTemplateID returns the work_order_template id in the mutation.
func (m *PropertyTypeMutation) WorkOrderTemplateID() (id int, exists bool) {
	if m.work_order_template != nil {
		return *m.work_order_template, true
	}
	return
}

// WorkOrderTemplateIDs returns the work_order_template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkOrderTemplateID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) WorkOrderTemplateIDs() (ids []int) {
	if id := m.work_order_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkOrderTemplate reset all changes of the "work_order_template" edge.
func (m *PropertyTypeMutation) ResetWorkOrderTemplate() {
	m.work_order_template = nil
	m.clearedwork_order_template = false
}

// SetProjectTypeID sets the project_type edge to ProjectType by id.
func (m *PropertyTypeMutation) SetProjectTypeID(id int) {
	m.project_type = &id
}

// ClearProjectType clears the project_type edge to ProjectType.
func (m *PropertyTypeMutation) ClearProjectType() {
	m.clearedproject_type = true
}

// ProjectTypeCleared returns if the edge project_type was cleared.
func (m *PropertyTypeMutation) ProjectTypeCleared() bool {
	return m.clearedproject_type
}

// ProjectTypeID returns the project_type id in the mutation.
func (m *PropertyTypeMutation) ProjectTypeID() (id int, exists bool) {
	if m.project_type != nil {
		return *m.project_type, true
	}
	return
}

// ProjectTypeIDs returns the project_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) ProjectTypeIDs() (ids []int) {
	if id := m.project_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectType reset all changes of the "project_type" edge.
func (m *PropertyTypeMutation) ResetProjectType() {
	m.project_type = nil
	m.clearedproject_type = false
}

// SetProjectTemplateID sets the project_template edge to ProjectTemplate by id.
func (m *PropertyTypeMutation) SetProjectTemplateID(id int) {
	m.project_template = &id
}

// ClearProjectTemplate clears the project_template edge to ProjectTemplate.
func (m *PropertyTypeMutation) ClearProjectTemplate() {
	m.clearedproject_template = true
}

// ProjectTemplateCleared returns if the edge project_template was cleared.
func (m *PropertyTypeMutation) ProjectTemplateCleared() bool {
	return m.clearedproject_template
}

// ProjectTemplateID returns the project_template id in the mutation.
func (m *PropertyTypeMutation) ProjectTemplateID() (id int, exists bool) {
	if m.project_template != nil {
		return *m.project_template, true
	}
	return
}

// ProjectTemplateIDs returns the project_template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectTemplateID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) ProjectTemplateIDs() (ids []int) {
	if id := m.project_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectTemplate reset all changes of the "project_template" edge.
func (m *PropertyTypeMutation) ResetProjectTemplate() {
	m.project_template = nil
	m.clearedproject_template = false
}

// SetWorkerTypeID sets the worker_type edge to WorkerType by id.
func (m *PropertyTypeMutation) SetWorkerTypeID(id int) {
	m.worker_type = &id
}

// ClearWorkerType clears the worker_type edge to WorkerType.
func (m *PropertyTypeMutation) ClearWorkerType() {
	m.clearedworker_type = true
}

// WorkerTypeCleared returns if the edge worker_type was cleared.
func (m *PropertyTypeMutation) WorkerTypeCleared() bool {
	return m.clearedworker_type
}

// WorkerTypeID returns the worker_type id in the mutation.
func (m *PropertyTypeMutation) WorkerTypeID() (id int, exists bool) {
	if m.worker_type != nil {
		return *m.worker_type, true
	}
	return
}

// WorkerTypeIDs returns the worker_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// WorkerTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) WorkerTypeIDs() (ids []int) {
	if id := m.worker_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkerType reset all changes of the "worker_type" edge.
func (m *PropertyTypeMutation) ResetWorkerType() {
	m.worker_type = nil
	m.clearedworker_type = false
}

// SetPropertyCategoryID sets the property_category edge to PropertyCategory by id.
func (m *PropertyTypeMutation) SetPropertyCategoryID(id int) {
	m.property_category = &id
}

// ClearPropertyCategory clears the property_category edge to PropertyCategory.
func (m *PropertyTypeMutation) ClearPropertyCategory() {
	m.clearedproperty_category = true
}

// PropertyCategoryCleared returns if the edge property_category was cleared.
func (m *PropertyTypeMutation) PropertyCategoryCleared() bool {
	return m.clearedproperty_category
}

// PropertyCategoryID returns the property_category id in the mutation.
func (m *PropertyTypeMutation) PropertyCategoryID() (id int, exists bool) {
	if m.property_category != nil {
		return *m.property_category, true
	}
	return
}

// PropertyCategoryIDs returns the property_category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PropertyCategoryID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) PropertyCategoryIDs() (ids []int) {
	if id := m.property_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPropertyCategory reset all changes of the "property_category" edge.
func (m *PropertyTypeMutation) ResetPropertyCategory() {
	m.property_category = nil
	m.clearedproperty_category = false
}

// Op returns the operation name.
func (m *PropertyTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PropertyType).
func (m *PropertyTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PropertyTypeMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.create_time != nil {
		fields = append(fields, propertytype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, propertytype.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, propertytype.FieldType)
	}
	if m.name != nil {
		fields = append(fields, propertytype.FieldName)
	}
	if m.external_id != nil {
		fields = append(fields, propertytype.FieldExternalID)
	}
	if m.index != nil {
		fields = append(fields, propertytype.FieldIndex)
	}
	if m.category != nil {
		fields = append(fields, propertytype.FieldCategory)
	}
	if m.int_val != nil {
		fields = append(fields, propertytype.FieldIntVal)
	}
	if m.bool_val != nil {
		fields = append(fields, propertytype.FieldBoolVal)
	}
	if m.float_val != nil {
		fields = append(fields, propertytype.FieldFloatVal)
	}
	if m.latitude_val != nil {
		fields = append(fields, propertytype.FieldLatitudeVal)
	}
	if m.longitude_val != nil {
		fields = append(fields, propertytype.FieldLongitudeVal)
	}
	if m.string_val != nil {
		fields = append(fields, propertytype.FieldStringVal)
	}
	if m.range_from_val != nil {
		fields = append(fields, propertytype.FieldRangeFromVal)
	}
	if m.range_to_val != nil {
		fields = append(fields, propertytype.FieldRangeToVal)
	}
	if m.is_instance_property != nil {
		fields = append(fields, propertytype.FieldIsInstanceProperty)
	}
	if m.editable != nil {
		fields = append(fields, propertytype.FieldEditable)
	}
	if m.mandatory != nil {
		fields = append(fields, propertytype.FieldMandatory)
	}
	if m.deleted != nil {
		fields = append(fields, propertytype.FieldDeleted)
	}
	if m.listable != nil {
		fields = append(fields, propertytype.FieldListable)
	}
	if m.nodeType != nil {
		fields = append(fields, propertytype.FieldNodeType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PropertyTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case propertytype.FieldCreateTime:
		return m.CreateTime()
	case propertytype.FieldUpdateTime:
		return m.UpdateTime()
	case propertytype.FieldType:
		return m.GetType()
	case propertytype.FieldName:
		return m.Name()
	case propertytype.FieldExternalID:
		return m.ExternalID()
	case propertytype.FieldIndex:
		return m.Index()
	case propertytype.FieldCategory:
		return m.Category()
	case propertytype.FieldIntVal:
		return m.IntVal()
	case propertytype.FieldBoolVal:
		return m.BoolVal()
	case propertytype.FieldFloatVal:
		return m.FloatVal()
	case propertytype.FieldLatitudeVal:
		return m.LatitudeVal()
	case propertytype.FieldLongitudeVal:
		return m.LongitudeVal()
	case propertytype.FieldStringVal:
		return m.StringVal()
	case propertytype.FieldRangeFromVal:
		return m.RangeFromVal()
	case propertytype.FieldRangeToVal:
		return m.RangeToVal()
	case propertytype.FieldIsInstanceProperty:
		return m.IsInstanceProperty()
	case propertytype.FieldEditable:
		return m.Editable()
	case propertytype.FieldMandatory:
		return m.Mandatory()
	case propertytype.FieldDeleted:
		return m.Deleted()
	case propertytype.FieldListable:
		return m.Listable()
	case propertytype.FieldNodeType:
		return m.NodeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PropertyTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case propertytype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case propertytype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case propertytype.FieldType:
		return m.OldType(ctx)
	case propertytype.FieldName:
		return m.OldName(ctx)
	case propertytype.FieldExternalID:
		return m.OldExternalID(ctx)
	case propertytype.FieldIndex:
		return m.OldIndex(ctx)
	case propertytype.FieldCategory:
		return m.OldCategory(ctx)
	case propertytype.FieldIntVal:
		return m.OldIntVal(ctx)
	case propertytype.FieldBoolVal:
		return m.OldBoolVal(ctx)
	case propertytype.FieldFloatVal:
		return m.OldFloatVal(ctx)
	case propertytype.FieldLatitudeVal:
		return m.OldLatitudeVal(ctx)
	case propertytype.FieldLongitudeVal:
		return m.OldLongitudeVal(ctx)
	case propertytype.FieldStringVal:
		return m.OldStringVal(ctx)
	case propertytype.FieldRangeFromVal:
		return m.OldRangeFromVal(ctx)
	case propertytype.FieldRangeToVal:
		return m.OldRangeToVal(ctx)
	case propertytype.FieldIsInstanceProperty:
		return m.OldIsInstanceProperty(ctx)
	case propertytype.FieldEditable:
		return m.OldEditable(ctx)
	case propertytype.FieldMandatory:
		return m.OldMandatory(ctx)
	case propertytype.FieldDeleted:
		return m.OldDeleted(ctx)
	case propertytype.FieldListable:
		return m.OldListable(ctx)
	case propertytype.FieldNodeType:
		return m.OldNodeType(ctx)
	}
	return nil, fmt.Errorf("unknown PropertyType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case propertytype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case propertytype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case propertytype.FieldType:
		v, ok := value.(propertytype.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case propertytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case propertytype.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case propertytype.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case propertytype.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case propertytype.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntVal(v)
		return nil
	case propertytype.FieldBoolVal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolVal(v)
		return nil
	case propertytype.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloatVal(v)
		return nil
	case propertytype.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitudeVal(v)
		return nil
	case propertytype.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitudeVal(v)
		return nil
	case propertytype.FieldStringVal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringVal(v)
		return nil
	case propertytype.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeFromVal(v)
		return nil
	case propertytype.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeToVal(v)
		return nil
	case propertytype.FieldIsInstanceProperty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInstanceProperty(v)
		return nil
	case propertytype.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case propertytype.FieldMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMandatory(v)
		return nil
	case propertytype.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case propertytype.FieldListable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListable(v)
		return nil
	case propertytype.FieldNodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PropertyTypeMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, propertytype.FieldIndex)
	}
	if m.addint_val != nil {
		fields = append(fields, propertytype.FieldIntVal)
	}
	if m.addfloat_val != nil {
		fields = append(fields, propertytype.FieldFloatVal)
	}
	if m.addlatitude_val != nil {
		fields = append(fields, propertytype.FieldLatitudeVal)
	}
	if m.addlongitude_val != nil {
		fields = append(fields, propertytype.FieldLongitudeVal)
	}
	if m.addrange_from_val != nil {
		fields = append(fields, propertytype.FieldRangeFromVal)
	}
	if m.addrange_to_val != nil {
		fields = append(fields, propertytype.FieldRangeToVal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PropertyTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case propertytype.FieldIndex:
		return m.AddedIndex()
	case propertytype.FieldIntVal:
		return m.AddedIntVal()
	case propertytype.FieldFloatVal:
		return m.AddedFloatVal()
	case propertytype.FieldLatitudeVal:
		return m.AddedLatitudeVal()
	case propertytype.FieldLongitudeVal:
		return m.AddedLongitudeVal()
	case propertytype.FieldRangeFromVal:
		return m.AddedRangeFromVal()
	case propertytype.FieldRangeToVal:
		return m.AddedRangeToVal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case propertytype.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case propertytype.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntVal(v)
		return nil
	case propertytype.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloatVal(v)
		return nil
	case propertytype.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitudeVal(v)
		return nil
	case propertytype.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitudeVal(v)
		return nil
	case propertytype.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeFromVal(v)
		return nil
	case propertytype.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeToVal(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PropertyTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(propertytype.FieldExternalID) {
		fields = append(fields, propertytype.FieldExternalID)
	}
	if m.FieldCleared(propertytype.FieldIndex) {
		fields = append(fields, propertytype.FieldIndex)
	}
	if m.FieldCleared(propertytype.FieldCategory) {
		fields = append(fields, propertytype.FieldCategory)
	}
	if m.FieldCleared(propertytype.FieldIntVal) {
		fields = append(fields, propertytype.FieldIntVal)
	}
	if m.FieldCleared(propertytype.FieldBoolVal) {
		fields = append(fields, propertytype.FieldBoolVal)
	}
	if m.FieldCleared(propertytype.FieldFloatVal) {
		fields = append(fields, propertytype.FieldFloatVal)
	}
	if m.FieldCleared(propertytype.FieldLatitudeVal) {
		fields = append(fields, propertytype.FieldLatitudeVal)
	}
	if m.FieldCleared(propertytype.FieldLongitudeVal) {
		fields = append(fields, propertytype.FieldLongitudeVal)
	}
	if m.FieldCleared(propertytype.FieldStringVal) {
		fields = append(fields, propertytype.FieldStringVal)
	}
	if m.FieldCleared(propertytype.FieldRangeFromVal) {
		fields = append(fields, propertytype.FieldRangeFromVal)
	}
	if m.FieldCleared(propertytype.FieldRangeToVal) {
		fields = append(fields, propertytype.FieldRangeToVal)
	}
	if m.FieldCleared(propertytype.FieldNodeType) {
		fields = append(fields, propertytype.FieldNodeType)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PropertyTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyTypeMutation) ClearField(name string) error {
	switch name {
	case propertytype.FieldExternalID:
		m.ClearExternalID()
		return nil
	case propertytype.FieldIndex:
		m.ClearIndex()
		return nil
	case propertytype.FieldCategory:
		m.ClearCategory()
		return nil
	case propertytype.FieldIntVal:
		m.ClearIntVal()
		return nil
	case propertytype.FieldBoolVal:
		m.ClearBoolVal()
		return nil
	case propertytype.FieldFloatVal:
		m.ClearFloatVal()
		return nil
	case propertytype.FieldLatitudeVal:
		m.ClearLatitudeVal()
		return nil
	case propertytype.FieldLongitudeVal:
		m.ClearLongitudeVal()
		return nil
	case propertytype.FieldStringVal:
		m.ClearStringVal()
		return nil
	case propertytype.FieldRangeFromVal:
		m.ClearRangeFromVal()
		return nil
	case propertytype.FieldRangeToVal:
		m.ClearRangeToVal()
		return nil
	case propertytype.FieldNodeType:
		m.ClearNodeType()
		return nil
	}
	return fmt.Errorf("unknown PropertyType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PropertyTypeMutation) ResetField(name string) error {
	switch name {
	case propertytype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case propertytype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case propertytype.FieldType:
		m.ResetType()
		return nil
	case propertytype.FieldName:
		m.ResetName()
		return nil
	case propertytype.FieldExternalID:
		m.ResetExternalID()
		return nil
	case propertytype.FieldIndex:
		m.ResetIndex()
		return nil
	case propertytype.FieldCategory:
		m.ResetCategory()
		return nil
	case propertytype.FieldIntVal:
		m.ResetIntVal()
		return nil
	case propertytype.FieldBoolVal:
		m.ResetBoolVal()
		return nil
	case propertytype.FieldFloatVal:
		m.ResetFloatVal()
		return nil
	case propertytype.FieldLatitudeVal:
		m.ResetLatitudeVal()
		return nil
	case propertytype.FieldLongitudeVal:
		m.ResetLongitudeVal()
		return nil
	case propertytype.FieldStringVal:
		m.ResetStringVal()
		return nil
	case propertytype.FieldRangeFromVal:
		m.ResetRangeFromVal()
		return nil
	case propertytype.FieldRangeToVal:
		m.ResetRangeToVal()
		return nil
	case propertytype.FieldIsInstanceProperty:
		m.ResetIsInstanceProperty()
		return nil
	case propertytype.FieldEditable:
		m.ResetEditable()
		return nil
	case propertytype.FieldMandatory:
		m.ResetMandatory()
		return nil
	case propertytype.FieldDeleted:
		m.ResetDeleted()
		return nil
	case propertytype.FieldListable:
		m.ResetListable()
		return nil
	case propertytype.FieldNodeType:
		m.ResetNodeType()
		return nil
	}
	return fmt.Errorf("unknown PropertyType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PropertyTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.properties != nil {
		edges = append(edges, propertytype.EdgeProperties)
	}
	if m.location_type != nil {
		edges = append(edges, propertytype.EdgeLocationType)
	}
	if m.equipment_port_type != nil {
		edges = append(edges, propertytype.EdgeEquipmentPortType)
	}
	if m.link_equipment_port_type != nil {
		edges = append(edges, propertytype.EdgeLinkEquipmentPortType)
	}
	if m.equipment_type != nil {
		edges = append(edges, propertytype.EdgeEquipmentType)
	}
	if m.service_type != nil {
		edges = append(edges, propertytype.EdgeServiceType)
	}
	if m.work_order_type != nil {
		edges = append(edges, propertytype.EdgeWorkOrderType)
	}
	if m.work_order_template != nil {
		edges = append(edges, propertytype.EdgeWorkOrderTemplate)
	}
	if m.project_type != nil {
		edges = append(edges, propertytype.EdgeProjectType)
	}
	if m.project_template != nil {
		edges = append(edges, propertytype.EdgeProjectTemplate)
	}
	if m.worker_type != nil {
		edges = append(edges, propertytype.EdgeWorkerType)
	}
	if m.property_category != nil {
		edges = append(edges, propertytype.EdgePropertyCategory)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PropertyTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case propertytype.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case propertytype.EdgeLocationType:
		if id := m.location_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeEquipmentPortType:
		if id := m.equipment_port_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeLinkEquipmentPortType:
		if id := m.link_equipment_port_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeEquipmentType:
		if id := m.equipment_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeServiceType:
		if id := m.service_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeWorkOrderType:
		if id := m.work_order_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeWorkOrderTemplate:
		if id := m.work_order_template; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeProjectType:
		if id := m.project_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeProjectTemplate:
		if id := m.project_template; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgeWorkerType:
		if id := m.worker_type; id != nil {
			return []ent.Value{*id}
		}
	case propertytype.EdgePropertyCategory:
		if id := m.property_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PropertyTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedproperties != nil {
		edges = append(edges, propertytype.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PropertyTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case propertytype.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PropertyTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedproperties {
		edges = append(edges, propertytype.EdgeProperties)
	}
	if m.clearedlocation_type {
		edges = append(edges, propertytype.EdgeLocationType)
	}
	if m.clearedequipment_port_type {
		edges = append(edges, propertytype.EdgeEquipmentPortType)
	}
	if m.clearedlink_equipment_port_type {
		edges = append(edges, propertytype.EdgeLinkEquipmentPortType)
	}
	if m.clearedequipment_type {
		edges = append(edges, propertytype.EdgeEquipmentType)
	}
	if m.clearedservice_type {
		edges = append(edges, propertytype.EdgeServiceType)
	}
	if m.clearedwork_order_type {
		edges = append(edges, propertytype.EdgeWorkOrderType)
	}
	if m.clearedwork_order_template {
		edges = append(edges, propertytype.EdgeWorkOrderTemplate)
	}
	if m.clearedproject_type {
		edges = append(edges, propertytype.EdgeProjectType)
	}
	if m.clearedproject_template {
		edges = append(edges, propertytype.EdgeProjectTemplate)
	}
	if m.clearedworker_type {
		edges = append(edges, propertytype.EdgeWorkerType)
	}
	if m.clearedproperty_category {
		edges = append(edges, propertytype.EdgePropertyCategory)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PropertyTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case propertytype.EdgeProperties:
		return m.clearedproperties
	case propertytype.EdgeLocationType:
		return m.clearedlocation_type
	case propertytype.EdgeEquipmentPortType:
		return m.clearedequipment_port_type
	case propertytype.EdgeLinkEquipmentPortType:
		return m.clearedlink_equipment_port_type
	case propertytype.EdgeEquipmentType:
		return m.clearedequipment_type
	case propertytype.EdgeServiceType:
		return m.clearedservice_type
	case propertytype.EdgeWorkOrderType:
		return m.clearedwork_order_type
	case propertytype.EdgeWorkOrderTemplate:
		return m.clearedwork_order_template
	case propertytype.EdgeProjectType:
		return m.clearedproject_type
	case propertytype.EdgeProjectTemplate:
		return m.clearedproject_template
	case propertytype.EdgeWorkerType:
		return m.clearedworker_type
	case propertytype.EdgePropertyCategory:
		return m.clearedproperty_category
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PropertyTypeMutation) ClearEdge(name string) error {
	switch name {
	case propertytype.EdgeLocationType:
		m.ClearLocationType()
		return nil
	case propertytype.EdgeEquipmentPortType:
		m.ClearEquipmentPortType()
		return nil
	case propertytype.EdgeLinkEquipmentPortType:
		m.ClearLinkEquipmentPortType()
		return nil
	case propertytype.EdgeEquipmentType:
		m.ClearEquipmentType()
		return nil
	case propertytype.EdgeServiceType:
		m.ClearServiceType()
		return nil
	case propertytype.EdgeWorkOrderType:
		m.ClearWorkOrderType()
		return nil
	case propertytype.EdgeWorkOrderTemplate:
		m.ClearWorkOrderTemplate()
		return nil
	case propertytype.EdgeProjectType:
		m.ClearProjectType()
		return nil
	case propertytype.EdgeProjectTemplate:
		m.ClearProjectTemplate()
		return nil
	case propertytype.EdgeWorkerType:
		m.ClearWorkerType()
		return nil
	case propertytype.EdgePropertyCategory:
		m.ClearPropertyCategory()
		return nil
	}
	return fmt.Errorf("unknown PropertyType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PropertyTypeMutation) ResetEdge(name string) error {
	switch name {
	case propertytype.EdgeProperties:
		m.ResetProperties()
		return nil
	case propertytype.EdgeLocationType:
		m.ResetLocationType()
		return nil
	case propertytype.EdgeEquipmentPortType:
		m.ResetEquipmentPortType()
		return nil
	case propertytype.EdgeLinkEquipmentPortType:
		m.ResetLinkEquipmentPortType()
		return nil
	case propertytype.EdgeEquipmentType:
		m.ResetEquipmentType()
		return nil
	case propertytype.EdgeServiceType:
		m.ResetServiceType()
		return nil
	case propertytype.EdgeWorkOrderType:
		m.ResetWorkOrderType()
		return nil
	case propertytype.EdgeWorkOrderTemplate:
		m.ResetWorkOrderTemplate()
		return nil
	case propertytype.EdgeProjectType:
		m.ResetProjectType()
		return nil
	case propertytype.EdgeProjectTemplate:
		m.ResetProjectTemplate()
		return nil
	case propertytype.EdgeWorkerType:
		m.ResetWorkerType()
		return nil
	case propertytype.EdgePropertyCategory:
		m.ResetPropertyCategory()
		return nil
	}
	return fmt.Errorf("unknown PropertyType edge %s", name)
}

// RecommendationsMutation represents an operation that mutate the RecommendationsSlice
// nodes in the graph.
type RecommendationsMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	externalId                    *string
	resource                      *string
	alarmType                     *string
	shortDescription              *string
	longDescription               *string
	command                       *string
	priority                      *int
	addpriority                   *int
	status                        *bool
	used                          *int
	addused                       *int
	runbook                       *string
	clearedFields                 map[string]struct{}
	recomendation_sources         *int
	clearedrecomendation_sources  bool
	recomendation_category        *int
	clearedrecomendation_category bool
	_UserCreate                   *int
	cleared_UserCreate            bool
	_UserApprobed                 *int
	cleared_UserApprobed          bool
	vendors_recomendations        *int
	clearedvendors_recomendations bool
	done                          bool
	oldValue                      func(context.Context) (*Recommendations, error)
	predicates                    []predicate.Recommendations
}

var _ ent.Mutation = (*RecommendationsMutation)(nil)

// recommendationsOption allows to manage the mutation configuration using functional options.
type recommendationsOption func(*RecommendationsMutation)

// newRecommendationsMutation creates new mutation for Recommendations.
func newRecommendationsMutation(c config, op Op, opts ...recommendationsOption) *RecommendationsMutation {
	m := &RecommendationsMutation{
		config:        c,
		op:            op,
		typ:           TypeRecommendations,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecommendationsID sets the id field of the mutation.
func withRecommendationsID(id int) recommendationsOption {
	return func(m *RecommendationsMutation) {
		var (
			err   error
			once  sync.Once
			value *Recommendations
		)
		m.oldValue = func(ctx context.Context) (*Recommendations, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recommendations.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecommendations sets the old Recommendations of the mutation.
func withRecommendations(node *Recommendations) recommendationsOption {
	return func(m *RecommendationsMutation) {
		m.oldValue = func(context.Context) (*Recommendations, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecommendationsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecommendationsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RecommendationsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *RecommendationsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *RecommendationsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *RecommendationsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *RecommendationsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *RecommendationsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *RecommendationsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetExternalId sets the externalId field.
func (m *RecommendationsMutation) SetExternalId(s string) {
	m.externalId = &s
}

// ExternalId returns the externalId value in the mutation.
func (m *RecommendationsMutation) ExternalId() (r string, exists bool) {
	v := m.externalId
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalId returns the old externalId value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldExternalId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalId: %w", err)
	}
	return oldValue.ExternalId, nil
}

// ResetExternalId reset all changes of the "externalId" field.
func (m *RecommendationsMutation) ResetExternalId() {
	m.externalId = nil
}

// SetResource sets the resource field.
func (m *RecommendationsMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the resource value in the mutation.
func (m *RecommendationsMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old resource value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResource is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource reset all changes of the "resource" field.
func (m *RecommendationsMutation) ResetResource() {
	m.resource = nil
}

// SetAlarmType sets the alarmType field.
func (m *RecommendationsMutation) SetAlarmType(s string) {
	m.alarmType = &s
}

// AlarmType returns the alarmType value in the mutation.
func (m *RecommendationsMutation) AlarmType() (r string, exists bool) {
	v := m.alarmType
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmType returns the old alarmType value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldAlarmType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAlarmType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAlarmType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmType: %w", err)
	}
	return oldValue.AlarmType, nil
}

// ResetAlarmType reset all changes of the "alarmType" field.
func (m *RecommendationsMutation) ResetAlarmType() {
	m.alarmType = nil
}

// SetShortDescription sets the shortDescription field.
func (m *RecommendationsMutation) SetShortDescription(s string) {
	m.shortDescription = &s
}

// ShortDescription returns the shortDescription value in the mutation.
func (m *RecommendationsMutation) ShortDescription() (r string, exists bool) {
	v := m.shortDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old shortDescription value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShortDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ResetShortDescription reset all changes of the "shortDescription" field.
func (m *RecommendationsMutation) ResetShortDescription() {
	m.shortDescription = nil
}

// SetLongDescription sets the longDescription field.
func (m *RecommendationsMutation) SetLongDescription(s string) {
	m.longDescription = &s
}

// LongDescription returns the longDescription value in the mutation.
func (m *RecommendationsMutation) LongDescription() (r string, exists bool) {
	v := m.longDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldLongDescription returns the old longDescription value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldLongDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongDescription: %w", err)
	}
	return oldValue.LongDescription, nil
}

// ResetLongDescription reset all changes of the "longDescription" field.
func (m *RecommendationsMutation) ResetLongDescription() {
	m.longDescription = nil
}

// SetCommand sets the command field.
func (m *RecommendationsMutation) SetCommand(s string) {
	m.command = &s
}

// Command returns the command value in the mutation.
func (m *RecommendationsMutation) Command() (r string, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old command value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldCommand(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCommand is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ClearCommand clears the value of command.
func (m *RecommendationsMutation) ClearCommand() {
	m.command = nil
	m.clearedFields[recommendations.FieldCommand] = struct{}{}
}

// CommandCleared returns if the field command was cleared in this mutation.
func (m *RecommendationsMutation) CommandCleared() bool {
	_, ok := m.clearedFields[recommendations.FieldCommand]
	return ok
}

// ResetCommand reset all changes of the "command" field.
func (m *RecommendationsMutation) ResetCommand() {
	m.command = nil
	delete(m.clearedFields, recommendations.FieldCommand)
}

// SetPriority sets the priority field.
func (m *RecommendationsMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the priority value in the mutation.
func (m *RecommendationsMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old priority value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriority is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to priority.
func (m *RecommendationsMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the priority field in this mutation.
func (m *RecommendationsMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority reset all changes of the "priority" field.
func (m *RecommendationsMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetStatus sets the status field.
func (m *RecommendationsMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the status value in the mutation.
func (m *RecommendationsMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *RecommendationsMutation) ResetStatus() {
	m.status = nil
}

// SetUsed sets the used field.
func (m *RecommendationsMutation) SetUsed(i int) {
	m.used = &i
	m.addused = nil
}

// Used returns the used value in the mutation.
func (m *RecommendationsMutation) Used() (r int, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old used value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldUsed(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// AddUsed adds i to used.
func (m *RecommendationsMutation) AddUsed(i int) {
	if m.addused != nil {
		*m.addused += i
	} else {
		m.addused = &i
	}
}

// AddedUsed returns the value that was added to the used field in this mutation.
func (m *RecommendationsMutation) AddedUsed() (r int, exists bool) {
	v := m.addused
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsed clears the value of used.
func (m *RecommendationsMutation) ClearUsed() {
	m.used = nil
	m.addused = nil
	m.clearedFields[recommendations.FieldUsed] = struct{}{}
}

// UsedCleared returns if the field used was cleared in this mutation.
func (m *RecommendationsMutation) UsedCleared() bool {
	_, ok := m.clearedFields[recommendations.FieldUsed]
	return ok
}

// ResetUsed reset all changes of the "used" field.
func (m *RecommendationsMutation) ResetUsed() {
	m.used = nil
	m.addused = nil
	delete(m.clearedFields, recommendations.FieldUsed)
}

// SetRunbook sets the runbook field.
func (m *RecommendationsMutation) SetRunbook(s string) {
	m.runbook = &s
}

// Runbook returns the runbook value in the mutation.
func (m *RecommendationsMutation) Runbook() (r string, exists bool) {
	v := m.runbook
	if v == nil {
		return
	}
	return *v, true
}

// OldRunbook returns the old runbook value of the Recommendations.
// If the Recommendations object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsMutation) OldRunbook(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRunbook is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRunbook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunbook: %w", err)
	}
	return oldValue.Runbook, nil
}

// ClearRunbook clears the value of runbook.
func (m *RecommendationsMutation) ClearRunbook() {
	m.runbook = nil
	m.clearedFields[recommendations.FieldRunbook] = struct{}{}
}

// RunbookCleared returns if the field runbook was cleared in this mutation.
func (m *RecommendationsMutation) RunbookCleared() bool {
	_, ok := m.clearedFields[recommendations.FieldRunbook]
	return ok
}

// ResetRunbook reset all changes of the "runbook" field.
func (m *RecommendationsMutation) ResetRunbook() {
	m.runbook = nil
	delete(m.clearedFields, recommendations.FieldRunbook)
}

// SetRecomendationSourcesID sets the recomendation_sources edge to RecommendationsSources by id.
func (m *RecommendationsMutation) SetRecomendationSourcesID(id int) {
	m.recomendation_sources = &id
}

// ClearRecomendationSources clears the recomendation_sources edge to RecommendationsSources.
func (m *RecommendationsMutation) ClearRecomendationSources() {
	m.clearedrecomendation_sources = true
}

// RecomendationSourcesCleared returns if the edge recomendation_sources was cleared.
func (m *RecommendationsMutation) RecomendationSourcesCleared() bool {
	return m.clearedrecomendation_sources
}

// RecomendationSourcesID returns the recomendation_sources id in the mutation.
func (m *RecommendationsMutation) RecomendationSourcesID() (id int, exists bool) {
	if m.recomendation_sources != nil {
		return *m.recomendation_sources, true
	}
	return
}

// RecomendationSourcesIDs returns the recomendation_sources ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RecomendationSourcesID instead. It exists only for internal usage by the builders.
func (m *RecommendationsMutation) RecomendationSourcesIDs() (ids []int) {
	if id := m.recomendation_sources; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecomendationSources reset all changes of the "recomendation_sources" edge.
func (m *RecommendationsMutation) ResetRecomendationSources() {
	m.recomendation_sources = nil
	m.clearedrecomendation_sources = false
}

// SetRecomendationCategoryID sets the recomendation_category edge to RecommendationsCategory by id.
func (m *RecommendationsMutation) SetRecomendationCategoryID(id int) {
	m.recomendation_category = &id
}

// ClearRecomendationCategory clears the recomendation_category edge to RecommendationsCategory.
func (m *RecommendationsMutation) ClearRecomendationCategory() {
	m.clearedrecomendation_category = true
}

// RecomendationCategoryCleared returns if the edge recomendation_category was cleared.
func (m *RecommendationsMutation) RecomendationCategoryCleared() bool {
	return m.clearedrecomendation_category
}

// RecomendationCategoryID returns the recomendation_category id in the mutation.
func (m *RecommendationsMutation) RecomendationCategoryID() (id int, exists bool) {
	if m.recomendation_category != nil {
		return *m.recomendation_category, true
	}
	return
}

// RecomendationCategoryIDs returns the recomendation_category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RecomendationCategoryID instead. It exists only for internal usage by the builders.
func (m *RecommendationsMutation) RecomendationCategoryIDs() (ids []int) {
	if id := m.recomendation_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecomendationCategory reset all changes of the "recomendation_category" edge.
func (m *RecommendationsMutation) ResetRecomendationCategory() {
	m.recomendation_category = nil
	m.clearedrecomendation_category = false
}

// SetUserCreateID sets the UserCreate edge to User by id.
func (m *RecommendationsMutation) SetUserCreateID(id int) {
	m._UserCreate = &id
}

// ClearUserCreate clears the UserCreate edge to User.
func (m *RecommendationsMutation) ClearUserCreate() {
	m.cleared_UserCreate = true
}

// UserCreateCleared returns if the edge UserCreate was cleared.
func (m *RecommendationsMutation) UserCreateCleared() bool {
	return m.cleared_UserCreate
}

// UserCreateID returns the UserCreate id in the mutation.
func (m *RecommendationsMutation) UserCreateID() (id int, exists bool) {
	if m._UserCreate != nil {
		return *m._UserCreate, true
	}
	return
}

// UserCreateIDs returns the UserCreate ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserCreateID instead. It exists only for internal usage by the builders.
func (m *RecommendationsMutation) UserCreateIDs() (ids []int) {
	if id := m._UserCreate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserCreate reset all changes of the "UserCreate" edge.
func (m *RecommendationsMutation) ResetUserCreate() {
	m._UserCreate = nil
	m.cleared_UserCreate = false
}

// SetUserApprobedID sets the UserApprobed edge to User by id.
func (m *RecommendationsMutation) SetUserApprobedID(id int) {
	m._UserApprobed = &id
}

// ClearUserApprobed clears the UserApprobed edge to User.
func (m *RecommendationsMutation) ClearUserApprobed() {
	m.cleared_UserApprobed = true
}

// UserApprobedCleared returns if the edge UserApprobed was cleared.
func (m *RecommendationsMutation) UserApprobedCleared() bool {
	return m.cleared_UserApprobed
}

// UserApprobedID returns the UserApprobed id in the mutation.
func (m *RecommendationsMutation) UserApprobedID() (id int, exists bool) {
	if m._UserApprobed != nil {
		return *m._UserApprobed, true
	}
	return
}

// UserApprobedIDs returns the UserApprobed ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserApprobedID instead. It exists only for internal usage by the builders.
func (m *RecommendationsMutation) UserApprobedIDs() (ids []int) {
	if id := m._UserApprobed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserApprobed reset all changes of the "UserApprobed" edge.
func (m *RecommendationsMutation) ResetUserApprobed() {
	m._UserApprobed = nil
	m.cleared_UserApprobed = false
}

// SetVendorsRecomendationsID sets the vendors_recomendations edge to Vendor by id.
func (m *RecommendationsMutation) SetVendorsRecomendationsID(id int) {
	m.vendors_recomendations = &id
}

// ClearVendorsRecomendations clears the vendors_recomendations edge to Vendor.
func (m *RecommendationsMutation) ClearVendorsRecomendations() {
	m.clearedvendors_recomendations = true
}

// VendorsRecomendationsCleared returns if the edge vendors_recomendations was cleared.
func (m *RecommendationsMutation) VendorsRecomendationsCleared() bool {
	return m.clearedvendors_recomendations
}

// VendorsRecomendationsID returns the vendors_recomendations id in the mutation.
func (m *RecommendationsMutation) VendorsRecomendationsID() (id int, exists bool) {
	if m.vendors_recomendations != nil {
		return *m.vendors_recomendations, true
	}
	return
}

// VendorsRecomendationsIDs returns the vendors_recomendations ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// VendorsRecomendationsID instead. It exists only for internal usage by the builders.
func (m *RecommendationsMutation) VendorsRecomendationsIDs() (ids []int) {
	if id := m.vendors_recomendations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVendorsRecomendations reset all changes of the "vendors_recomendations" edge.
func (m *RecommendationsMutation) ResetVendorsRecomendations() {
	m.vendors_recomendations = nil
	m.clearedvendors_recomendations = false
}

// Op returns the operation name.
func (m *RecommendationsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Recommendations).
func (m *RecommendationsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RecommendationsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, recommendations.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, recommendations.FieldUpdateTime)
	}
	if m.externalId != nil {
		fields = append(fields, recommendations.FieldExternalId)
	}
	if m.resource != nil {
		fields = append(fields, recommendations.FieldResource)
	}
	if m.alarmType != nil {
		fields = append(fields, recommendations.FieldAlarmType)
	}
	if m.shortDescription != nil {
		fields = append(fields, recommendations.FieldShortDescription)
	}
	if m.longDescription != nil {
		fields = append(fields, recommendations.FieldLongDescription)
	}
	if m.command != nil {
		fields = append(fields, recommendations.FieldCommand)
	}
	if m.priority != nil {
		fields = append(fields, recommendations.FieldPriority)
	}
	if m.status != nil {
		fields = append(fields, recommendations.FieldStatus)
	}
	if m.used != nil {
		fields = append(fields, recommendations.FieldUsed)
	}
	if m.runbook != nil {
		fields = append(fields, recommendations.FieldRunbook)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RecommendationsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recommendations.FieldCreateTime:
		return m.CreateTime()
	case recommendations.FieldUpdateTime:
		return m.UpdateTime()
	case recommendations.FieldExternalId:
		return m.ExternalId()
	case recommendations.FieldResource:
		return m.Resource()
	case recommendations.FieldAlarmType:
		return m.AlarmType()
	case recommendations.FieldShortDescription:
		return m.ShortDescription()
	case recommendations.FieldLongDescription:
		return m.LongDescription()
	case recommendations.FieldCommand:
		return m.Command()
	case recommendations.FieldPriority:
		return m.Priority()
	case recommendations.FieldStatus:
		return m.Status()
	case recommendations.FieldUsed:
		return m.Used()
	case recommendations.FieldRunbook:
		return m.Runbook()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RecommendationsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recommendations.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case recommendations.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case recommendations.FieldExternalId:
		return m.OldExternalId(ctx)
	case recommendations.FieldResource:
		return m.OldResource(ctx)
	case recommendations.FieldAlarmType:
		return m.OldAlarmType(ctx)
	case recommendations.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case recommendations.FieldLongDescription:
		return m.OldLongDescription(ctx)
	case recommendations.FieldCommand:
		return m.OldCommand(ctx)
	case recommendations.FieldPriority:
		return m.OldPriority(ctx)
	case recommendations.FieldStatus:
		return m.OldStatus(ctx)
	case recommendations.FieldUsed:
		return m.OldUsed(ctx)
	case recommendations.FieldRunbook:
		return m.OldRunbook(ctx)
	}
	return nil, fmt.Errorf("unknown Recommendations field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RecommendationsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recommendations.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case recommendations.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case recommendations.FieldExternalId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalId(v)
		return nil
	case recommendations.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case recommendations.FieldAlarmType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmType(v)
		return nil
	case recommendations.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case recommendations.FieldLongDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongDescription(v)
		return nil
	case recommendations.FieldCommand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case recommendations.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case recommendations.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case recommendations.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case recommendations.FieldRunbook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunbook(v)
		return nil
	}
	return fmt.Errorf("unknown Recommendations field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RecommendationsMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, recommendations.FieldPriority)
	}
	if m.addused != nil {
		fields = append(fields, recommendations.FieldUsed)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RecommendationsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recommendations.FieldPriority:
		return m.AddedPriority()
	case recommendations.FieldUsed:
		return m.AddedUsed()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RecommendationsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recommendations.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case recommendations.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsed(v)
		return nil
	}
	return fmt.Errorf("unknown Recommendations numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RecommendationsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recommendations.FieldCommand) {
		fields = append(fields, recommendations.FieldCommand)
	}
	if m.FieldCleared(recommendations.FieldUsed) {
		fields = append(fields, recommendations.FieldUsed)
	}
	if m.FieldCleared(recommendations.FieldRunbook) {
		fields = append(fields, recommendations.FieldRunbook)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RecommendationsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecommendationsMutation) ClearField(name string) error {
	switch name {
	case recommendations.FieldCommand:
		m.ClearCommand()
		return nil
	case recommendations.FieldUsed:
		m.ClearUsed()
		return nil
	case recommendations.FieldRunbook:
		m.ClearRunbook()
		return nil
	}
	return fmt.Errorf("unknown Recommendations nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RecommendationsMutation) ResetField(name string) error {
	switch name {
	case recommendations.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case recommendations.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case recommendations.FieldExternalId:
		m.ResetExternalId()
		return nil
	case recommendations.FieldResource:
		m.ResetResource()
		return nil
	case recommendations.FieldAlarmType:
		m.ResetAlarmType()
		return nil
	case recommendations.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case recommendations.FieldLongDescription:
		m.ResetLongDescription()
		return nil
	case recommendations.FieldCommand:
		m.ResetCommand()
		return nil
	case recommendations.FieldPriority:
		m.ResetPriority()
		return nil
	case recommendations.FieldStatus:
		m.ResetStatus()
		return nil
	case recommendations.FieldUsed:
		m.ResetUsed()
		return nil
	case recommendations.FieldRunbook:
		m.ResetRunbook()
		return nil
	}
	return fmt.Errorf("unknown Recommendations field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RecommendationsMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.recomendation_sources != nil {
		edges = append(edges, recommendations.EdgeRecomendationSources)
	}
	if m.recomendation_category != nil {
		edges = append(edges, recommendations.EdgeRecomendationCategory)
	}
	if m._UserCreate != nil {
		edges = append(edges, recommendations.EdgeUserCreate)
	}
	if m._UserApprobed != nil {
		edges = append(edges, recommendations.EdgeUserApprobed)
	}
	if m.vendors_recomendations != nil {
		edges = append(edges, recommendations.EdgeVendorsRecomendations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RecommendationsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recommendations.EdgeRecomendationSources:
		if id := m.recomendation_sources; id != nil {
			return []ent.Value{*id}
		}
	case recommendations.EdgeRecomendationCategory:
		if id := m.recomendation_category; id != nil {
			return []ent.Value{*id}
		}
	case recommendations.EdgeUserCreate:
		if id := m._UserCreate; id != nil {
			return []ent.Value{*id}
		}
	case recommendations.EdgeUserApprobed:
		if id := m._UserApprobed; id != nil {
			return []ent.Value{*id}
		}
	case recommendations.EdgeVendorsRecomendations:
		if id := m.vendors_recomendations; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RecommendationsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RecommendationsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RecommendationsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrecomendation_sources {
		edges = append(edges, recommendations.EdgeRecomendationSources)
	}
	if m.clearedrecomendation_category {
		edges = append(edges, recommendations.EdgeRecomendationCategory)
	}
	if m.cleared_UserCreate {
		edges = append(edges, recommendations.EdgeUserCreate)
	}
	if m.cleared_UserApprobed {
		edges = append(edges, recommendations.EdgeUserApprobed)
	}
	if m.clearedvendors_recomendations {
		edges = append(edges, recommendations.EdgeVendorsRecomendations)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RecommendationsMutation) EdgeCleared(name string) bool {
	switch name {
	case recommendations.EdgeRecomendationSources:
		return m.clearedrecomendation_sources
	case recommendations.EdgeRecomendationCategory:
		return m.clearedrecomendation_category
	case recommendations.EdgeUserCreate:
		return m.cleared_UserCreate
	case recommendations.EdgeUserApprobed:
		return m.cleared_UserApprobed
	case recommendations.EdgeVendorsRecomendations:
		return m.clearedvendors_recomendations
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RecommendationsMutation) ClearEdge(name string) error {
	switch name {
	case recommendations.EdgeRecomendationSources:
		m.ClearRecomendationSources()
		return nil
	case recommendations.EdgeRecomendationCategory:
		m.ClearRecomendationCategory()
		return nil
	case recommendations.EdgeUserCreate:
		m.ClearUserCreate()
		return nil
	case recommendations.EdgeUserApprobed:
		m.ClearUserApprobed()
		return nil
	case recommendations.EdgeVendorsRecomendations:
		m.ClearVendorsRecomendations()
		return nil
	}
	return fmt.Errorf("unknown Recommendations unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RecommendationsMutation) ResetEdge(name string) error {
	switch name {
	case recommendations.EdgeRecomendationSources:
		m.ResetRecomendationSources()
		return nil
	case recommendations.EdgeRecomendationCategory:
		m.ResetRecomendationCategory()
		return nil
	case recommendations.EdgeUserCreate:
		m.ResetUserCreate()
		return nil
	case recommendations.EdgeUserApprobed:
		m.ResetUserApprobed()
		return nil
	case recommendations.EdgeVendorsRecomendations:
		m.ResetVendorsRecomendations()
		return nil
	}
	return fmt.Errorf("unknown Recommendations edge %s", name)
}

// RecommendationsCategoryMutation represents an operation that mutate the RecommendationsCategories
// nodes in the graph.
type RecommendationsCategoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	name                   *string
	clearedFields          map[string]struct{}
	recommendations        map[int]struct{}
	removedrecommendations map[int]struct{}
	clearedrecommendations bool
	done                   bool
	oldValue               func(context.Context) (*RecommendationsCategory, error)
	predicates             []predicate.RecommendationsCategory
}

var _ ent.Mutation = (*RecommendationsCategoryMutation)(nil)

// recommendationscategoryOption allows to manage the mutation configuration using functional options.
type recommendationscategoryOption func(*RecommendationsCategoryMutation)

// newRecommendationsCategoryMutation creates new mutation for RecommendationsCategory.
func newRecommendationsCategoryMutation(c config, op Op, opts ...recommendationscategoryOption) *RecommendationsCategoryMutation {
	m := &RecommendationsCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRecommendationsCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecommendationsCategoryID sets the id field of the mutation.
func withRecommendationsCategoryID(id int) recommendationscategoryOption {
	return func(m *RecommendationsCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RecommendationsCategory
		)
		m.oldValue = func(ctx context.Context) (*RecommendationsCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecommendationsCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecommendationsCategory sets the old RecommendationsCategory of the mutation.
func withRecommendationsCategory(node *RecommendationsCategory) recommendationscategoryOption {
	return func(m *RecommendationsCategoryMutation) {
		m.oldValue = func(context.Context) (*RecommendationsCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecommendationsCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecommendationsCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RecommendationsCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *RecommendationsCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *RecommendationsCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the RecommendationsCategory.
// If the RecommendationsCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *RecommendationsCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *RecommendationsCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *RecommendationsCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the RecommendationsCategory.
// If the RecommendationsCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *RecommendationsCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *RecommendationsCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RecommendationsCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the RecommendationsCategory.
// If the RecommendationsCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RecommendationsCategoryMutation) ResetName() {
	m.name = nil
}

// AddRecommendationIDs adds the recommendations edge to Recommendations by ids.
func (m *RecommendationsCategoryMutation) AddRecommendationIDs(ids ...int) {
	if m.recommendations == nil {
		m.recommendations = make(map[int]struct{})
	}
	for i := range ids {
		m.recommendations[ids[i]] = struct{}{}
	}
}

// ClearRecommendations clears the recommendations edge to Recommendations.
func (m *RecommendationsCategoryMutation) ClearRecommendations() {
	m.clearedrecommendations = true
}

// RecommendationsCleared returns if the edge recommendations was cleared.
func (m *RecommendationsCategoryMutation) RecommendationsCleared() bool {
	return m.clearedrecommendations
}

// RemoveRecommendationIDs removes the recommendations edge to Recommendations by ids.
func (m *RecommendationsCategoryMutation) RemoveRecommendationIDs(ids ...int) {
	if m.removedrecommendations == nil {
		m.removedrecommendations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrecommendations[ids[i]] = struct{}{}
	}
}

// RemovedRecommendations returns the removed ids of recommendations.
func (m *RecommendationsCategoryMutation) RemovedRecommendationsIDs() (ids []int) {
	for id := range m.removedrecommendations {
		ids = append(ids, id)
	}
	return
}

// RecommendationsIDs returns the recommendations ids in the mutation.
func (m *RecommendationsCategoryMutation) RecommendationsIDs() (ids []int) {
	for id := range m.recommendations {
		ids = append(ids, id)
	}
	return
}

// ResetRecommendations reset all changes of the "recommendations" edge.
func (m *RecommendationsCategoryMutation) ResetRecommendations() {
	m.recommendations = nil
	m.clearedrecommendations = false
	m.removedrecommendations = nil
}

// Op returns the operation name.
func (m *RecommendationsCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RecommendationsCategory).
func (m *RecommendationsCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RecommendationsCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, recommendationscategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, recommendationscategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, recommendationscategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RecommendationsCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recommendationscategory.FieldCreateTime:
		return m.CreateTime()
	case recommendationscategory.FieldUpdateTime:
		return m.UpdateTime()
	case recommendationscategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RecommendationsCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recommendationscategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case recommendationscategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case recommendationscategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RecommendationsCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RecommendationsCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recommendationscategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case recommendationscategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case recommendationscategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RecommendationsCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RecommendationsCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RecommendationsCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RecommendationsCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecommendationsCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RecommendationsCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RecommendationsCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecommendationsCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecommendationsCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RecommendationsCategoryMutation) ResetField(name string) error {
	switch name {
	case recommendationscategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case recommendationscategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case recommendationscategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RecommendationsCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recommendations != nil {
		edges = append(edges, recommendationscategory.EdgeRecommendations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RecommendationsCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recommendationscategory.EdgeRecommendations:
		ids := make([]ent.Value, 0, len(m.recommendations))
		for id := range m.recommendations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RecommendationsCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecommendations != nil {
		edges = append(edges, recommendationscategory.EdgeRecommendations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RecommendationsCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case recommendationscategory.EdgeRecommendations:
		ids := make([]ent.Value, 0, len(m.removedrecommendations))
		for id := range m.removedrecommendations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RecommendationsCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecommendations {
		edges = append(edges, recommendationscategory.EdgeRecommendations)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RecommendationsCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case recommendationscategory.EdgeRecommendations:
		return m.clearedrecommendations
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RecommendationsCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RecommendationsCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RecommendationsCategoryMutation) ResetEdge(name string) error {
	switch name {
	case recommendationscategory.EdgeRecommendations:
		m.ResetRecommendations()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsCategory edge %s", name)
}

// RecommendationsSourcesMutation represents an operation that mutate the RecommendationsSourcesSlice
// nodes in the graph.
type RecommendationsSourcesMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	name                   *string
	clearedFields          map[string]struct{}
	recommendations        map[int]struct{}
	removedrecommendations map[int]struct{}
	clearedrecommendations bool
	done                   bool
	oldValue               func(context.Context) (*RecommendationsSources, error)
	predicates             []predicate.RecommendationsSources
}

var _ ent.Mutation = (*RecommendationsSourcesMutation)(nil)

// recommendationssourcesOption allows to manage the mutation configuration using functional options.
type recommendationssourcesOption func(*RecommendationsSourcesMutation)

// newRecommendationsSourcesMutation creates new mutation for RecommendationsSources.
func newRecommendationsSourcesMutation(c config, op Op, opts ...recommendationssourcesOption) *RecommendationsSourcesMutation {
	m := &RecommendationsSourcesMutation{
		config:        c,
		op:            op,
		typ:           TypeRecommendationsSources,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecommendationsSourcesID sets the id field of the mutation.
func withRecommendationsSourcesID(id int) recommendationssourcesOption {
	return func(m *RecommendationsSourcesMutation) {
		var (
			err   error
			once  sync.Once
			value *RecommendationsSources
		)
		m.oldValue = func(ctx context.Context) (*RecommendationsSources, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecommendationsSources.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecommendationsSources sets the old RecommendationsSources of the mutation.
func withRecommendationsSources(node *RecommendationsSources) recommendationssourcesOption {
	return func(m *RecommendationsSourcesMutation) {
		m.oldValue = func(context.Context) (*RecommendationsSources, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecommendationsSourcesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecommendationsSourcesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RecommendationsSourcesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *RecommendationsSourcesMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *RecommendationsSourcesMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the RecommendationsSources.
// If the RecommendationsSources object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsSourcesMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *RecommendationsSourcesMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *RecommendationsSourcesMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *RecommendationsSourcesMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the RecommendationsSources.
// If the RecommendationsSources object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsSourcesMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *RecommendationsSourcesMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *RecommendationsSourcesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RecommendationsSourcesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the RecommendationsSources.
// If the RecommendationsSources object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RecommendationsSourcesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RecommendationsSourcesMutation) ResetName() {
	m.name = nil
}

// AddRecommendationIDs adds the recommendations edge to Recommendations by ids.
func (m *RecommendationsSourcesMutation) AddRecommendationIDs(ids ...int) {
	if m.recommendations == nil {
		m.recommendations = make(map[int]struct{})
	}
	for i := range ids {
		m.recommendations[ids[i]] = struct{}{}
	}
}

// ClearRecommendations clears the recommendations edge to Recommendations.
func (m *RecommendationsSourcesMutation) ClearRecommendations() {
	m.clearedrecommendations = true
}

// RecommendationsCleared returns if the edge recommendations was cleared.
func (m *RecommendationsSourcesMutation) RecommendationsCleared() bool {
	return m.clearedrecommendations
}

// RemoveRecommendationIDs removes the recommendations edge to Recommendations by ids.
func (m *RecommendationsSourcesMutation) RemoveRecommendationIDs(ids ...int) {
	if m.removedrecommendations == nil {
		m.removedrecommendations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrecommendations[ids[i]] = struct{}{}
	}
}

// RemovedRecommendations returns the removed ids of recommendations.
func (m *RecommendationsSourcesMutation) RemovedRecommendationsIDs() (ids []int) {
	for id := range m.removedrecommendations {
		ids = append(ids, id)
	}
	return
}

// RecommendationsIDs returns the recommendations ids in the mutation.
func (m *RecommendationsSourcesMutation) RecommendationsIDs() (ids []int) {
	for id := range m.recommendations {
		ids = append(ids, id)
	}
	return
}

// ResetRecommendations reset all changes of the "recommendations" edge.
func (m *RecommendationsSourcesMutation) ResetRecommendations() {
	m.recommendations = nil
	m.clearedrecommendations = false
	m.removedrecommendations = nil
}

// Op returns the operation name.
func (m *RecommendationsSourcesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RecommendationsSources).
func (m *RecommendationsSourcesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RecommendationsSourcesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, recommendationssources.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, recommendationssources.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, recommendationssources.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RecommendationsSourcesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recommendationssources.FieldCreateTime:
		return m.CreateTime()
	case recommendationssources.FieldUpdateTime:
		return m.UpdateTime()
	case recommendationssources.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RecommendationsSourcesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recommendationssources.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case recommendationssources.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case recommendationssources.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RecommendationsSources field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RecommendationsSourcesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recommendationssources.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case recommendationssources.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case recommendationssources.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RecommendationsSources field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RecommendationsSourcesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RecommendationsSourcesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RecommendationsSourcesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecommendationsSources numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RecommendationsSourcesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RecommendationsSourcesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecommendationsSourcesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecommendationsSources nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RecommendationsSourcesMutation) ResetField(name string) error {
	switch name {
	case recommendationssources.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case recommendationssources.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case recommendationssources.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsSources field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RecommendationsSourcesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recommendations != nil {
		edges = append(edges, recommendationssources.EdgeRecommendations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RecommendationsSourcesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recommendationssources.EdgeRecommendations:
		ids := make([]ent.Value, 0, len(m.recommendations))
		for id := range m.recommendations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RecommendationsSourcesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecommendations != nil {
		edges = append(edges, recommendationssources.EdgeRecommendations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RecommendationsSourcesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case recommendationssources.EdgeRecommendations:
		ids := make([]ent.Value, 0, len(m.removedrecommendations))
		for id := range m.removedrecommendations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RecommendationsSourcesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecommendations {
		edges = append(edges, recommendationssources.EdgeRecommendations)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RecommendationsSourcesMutation) EdgeCleared(name string) bool {
	switch name {
	case recommendationssources.EdgeRecommendations:
		return m.clearedrecommendations
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RecommendationsSourcesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RecommendationsSources unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RecommendationsSourcesMutation) ResetEdge(name string) error {
	switch name {
	case recommendationssources.EdgeRecommendations:
		m.ResetRecommendations()
		return nil
	}
	return fmt.Errorf("unknown RecommendationsSources edge %s", name)
}

// ReportFilterMutation represents an operation that mutate the ReportFilters
// nodes in the graph.
type ReportFilterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	entity        *reportfilter.Entity
	filters       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ReportFilter, error)
	predicates    []predicate.ReportFilter
}

var _ ent.Mutation = (*ReportFilterMutation)(nil)

// reportfilterOption allows to manage the mutation configuration using functional options.
type reportfilterOption func(*ReportFilterMutation)

// newReportFilterMutation creates new mutation for ReportFilter.
func newReportFilterMutation(c config, op Op, opts ...reportfilterOption) *ReportFilterMutation {
	m := &ReportFilterMutation{
		config:        c,
		op:            op,
		typ:           TypeReportFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportFilterID sets the id field of the mutation.
func withReportFilterID(id int) reportfilterOption {
	return func(m *ReportFilterMutation) {
		var (
			err   error
			once  sync.Once
			value *ReportFilter
		)
		m.oldValue = func(ctx context.Context) (*ReportFilter, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReportFilter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReportFilter sets the old ReportFilter of the mutation.
func withReportFilter(node *ReportFilter) reportfilterOption {
	return func(m *ReportFilterMutation) {
		m.oldValue = func(context.Context) (*ReportFilter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportFilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportFilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReportFilterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ReportFilterMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ReportFilterMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ReportFilter.
// If the ReportFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReportFilterMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ReportFilterMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ReportFilterMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ReportFilterMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ReportFilter.
// If the ReportFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReportFilterMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ReportFilterMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ReportFilterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ReportFilterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ReportFilter.
// If the ReportFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReportFilterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ReportFilterMutation) ResetName() {
	m.name = nil
}

// SetEntity sets the entity field.
func (m *ReportFilterMutation) SetEntity(r reportfilter.Entity) {
	m.entity = &r
}

// Entity returns the entity value in the mutation.
func (m *ReportFilterMutation) Entity() (r reportfilter.Entity, exists bool) {
	v := m.entity
	if v == nil {
		return
	}
	return *v, true
}

// OldEntity returns the old entity value of the ReportFilter.
// If the ReportFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReportFilterMutation) OldEntity(ctx context.Context) (v reportfilter.Entity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEntity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEntity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntity: %w", err)
	}
	return oldValue.Entity, nil
}

// ResetEntity reset all changes of the "entity" field.
func (m *ReportFilterMutation) ResetEntity() {
	m.entity = nil
}

// SetFilters sets the filters field.
func (m *ReportFilterMutation) SetFilters(s string) {
	m.filters = &s
}

// Filters returns the filters value in the mutation.
func (m *ReportFilterMutation) Filters() (r string, exists bool) {
	v := m.filters
	if v == nil {
		return
	}
	return *v, true
}

// OldFilters returns the old filters value of the ReportFilter.
// If the ReportFilter object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReportFilterMutation) OldFilters(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFilters is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilters: %w", err)
	}
	return oldValue.Filters, nil
}

// ResetFilters reset all changes of the "filters" field.
func (m *ReportFilterMutation) ResetFilters() {
	m.filters = nil
}

// Op returns the operation name.
func (m *ReportFilterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReportFilter).
func (m *ReportFilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReportFilterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, reportfilter.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, reportfilter.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, reportfilter.FieldName)
	}
	if m.entity != nil {
		fields = append(fields, reportfilter.FieldEntity)
	}
	if m.filters != nil {
		fields = append(fields, reportfilter.FieldFilters)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReportFilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reportfilter.FieldCreateTime:
		return m.CreateTime()
	case reportfilter.FieldUpdateTime:
		return m.UpdateTime()
	case reportfilter.FieldName:
		return m.Name()
	case reportfilter.FieldEntity:
		return m.Entity()
	case reportfilter.FieldFilters:
		return m.Filters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReportFilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reportfilter.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case reportfilter.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case reportfilter.FieldName:
		return m.OldName(ctx)
	case reportfilter.FieldEntity:
		return m.OldEntity(ctx)
	case reportfilter.FieldFilters:
		return m.OldFilters(ctx)
	}
	return nil, fmt.Errorf("unknown ReportFilter field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReportFilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reportfilter.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case reportfilter.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case reportfilter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case reportfilter.FieldEntity:
		v, ok := value.(reportfilter.Entity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntity(v)
		return nil
	case reportfilter.FieldFilters:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilters(v)
		return nil
	}
	return fmt.Errorf("unknown ReportFilter field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReportFilterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReportFilterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReportFilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReportFilter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReportFilterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReportFilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportFilterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReportFilter nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReportFilterMutation) ResetField(name string) error {
	switch name {
	case reportfilter.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case reportfilter.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case reportfilter.FieldName:
		m.ResetName()
		return nil
	case reportfilter.FieldEntity:
		m.ResetEntity()
		return nil
	case reportfilter.FieldFilters:
		m.ResetFilters()
		return nil
	}
	return fmt.Errorf("unknown ReportFilter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReportFilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReportFilterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReportFilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReportFilterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReportFilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReportFilterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReportFilterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReportFilter unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReportFilterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReportFilter edge %s", name)
}

// RuleMutation represents an operation that mutate the Rules
// nodes in the graph.
type RuleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	gracePeriod          *int
	addgracePeriod       *int
	startDateTime        *time.Time
	endDateTime          *time.Time
	status               *bool
	eventTypeName        *string
	specificProblem      *string
	additionalInfo       *string
	clearedFields        map[string]struct{}
	ruletype             *int
	clearedruletype      bool
	eventseverity        *int
	clearedeventseverity bool
	threshold            *int
	clearedthreshold     bool
	rulelimitrule        map[int]struct{}
	removedrulelimitrule map[int]struct{}
	clearedrulelimitrule bool
	done                 bool
	oldValue             func(context.Context) (*Rule, error)
	predicates           []predicate.Rule
}

var _ ent.Mutation = (*RuleMutation)(nil)

// ruleOption allows to manage the mutation configuration using functional options.
type ruleOption func(*RuleMutation)

// newRuleMutation creates new mutation for Rule.
func newRuleMutation(c config, op Op, opts ...ruleOption) *RuleMutation {
	m := &RuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleID sets the id field of the mutation.
func withRuleID(id int) ruleOption {
	return func(m *RuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Rule
		)
		m.oldValue = func(ctx context.Context) (*Rule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRule sets the old Rule of the mutation.
func withRule(node *Rule) ruleOption {
	return func(m *RuleMutation) {
		m.oldValue = func(context.Context) (*Rule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *RuleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *RuleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *RuleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *RuleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *RuleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *RuleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *RuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RuleMutation) ResetName() {
	m.name = nil
}

// SetGracePeriod sets the gracePeriod field.
func (m *RuleMutation) SetGracePeriod(i int) {
	m.gracePeriod = &i
	m.addgracePeriod = nil
}

// GracePeriod returns the gracePeriod value in the mutation.
func (m *RuleMutation) GracePeriod() (r int, exists bool) {
	v := m.gracePeriod
	if v == nil {
		return
	}
	return *v, true
}

// OldGracePeriod returns the old gracePeriod value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldGracePeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGracePeriod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGracePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGracePeriod: %w", err)
	}
	return oldValue.GracePeriod, nil
}

// AddGracePeriod adds i to gracePeriod.
func (m *RuleMutation) AddGracePeriod(i int) {
	if m.addgracePeriod != nil {
		*m.addgracePeriod += i
	} else {
		m.addgracePeriod = &i
	}
}

// AddedGracePeriod returns the value that was added to the gracePeriod field in this mutation.
func (m *RuleMutation) AddedGracePeriod() (r int, exists bool) {
	v := m.addgracePeriod
	if v == nil {
		return
	}
	return *v, true
}

// ResetGracePeriod reset all changes of the "gracePeriod" field.
func (m *RuleMutation) ResetGracePeriod() {
	m.gracePeriod = nil
	m.addgracePeriod = nil
}

// SetStartDateTime sets the startDateTime field.
func (m *RuleMutation) SetStartDateTime(t time.Time) {
	m.startDateTime = &t
}

// StartDateTime returns the startDateTime value in the mutation.
func (m *RuleMutation) StartDateTime() (r time.Time, exists bool) {
	v := m.startDateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDateTime returns the old startDateTime value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldStartDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDateTime: %w", err)
	}
	return oldValue.StartDateTime, nil
}

// ResetStartDateTime reset all changes of the "startDateTime" field.
func (m *RuleMutation) ResetStartDateTime() {
	m.startDateTime = nil
}

// SetEndDateTime sets the endDateTime field.
func (m *RuleMutation) SetEndDateTime(t time.Time) {
	m.endDateTime = &t
}

// EndDateTime returns the endDateTime value in the mutation.
func (m *RuleMutation) EndDateTime() (r time.Time, exists bool) {
	v := m.endDateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDateTime returns the old endDateTime value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldEndDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndDateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDateTime: %w", err)
	}
	return oldValue.EndDateTime, nil
}

// ResetEndDateTime reset all changes of the "endDateTime" field.
func (m *RuleMutation) ResetEndDateTime() {
	m.endDateTime = nil
}

// SetStatus sets the status field.
func (m *RuleMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the status value in the mutation.
func (m *RuleMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *RuleMutation) ResetStatus() {
	m.status = nil
}

// SetEventTypeName sets the eventTypeName field.
func (m *RuleMutation) SetEventTypeName(s string) {
	m.eventTypeName = &s
}

// EventTypeName returns the eventTypeName value in the mutation.
func (m *RuleMutation) EventTypeName() (r string, exists bool) {
	v := m.eventTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTypeName returns the old eventTypeName value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldEventTypeName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEventTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEventTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTypeName: %w", err)
	}
	return oldValue.EventTypeName, nil
}

// ClearEventTypeName clears the value of eventTypeName.
func (m *RuleMutation) ClearEventTypeName() {
	m.eventTypeName = nil
	m.clearedFields[rule.FieldEventTypeName] = struct{}{}
}

// EventTypeNameCleared returns if the field eventTypeName was cleared in this mutation.
func (m *RuleMutation) EventTypeNameCleared() bool {
	_, ok := m.clearedFields[rule.FieldEventTypeName]
	return ok
}

// ResetEventTypeName reset all changes of the "eventTypeName" field.
func (m *RuleMutation) ResetEventTypeName() {
	m.eventTypeName = nil
	delete(m.clearedFields, rule.FieldEventTypeName)
}

// SetSpecificProblem sets the specificProblem field.
func (m *RuleMutation) SetSpecificProblem(s string) {
	m.specificProblem = &s
}

// SpecificProblem returns the specificProblem value in the mutation.
func (m *RuleMutation) SpecificProblem() (r string, exists bool) {
	v := m.specificProblem
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecificProblem returns the old specificProblem value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldSpecificProblem(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecificProblem is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecificProblem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecificProblem: %w", err)
	}
	return oldValue.SpecificProblem, nil
}

// ClearSpecificProblem clears the value of specificProblem.
func (m *RuleMutation) ClearSpecificProblem() {
	m.specificProblem = nil
	m.clearedFields[rule.FieldSpecificProblem] = struct{}{}
}

// SpecificProblemCleared returns if the field specificProblem was cleared in this mutation.
func (m *RuleMutation) SpecificProblemCleared() bool {
	_, ok := m.clearedFields[rule.FieldSpecificProblem]
	return ok
}

// ResetSpecificProblem reset all changes of the "specificProblem" field.
func (m *RuleMutation) ResetSpecificProblem() {
	m.specificProblem = nil
	delete(m.clearedFields, rule.FieldSpecificProblem)
}

// SetAdditionalInfo sets the additionalInfo field.
func (m *RuleMutation) SetAdditionalInfo(s string) {
	m.additionalInfo = &s
}

// AdditionalInfo returns the additionalInfo value in the mutation.
func (m *RuleMutation) AdditionalInfo() (r string, exists bool) {
	v := m.additionalInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalInfo returns the old additionalInfo value of the Rule.
// If the Rule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleMutation) OldAdditionalInfo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdditionalInfo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdditionalInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalInfo: %w", err)
	}
	return oldValue.AdditionalInfo, nil
}

// ClearAdditionalInfo clears the value of additionalInfo.
func (m *RuleMutation) ClearAdditionalInfo() {
	m.additionalInfo = nil
	m.clearedFields[rule.FieldAdditionalInfo] = struct{}{}
}

// AdditionalInfoCleared returns if the field additionalInfo was cleared in this mutation.
func (m *RuleMutation) AdditionalInfoCleared() bool {
	_, ok := m.clearedFields[rule.FieldAdditionalInfo]
	return ok
}

// ResetAdditionalInfo reset all changes of the "additionalInfo" field.
func (m *RuleMutation) ResetAdditionalInfo() {
	m.additionalInfo = nil
	delete(m.clearedFields, rule.FieldAdditionalInfo)
}

// SetRuletypeID sets the ruletype edge to RuleType by id.
func (m *RuleMutation) SetRuletypeID(id int) {
	m.ruletype = &id
}

// ClearRuletype clears the ruletype edge to RuleType.
func (m *RuleMutation) ClearRuletype() {
	m.clearedruletype = true
}

// RuletypeCleared returns if the edge ruletype was cleared.
func (m *RuleMutation) RuletypeCleared() bool {
	return m.clearedruletype
}

// RuletypeID returns the ruletype id in the mutation.
func (m *RuleMutation) RuletypeID() (id int, exists bool) {
	if m.ruletype != nil {
		return *m.ruletype, true
	}
	return
}

// RuletypeIDs returns the ruletype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RuletypeID instead. It exists only for internal usage by the builders.
func (m *RuleMutation) RuletypeIDs() (ids []int) {
	if id := m.ruletype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRuletype reset all changes of the "ruletype" edge.
func (m *RuleMutation) ResetRuletype() {
	m.ruletype = nil
	m.clearedruletype = false
}

// SetEventseverityID sets the eventseverity edge to EventSeverity by id.
func (m *RuleMutation) SetEventseverityID(id int) {
	m.eventseverity = &id
}

// ClearEventseverity clears the eventseverity edge to EventSeverity.
func (m *RuleMutation) ClearEventseverity() {
	m.clearedeventseverity = true
}

// EventseverityCleared returns if the edge eventseverity was cleared.
func (m *RuleMutation) EventseverityCleared() bool {
	return m.clearedeventseverity
}

// EventseverityID returns the eventseverity id in the mutation.
func (m *RuleMutation) EventseverityID() (id int, exists bool) {
	if m.eventseverity != nil {
		return *m.eventseverity, true
	}
	return
}

// EventseverityIDs returns the eventseverity ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EventseverityID instead. It exists only for internal usage by the builders.
func (m *RuleMutation) EventseverityIDs() (ids []int) {
	if id := m.eventseverity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEventseverity reset all changes of the "eventseverity" edge.
func (m *RuleMutation) ResetEventseverity() {
	m.eventseverity = nil
	m.clearedeventseverity = false
}

// SetThresholdID sets the threshold edge to Threshold by id.
func (m *RuleMutation) SetThresholdID(id int) {
	m.threshold = &id
}

// ClearThreshold clears the threshold edge to Threshold.
func (m *RuleMutation) ClearThreshold() {
	m.clearedthreshold = true
}

// ThresholdCleared returns if the edge threshold was cleared.
func (m *RuleMutation) ThresholdCleared() bool {
	return m.clearedthreshold
}

// ThresholdID returns the threshold id in the mutation.
func (m *RuleMutation) ThresholdID() (id int, exists bool) {
	if m.threshold != nil {
		return *m.threshold, true
	}
	return
}

// ThresholdIDs returns the threshold ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ThresholdID instead. It exists only for internal usage by the builders.
func (m *RuleMutation) ThresholdIDs() (ids []int) {
	if id := m.threshold; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThreshold reset all changes of the "threshold" edge.
func (m *RuleMutation) ResetThreshold() {
	m.threshold = nil
	m.clearedthreshold = false
}

// AddRulelimitruleIDs adds the rulelimitrule edge to RuleLimit by ids.
func (m *RuleMutation) AddRulelimitruleIDs(ids ...int) {
	if m.rulelimitrule == nil {
		m.rulelimitrule = make(map[int]struct{})
	}
	for i := range ids {
		m.rulelimitrule[ids[i]] = struct{}{}
	}
}

// ClearRulelimitrule clears the rulelimitrule edge to RuleLimit.
func (m *RuleMutation) ClearRulelimitrule() {
	m.clearedrulelimitrule = true
}

// RulelimitruleCleared returns if the edge rulelimitrule was cleared.
func (m *RuleMutation) RulelimitruleCleared() bool {
	return m.clearedrulelimitrule
}

// RemoveRulelimitruleIDs removes the rulelimitrule edge to RuleLimit by ids.
func (m *RuleMutation) RemoveRulelimitruleIDs(ids ...int) {
	if m.removedrulelimitrule == nil {
		m.removedrulelimitrule = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrulelimitrule[ids[i]] = struct{}{}
	}
}

// RemovedRulelimitrule returns the removed ids of rulelimitrule.
func (m *RuleMutation) RemovedRulelimitruleIDs() (ids []int) {
	for id := range m.removedrulelimitrule {
		ids = append(ids, id)
	}
	return
}

// RulelimitruleIDs returns the rulelimitrule ids in the mutation.
func (m *RuleMutation) RulelimitruleIDs() (ids []int) {
	for id := range m.rulelimitrule {
		ids = append(ids, id)
	}
	return
}

// ResetRulelimitrule reset all changes of the "rulelimitrule" edge.
func (m *RuleMutation) ResetRulelimitrule() {
	m.rulelimitrule = nil
	m.clearedrulelimitrule = false
	m.removedrulelimitrule = nil
}

// Op returns the operation name.
func (m *RuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rule).
func (m *RuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RuleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, rule.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, rule.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, rule.FieldName)
	}
	if m.gracePeriod != nil {
		fields = append(fields, rule.FieldGracePeriod)
	}
	if m.startDateTime != nil {
		fields = append(fields, rule.FieldStartDateTime)
	}
	if m.endDateTime != nil {
		fields = append(fields, rule.FieldEndDateTime)
	}
	if m.status != nil {
		fields = append(fields, rule.FieldStatus)
	}
	if m.eventTypeName != nil {
		fields = append(fields, rule.FieldEventTypeName)
	}
	if m.specificProblem != nil {
		fields = append(fields, rule.FieldSpecificProblem)
	}
	if m.additionalInfo != nil {
		fields = append(fields, rule.FieldAdditionalInfo)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldCreateTime:
		return m.CreateTime()
	case rule.FieldUpdateTime:
		return m.UpdateTime()
	case rule.FieldName:
		return m.Name()
	case rule.FieldGracePeriod:
		return m.GracePeriod()
	case rule.FieldStartDateTime:
		return m.StartDateTime()
	case rule.FieldEndDateTime:
		return m.EndDateTime()
	case rule.FieldStatus:
		return m.Status()
	case rule.FieldEventTypeName:
		return m.EventTypeName()
	case rule.FieldSpecificProblem:
		return m.SpecificProblem()
	case rule.FieldAdditionalInfo:
		return m.AdditionalInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rule.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case rule.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case rule.FieldName:
		return m.OldName(ctx)
	case rule.FieldGracePeriod:
		return m.OldGracePeriod(ctx)
	case rule.FieldStartDateTime:
		return m.OldStartDateTime(ctx)
	case rule.FieldEndDateTime:
		return m.OldEndDateTime(ctx)
	case rule.FieldStatus:
		return m.OldStatus(ctx)
	case rule.FieldEventTypeName:
		return m.OldEventTypeName(ctx)
	case rule.FieldSpecificProblem:
		return m.OldSpecificProblem(ctx)
	case rule.FieldAdditionalInfo:
		return m.OldAdditionalInfo(ctx)
	}
	return nil, fmt.Errorf("unknown Rule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rule.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case rule.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case rule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rule.FieldGracePeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGracePeriod(v)
		return nil
	case rule.FieldStartDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDateTime(v)
		return nil
	case rule.FieldEndDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDateTime(v)
		return nil
	case rule.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rule.FieldEventTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTypeName(v)
		return nil
	case rule.FieldSpecificProblem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecificProblem(v)
		return nil
	case rule.FieldAdditionalInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalInfo(v)
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RuleMutation) AddedFields() []string {
	var fields []string
	if m.addgracePeriod != nil {
		fields = append(fields, rule.FieldGracePeriod)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldGracePeriod:
		return m.AddedGracePeriod()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rule.FieldGracePeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGracePeriod(v)
		return nil
	}
	return fmt.Errorf("unknown Rule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rule.FieldEventTypeName) {
		fields = append(fields, rule.FieldEventTypeName)
	}
	if m.FieldCleared(rule.FieldSpecificProblem) {
		fields = append(fields, rule.FieldSpecificProblem)
	}
	if m.FieldCleared(rule.FieldAdditionalInfo) {
		fields = append(fields, rule.FieldAdditionalInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleMutation) ClearField(name string) error {
	switch name {
	case rule.FieldEventTypeName:
		m.ClearEventTypeName()
		return nil
	case rule.FieldSpecificProblem:
		m.ClearSpecificProblem()
		return nil
	case rule.FieldAdditionalInfo:
		m.ClearAdditionalInfo()
		return nil
	}
	return fmt.Errorf("unknown Rule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RuleMutation) ResetField(name string) error {
	switch name {
	case rule.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case rule.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case rule.FieldName:
		m.ResetName()
		return nil
	case rule.FieldGracePeriod:
		m.ResetGracePeriod()
		return nil
	case rule.FieldStartDateTime:
		m.ResetStartDateTime()
		return nil
	case rule.FieldEndDateTime:
		m.ResetEndDateTime()
		return nil
	case rule.FieldStatus:
		m.ResetStatus()
		return nil
	case rule.FieldEventTypeName:
		m.ResetEventTypeName()
		return nil
	case rule.FieldSpecificProblem:
		m.ResetSpecificProblem()
		return nil
	case rule.FieldAdditionalInfo:
		m.ResetAdditionalInfo()
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.ruletype != nil {
		edges = append(edges, rule.EdgeRuletype)
	}
	if m.eventseverity != nil {
		edges = append(edges, rule.EdgeEventseverity)
	}
	if m.threshold != nil {
		edges = append(edges, rule.EdgeThreshold)
	}
	if m.rulelimitrule != nil {
		edges = append(edges, rule.EdgeRulelimitrule)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeRuletype:
		if id := m.ruletype; id != nil {
			return []ent.Value{*id}
		}
	case rule.EdgeEventseverity:
		if id := m.eventseverity; id != nil {
			return []ent.Value{*id}
		}
	case rule.EdgeThreshold:
		if id := m.threshold; id != nil {
			return []ent.Value{*id}
		}
	case rule.EdgeRulelimitrule:
		ids := make([]ent.Value, 0, len(m.rulelimitrule))
		for id := range m.rulelimitrule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrulelimitrule != nil {
		edges = append(edges, rule.EdgeRulelimitrule)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeRulelimitrule:
		ids := make([]ent.Value, 0, len(m.removedrulelimitrule))
		for id := range m.removedrulelimitrule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedruletype {
		edges = append(edges, rule.EdgeRuletype)
	}
	if m.clearedeventseverity {
		edges = append(edges, rule.EdgeEventseverity)
	}
	if m.clearedthreshold {
		edges = append(edges, rule.EdgeThreshold)
	}
	if m.clearedrulelimitrule {
		edges = append(edges, rule.EdgeRulelimitrule)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RuleMutation) EdgeCleared(name string) bool {
	switch name {
	case rule.EdgeRuletype:
		return m.clearedruletype
	case rule.EdgeEventseverity:
		return m.clearedeventseverity
	case rule.EdgeThreshold:
		return m.clearedthreshold
	case rule.EdgeRulelimitrule:
		return m.clearedrulelimitrule
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RuleMutation) ClearEdge(name string) error {
	switch name {
	case rule.EdgeRuletype:
		m.ClearRuletype()
		return nil
	case rule.EdgeEventseverity:
		m.ClearEventseverity()
		return nil
	case rule.EdgeThreshold:
		m.ClearThreshold()
		return nil
	}
	return fmt.Errorf("unknown Rule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RuleMutation) ResetEdge(name string) error {
	switch name {
	case rule.EdgeRuletype:
		m.ResetRuletype()
		return nil
	case rule.EdgeEventseverity:
		m.ResetEventseverity()
		return nil
	case rule.EdgeThreshold:
		m.ResetThreshold()
		return nil
	case rule.EdgeRulelimitrule:
		m.ResetRulelimitrule()
		return nil
	}
	return fmt.Errorf("unknown Rule edge %s", name)
}

// RuleLimitMutation represents an operation that mutate the RuleLimits
// nodes in the graph.
type RuleLimitMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	number            *int
	addnumber         *int
	limitType         *string
	clearedFields     map[string]struct{}
	comparator        *int
	clearedcomparator bool
	rule              *int
	clearedrule       bool
	done              bool
	oldValue          func(context.Context) (*RuleLimit, error)
	predicates        []predicate.RuleLimit
}

var _ ent.Mutation = (*RuleLimitMutation)(nil)

// rulelimitOption allows to manage the mutation configuration using functional options.
type rulelimitOption func(*RuleLimitMutation)

// newRuleLimitMutation creates new mutation for RuleLimit.
func newRuleLimitMutation(c config, op Op, opts ...rulelimitOption) *RuleLimitMutation {
	m := &RuleLimitMutation{
		config:        c,
		op:            op,
		typ:           TypeRuleLimit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleLimitID sets the id field of the mutation.
func withRuleLimitID(id int) rulelimitOption {
	return func(m *RuleLimitMutation) {
		var (
			err   error
			once  sync.Once
			value *RuleLimit
		)
		m.oldValue = func(ctx context.Context) (*RuleLimit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RuleLimit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRuleLimit sets the old RuleLimit of the mutation.
func withRuleLimit(node *RuleLimit) rulelimitOption {
	return func(m *RuleLimitMutation) {
		m.oldValue = func(context.Context) (*RuleLimit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleLimitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleLimitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RuleLimitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *RuleLimitMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *RuleLimitMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the RuleLimit.
// If the RuleLimit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleLimitMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *RuleLimitMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *RuleLimitMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *RuleLimitMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the RuleLimit.
// If the RuleLimit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleLimitMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *RuleLimitMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNumber sets the number field.
func (m *RuleLimitMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the number value in the mutation.
func (m *RuleLimitMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old number value of the RuleLimit.
// If the RuleLimit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleLimitMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to number.
func (m *RuleLimitMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the number field in this mutation.
func (m *RuleLimitMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber reset all changes of the "number" field.
func (m *RuleLimitMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetLimitType sets the limitType field.
func (m *RuleLimitMutation) SetLimitType(s string) {
	m.limitType = &s
}

// LimitType returns the limitType value in the mutation.
func (m *RuleLimitMutation) LimitType() (r string, exists bool) {
	v := m.limitType
	if v == nil {
		return
	}
	return *v, true
}

// OldLimitType returns the old limitType value of the RuleLimit.
// If the RuleLimit object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleLimitMutation) OldLimitType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLimitType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLimitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimitType: %w", err)
	}
	return oldValue.LimitType, nil
}

// ResetLimitType reset all changes of the "limitType" field.
func (m *RuleLimitMutation) ResetLimitType() {
	m.limitType = nil
}

// SetComparatorID sets the comparator edge to Comparator by id.
func (m *RuleLimitMutation) SetComparatorID(id int) {
	m.comparator = &id
}

// ClearComparator clears the comparator edge to Comparator.
func (m *RuleLimitMutation) ClearComparator() {
	m.clearedcomparator = true
}

// ComparatorCleared returns if the edge comparator was cleared.
func (m *RuleLimitMutation) ComparatorCleared() bool {
	return m.clearedcomparator
}

// ComparatorID returns the comparator id in the mutation.
func (m *RuleLimitMutation) ComparatorID() (id int, exists bool) {
	if m.comparator != nil {
		return *m.comparator, true
	}
	return
}

// ComparatorIDs returns the comparator ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ComparatorID instead. It exists only for internal usage by the builders.
func (m *RuleLimitMutation) ComparatorIDs() (ids []int) {
	if id := m.comparator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComparator reset all changes of the "comparator" edge.
func (m *RuleLimitMutation) ResetComparator() {
	m.comparator = nil
	m.clearedcomparator = false
}

// SetRuleID sets the rule edge to Rule by id.
func (m *RuleLimitMutation) SetRuleID(id int) {
	m.rule = &id
}

// ClearRule clears the rule edge to Rule.
func (m *RuleLimitMutation) ClearRule() {
	m.clearedrule = true
}

// RuleCleared returns if the edge rule was cleared.
func (m *RuleLimitMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleID returns the rule id in the mutation.
func (m *RuleLimitMutation) RuleID() (id int, exists bool) {
	if m.rule != nil {
		return *m.rule, true
	}
	return
}

// RuleIDs returns the rule ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *RuleLimitMutation) RuleIDs() (ids []int) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule reset all changes of the "rule" edge.
func (m *RuleLimitMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Op returns the operation name.
func (m *RuleLimitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RuleLimit).
func (m *RuleLimitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RuleLimitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, rulelimit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, rulelimit.FieldUpdateTime)
	}
	if m.number != nil {
		fields = append(fields, rulelimit.FieldNumber)
	}
	if m.limitType != nil {
		fields = append(fields, rulelimit.FieldLimitType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RuleLimitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rulelimit.FieldCreateTime:
		return m.CreateTime()
	case rulelimit.FieldUpdateTime:
		return m.UpdateTime()
	case rulelimit.FieldNumber:
		return m.Number()
	case rulelimit.FieldLimitType:
		return m.LimitType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RuleLimitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rulelimit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case rulelimit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case rulelimit.FieldNumber:
		return m.OldNumber(ctx)
	case rulelimit.FieldLimitType:
		return m.OldLimitType(ctx)
	}
	return nil, fmt.Errorf("unknown RuleLimit field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RuleLimitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rulelimit.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case rulelimit.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case rulelimit.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case rulelimit.FieldLimitType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimitType(v)
		return nil
	}
	return fmt.Errorf("unknown RuleLimit field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RuleLimitMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, rulelimit.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RuleLimitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rulelimit.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RuleLimitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rulelimit.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown RuleLimit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RuleLimitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RuleLimitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleLimitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RuleLimit nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RuleLimitMutation) ResetField(name string) error {
	switch name {
	case rulelimit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case rulelimit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case rulelimit.FieldNumber:
		m.ResetNumber()
		return nil
	case rulelimit.FieldLimitType:
		m.ResetLimitType()
		return nil
	}
	return fmt.Errorf("unknown RuleLimit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RuleLimitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.comparator != nil {
		edges = append(edges, rulelimit.EdgeComparator)
	}
	if m.rule != nil {
		edges = append(edges, rulelimit.EdgeRule)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RuleLimitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rulelimit.EdgeComparator:
		if id := m.comparator; id != nil {
			return []ent.Value{*id}
		}
	case rulelimit.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RuleLimitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RuleLimitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RuleLimitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomparator {
		edges = append(edges, rulelimit.EdgeComparator)
	}
	if m.clearedrule {
		edges = append(edges, rulelimit.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RuleLimitMutation) EdgeCleared(name string) bool {
	switch name {
	case rulelimit.EdgeComparator:
		return m.clearedcomparator
	case rulelimit.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RuleLimitMutation) ClearEdge(name string) error {
	switch name {
	case rulelimit.EdgeComparator:
		m.ClearComparator()
		return nil
	case rulelimit.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown RuleLimit unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RuleLimitMutation) ResetEdge(name string) error {
	switch name {
	case rulelimit.EdgeComparator:
		m.ResetComparator()
		return nil
	case rulelimit.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown RuleLimit edge %s", name)
}

// RuleTypeMutation represents an operation that mutate the RuleTypes
// nodes in the graph.
type RuleTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	clearedFields       map[string]struct{}
	ruletyperule        map[int]struct{}
	removedruletyperule map[int]struct{}
	clearedruletyperule bool
	done                bool
	oldValue            func(context.Context) (*RuleType, error)
	predicates          []predicate.RuleType
}

var _ ent.Mutation = (*RuleTypeMutation)(nil)

// ruletypeOption allows to manage the mutation configuration using functional options.
type ruletypeOption func(*RuleTypeMutation)

// newRuleTypeMutation creates new mutation for RuleType.
func newRuleTypeMutation(c config, op Op, opts ...ruletypeOption) *RuleTypeMutation {
	m := &RuleTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeRuleType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleTypeID sets the id field of the mutation.
func withRuleTypeID(id int) ruletypeOption {
	return func(m *RuleTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *RuleType
		)
		m.oldValue = func(ctx context.Context) (*RuleType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RuleType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRuleType sets the old RuleType of the mutation.
func withRuleType(node *RuleType) ruletypeOption {
	return func(m *RuleTypeMutation) {
		m.oldValue = func(context.Context) (*RuleType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RuleTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *RuleTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *RuleTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the RuleType.
// If the RuleType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *RuleTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *RuleTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *RuleTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the RuleType.
// If the RuleType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *RuleTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *RuleTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RuleTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the RuleType.
// If the RuleType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RuleTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RuleTypeMutation) ResetName() {
	m.name = nil
}

// AddRuletyperuleIDs adds the ruletyperule edge to Rule by ids.
func (m *RuleTypeMutation) AddRuletyperuleIDs(ids ...int) {
	if m.ruletyperule == nil {
		m.ruletyperule = make(map[int]struct{})
	}
	for i := range ids {
		m.ruletyperule[ids[i]] = struct{}{}
	}
}

// ClearRuletyperule clears the ruletyperule edge to Rule.
func (m *RuleTypeMutation) ClearRuletyperule() {
	m.clearedruletyperule = true
}

// RuletyperuleCleared returns if the edge ruletyperule was cleared.
func (m *RuleTypeMutation) RuletyperuleCleared() bool {
	return m.clearedruletyperule
}

// RemoveRuletyperuleIDs removes the ruletyperule edge to Rule by ids.
func (m *RuleTypeMutation) RemoveRuletyperuleIDs(ids ...int) {
	if m.removedruletyperule == nil {
		m.removedruletyperule = make(map[int]struct{})
	}
	for i := range ids {
		m.removedruletyperule[ids[i]] = struct{}{}
	}
}

// RemovedRuletyperule returns the removed ids of ruletyperule.
func (m *RuleTypeMutation) RemovedRuletyperuleIDs() (ids []int) {
	for id := range m.removedruletyperule {
		ids = append(ids, id)
	}
	return
}

// RuletyperuleIDs returns the ruletyperule ids in the mutation.
func (m *RuleTypeMutation) RuletyperuleIDs() (ids []int) {
	for id := range m.ruletyperule {
		ids = append(ids, id)
	}
	return
}

// ResetRuletyperule reset all changes of the "ruletyperule" edge.
func (m *RuleTypeMutation) ResetRuletyperule() {
	m.ruletyperule = nil
	m.clearedruletyperule = false
	m.removedruletyperule = nil
}

// Op returns the operation name.
func (m *RuleTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RuleType).
func (m *RuleTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RuleTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, ruletype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ruletype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, ruletype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RuleTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ruletype.FieldCreateTime:
		return m.CreateTime()
	case ruletype.FieldUpdateTime:
		return m.UpdateTime()
	case ruletype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RuleTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ruletype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ruletype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ruletype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RuleType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RuleTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ruletype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ruletype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ruletype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RuleType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RuleTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RuleTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RuleTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RuleType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RuleTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RuleTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RuleType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RuleTypeMutation) ResetField(name string) error {
	switch name {
	case ruletype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ruletype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ruletype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RuleType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RuleTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ruletyperule != nil {
		edges = append(edges, ruletype.EdgeRuletyperule)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RuleTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ruletype.EdgeRuletyperule:
		ids := make([]ent.Value, 0, len(m.ruletyperule))
		for id := range m.ruletyperule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RuleTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedruletyperule != nil {
		edges = append(edges, ruletype.EdgeRuletyperule)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RuleTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ruletype.EdgeRuletyperule:
		ids := make([]ent.Value, 0, len(m.removedruletyperule))
		for id := range m.removedruletyperule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RuleTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedruletyperule {
		edges = append(edges, ruletype.EdgeRuletyperule)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RuleTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case ruletype.EdgeRuletyperule:
		return m.clearedruletyperule
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RuleTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RuleType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RuleTypeMutation) ResetEdge(name string) error {
	switch name {
	case ruletype.EdgeRuletyperule:
		m.ResetRuletyperule()
		return nil
	}
	return fmt.Errorf("unknown RuleType edge %s", name)
}

// ServiceMutation represents an operation that mutate the Services
// nodes in the graph.
type ServiceMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	name              *string
	external_id       *string
	status            *service.Status
	clearedFields     map[string]struct{}
	_type             *int
	cleared_type      bool
	downstream        map[int]struct{}
	removeddownstream map[int]struct{}
	cleareddownstream bool
	upstream          map[int]struct{}
	removedupstream   map[int]struct{}
	clearedupstream   bool
	properties        map[int]struct{}
	removedproperties map[int]struct{}
	clearedproperties bool
	links             map[int]struct{}
	removedlinks      map[int]struct{}
	clearedlinks      bool
	ports             map[int]struct{}
	removedports      map[int]struct{}
	clearedports      bool
	customer          map[int]struct{}
	removedcustomer   map[int]struct{}
	clearedcustomer   bool
	endpoints         map[int]struct{}
	removedendpoints  map[int]struct{}
	clearedendpoints  bool
	done              bool
	oldValue          func(context.Context) (*Service, error)
	predicates        []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows to manage the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for Service.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the id field of the mutation.
func withServiceID(id int) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ServiceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ServiceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ServiceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ServiceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ServiceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ServiceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetExternalID sets the external_id field.
func (m *ServiceMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the external_id value in the mutation.
func (m *ServiceMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old external_id value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of external_id.
func (m *ServiceMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[service.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the field external_id was cleared in this mutation.
func (m *ServiceMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[service.FieldExternalID]
	return ok
}

// ResetExternalID reset all changes of the "external_id" field.
func (m *ServiceMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, service.FieldExternalID)
}

// SetStatus sets the status field.
func (m *ServiceMutation) SetStatus(s service.Status) {
	m.status = &s
}

// Status returns the status value in the mutation.
func (m *ServiceMutation) Status() (r service.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldStatus(ctx context.Context) (v service.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *ServiceMutation) ResetStatus() {
	m.status = nil
}

// SetTypeID sets the type edge to ServiceType by id.
func (m *ServiceMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to ServiceType.
func (m *ServiceMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *ServiceMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *ServiceMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *ServiceMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// AddDownstreamIDs adds the downstream edge to Service by ids.
func (m *ServiceMutation) AddDownstreamIDs(ids ...int) {
	if m.downstream == nil {
		m.downstream = make(map[int]struct{})
	}
	for i := range ids {
		m.downstream[ids[i]] = struct{}{}
	}
}

// ClearDownstream clears the downstream edge to Service.
func (m *ServiceMutation) ClearDownstream() {
	m.cleareddownstream = true
}

// DownstreamCleared returns if the edge downstream was cleared.
func (m *ServiceMutation) DownstreamCleared() bool {
	return m.cleareddownstream
}

// RemoveDownstreamIDs removes the downstream edge to Service by ids.
func (m *ServiceMutation) RemoveDownstreamIDs(ids ...int) {
	if m.removeddownstream == nil {
		m.removeddownstream = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddownstream[ids[i]] = struct{}{}
	}
}

// RemovedDownstream returns the removed ids of downstream.
func (m *ServiceMutation) RemovedDownstreamIDs() (ids []int) {
	for id := range m.removeddownstream {
		ids = append(ids, id)
	}
	return
}

// DownstreamIDs returns the downstream ids in the mutation.
func (m *ServiceMutation) DownstreamIDs() (ids []int) {
	for id := range m.downstream {
		ids = append(ids, id)
	}
	return
}

// ResetDownstream reset all changes of the "downstream" edge.
func (m *ServiceMutation) ResetDownstream() {
	m.downstream = nil
	m.cleareddownstream = false
	m.removeddownstream = nil
}

// AddUpstreamIDs adds the upstream edge to Service by ids.
func (m *ServiceMutation) AddUpstreamIDs(ids ...int) {
	if m.upstream == nil {
		m.upstream = make(map[int]struct{})
	}
	for i := range ids {
		m.upstream[ids[i]] = struct{}{}
	}
}

// ClearUpstream clears the upstream edge to Service.
func (m *ServiceMutation) ClearUpstream() {
	m.clearedupstream = true
}

// UpstreamCleared returns if the edge upstream was cleared.
func (m *ServiceMutation) UpstreamCleared() bool {
	return m.clearedupstream
}

// RemoveUpstreamIDs removes the upstream edge to Service by ids.
func (m *ServiceMutation) RemoveUpstreamIDs(ids ...int) {
	if m.removedupstream == nil {
		m.removedupstream = make(map[int]struct{})
	}
	for i := range ids {
		m.removedupstream[ids[i]] = struct{}{}
	}
}

// RemovedUpstream returns the removed ids of upstream.
func (m *ServiceMutation) RemovedUpstreamIDs() (ids []int) {
	for id := range m.removedupstream {
		ids = append(ids, id)
	}
	return
}

// UpstreamIDs returns the upstream ids in the mutation.
func (m *ServiceMutation) UpstreamIDs() (ids []int) {
	for id := range m.upstream {
		ids = append(ids, id)
	}
	return
}

// ResetUpstream reset all changes of the "upstream" edge.
func (m *ServiceMutation) ResetUpstream() {
	m.upstream = nil
	m.clearedupstream = false
	m.removedupstream = nil
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *ServiceMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *ServiceMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *ServiceMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *ServiceMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *ServiceMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *ServiceMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *ServiceMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddLinkIDs adds the links edge to Link by ids.
func (m *ServiceMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the links edge to Link.
func (m *ServiceMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared returns if the edge links was cleared.
func (m *ServiceMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the links edge to Link by ids.
func (m *ServiceMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed ids of links.
func (m *ServiceMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the links ids in the mutation.
func (m *ServiceMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks reset all changes of the "links" edge.
func (m *ServiceMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// AddPortIDs adds the ports edge to EquipmentPort by ids.
func (m *ServiceMutation) AddPortIDs(ids ...int) {
	if m.ports == nil {
		m.ports = make(map[int]struct{})
	}
	for i := range ids {
		m.ports[ids[i]] = struct{}{}
	}
}

// ClearPorts clears the ports edge to EquipmentPort.
func (m *ServiceMutation) ClearPorts() {
	m.clearedports = true
}

// PortsCleared returns if the edge ports was cleared.
func (m *ServiceMutation) PortsCleared() bool {
	return m.clearedports
}

// RemovePortIDs removes the ports edge to EquipmentPort by ids.
func (m *ServiceMutation) RemovePortIDs(ids ...int) {
	if m.removedports == nil {
		m.removedports = make(map[int]struct{})
	}
	for i := range ids {
		m.removedports[ids[i]] = struct{}{}
	}
}

// RemovedPorts returns the removed ids of ports.
func (m *ServiceMutation) RemovedPortsIDs() (ids []int) {
	for id := range m.removedports {
		ids = append(ids, id)
	}
	return
}

// PortsIDs returns the ports ids in the mutation.
func (m *ServiceMutation) PortsIDs() (ids []int) {
	for id := range m.ports {
		ids = append(ids, id)
	}
	return
}

// ResetPorts reset all changes of the "ports" edge.
func (m *ServiceMutation) ResetPorts() {
	m.ports = nil
	m.clearedports = false
	m.removedports = nil
}

// AddCustomerIDs adds the customer edge to Customer by ids.
func (m *ServiceMutation) AddCustomerIDs(ids ...int) {
	if m.customer == nil {
		m.customer = make(map[int]struct{})
	}
	for i := range ids {
		m.customer[ids[i]] = struct{}{}
	}
}

// ClearCustomer clears the customer edge to Customer.
func (m *ServiceMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *ServiceMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// RemoveCustomerIDs removes the customer edge to Customer by ids.
func (m *ServiceMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomer == nil {
		m.removedcustomer = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcustomer[ids[i]] = struct{}{}
	}
}

// RemovedCustomer returns the removed ids of customer.
func (m *ServiceMutation) RemovedCustomerIDs() (ids []int) {
	for id := range m.removedcustomer {
		ids = append(ids, id)
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
func (m *ServiceMutation) CustomerIDs() (ids []int) {
	for id := range m.customer {
		ids = append(ids, id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *ServiceMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
	m.removedcustomer = nil
}

// AddEndpointIDs adds the endpoints edge to ServiceEndpoint by ids.
func (m *ServiceMutation) AddEndpointIDs(ids ...int) {
	if m.endpoints == nil {
		m.endpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.endpoints[ids[i]] = struct{}{}
	}
}

// ClearEndpoints clears the endpoints edge to ServiceEndpoint.
func (m *ServiceMutation) ClearEndpoints() {
	m.clearedendpoints = true
}

// EndpointsCleared returns if the edge endpoints was cleared.
func (m *ServiceMutation) EndpointsCleared() bool {
	return m.clearedendpoints
}

// RemoveEndpointIDs removes the endpoints edge to ServiceEndpoint by ids.
func (m *ServiceMutation) RemoveEndpointIDs(ids ...int) {
	if m.removedendpoints == nil {
		m.removedendpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.removedendpoints[ids[i]] = struct{}{}
	}
}

// RemovedEndpoints returns the removed ids of endpoints.
func (m *ServiceMutation) RemovedEndpointsIDs() (ids []int) {
	for id := range m.removedendpoints {
		ids = append(ids, id)
	}
	return
}

// EndpointsIDs returns the endpoints ids in the mutation.
func (m *ServiceMutation) EndpointsIDs() (ids []int) {
	for id := range m.endpoints {
		ids = append(ids, id)
	}
	return
}

// ResetEndpoints reset all changes of the "endpoints" edge.
func (m *ServiceMutation) ResetEndpoints() {
	m.endpoints = nil
	m.clearedendpoints = false
	m.removedendpoints = nil
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, service.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, service.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.external_id != nil {
		fields = append(fields, service.FieldExternalID)
	}
	if m.status != nil {
		fields = append(fields, service.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldCreateTime:
		return m.CreateTime()
	case service.FieldUpdateTime:
		return m.UpdateTime()
	case service.FieldName:
		return m.Name()
	case service.FieldExternalID:
		return m.ExternalID()
	case service.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case service.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldExternalID:
		return m.OldExternalID(ctx)
	case service.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case service.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case service.FieldStatus:
		v, ok := value.(service.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(service.FieldExternalID) {
		fields = append(fields, service.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	switch name {
	case service.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case service.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldExternalID:
		m.ResetExternalID()
		return nil
	case service.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m._type != nil {
		edges = append(edges, service.EdgeType)
	}
	if m.downstream != nil {
		edges = append(edges, service.EdgeDownstream)
	}
	if m.upstream != nil {
		edges = append(edges, service.EdgeUpstream)
	}
	if m.properties != nil {
		edges = append(edges, service.EdgeProperties)
	}
	if m.links != nil {
		edges = append(edges, service.EdgeLinks)
	}
	if m.ports != nil {
		edges = append(edges, service.EdgePorts)
	}
	if m.customer != nil {
		edges = append(edges, service.EdgeCustomer)
	}
	if m.endpoints != nil {
		edges = append(edges, service.EdgeEndpoints)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeDownstream:
		ids := make([]ent.Value, 0, len(m.downstream))
		for id := range m.downstream {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeUpstream:
		ids := make([]ent.Value, 0, len(m.upstream))
		for id := range m.upstream {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	case service.EdgePorts:
		ids := make([]ent.Value, 0, len(m.ports))
		for id := range m.ports {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.customer))
		for id := range m.customer {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.endpoints))
		for id := range m.endpoints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removeddownstream != nil {
		edges = append(edges, service.EdgeDownstream)
	}
	if m.removedupstream != nil {
		edges = append(edges, service.EdgeUpstream)
	}
	if m.removedproperties != nil {
		edges = append(edges, service.EdgeProperties)
	}
	if m.removedlinks != nil {
		edges = append(edges, service.EdgeLinks)
	}
	if m.removedports != nil {
		edges = append(edges, service.EdgePorts)
	}
	if m.removedcustomer != nil {
		edges = append(edges, service.EdgeCustomer)
	}
	if m.removedendpoints != nil {
		edges = append(edges, service.EdgeEndpoints)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeDownstream:
		ids := make([]ent.Value, 0, len(m.removeddownstream))
		for id := range m.removeddownstream {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeUpstream:
		ids := make([]ent.Value, 0, len(m.removedupstream))
		for id := range m.removedupstream {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	case service.EdgePorts:
		ids := make([]ent.Value, 0, len(m.removedports))
		for id := range m.removedports {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.removedcustomer))
		for id := range m.removedcustomer {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.removedendpoints))
		for id := range m.removedendpoints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleared_type {
		edges = append(edges, service.EdgeType)
	}
	if m.cleareddownstream {
		edges = append(edges, service.EdgeDownstream)
	}
	if m.clearedupstream {
		edges = append(edges, service.EdgeUpstream)
	}
	if m.clearedproperties {
		edges = append(edges, service.EdgeProperties)
	}
	if m.clearedlinks {
		edges = append(edges, service.EdgeLinks)
	}
	if m.clearedports {
		edges = append(edges, service.EdgePorts)
	}
	if m.clearedcustomer {
		edges = append(edges, service.EdgeCustomer)
	}
	if m.clearedendpoints {
		edges = append(edges, service.EdgeEndpoints)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeType:
		return m.cleared_type
	case service.EdgeDownstream:
		return m.cleareddownstream
	case service.EdgeUpstream:
		return m.clearedupstream
	case service.EdgeProperties:
		return m.clearedproperties
	case service.EdgeLinks:
		return m.clearedlinks
	case service.EdgePorts:
		return m.clearedports
	case service.EdgeCustomer:
		return m.clearedcustomer
	case service.EdgeEndpoints:
		return m.clearedendpoints
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeType:
		m.ResetType()
		return nil
	case service.EdgeDownstream:
		m.ResetDownstream()
		return nil
	case service.EdgeUpstream:
		m.ResetUpstream()
		return nil
	case service.EdgeProperties:
		m.ResetProperties()
		return nil
	case service.EdgeLinks:
		m.ResetLinks()
		return nil
	case service.EdgePorts:
		m.ResetPorts()
		return nil
	case service.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case service.EdgeEndpoints:
		m.ResetEndpoints()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// ServiceEndpointMutation represents an operation that mutate the ServiceEndpoints
// nodes in the graph.
type ServiceEndpointMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	port              *int
	clearedport       bool
	equipment         *int
	clearedequipment  bool
	service           *int
	clearedservice    bool
	definition        *int
	cleareddefinition bool
	done              bool
	oldValue          func(context.Context) (*ServiceEndpoint, error)
	predicates        []predicate.ServiceEndpoint
}

var _ ent.Mutation = (*ServiceEndpointMutation)(nil)

// serviceendpointOption allows to manage the mutation configuration using functional options.
type serviceendpointOption func(*ServiceEndpointMutation)

// newServiceEndpointMutation creates new mutation for ServiceEndpoint.
func newServiceEndpointMutation(c config, op Op, opts ...serviceendpointOption) *ServiceEndpointMutation {
	m := &ServiceEndpointMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceEndpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceEndpointID sets the id field of the mutation.
func withServiceEndpointID(id int) serviceendpointOption {
	return func(m *ServiceEndpointMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceEndpoint
		)
		m.oldValue = func(ctx context.Context) (*ServiceEndpoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceEndpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceEndpoint sets the old ServiceEndpoint of the mutation.
func withServiceEndpoint(node *ServiceEndpoint) serviceendpointOption {
	return func(m *ServiceEndpointMutation) {
		m.oldValue = func(context.Context) (*ServiceEndpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceEndpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceEndpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServiceEndpointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ServiceEndpointMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ServiceEndpointMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ServiceEndpoint.
// If the ServiceEndpoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceEndpointMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ServiceEndpointMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ServiceEndpointMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ServiceEndpointMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ServiceEndpoint.
// If the ServiceEndpoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceEndpointMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ServiceEndpointMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPortID sets the port edge to EquipmentPort by id.
func (m *ServiceEndpointMutation) SetPortID(id int) {
	m.port = &id
}

// ClearPort clears the port edge to EquipmentPort.
func (m *ServiceEndpointMutation) ClearPort() {
	m.clearedport = true
}

// PortCleared returns if the edge port was cleared.
func (m *ServiceEndpointMutation) PortCleared() bool {
	return m.clearedport
}

// PortID returns the port id in the mutation.
func (m *ServiceEndpointMutation) PortID() (id int, exists bool) {
	if m.port != nil {
		return *m.port, true
	}
	return
}

// PortIDs returns the port ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PortID instead. It exists only for internal usage by the builders.
func (m *ServiceEndpointMutation) PortIDs() (ids []int) {
	if id := m.port; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPort reset all changes of the "port" edge.
func (m *ServiceEndpointMutation) ResetPort() {
	m.port = nil
	m.clearedport = false
}

// SetEquipmentID sets the equipment edge to Equipment by id.
func (m *ServiceEndpointMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *ServiceEndpointMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *ServiceEndpointMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the equipment id in the mutation.
func (m *ServiceEndpointMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *ServiceEndpointMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *ServiceEndpointMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetServiceID sets the service edge to Service by id.
func (m *ServiceEndpointMutation) SetServiceID(id int) {
	m.service = &id
}

// ClearService clears the service edge to Service.
func (m *ServiceEndpointMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared returns if the edge service was cleared.
func (m *ServiceEndpointMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the service id in the mutation.
func (m *ServiceEndpointMutation) ServiceID() (id int, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the service ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *ServiceEndpointMutation) ServiceIDs() (ids []int) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService reset all changes of the "service" edge.
func (m *ServiceEndpointMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// SetDefinitionID sets the definition edge to ServiceEndpointDefinition by id.
func (m *ServiceEndpointMutation) SetDefinitionID(id int) {
	m.definition = &id
}

// ClearDefinition clears the definition edge to ServiceEndpointDefinition.
func (m *ServiceEndpointMutation) ClearDefinition() {
	m.cleareddefinition = true
}

// DefinitionCleared returns if the edge definition was cleared.
func (m *ServiceEndpointMutation) DefinitionCleared() bool {
	return m.cleareddefinition
}

// DefinitionID returns the definition id in the mutation.
func (m *ServiceEndpointMutation) DefinitionID() (id int, exists bool) {
	if m.definition != nil {
		return *m.definition, true
	}
	return
}

// DefinitionIDs returns the definition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DefinitionID instead. It exists only for internal usage by the builders.
func (m *ServiceEndpointMutation) DefinitionIDs() (ids []int) {
	if id := m.definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefinition reset all changes of the "definition" edge.
func (m *ServiceEndpointMutation) ResetDefinition() {
	m.definition = nil
	m.cleareddefinition = false
}

// Op returns the operation name.
func (m *ServiceEndpointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ServiceEndpoint).
func (m *ServiceEndpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServiceEndpointMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, serviceendpoint.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serviceendpoint.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServiceEndpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceendpoint.FieldCreateTime:
		return m.CreateTime()
	case serviceendpoint.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServiceEndpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceendpoint.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceendpoint.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceEndpoint field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceEndpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceendpoint.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceendpoint.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServiceEndpointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServiceEndpointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceEndpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceEndpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServiceEndpointMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServiceEndpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceEndpointMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceEndpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServiceEndpointMutation) ResetField(name string) error {
	switch name {
	case serviceendpoint.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceendpoint.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServiceEndpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.port != nil {
		edges = append(edges, serviceendpoint.EdgePort)
	}
	if m.equipment != nil {
		edges = append(edges, serviceendpoint.EdgeEquipment)
	}
	if m.service != nil {
		edges = append(edges, serviceendpoint.EdgeService)
	}
	if m.definition != nil {
		edges = append(edges, serviceendpoint.EdgeDefinition)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServiceEndpointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceendpoint.EdgePort:
		if id := m.port; id != nil {
			return []ent.Value{*id}
		}
	case serviceendpoint.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case serviceendpoint.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case serviceendpoint.EdgeDefinition:
		if id := m.definition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServiceEndpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServiceEndpointMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServiceEndpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedport {
		edges = append(edges, serviceendpoint.EdgePort)
	}
	if m.clearedequipment {
		edges = append(edges, serviceendpoint.EdgeEquipment)
	}
	if m.clearedservice {
		edges = append(edges, serviceendpoint.EdgeService)
	}
	if m.cleareddefinition {
		edges = append(edges, serviceendpoint.EdgeDefinition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServiceEndpointMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceendpoint.EdgePort:
		return m.clearedport
	case serviceendpoint.EdgeEquipment:
		return m.clearedequipment
	case serviceendpoint.EdgeService:
		return m.clearedservice
	case serviceendpoint.EdgeDefinition:
		return m.cleareddefinition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServiceEndpointMutation) ClearEdge(name string) error {
	switch name {
	case serviceendpoint.EdgePort:
		m.ClearPort()
		return nil
	case serviceendpoint.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case serviceendpoint.EdgeService:
		m.ClearService()
		return nil
	case serviceendpoint.EdgeDefinition:
		m.ClearDefinition()
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpoint unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServiceEndpointMutation) ResetEdge(name string) error {
	switch name {
	case serviceendpoint.EdgePort:
		m.ResetPort()
		return nil
	case serviceendpoint.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case serviceendpoint.EdgeService:
		m.ResetService()
		return nil
	case serviceendpoint.EdgeDefinition:
		m.ResetDefinition()
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpoint edge %s", name)
}

// ServiceEndpointDefinitionMutation represents an operation that mutate the ServiceEndpointDefinitions
// nodes in the graph.
type ServiceEndpointDefinitionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	role                  *string
	name                  *string
	index                 *int
	addindex              *int
	clearedFields         map[string]struct{}
	endpoints             map[int]struct{}
	removedendpoints      map[int]struct{}
	clearedendpoints      bool
	service_type          *int
	clearedservice_type   bool
	equipment_type        *int
	clearedequipment_type bool
	done                  bool
	oldValue              func(context.Context) (*ServiceEndpointDefinition, error)
	predicates            []predicate.ServiceEndpointDefinition
}

var _ ent.Mutation = (*ServiceEndpointDefinitionMutation)(nil)

// serviceendpointdefinitionOption allows to manage the mutation configuration using functional options.
type serviceendpointdefinitionOption func(*ServiceEndpointDefinitionMutation)

// newServiceEndpointDefinitionMutation creates new mutation for ServiceEndpointDefinition.
func newServiceEndpointDefinitionMutation(c config, op Op, opts ...serviceendpointdefinitionOption) *ServiceEndpointDefinitionMutation {
	m := &ServiceEndpointDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceEndpointDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceEndpointDefinitionID sets the id field of the mutation.
func withServiceEndpointDefinitionID(id int) serviceendpointdefinitionOption {
	return func(m *ServiceEndpointDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceEndpointDefinition
		)
		m.oldValue = func(ctx context.Context) (*ServiceEndpointDefinition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceEndpointDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceEndpointDefinition sets the old ServiceEndpointDefinition of the mutation.
func withServiceEndpointDefinition(node *ServiceEndpointDefinition) serviceendpointdefinitionOption {
	return func(m *ServiceEndpointDefinitionMutation) {
		m.oldValue = func(context.Context) (*ServiceEndpointDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceEndpointDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceEndpointDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServiceEndpointDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ServiceEndpointDefinitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ServiceEndpointDefinitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ServiceEndpointDefinition.
// If the ServiceEndpointDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceEndpointDefinitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ServiceEndpointDefinitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ServiceEndpointDefinitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ServiceEndpointDefinitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ServiceEndpointDefinition.
// If the ServiceEndpointDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceEndpointDefinitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ServiceEndpointDefinitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRole sets the role field.
func (m *ServiceEndpointDefinitionMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the role value in the mutation.
func (m *ServiceEndpointDefinitionMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old role value of the ServiceEndpointDefinition.
// If the ServiceEndpointDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceEndpointDefinitionMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of role.
func (m *ServiceEndpointDefinitionMutation) ClearRole() {
	m.role = nil
	m.clearedFields[serviceendpointdefinition.FieldRole] = struct{}{}
}

// RoleCleared returns if the field role was cleared in this mutation.
func (m *ServiceEndpointDefinitionMutation) RoleCleared() bool {
	_, ok := m.clearedFields[serviceendpointdefinition.FieldRole]
	return ok
}

// ResetRole reset all changes of the "role" field.
func (m *ServiceEndpointDefinitionMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, serviceendpointdefinition.FieldRole)
}

// SetName sets the name field.
func (m *ServiceEndpointDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ServiceEndpointDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ServiceEndpointDefinition.
// If the ServiceEndpointDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceEndpointDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ServiceEndpointDefinitionMutation) ResetName() {
	m.name = nil
}

// SetIndex sets the index field.
func (m *ServiceEndpointDefinitionMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *ServiceEndpointDefinitionMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the ServiceEndpointDefinition.
// If the ServiceEndpointDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceEndpointDefinitionMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *ServiceEndpointDefinitionMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *ServiceEndpointDefinitionMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *ServiceEndpointDefinitionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// AddEndpointIDs adds the endpoints edge to ServiceEndpoint by ids.
func (m *ServiceEndpointDefinitionMutation) AddEndpointIDs(ids ...int) {
	if m.endpoints == nil {
		m.endpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.endpoints[ids[i]] = struct{}{}
	}
}

// ClearEndpoints clears the endpoints edge to ServiceEndpoint.
func (m *ServiceEndpointDefinitionMutation) ClearEndpoints() {
	m.clearedendpoints = true
}

// EndpointsCleared returns if the edge endpoints was cleared.
func (m *ServiceEndpointDefinitionMutation) EndpointsCleared() bool {
	return m.clearedendpoints
}

// RemoveEndpointIDs removes the endpoints edge to ServiceEndpoint by ids.
func (m *ServiceEndpointDefinitionMutation) RemoveEndpointIDs(ids ...int) {
	if m.removedendpoints == nil {
		m.removedendpoints = make(map[int]struct{})
	}
	for i := range ids {
		m.removedendpoints[ids[i]] = struct{}{}
	}
}

// RemovedEndpoints returns the removed ids of endpoints.
func (m *ServiceEndpointDefinitionMutation) RemovedEndpointsIDs() (ids []int) {
	for id := range m.removedendpoints {
		ids = append(ids, id)
	}
	return
}

// EndpointsIDs returns the endpoints ids in the mutation.
func (m *ServiceEndpointDefinitionMutation) EndpointsIDs() (ids []int) {
	for id := range m.endpoints {
		ids = append(ids, id)
	}
	return
}

// ResetEndpoints reset all changes of the "endpoints" edge.
func (m *ServiceEndpointDefinitionMutation) ResetEndpoints() {
	m.endpoints = nil
	m.clearedendpoints = false
	m.removedendpoints = nil
}

// SetServiceTypeID sets the service_type edge to ServiceType by id.
func (m *ServiceEndpointDefinitionMutation) SetServiceTypeID(id int) {
	m.service_type = &id
}

// ClearServiceType clears the service_type edge to ServiceType.
func (m *ServiceEndpointDefinitionMutation) ClearServiceType() {
	m.clearedservice_type = true
}

// ServiceTypeCleared returns if the edge service_type was cleared.
func (m *ServiceEndpointDefinitionMutation) ServiceTypeCleared() bool {
	return m.clearedservice_type
}

// ServiceTypeID returns the service_type id in the mutation.
func (m *ServiceEndpointDefinitionMutation) ServiceTypeID() (id int, exists bool) {
	if m.service_type != nil {
		return *m.service_type, true
	}
	return
}

// ServiceTypeIDs returns the service_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServiceTypeID instead. It exists only for internal usage by the builders.
func (m *ServiceEndpointDefinitionMutation) ServiceTypeIDs() (ids []int) {
	if id := m.service_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceType reset all changes of the "service_type" edge.
func (m *ServiceEndpointDefinitionMutation) ResetServiceType() {
	m.service_type = nil
	m.clearedservice_type = false
}

// SetEquipmentTypeID sets the equipment_type edge to EquipmentType by id.
func (m *ServiceEndpointDefinitionMutation) SetEquipmentTypeID(id int) {
	m.equipment_type = &id
}

// ClearEquipmentType clears the equipment_type edge to EquipmentType.
func (m *ServiceEndpointDefinitionMutation) ClearEquipmentType() {
	m.clearedequipment_type = true
}

// EquipmentTypeCleared returns if the edge equipment_type was cleared.
func (m *ServiceEndpointDefinitionMutation) EquipmentTypeCleared() bool {
	return m.clearedequipment_type
}

// EquipmentTypeID returns the equipment_type id in the mutation.
func (m *ServiceEndpointDefinitionMutation) EquipmentTypeID() (id int, exists bool) {
	if m.equipment_type != nil {
		return *m.equipment_type, true
	}
	return
}

// EquipmentTypeIDs returns the equipment_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EquipmentTypeID instead. It exists only for internal usage by the builders.
func (m *ServiceEndpointDefinitionMutation) EquipmentTypeIDs() (ids []int) {
	if id := m.equipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentType reset all changes of the "equipment_type" edge.
func (m *ServiceEndpointDefinitionMutation) ResetEquipmentType() {
	m.equipment_type = nil
	m.clearedequipment_type = false
}

// Op returns the operation name.
func (m *ServiceEndpointDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ServiceEndpointDefinition).
func (m *ServiceEndpointDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServiceEndpointDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, serviceendpointdefinition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serviceendpointdefinition.FieldUpdateTime)
	}
	if m.role != nil {
		fields = append(fields, serviceendpointdefinition.FieldRole)
	}
	if m.name != nil {
		fields = append(fields, serviceendpointdefinition.FieldName)
	}
	if m.index != nil {
		fields = append(fields, serviceendpointdefinition.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServiceEndpointDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceendpointdefinition.FieldCreateTime:
		return m.CreateTime()
	case serviceendpointdefinition.FieldUpdateTime:
		return m.UpdateTime()
	case serviceendpointdefinition.FieldRole:
		return m.Role()
	case serviceendpointdefinition.FieldName:
		return m.Name()
	case serviceendpointdefinition.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServiceEndpointDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceendpointdefinition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceendpointdefinition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serviceendpointdefinition.FieldRole:
		return m.OldRole(ctx)
	case serviceendpointdefinition.FieldName:
		return m.OldName(ctx)
	case serviceendpointdefinition.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceEndpointDefinition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceEndpointDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceendpointdefinition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceendpointdefinition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serviceendpointdefinition.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case serviceendpointdefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case serviceendpointdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpointDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServiceEndpointDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, serviceendpointdefinition.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServiceEndpointDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceendpointdefinition.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceEndpointDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceendpointdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpointDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServiceEndpointDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceendpointdefinition.FieldRole) {
		fields = append(fields, serviceendpointdefinition.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServiceEndpointDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceEndpointDefinitionMutation) ClearField(name string) error {
	switch name {
	case serviceendpointdefinition.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpointDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServiceEndpointDefinitionMutation) ResetField(name string) error {
	switch name {
	case serviceendpointdefinition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceendpointdefinition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serviceendpointdefinition.FieldRole:
		m.ResetRole()
		return nil
	case serviceendpointdefinition.FieldName:
		m.ResetName()
		return nil
	case serviceendpointdefinition.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpointDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServiceEndpointDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.endpoints != nil {
		edges = append(edges, serviceendpointdefinition.EdgeEndpoints)
	}
	if m.service_type != nil {
		edges = append(edges, serviceendpointdefinition.EdgeServiceType)
	}
	if m.equipment_type != nil {
		edges = append(edges, serviceendpointdefinition.EdgeEquipmentType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServiceEndpointDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceendpointdefinition.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.endpoints))
		for id := range m.endpoints {
			ids = append(ids, id)
		}
		return ids
	case serviceendpointdefinition.EdgeServiceType:
		if id := m.service_type; id != nil {
			return []ent.Value{*id}
		}
	case serviceendpointdefinition.EdgeEquipmentType:
		if id := m.equipment_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServiceEndpointDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedendpoints != nil {
		edges = append(edges, serviceendpointdefinition.EdgeEndpoints)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServiceEndpointDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceendpointdefinition.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.removedendpoints))
		for id := range m.removedendpoints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServiceEndpointDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedendpoints {
		edges = append(edges, serviceendpointdefinition.EdgeEndpoints)
	}
	if m.clearedservice_type {
		edges = append(edges, serviceendpointdefinition.EdgeServiceType)
	}
	if m.clearedequipment_type {
		edges = append(edges, serviceendpointdefinition.EdgeEquipmentType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServiceEndpointDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceendpointdefinition.EdgeEndpoints:
		return m.clearedendpoints
	case serviceendpointdefinition.EdgeServiceType:
		return m.clearedservice_type
	case serviceendpointdefinition.EdgeEquipmentType:
		return m.clearedequipment_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServiceEndpointDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case serviceendpointdefinition.EdgeServiceType:
		m.ClearServiceType()
		return nil
	case serviceendpointdefinition.EdgeEquipmentType:
		m.ClearEquipmentType()
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpointDefinition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServiceEndpointDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case serviceendpointdefinition.EdgeEndpoints:
		m.ResetEndpoints()
		return nil
	case serviceendpointdefinition.EdgeServiceType:
		m.ResetServiceType()
		return nil
	case serviceendpointdefinition.EdgeEquipmentType:
		m.ResetEquipmentType()
		return nil
	}
	return fmt.Errorf("unknown ServiceEndpointDefinition edge %s", name)
}

// ServiceTypeMutation represents an operation that mutate the ServiceTypes
// nodes in the graph.
type ServiceTypeMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	name                        *string
	has_customer                *bool
	is_deleted                  *bool
	discovery_method            *servicetype.DiscoveryMethod
	clearedFields               map[string]struct{}
	services                    map[int]struct{}
	removedservices             map[int]struct{}
	clearedservices             bool
	property_types              map[int]struct{}
	removedproperty_types       map[int]struct{}
	clearedproperty_types       bool
	endpoint_definitions        map[int]struct{}
	removedendpoint_definitions map[int]struct{}
	clearedendpoint_definitions bool
	done                        bool
	oldValue                    func(context.Context) (*ServiceType, error)
	predicates                  []predicate.ServiceType
}

var _ ent.Mutation = (*ServiceTypeMutation)(nil)

// servicetypeOption allows to manage the mutation configuration using functional options.
type servicetypeOption func(*ServiceTypeMutation)

// newServiceTypeMutation creates new mutation for ServiceType.
func newServiceTypeMutation(c config, op Op, opts ...servicetypeOption) *ServiceTypeMutation {
	m := &ServiceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceTypeID sets the id field of the mutation.
func withServiceTypeID(id int) servicetypeOption {
	return func(m *ServiceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceType
		)
		m.oldValue = func(ctx context.Context) (*ServiceType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceType sets the old ServiceType of the mutation.
func withServiceType(node *ServiceType) servicetypeOption {
	return func(m *ServiceTypeMutation) {
		m.oldValue = func(context.Context) (*ServiceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServiceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ServiceTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ServiceTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the ServiceType.
// If the ServiceType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ServiceTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ServiceTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ServiceTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the ServiceType.
// If the ServiceType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ServiceTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ServiceTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ServiceTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ServiceType.
// If the ServiceType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ServiceTypeMutation) ResetName() {
	m.name = nil
}

// SetHasCustomer sets the has_customer field.
func (m *ServiceTypeMutation) SetHasCustomer(b bool) {
	m.has_customer = &b
}

// HasCustomer returns the has_customer value in the mutation.
func (m *ServiceTypeMutation) HasCustomer() (r bool, exists bool) {
	v := m.has_customer
	if v == nil {
		return
	}
	return *v, true
}

// OldHasCustomer returns the old has_customer value of the ServiceType.
// If the ServiceType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceTypeMutation) OldHasCustomer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasCustomer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasCustomer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasCustomer: %w", err)
	}
	return oldValue.HasCustomer, nil
}

// ResetHasCustomer reset all changes of the "has_customer" field.
func (m *ServiceTypeMutation) ResetHasCustomer() {
	m.has_customer = nil
}

// SetIsDeleted sets the is_deleted field.
func (m *ServiceTypeMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the is_deleted value in the mutation.
func (m *ServiceTypeMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old is_deleted value of the ServiceType.
// If the ServiceType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceTypeMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted reset all changes of the "is_deleted" field.
func (m *ServiceTypeMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetDiscoveryMethod sets the discovery_method field.
func (m *ServiceTypeMutation) SetDiscoveryMethod(sm servicetype.DiscoveryMethod) {
	m.discovery_method = &sm
}

// DiscoveryMethod returns the discovery_method value in the mutation.
func (m *ServiceTypeMutation) DiscoveryMethod() (r servicetype.DiscoveryMethod, exists bool) {
	v := m.discovery_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveryMethod returns the old discovery_method value of the ServiceType.
// If the ServiceType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceTypeMutation) OldDiscoveryMethod(ctx context.Context) (v servicetype.DiscoveryMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscoveryMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscoveryMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveryMethod: %w", err)
	}
	return oldValue.DiscoveryMethod, nil
}

// ResetDiscoveryMethod reset all changes of the "discovery_method" field.
func (m *ServiceTypeMutation) ResetDiscoveryMethod() {
	m.discovery_method = nil
}

// AddServiceIDs adds the services edge to Service by ids.
func (m *ServiceTypeMutation) AddServiceIDs(ids ...int) {
	if m.services == nil {
		m.services = make(map[int]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the services edge to Service.
func (m *ServiceTypeMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared returns if the edge services was cleared.
func (m *ServiceTypeMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the services edge to Service by ids.
func (m *ServiceTypeMutation) RemoveServiceIDs(ids ...int) {
	if m.removedservices == nil {
		m.removedservices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed ids of services.
func (m *ServiceTypeMutation) RemovedServicesIDs() (ids []int) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the services ids in the mutation.
func (m *ServiceTypeMutation) ServicesIDs() (ids []int) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices reset all changes of the "services" edge.
func (m *ServiceTypeMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *ServiceTypeMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// ClearPropertyTypes clears the property_types edge to PropertyType.
func (m *ServiceTypeMutation) ClearPropertyTypes() {
	m.clearedproperty_types = true
}

// PropertyTypesCleared returns if the edge property_types was cleared.
func (m *ServiceTypeMutation) PropertyTypesCleared() bool {
	return m.clearedproperty_types
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *ServiceTypeMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *ServiceTypeMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *ServiceTypeMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *ServiceTypeMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.clearedproperty_types = false
	m.removedproperty_types = nil
}

// AddEndpointDefinitionIDs adds the endpoint_definitions edge to ServiceEndpointDefinition by ids.
func (m *ServiceTypeMutation) AddEndpointDefinitionIDs(ids ...int) {
	if m.endpoint_definitions == nil {
		m.endpoint_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.endpoint_definitions[ids[i]] = struct{}{}
	}
}

// ClearEndpointDefinitions clears the endpoint_definitions edge to ServiceEndpointDefinition.
func (m *ServiceTypeMutation) ClearEndpointDefinitions() {
	m.clearedendpoint_definitions = true
}

// EndpointDefinitionsCleared returns if the edge endpoint_definitions was cleared.
func (m *ServiceTypeMutation) EndpointDefinitionsCleared() bool {
	return m.clearedendpoint_definitions
}

// RemoveEndpointDefinitionIDs removes the endpoint_definitions edge to ServiceEndpointDefinition by ids.
func (m *ServiceTypeMutation) RemoveEndpointDefinitionIDs(ids ...int) {
	if m.removedendpoint_definitions == nil {
		m.removedendpoint_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedendpoint_definitions[ids[i]] = struct{}{}
	}
}

// RemovedEndpointDefinitions returns the removed ids of endpoint_definitions.
func (m *ServiceTypeMutation) RemovedEndpointDefinitionsIDs() (ids []int) {
	for id := range m.removedendpoint_definitions {
		ids = append(ids, id)
	}
	return
}

// EndpointDefinitionsIDs returns the endpoint_definitions ids in the mutation.
func (m *ServiceTypeMutation) EndpointDefinitionsIDs() (ids []int) {
	for id := range m.endpoint_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetEndpointDefinitions reset all changes of the "endpoint_definitions" edge.
func (m *ServiceTypeMutation) ResetEndpointDefinitions() {
	m.endpoint_definitions = nil
	m.clearedendpoint_definitions = false
	m.removedendpoint_definitions = nil
}

// Op returns the operation name.
func (m *ServiceTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ServiceType).
func (m *ServiceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServiceTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, servicetype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, servicetype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, servicetype.FieldName)
	}
	if m.has_customer != nil {
		fields = append(fields, servicetype.FieldHasCustomer)
	}
	if m.is_deleted != nil {
		fields = append(fields, servicetype.FieldIsDeleted)
	}
	if m.discovery_method != nil {
		fields = append(fields, servicetype.FieldDiscoveryMethod)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServiceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicetype.FieldCreateTime:
		return m.CreateTime()
	case servicetype.FieldUpdateTime:
		return m.UpdateTime()
	case servicetype.FieldName:
		return m.Name()
	case servicetype.FieldHasCustomer:
		return m.HasCustomer()
	case servicetype.FieldIsDeleted:
		return m.IsDeleted()
	case servicetype.FieldDiscoveryMethod:
		return m.DiscoveryMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServiceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicetype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case servicetype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case servicetype.FieldName:
		return m.OldName(ctx)
	case servicetype.FieldHasCustomer:
		return m.OldHasCustomer(ctx)
	case servicetype.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case servicetype.FieldDiscoveryMethod:
		return m.OldDiscoveryMethod(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicetype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case servicetype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case servicetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servicetype.FieldHasCustomer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasCustomer(v)
		return nil
	case servicetype.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case servicetype.FieldDiscoveryMethod:
		v, ok := value.(servicetype.DiscoveryMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveryMethod(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServiceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServiceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServiceTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServiceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServiceType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServiceTypeMutation) ResetField(name string) error {
	switch name {
	case servicetype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case servicetype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case servicetype.FieldName:
		m.ResetName()
		return nil
	case servicetype.FieldHasCustomer:
		m.ResetHasCustomer()
		return nil
	case servicetype.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case servicetype.FieldDiscoveryMethod:
		m.ResetDiscoveryMethod()
		return nil
	}
	return fmt.Errorf("unknown ServiceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServiceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.services != nil {
		edges = append(edges, servicetype.EdgeServices)
	}
	if m.property_types != nil {
		edges = append(edges, servicetype.EdgePropertyTypes)
	}
	if m.endpoint_definitions != nil {
		edges = append(edges, servicetype.EdgeEndpointDefinitions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServiceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicetype.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case servicetype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	case servicetype.EdgeEndpointDefinitions:
		ids := make([]ent.Value, 0, len(m.endpoint_definitions))
		for id := range m.endpoint_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServiceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedservices != nil {
		edges = append(edges, servicetype.EdgeServices)
	}
	if m.removedproperty_types != nil {
		edges = append(edges, servicetype.EdgePropertyTypes)
	}
	if m.removedendpoint_definitions != nil {
		edges = append(edges, servicetype.EdgeEndpointDefinitions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServiceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servicetype.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	case servicetype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	case servicetype.EdgeEndpointDefinitions:
		ids := make([]ent.Value, 0, len(m.removedendpoint_definitions))
		for id := range m.removedendpoint_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServiceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedservices {
		edges = append(edges, servicetype.EdgeServices)
	}
	if m.clearedproperty_types {
		edges = append(edges, servicetype.EdgePropertyTypes)
	}
	if m.clearedendpoint_definitions {
		edges = append(edges, servicetype.EdgeEndpointDefinitions)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServiceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servicetype.EdgeServices:
		return m.clearedservices
	case servicetype.EdgePropertyTypes:
		return m.clearedproperty_types
	case servicetype.EdgeEndpointDefinitions:
		return m.clearedendpoint_definitions
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServiceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServiceTypeMutation) ResetEdge(name string) error {
	switch name {
	case servicetype.EdgeServices:
		m.ResetServices()
		return nil
	case servicetype.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	case servicetype.EdgeEndpointDefinitions:
		m.ResetEndpointDefinitions()
		return nil
	}
	return fmt.Errorf("unknown ServiceType edge %s", name)
}

// SurveyMutation represents an operation that mutate the Surveys
// nodes in the graph.
type SurveyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	owner_name           *string
	creation_timestamp   *time.Time
	completion_timestamp *time.Time
	clearedFields        map[string]struct{}
	location             *int
	clearedlocation      bool
	source_file          *int
	clearedsource_file   bool
	questions            map[int]struct{}
	removedquestions     map[int]struct{}
	clearedquestions     bool
	done                 bool
	oldValue             func(context.Context) (*Survey, error)
	predicates           []predicate.Survey
}

var _ ent.Mutation = (*SurveyMutation)(nil)

// surveyOption allows to manage the mutation configuration using functional options.
type surveyOption func(*SurveyMutation)

// newSurveyMutation creates new mutation for Survey.
func newSurveyMutation(c config, op Op, opts ...surveyOption) *SurveyMutation {
	m := &SurveyMutation{
		config:        c,
		op:            op,
		typ:           TypeSurvey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyID sets the id field of the mutation.
func withSurveyID(id int) surveyOption {
	return func(m *SurveyMutation) {
		var (
			err   error
			once  sync.Once
			value *Survey
		)
		m.oldValue = func(ctx context.Context) (*Survey, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Survey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurvey sets the old Survey of the mutation.
func withSurvey(node *Survey) surveyOption {
	return func(m *SurveyMutation) {
		m.oldValue = func(context.Context) (*Survey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SurveyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *SurveyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *SurveyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Survey.
// If the Survey object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *SurveyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *SurveyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *SurveyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Survey.
// If the Survey object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *SurveyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *SurveyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *SurveyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Survey.
// If the Survey object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *SurveyMutation) ResetName() {
	m.name = nil
}

// SetOwnerName sets the owner_name field.
func (m *SurveyMutation) SetOwnerName(s string) {
	m.owner_name = &s
}

// OwnerName returns the owner_name value in the mutation.
func (m *SurveyMutation) OwnerName() (r string, exists bool) {
	v := m.owner_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerName returns the old owner_name value of the Survey.
// If the Survey object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyMutation) OldOwnerName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerName: %w", err)
	}
	return oldValue.OwnerName, nil
}

// ClearOwnerName clears the value of owner_name.
func (m *SurveyMutation) ClearOwnerName() {
	m.owner_name = nil
	m.clearedFields[survey.FieldOwnerName] = struct{}{}
}

// OwnerNameCleared returns if the field owner_name was cleared in this mutation.
func (m *SurveyMutation) OwnerNameCleared() bool {
	_, ok := m.clearedFields[survey.FieldOwnerName]
	return ok
}

// ResetOwnerName reset all changes of the "owner_name" field.
func (m *SurveyMutation) ResetOwnerName() {
	m.owner_name = nil
	delete(m.clearedFields, survey.FieldOwnerName)
}

// SetCreationTimestamp sets the creation_timestamp field.
func (m *SurveyMutation) SetCreationTimestamp(t time.Time) {
	m.creation_timestamp = &t
}

// CreationTimestamp returns the creation_timestamp value in the mutation.
func (m *SurveyMutation) CreationTimestamp() (r time.Time, exists bool) {
	v := m.creation_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationTimestamp returns the old creation_timestamp value of the Survey.
// If the Survey object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyMutation) OldCreationTimestamp(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreationTimestamp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreationTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationTimestamp: %w", err)
	}
	return oldValue.CreationTimestamp, nil
}

// ClearCreationTimestamp clears the value of creation_timestamp.
func (m *SurveyMutation) ClearCreationTimestamp() {
	m.creation_timestamp = nil
	m.clearedFields[survey.FieldCreationTimestamp] = struct{}{}
}

// CreationTimestampCleared returns if the field creation_timestamp was cleared in this mutation.
func (m *SurveyMutation) CreationTimestampCleared() bool {
	_, ok := m.clearedFields[survey.FieldCreationTimestamp]
	return ok
}

// ResetCreationTimestamp reset all changes of the "creation_timestamp" field.
func (m *SurveyMutation) ResetCreationTimestamp() {
	m.creation_timestamp = nil
	delete(m.clearedFields, survey.FieldCreationTimestamp)
}

// SetCompletionTimestamp sets the completion_timestamp field.
func (m *SurveyMutation) SetCompletionTimestamp(t time.Time) {
	m.completion_timestamp = &t
}

// CompletionTimestamp returns the completion_timestamp value in the mutation.
func (m *SurveyMutation) CompletionTimestamp() (r time.Time, exists bool) {
	v := m.completion_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTimestamp returns the old completion_timestamp value of the Survey.
// If the Survey object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyMutation) OldCompletionTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompletionTimestamp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompletionTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTimestamp: %w", err)
	}
	return oldValue.CompletionTimestamp, nil
}

// ResetCompletionTimestamp reset all changes of the "completion_timestamp" field.
func (m *SurveyMutation) ResetCompletionTimestamp() {
	m.completion_timestamp = nil
}

// SetLocationID sets the location edge to Location by id.
func (m *SurveyMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *SurveyMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *SurveyMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *SurveyMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *SurveyMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *SurveyMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetSourceFileID sets the source_file edge to File by id.
func (m *SurveyMutation) SetSourceFileID(id int) {
	m.source_file = &id
}

// ClearSourceFile clears the source_file edge to File.
func (m *SurveyMutation) ClearSourceFile() {
	m.clearedsource_file = true
}

// SourceFileCleared returns if the edge source_file was cleared.
func (m *SurveyMutation) SourceFileCleared() bool {
	return m.clearedsource_file
}

// SourceFileID returns the source_file id in the mutation.
func (m *SurveyMutation) SourceFileID() (id int, exists bool) {
	if m.source_file != nil {
		return *m.source_file, true
	}
	return
}

// SourceFileIDs returns the source_file ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SourceFileID instead. It exists only for internal usage by the builders.
func (m *SurveyMutation) SourceFileIDs() (ids []int) {
	if id := m.source_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceFile reset all changes of the "source_file" edge.
func (m *SurveyMutation) ResetSourceFile() {
	m.source_file = nil
	m.clearedsource_file = false
}

// AddQuestionIDs adds the questions edge to SurveyQuestion by ids.
func (m *SurveyMutation) AddQuestionIDs(ids ...int) {
	if m.questions == nil {
		m.questions = make(map[int]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the questions edge to SurveyQuestion.
func (m *SurveyMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared returns if the edge questions was cleared.
func (m *SurveyMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the questions edge to SurveyQuestion by ids.
func (m *SurveyMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed ids of questions.
func (m *SurveyMutation) RemovedQuestionsIDs() (ids []int) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the questions ids in the mutation.
func (m *SurveyMutation) QuestionsIDs() (ids []int) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions reset all changes of the "questions" edge.
func (m *SurveyMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// Op returns the operation name.
func (m *SurveyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Survey).
func (m *SurveyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SurveyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, survey.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, survey.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, survey.FieldName)
	}
	if m.owner_name != nil {
		fields = append(fields, survey.FieldOwnerName)
	}
	if m.creation_timestamp != nil {
		fields = append(fields, survey.FieldCreationTimestamp)
	}
	if m.completion_timestamp != nil {
		fields = append(fields, survey.FieldCompletionTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SurveyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldCreateTime:
		return m.CreateTime()
	case survey.FieldUpdateTime:
		return m.UpdateTime()
	case survey.FieldName:
		return m.Name()
	case survey.FieldOwnerName:
		return m.OwnerName()
	case survey.FieldCreationTimestamp:
		return m.CreationTimestamp()
	case survey.FieldCompletionTimestamp:
		return m.CompletionTimestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SurveyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case survey.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case survey.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case survey.FieldName:
		return m.OldName(ctx)
	case survey.FieldOwnerName:
		return m.OldOwnerName(ctx)
	case survey.FieldCreationTimestamp:
		return m.OldCreationTimestamp(ctx)
	case survey.FieldCompletionTimestamp:
		return m.OldCompletionTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Survey field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case survey.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case survey.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case survey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case survey.FieldOwnerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerName(v)
		return nil
	case survey.FieldCreationTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationTimestamp(v)
		return nil
	case survey.FieldCompletionTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SurveyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SurveyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Survey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SurveyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(survey.FieldOwnerName) {
		fields = append(fields, survey.FieldOwnerName)
	}
	if m.FieldCleared(survey.FieldCreationTimestamp) {
		fields = append(fields, survey.FieldCreationTimestamp)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SurveyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyMutation) ClearField(name string) error {
	switch name {
	case survey.FieldOwnerName:
		m.ClearOwnerName()
		return nil
	case survey.FieldCreationTimestamp:
		m.ClearCreationTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Survey nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SurveyMutation) ResetField(name string) error {
	switch name {
	case survey.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case survey.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case survey.FieldName:
		m.ResetName()
		return nil
	case survey.FieldOwnerName:
		m.ResetOwnerName()
		return nil
	case survey.FieldCreationTimestamp:
		m.ResetCreationTimestamp()
		return nil
	case survey.FieldCompletionTimestamp:
		m.ResetCompletionTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SurveyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.location != nil {
		edges = append(edges, survey.EdgeLocation)
	}
	if m.source_file != nil {
		edges = append(edges, survey.EdgeSourceFile)
	}
	if m.questions != nil {
		edges = append(edges, survey.EdgeQuestions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SurveyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case survey.EdgeSourceFile:
		if id := m.source_file; id != nil {
			return []ent.Value{*id}
		}
	case survey.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SurveyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedquestions != nil {
		edges = append(edges, survey.EdgeQuestions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SurveyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SurveyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlocation {
		edges = append(edges, survey.EdgeLocation)
	}
	if m.clearedsource_file {
		edges = append(edges, survey.EdgeSourceFile)
	}
	if m.clearedquestions {
		edges = append(edges, survey.EdgeQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SurveyMutation) EdgeCleared(name string) bool {
	switch name {
	case survey.EdgeLocation:
		return m.clearedlocation
	case survey.EdgeSourceFile:
		return m.clearedsource_file
	case survey.EdgeQuestions:
		return m.clearedquestions
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SurveyMutation) ClearEdge(name string) error {
	switch name {
	case survey.EdgeLocation:
		m.ClearLocation()
		return nil
	case survey.EdgeSourceFile:
		m.ClearSourceFile()
		return nil
	}
	return fmt.Errorf("unknown Survey unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SurveyMutation) ResetEdge(name string) error {
	switch name {
	case survey.EdgeLocation:
		m.ResetLocation()
		return nil
	case survey.EdgeSourceFile:
		m.ResetSourceFile()
		return nil
	case survey.EdgeQuestions:
		m.ResetQuestions()
		return nil
	}
	return fmt.Errorf("unknown Survey edge %s", name)
}

// SurveyCellScanMutation represents an operation that mutate the SurveyCellScans
// nodes in the graph.
type SurveyCellScanMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	network_type            *surveycellscan.NetworkType
	signal_strength         *int
	addsignal_strength      *int
	timestamp               *time.Time
	base_station_id         *string
	network_id              *string
	system_id               *string
	cell_id                 *string
	location_area_code      *string
	mobile_country_code     *string
	mobile_network_code     *string
	primary_scrambling_code *string
	operator                *string
	arfcn                   *int
	addarfcn                *int
	physical_cell_id        *string
	tracking_area_code      *string
	timing_advance          *int
	addtiming_advance       *int
	earfcn                  *int
	addearfcn               *int
	uarfcn                  *int
	adduarfcn               *int
	latitude                *float64
	addlatitude             *float64
	longitude               *float64
	addlongitude            *float64
	altitude                *float64
	addaltitude             *float64
	heading                 *float64
	addheading              *float64
	rssi                    *float64
	addrssi                 *float64
	clearedFields           map[string]struct{}
	checklist_item          *int
	clearedchecklist_item   bool
	survey_question         *int
	clearedsurvey_question  bool
	location                *int
	clearedlocation         bool
	done                    bool
	oldValue                func(context.Context) (*SurveyCellScan, error)
	predicates              []predicate.SurveyCellScan
}

var _ ent.Mutation = (*SurveyCellScanMutation)(nil)

// surveycellscanOption allows to manage the mutation configuration using functional options.
type surveycellscanOption func(*SurveyCellScanMutation)

// newSurveyCellScanMutation creates new mutation for SurveyCellScan.
func newSurveyCellScanMutation(c config, op Op, opts ...surveycellscanOption) *SurveyCellScanMutation {
	m := &SurveyCellScanMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyCellScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyCellScanID sets the id field of the mutation.
func withSurveyCellScanID(id int) surveycellscanOption {
	return func(m *SurveyCellScanMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyCellScan
		)
		m.oldValue = func(ctx context.Context) (*SurveyCellScan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyCellScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyCellScan sets the old SurveyCellScan of the mutation.
func withSurveyCellScan(node *SurveyCellScan) surveycellscanOption {
	return func(m *SurveyCellScanMutation) {
		m.oldValue = func(context.Context) (*SurveyCellScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyCellScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyCellScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SurveyCellScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *SurveyCellScanMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *SurveyCellScanMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *SurveyCellScanMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *SurveyCellScanMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *SurveyCellScanMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *SurveyCellScanMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNetworkType sets the network_type field.
func (m *SurveyCellScanMutation) SetNetworkType(st surveycellscan.NetworkType) {
	m.network_type = &st
}

// NetworkType returns the network_type value in the mutation.
func (m *SurveyCellScanMutation) NetworkType() (r surveycellscan.NetworkType, exists bool) {
	v := m.network_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkType returns the old network_type value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldNetworkType(ctx context.Context) (v surveycellscan.NetworkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetworkType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetworkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkType: %w", err)
	}
	return oldValue.NetworkType, nil
}

// ResetNetworkType reset all changes of the "network_type" field.
func (m *SurveyCellScanMutation) ResetNetworkType() {
	m.network_type = nil
}

// SetSignalStrength sets the signal_strength field.
func (m *SurveyCellScanMutation) SetSignalStrength(i int) {
	m.signal_strength = &i
	m.addsignal_strength = nil
}

// SignalStrength returns the signal_strength value in the mutation.
func (m *SurveyCellScanMutation) SignalStrength() (r int, exists bool) {
	v := m.signal_strength
	if v == nil {
		return
	}
	return *v, true
}

// OldSignalStrength returns the old signal_strength value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldSignalStrength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSignalStrength is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSignalStrength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignalStrength: %w", err)
	}
	return oldValue.SignalStrength, nil
}

// AddSignalStrength adds i to signal_strength.
func (m *SurveyCellScanMutation) AddSignalStrength(i int) {
	if m.addsignal_strength != nil {
		*m.addsignal_strength += i
	} else {
		m.addsignal_strength = &i
	}
}

// AddedSignalStrength returns the value that was added to the signal_strength field in this mutation.
func (m *SurveyCellScanMutation) AddedSignalStrength() (r int, exists bool) {
	v := m.addsignal_strength
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignalStrength reset all changes of the "signal_strength" field.
func (m *SurveyCellScanMutation) ResetSignalStrength() {
	m.signal_strength = nil
	m.addsignal_strength = nil
}

// SetTimestamp sets the timestamp field.
func (m *SurveyCellScanMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the timestamp value in the mutation.
func (m *SurveyCellScanMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old timestamp value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldTimestamp(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimestamp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ClearTimestamp clears the value of timestamp.
func (m *SurveyCellScanMutation) ClearTimestamp() {
	m.timestamp = nil
	m.clearedFields[surveycellscan.FieldTimestamp] = struct{}{}
}

// TimestampCleared returns if the field timestamp was cleared in this mutation.
func (m *SurveyCellScanMutation) TimestampCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldTimestamp]
	return ok
}

// ResetTimestamp reset all changes of the "timestamp" field.
func (m *SurveyCellScanMutation) ResetTimestamp() {
	m.timestamp = nil
	delete(m.clearedFields, surveycellscan.FieldTimestamp)
}

// SetBaseStationID sets the base_station_id field.
func (m *SurveyCellScanMutation) SetBaseStationID(s string) {
	m.base_station_id = &s
}

// BaseStationID returns the base_station_id value in the mutation.
func (m *SurveyCellScanMutation) BaseStationID() (r string, exists bool) {
	v := m.base_station_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseStationID returns the old base_station_id value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldBaseStationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBaseStationID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBaseStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseStationID: %w", err)
	}
	return oldValue.BaseStationID, nil
}

// ClearBaseStationID clears the value of base_station_id.
func (m *SurveyCellScanMutation) ClearBaseStationID() {
	m.base_station_id = nil
	m.clearedFields[surveycellscan.FieldBaseStationID] = struct{}{}
}

// BaseStationIDCleared returns if the field base_station_id was cleared in this mutation.
func (m *SurveyCellScanMutation) BaseStationIDCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldBaseStationID]
	return ok
}

// ResetBaseStationID reset all changes of the "base_station_id" field.
func (m *SurveyCellScanMutation) ResetBaseStationID() {
	m.base_station_id = nil
	delete(m.clearedFields, surveycellscan.FieldBaseStationID)
}

// SetNetworkID sets the network_id field.
func (m *SurveyCellScanMutation) SetNetworkID(s string) {
	m.network_id = &s
}

// NetworkID returns the network_id value in the mutation.
func (m *SurveyCellScanMutation) NetworkID() (r string, exists bool) {
	v := m.network_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkID returns the old network_id value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldNetworkID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetworkID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetworkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkID: %w", err)
	}
	return oldValue.NetworkID, nil
}

// ClearNetworkID clears the value of network_id.
func (m *SurveyCellScanMutation) ClearNetworkID() {
	m.network_id = nil
	m.clearedFields[surveycellscan.FieldNetworkID] = struct{}{}
}

// NetworkIDCleared returns if the field network_id was cleared in this mutation.
func (m *SurveyCellScanMutation) NetworkIDCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldNetworkID]
	return ok
}

// ResetNetworkID reset all changes of the "network_id" field.
func (m *SurveyCellScanMutation) ResetNetworkID() {
	m.network_id = nil
	delete(m.clearedFields, surveycellscan.FieldNetworkID)
}

// SetSystemID sets the system_id field.
func (m *SurveyCellScanMutation) SetSystemID(s string) {
	m.system_id = &s
}

// SystemID returns the system_id value in the mutation.
func (m *SurveyCellScanMutation) SystemID() (r string, exists bool) {
	v := m.system_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemID returns the old system_id value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldSystemID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSystemID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSystemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemID: %w", err)
	}
	return oldValue.SystemID, nil
}

// ClearSystemID clears the value of system_id.
func (m *SurveyCellScanMutation) ClearSystemID() {
	m.system_id = nil
	m.clearedFields[surveycellscan.FieldSystemID] = struct{}{}
}

// SystemIDCleared returns if the field system_id was cleared in this mutation.
func (m *SurveyCellScanMutation) SystemIDCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldSystemID]
	return ok
}

// ResetSystemID reset all changes of the "system_id" field.
func (m *SurveyCellScanMutation) ResetSystemID() {
	m.system_id = nil
	delete(m.clearedFields, surveycellscan.FieldSystemID)
}

// SetCellID sets the cell_id field.
func (m *SurveyCellScanMutation) SetCellID(s string) {
	m.cell_id = &s
}

// CellID returns the cell_id value in the mutation.
func (m *SurveyCellScanMutation) CellID() (r string, exists bool) {
	v := m.cell_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCellID returns the old cell_id value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldCellID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCellID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCellID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCellID: %w", err)
	}
	return oldValue.CellID, nil
}

// ClearCellID clears the value of cell_id.
func (m *SurveyCellScanMutation) ClearCellID() {
	m.cell_id = nil
	m.clearedFields[surveycellscan.FieldCellID] = struct{}{}
}

// CellIDCleared returns if the field cell_id was cleared in this mutation.
func (m *SurveyCellScanMutation) CellIDCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldCellID]
	return ok
}

// ResetCellID reset all changes of the "cell_id" field.
func (m *SurveyCellScanMutation) ResetCellID() {
	m.cell_id = nil
	delete(m.clearedFields, surveycellscan.FieldCellID)
}

// SetLocationAreaCode sets the location_area_code field.
func (m *SurveyCellScanMutation) SetLocationAreaCode(s string) {
	m.location_area_code = &s
}

// LocationAreaCode returns the location_area_code value in the mutation.
func (m *SurveyCellScanMutation) LocationAreaCode() (r string, exists bool) {
	v := m.location_area_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationAreaCode returns the old location_area_code value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldLocationAreaCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocationAreaCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocationAreaCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationAreaCode: %w", err)
	}
	return oldValue.LocationAreaCode, nil
}

// ClearLocationAreaCode clears the value of location_area_code.
func (m *SurveyCellScanMutation) ClearLocationAreaCode() {
	m.location_area_code = nil
	m.clearedFields[surveycellscan.FieldLocationAreaCode] = struct{}{}
}

// LocationAreaCodeCleared returns if the field location_area_code was cleared in this mutation.
func (m *SurveyCellScanMutation) LocationAreaCodeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldLocationAreaCode]
	return ok
}

// ResetLocationAreaCode reset all changes of the "location_area_code" field.
func (m *SurveyCellScanMutation) ResetLocationAreaCode() {
	m.location_area_code = nil
	delete(m.clearedFields, surveycellscan.FieldLocationAreaCode)
}

// SetMobileCountryCode sets the mobile_country_code field.
func (m *SurveyCellScanMutation) SetMobileCountryCode(s string) {
	m.mobile_country_code = &s
}

// MobileCountryCode returns the mobile_country_code value in the mutation.
func (m *SurveyCellScanMutation) MobileCountryCode() (r string, exists bool) {
	v := m.mobile_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileCountryCode returns the old mobile_country_code value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldMobileCountryCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileCountryCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileCountryCode: %w", err)
	}
	return oldValue.MobileCountryCode, nil
}

// ClearMobileCountryCode clears the value of mobile_country_code.
func (m *SurveyCellScanMutation) ClearMobileCountryCode() {
	m.mobile_country_code = nil
	m.clearedFields[surveycellscan.FieldMobileCountryCode] = struct{}{}
}

// MobileCountryCodeCleared returns if the field mobile_country_code was cleared in this mutation.
func (m *SurveyCellScanMutation) MobileCountryCodeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldMobileCountryCode]
	return ok
}

// ResetMobileCountryCode reset all changes of the "mobile_country_code" field.
func (m *SurveyCellScanMutation) ResetMobileCountryCode() {
	m.mobile_country_code = nil
	delete(m.clearedFields, surveycellscan.FieldMobileCountryCode)
}

// SetMobileNetworkCode sets the mobile_network_code field.
func (m *SurveyCellScanMutation) SetMobileNetworkCode(s string) {
	m.mobile_network_code = &s
}

// MobileNetworkCode returns the mobile_network_code value in the mutation.
func (m *SurveyCellScanMutation) MobileNetworkCode() (r string, exists bool) {
	v := m.mobile_network_code
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNetworkCode returns the old mobile_network_code value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldMobileNetworkCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileNetworkCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileNetworkCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNetworkCode: %w", err)
	}
	return oldValue.MobileNetworkCode, nil
}

// ClearMobileNetworkCode clears the value of mobile_network_code.
func (m *SurveyCellScanMutation) ClearMobileNetworkCode() {
	m.mobile_network_code = nil
	m.clearedFields[surveycellscan.FieldMobileNetworkCode] = struct{}{}
}

// MobileNetworkCodeCleared returns if the field mobile_network_code was cleared in this mutation.
func (m *SurveyCellScanMutation) MobileNetworkCodeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldMobileNetworkCode]
	return ok
}

// ResetMobileNetworkCode reset all changes of the "mobile_network_code" field.
func (m *SurveyCellScanMutation) ResetMobileNetworkCode() {
	m.mobile_network_code = nil
	delete(m.clearedFields, surveycellscan.FieldMobileNetworkCode)
}

// SetPrimaryScramblingCode sets the primary_scrambling_code field.
func (m *SurveyCellScanMutation) SetPrimaryScramblingCode(s string) {
	m.primary_scrambling_code = &s
}

// PrimaryScramblingCode returns the primary_scrambling_code value in the mutation.
func (m *SurveyCellScanMutation) PrimaryScramblingCode() (r string, exists bool) {
	v := m.primary_scrambling_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryScramblingCode returns the old primary_scrambling_code value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldPrimaryScramblingCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrimaryScramblingCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrimaryScramblingCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryScramblingCode: %w", err)
	}
	return oldValue.PrimaryScramblingCode, nil
}

// ClearPrimaryScramblingCode clears the value of primary_scrambling_code.
func (m *SurveyCellScanMutation) ClearPrimaryScramblingCode() {
	m.primary_scrambling_code = nil
	m.clearedFields[surveycellscan.FieldPrimaryScramblingCode] = struct{}{}
}

// PrimaryScramblingCodeCleared returns if the field primary_scrambling_code was cleared in this mutation.
func (m *SurveyCellScanMutation) PrimaryScramblingCodeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldPrimaryScramblingCode]
	return ok
}

// ResetPrimaryScramblingCode reset all changes of the "primary_scrambling_code" field.
func (m *SurveyCellScanMutation) ResetPrimaryScramblingCode() {
	m.primary_scrambling_code = nil
	delete(m.clearedFields, surveycellscan.FieldPrimaryScramblingCode)
}

// SetOperator sets the operator field.
func (m *SurveyCellScanMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the operator value in the mutation.
func (m *SurveyCellScanMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old operator value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldOperator(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperator is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ClearOperator clears the value of operator.
func (m *SurveyCellScanMutation) ClearOperator() {
	m.operator = nil
	m.clearedFields[surveycellscan.FieldOperator] = struct{}{}
}

// OperatorCleared returns if the field operator was cleared in this mutation.
func (m *SurveyCellScanMutation) OperatorCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldOperator]
	return ok
}

// ResetOperator reset all changes of the "operator" field.
func (m *SurveyCellScanMutation) ResetOperator() {
	m.operator = nil
	delete(m.clearedFields, surveycellscan.FieldOperator)
}

// SetArfcn sets the arfcn field.
func (m *SurveyCellScanMutation) SetArfcn(i int) {
	m.arfcn = &i
	m.addarfcn = nil
}

// Arfcn returns the arfcn value in the mutation.
func (m *SurveyCellScanMutation) Arfcn() (r int, exists bool) {
	v := m.arfcn
	if v == nil {
		return
	}
	return *v, true
}

// OldArfcn returns the old arfcn value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldArfcn(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldArfcn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldArfcn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArfcn: %w", err)
	}
	return oldValue.Arfcn, nil
}

// AddArfcn adds i to arfcn.
func (m *SurveyCellScanMutation) AddArfcn(i int) {
	if m.addarfcn != nil {
		*m.addarfcn += i
	} else {
		m.addarfcn = &i
	}
}

// AddedArfcn returns the value that was added to the arfcn field in this mutation.
func (m *SurveyCellScanMutation) AddedArfcn() (r int, exists bool) {
	v := m.addarfcn
	if v == nil {
		return
	}
	return *v, true
}

// ClearArfcn clears the value of arfcn.
func (m *SurveyCellScanMutation) ClearArfcn() {
	m.arfcn = nil
	m.addarfcn = nil
	m.clearedFields[surveycellscan.FieldArfcn] = struct{}{}
}

// ArfcnCleared returns if the field arfcn was cleared in this mutation.
func (m *SurveyCellScanMutation) ArfcnCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldArfcn]
	return ok
}

// ResetArfcn reset all changes of the "arfcn" field.
func (m *SurveyCellScanMutation) ResetArfcn() {
	m.arfcn = nil
	m.addarfcn = nil
	delete(m.clearedFields, surveycellscan.FieldArfcn)
}

// SetPhysicalCellID sets the physical_cell_id field.
func (m *SurveyCellScanMutation) SetPhysicalCellID(s string) {
	m.physical_cell_id = &s
}

// PhysicalCellID returns the physical_cell_id value in the mutation.
func (m *SurveyCellScanMutation) PhysicalCellID() (r string, exists bool) {
	v := m.physical_cell_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicalCellID returns the old physical_cell_id value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldPhysicalCellID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhysicalCellID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhysicalCellID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicalCellID: %w", err)
	}
	return oldValue.PhysicalCellID, nil
}

// ClearPhysicalCellID clears the value of physical_cell_id.
func (m *SurveyCellScanMutation) ClearPhysicalCellID() {
	m.physical_cell_id = nil
	m.clearedFields[surveycellscan.FieldPhysicalCellID] = struct{}{}
}

// PhysicalCellIDCleared returns if the field physical_cell_id was cleared in this mutation.
func (m *SurveyCellScanMutation) PhysicalCellIDCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldPhysicalCellID]
	return ok
}

// ResetPhysicalCellID reset all changes of the "physical_cell_id" field.
func (m *SurveyCellScanMutation) ResetPhysicalCellID() {
	m.physical_cell_id = nil
	delete(m.clearedFields, surveycellscan.FieldPhysicalCellID)
}

// SetTrackingAreaCode sets the tracking_area_code field.
func (m *SurveyCellScanMutation) SetTrackingAreaCode(s string) {
	m.tracking_area_code = &s
}

// TrackingAreaCode returns the tracking_area_code value in the mutation.
func (m *SurveyCellScanMutation) TrackingAreaCode() (r string, exists bool) {
	v := m.tracking_area_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingAreaCode returns the old tracking_area_code value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldTrackingAreaCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTrackingAreaCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTrackingAreaCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingAreaCode: %w", err)
	}
	return oldValue.TrackingAreaCode, nil
}

// ClearTrackingAreaCode clears the value of tracking_area_code.
func (m *SurveyCellScanMutation) ClearTrackingAreaCode() {
	m.tracking_area_code = nil
	m.clearedFields[surveycellscan.FieldTrackingAreaCode] = struct{}{}
}

// TrackingAreaCodeCleared returns if the field tracking_area_code was cleared in this mutation.
func (m *SurveyCellScanMutation) TrackingAreaCodeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldTrackingAreaCode]
	return ok
}

// ResetTrackingAreaCode reset all changes of the "tracking_area_code" field.
func (m *SurveyCellScanMutation) ResetTrackingAreaCode() {
	m.tracking_area_code = nil
	delete(m.clearedFields, surveycellscan.FieldTrackingAreaCode)
}

// SetTimingAdvance sets the timing_advance field.
func (m *SurveyCellScanMutation) SetTimingAdvance(i int) {
	m.timing_advance = &i
	m.addtiming_advance = nil
}

// TimingAdvance returns the timing_advance value in the mutation.
func (m *SurveyCellScanMutation) TimingAdvance() (r int, exists bool) {
	v := m.timing_advance
	if v == nil {
		return
	}
	return *v, true
}

// OldTimingAdvance returns the old timing_advance value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldTimingAdvance(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimingAdvance is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimingAdvance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimingAdvance: %w", err)
	}
	return oldValue.TimingAdvance, nil
}

// AddTimingAdvance adds i to timing_advance.
func (m *SurveyCellScanMutation) AddTimingAdvance(i int) {
	if m.addtiming_advance != nil {
		*m.addtiming_advance += i
	} else {
		m.addtiming_advance = &i
	}
}

// AddedTimingAdvance returns the value that was added to the timing_advance field in this mutation.
func (m *SurveyCellScanMutation) AddedTimingAdvance() (r int, exists bool) {
	v := m.addtiming_advance
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimingAdvance clears the value of timing_advance.
func (m *SurveyCellScanMutation) ClearTimingAdvance() {
	m.timing_advance = nil
	m.addtiming_advance = nil
	m.clearedFields[surveycellscan.FieldTimingAdvance] = struct{}{}
}

// TimingAdvanceCleared returns if the field timing_advance was cleared in this mutation.
func (m *SurveyCellScanMutation) TimingAdvanceCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldTimingAdvance]
	return ok
}

// ResetTimingAdvance reset all changes of the "timing_advance" field.
func (m *SurveyCellScanMutation) ResetTimingAdvance() {
	m.timing_advance = nil
	m.addtiming_advance = nil
	delete(m.clearedFields, surveycellscan.FieldTimingAdvance)
}

// SetEarfcn sets the earfcn field.
func (m *SurveyCellScanMutation) SetEarfcn(i int) {
	m.earfcn = &i
	m.addearfcn = nil
}

// Earfcn returns the earfcn value in the mutation.
func (m *SurveyCellScanMutation) Earfcn() (r int, exists bool) {
	v := m.earfcn
	if v == nil {
		return
	}
	return *v, true
}

// OldEarfcn returns the old earfcn value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldEarfcn(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarfcn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarfcn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarfcn: %w", err)
	}
	return oldValue.Earfcn, nil
}

// AddEarfcn adds i to earfcn.
func (m *SurveyCellScanMutation) AddEarfcn(i int) {
	if m.addearfcn != nil {
		*m.addearfcn += i
	} else {
		m.addearfcn = &i
	}
}

// AddedEarfcn returns the value that was added to the earfcn field in this mutation.
func (m *SurveyCellScanMutation) AddedEarfcn() (r int, exists bool) {
	v := m.addearfcn
	if v == nil {
		return
	}
	return *v, true
}

// ClearEarfcn clears the value of earfcn.
func (m *SurveyCellScanMutation) ClearEarfcn() {
	m.earfcn = nil
	m.addearfcn = nil
	m.clearedFields[surveycellscan.FieldEarfcn] = struct{}{}
}

// EarfcnCleared returns if the field earfcn was cleared in this mutation.
func (m *SurveyCellScanMutation) EarfcnCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldEarfcn]
	return ok
}

// ResetEarfcn reset all changes of the "earfcn" field.
func (m *SurveyCellScanMutation) ResetEarfcn() {
	m.earfcn = nil
	m.addearfcn = nil
	delete(m.clearedFields, surveycellscan.FieldEarfcn)
}

// SetUarfcn sets the uarfcn field.
func (m *SurveyCellScanMutation) SetUarfcn(i int) {
	m.uarfcn = &i
	m.adduarfcn = nil
}

// Uarfcn returns the uarfcn value in the mutation.
func (m *SurveyCellScanMutation) Uarfcn() (r int, exists bool) {
	v := m.uarfcn
	if v == nil {
		return
	}
	return *v, true
}

// OldUarfcn returns the old uarfcn value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldUarfcn(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUarfcn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUarfcn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUarfcn: %w", err)
	}
	return oldValue.Uarfcn, nil
}

// AddUarfcn adds i to uarfcn.
func (m *SurveyCellScanMutation) AddUarfcn(i int) {
	if m.adduarfcn != nil {
		*m.adduarfcn += i
	} else {
		m.adduarfcn = &i
	}
}

// AddedUarfcn returns the value that was added to the uarfcn field in this mutation.
func (m *SurveyCellScanMutation) AddedUarfcn() (r int, exists bool) {
	v := m.adduarfcn
	if v == nil {
		return
	}
	return *v, true
}

// ClearUarfcn clears the value of uarfcn.
func (m *SurveyCellScanMutation) ClearUarfcn() {
	m.uarfcn = nil
	m.adduarfcn = nil
	m.clearedFields[surveycellscan.FieldUarfcn] = struct{}{}
}

// UarfcnCleared returns if the field uarfcn was cleared in this mutation.
func (m *SurveyCellScanMutation) UarfcnCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldUarfcn]
	return ok
}

// ResetUarfcn reset all changes of the "uarfcn" field.
func (m *SurveyCellScanMutation) ResetUarfcn() {
	m.uarfcn = nil
	m.adduarfcn = nil
	delete(m.clearedFields, surveycellscan.FieldUarfcn)
}

// SetLatitude sets the latitude field.
func (m *SurveyCellScanMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the latitude value in the mutation.
func (m *SurveyCellScanMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old latitude value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to latitude.
func (m *SurveyCellScanMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the latitude field in this mutation.
func (m *SurveyCellScanMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of latitude.
func (m *SurveyCellScanMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[surveycellscan.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the field latitude was cleared in this mutation.
func (m *SurveyCellScanMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldLatitude]
	return ok
}

// ResetLatitude reset all changes of the "latitude" field.
func (m *SurveyCellScanMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, surveycellscan.FieldLatitude)
}

// SetLongitude sets the longitude field.
func (m *SurveyCellScanMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the longitude value in the mutation.
func (m *SurveyCellScanMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old longitude value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to longitude.
func (m *SurveyCellScanMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the longitude field in this mutation.
func (m *SurveyCellScanMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of longitude.
func (m *SurveyCellScanMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[surveycellscan.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the field longitude was cleared in this mutation.
func (m *SurveyCellScanMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldLongitude]
	return ok
}

// ResetLongitude reset all changes of the "longitude" field.
func (m *SurveyCellScanMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, surveycellscan.FieldLongitude)
}

// SetAltitude sets the altitude field.
func (m *SurveyCellScanMutation) SetAltitude(f float64) {
	m.altitude = &f
	m.addaltitude = nil
}

// Altitude returns the altitude value in the mutation.
func (m *SurveyCellScanMutation) Altitude() (r float64, exists bool) {
	v := m.altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldAltitude returns the old altitude value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldAltitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAltitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltitude: %w", err)
	}
	return oldValue.Altitude, nil
}

// AddAltitude adds f to altitude.
func (m *SurveyCellScanMutation) AddAltitude(f float64) {
	if m.addaltitude != nil {
		*m.addaltitude += f
	} else {
		m.addaltitude = &f
	}
}

// AddedAltitude returns the value that was added to the altitude field in this mutation.
func (m *SurveyCellScanMutation) AddedAltitude() (r float64, exists bool) {
	v := m.addaltitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearAltitude clears the value of altitude.
func (m *SurveyCellScanMutation) ClearAltitude() {
	m.altitude = nil
	m.addaltitude = nil
	m.clearedFields[surveycellscan.FieldAltitude] = struct{}{}
}

// AltitudeCleared returns if the field altitude was cleared in this mutation.
func (m *SurveyCellScanMutation) AltitudeCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldAltitude]
	return ok
}

// ResetAltitude reset all changes of the "altitude" field.
func (m *SurveyCellScanMutation) ResetAltitude() {
	m.altitude = nil
	m.addaltitude = nil
	delete(m.clearedFields, surveycellscan.FieldAltitude)
}

// SetHeading sets the heading field.
func (m *SurveyCellScanMutation) SetHeading(f float64) {
	m.heading = &f
	m.addheading = nil
}

// Heading returns the heading value in the mutation.
func (m *SurveyCellScanMutation) Heading() (r float64, exists bool) {
	v := m.heading
	if v == nil {
		return
	}
	return *v, true
}

// OldHeading returns the old heading value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldHeading(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeading is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeading: %w", err)
	}
	return oldValue.Heading, nil
}

// AddHeading adds f to heading.
func (m *SurveyCellScanMutation) AddHeading(f float64) {
	if m.addheading != nil {
		*m.addheading += f
	} else {
		m.addheading = &f
	}
}

// AddedHeading returns the value that was added to the heading field in this mutation.
func (m *SurveyCellScanMutation) AddedHeading() (r float64, exists bool) {
	v := m.addheading
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeading clears the value of heading.
func (m *SurveyCellScanMutation) ClearHeading() {
	m.heading = nil
	m.addheading = nil
	m.clearedFields[surveycellscan.FieldHeading] = struct{}{}
}

// HeadingCleared returns if the field heading was cleared in this mutation.
func (m *SurveyCellScanMutation) HeadingCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldHeading]
	return ok
}

// ResetHeading reset all changes of the "heading" field.
func (m *SurveyCellScanMutation) ResetHeading() {
	m.heading = nil
	m.addheading = nil
	delete(m.clearedFields, surveycellscan.FieldHeading)
}

// SetRssi sets the rssi field.
func (m *SurveyCellScanMutation) SetRssi(f float64) {
	m.rssi = &f
	m.addrssi = nil
}

// Rssi returns the rssi value in the mutation.
func (m *SurveyCellScanMutation) Rssi() (r float64, exists bool) {
	v := m.rssi
	if v == nil {
		return
	}
	return *v, true
}

// OldRssi returns the old rssi value of the SurveyCellScan.
// If the SurveyCellScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyCellScanMutation) OldRssi(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRssi is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRssi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRssi: %w", err)
	}
	return oldValue.Rssi, nil
}

// AddRssi adds f to rssi.
func (m *SurveyCellScanMutation) AddRssi(f float64) {
	if m.addrssi != nil {
		*m.addrssi += f
	} else {
		m.addrssi = &f
	}
}

// AddedRssi returns the value that was added to the rssi field in this mutation.
func (m *SurveyCellScanMutation) AddedRssi() (r float64, exists bool) {
	v := m.addrssi
	if v == nil {
		return
	}
	return *v, true
}

// ClearRssi clears the value of rssi.
func (m *SurveyCellScanMutation) ClearRssi() {
	m.rssi = nil
	m.addrssi = nil
	m.clearedFields[surveycellscan.FieldRssi] = struct{}{}
}

// RssiCleared returns if the field rssi was cleared in this mutation.
func (m *SurveyCellScanMutation) RssiCleared() bool {
	_, ok := m.clearedFields[surveycellscan.FieldRssi]
	return ok
}

// ResetRssi reset all changes of the "rssi" field.
func (m *SurveyCellScanMutation) ResetRssi() {
	m.rssi = nil
	m.addrssi = nil
	delete(m.clearedFields, surveycellscan.FieldRssi)
}

// SetChecklistItemID sets the checklist_item edge to CheckListItem by id.
func (m *SurveyCellScanMutation) SetChecklistItemID(id int) {
	m.checklist_item = &id
}

// ClearChecklistItem clears the checklist_item edge to CheckListItem.
func (m *SurveyCellScanMutation) ClearChecklistItem() {
	m.clearedchecklist_item = true
}

// ChecklistItemCleared returns if the edge checklist_item was cleared.
func (m *SurveyCellScanMutation) ChecklistItemCleared() bool {
	return m.clearedchecklist_item
}

// ChecklistItemID returns the checklist_item id in the mutation.
func (m *SurveyCellScanMutation) ChecklistItemID() (id int, exists bool) {
	if m.checklist_item != nil {
		return *m.checklist_item, true
	}
	return
}

// ChecklistItemIDs returns the checklist_item ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ChecklistItemID instead. It exists only for internal usage by the builders.
func (m *SurveyCellScanMutation) ChecklistItemIDs() (ids []int) {
	if id := m.checklist_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChecklistItem reset all changes of the "checklist_item" edge.
func (m *SurveyCellScanMutation) ResetChecklistItem() {
	m.checklist_item = nil
	m.clearedchecklist_item = false
}

// SetSurveyQuestionID sets the survey_question edge to SurveyQuestion by id.
func (m *SurveyCellScanMutation) SetSurveyQuestionID(id int) {
	m.survey_question = &id
}

// ClearSurveyQuestion clears the survey_question edge to SurveyQuestion.
func (m *SurveyCellScanMutation) ClearSurveyQuestion() {
	m.clearedsurvey_question = true
}

// SurveyQuestionCleared returns if the edge survey_question was cleared.
func (m *SurveyCellScanMutation) SurveyQuestionCleared() bool {
	return m.clearedsurvey_question
}

// SurveyQuestionID returns the survey_question id in the mutation.
func (m *SurveyCellScanMutation) SurveyQuestionID() (id int, exists bool) {
	if m.survey_question != nil {
		return *m.survey_question, true
	}
	return
}

// SurveyQuestionIDs returns the survey_question ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SurveyQuestionID instead. It exists only for internal usage by the builders.
func (m *SurveyCellScanMutation) SurveyQuestionIDs() (ids []int) {
	if id := m.survey_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurveyQuestion reset all changes of the "survey_question" edge.
func (m *SurveyCellScanMutation) ResetSurveyQuestion() {
	m.survey_question = nil
	m.clearedsurvey_question = false
}

// SetLocationID sets the location edge to Location by id.
func (m *SurveyCellScanMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *SurveyCellScanMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *SurveyCellScanMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *SurveyCellScanMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *SurveyCellScanMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *SurveyCellScanMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Op returns the operation name.
func (m *SurveyCellScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SurveyCellScan).
func (m *SurveyCellScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SurveyCellScanMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.create_time != nil {
		fields = append(fields, surveycellscan.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, surveycellscan.FieldUpdateTime)
	}
	if m.network_type != nil {
		fields = append(fields, surveycellscan.FieldNetworkType)
	}
	if m.signal_strength != nil {
		fields = append(fields, surveycellscan.FieldSignalStrength)
	}
	if m.timestamp != nil {
		fields = append(fields, surveycellscan.FieldTimestamp)
	}
	if m.base_station_id != nil {
		fields = append(fields, surveycellscan.FieldBaseStationID)
	}
	if m.network_id != nil {
		fields = append(fields, surveycellscan.FieldNetworkID)
	}
	if m.system_id != nil {
		fields = append(fields, surveycellscan.FieldSystemID)
	}
	if m.cell_id != nil {
		fields = append(fields, surveycellscan.FieldCellID)
	}
	if m.location_area_code != nil {
		fields = append(fields, surveycellscan.FieldLocationAreaCode)
	}
	if m.mobile_country_code != nil {
		fields = append(fields, surveycellscan.FieldMobileCountryCode)
	}
	if m.mobile_network_code != nil {
		fields = append(fields, surveycellscan.FieldMobileNetworkCode)
	}
	if m.primary_scrambling_code != nil {
		fields = append(fields, surveycellscan.FieldPrimaryScramblingCode)
	}
	if m.operator != nil {
		fields = append(fields, surveycellscan.FieldOperator)
	}
	if m.arfcn != nil {
		fields = append(fields, surveycellscan.FieldArfcn)
	}
	if m.physical_cell_id != nil {
		fields = append(fields, surveycellscan.FieldPhysicalCellID)
	}
	if m.tracking_area_code != nil {
		fields = append(fields, surveycellscan.FieldTrackingAreaCode)
	}
	if m.timing_advance != nil {
		fields = append(fields, surveycellscan.FieldTimingAdvance)
	}
	if m.earfcn != nil {
		fields = append(fields, surveycellscan.FieldEarfcn)
	}
	if m.uarfcn != nil {
		fields = append(fields, surveycellscan.FieldUarfcn)
	}
	if m.latitude != nil {
		fields = append(fields, surveycellscan.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, surveycellscan.FieldLongitude)
	}
	if m.altitude != nil {
		fields = append(fields, surveycellscan.FieldAltitude)
	}
	if m.heading != nil {
		fields = append(fields, surveycellscan.FieldHeading)
	}
	if m.rssi != nil {
		fields = append(fields, surveycellscan.FieldRssi)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SurveyCellScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveycellscan.FieldCreateTime:
		return m.CreateTime()
	case surveycellscan.FieldUpdateTime:
		return m.UpdateTime()
	case surveycellscan.FieldNetworkType:
		return m.NetworkType()
	case surveycellscan.FieldSignalStrength:
		return m.SignalStrength()
	case surveycellscan.FieldTimestamp:
		return m.Timestamp()
	case surveycellscan.FieldBaseStationID:
		return m.BaseStationID()
	case surveycellscan.FieldNetworkID:
		return m.NetworkID()
	case surveycellscan.FieldSystemID:
		return m.SystemID()
	case surveycellscan.FieldCellID:
		return m.CellID()
	case surveycellscan.FieldLocationAreaCode:
		return m.LocationAreaCode()
	case surveycellscan.FieldMobileCountryCode:
		return m.MobileCountryCode()
	case surveycellscan.FieldMobileNetworkCode:
		return m.MobileNetworkCode()
	case surveycellscan.FieldPrimaryScramblingCode:
		return m.PrimaryScramblingCode()
	case surveycellscan.FieldOperator:
		return m.Operator()
	case surveycellscan.FieldArfcn:
		return m.Arfcn()
	case surveycellscan.FieldPhysicalCellID:
		return m.PhysicalCellID()
	case surveycellscan.FieldTrackingAreaCode:
		return m.TrackingAreaCode()
	case surveycellscan.FieldTimingAdvance:
		return m.TimingAdvance()
	case surveycellscan.FieldEarfcn:
		return m.Earfcn()
	case surveycellscan.FieldUarfcn:
		return m.Uarfcn()
	case surveycellscan.FieldLatitude:
		return m.Latitude()
	case surveycellscan.FieldLongitude:
		return m.Longitude()
	case surveycellscan.FieldAltitude:
		return m.Altitude()
	case surveycellscan.FieldHeading:
		return m.Heading()
	case surveycellscan.FieldRssi:
		return m.Rssi()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SurveyCellScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveycellscan.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case surveycellscan.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case surveycellscan.FieldNetworkType:
		return m.OldNetworkType(ctx)
	case surveycellscan.FieldSignalStrength:
		return m.OldSignalStrength(ctx)
	case surveycellscan.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case surveycellscan.FieldBaseStationID:
		return m.OldBaseStationID(ctx)
	case surveycellscan.FieldNetworkID:
		return m.OldNetworkID(ctx)
	case surveycellscan.FieldSystemID:
		return m.OldSystemID(ctx)
	case surveycellscan.FieldCellID:
		return m.OldCellID(ctx)
	case surveycellscan.FieldLocationAreaCode:
		return m.OldLocationAreaCode(ctx)
	case surveycellscan.FieldMobileCountryCode:
		return m.OldMobileCountryCode(ctx)
	case surveycellscan.FieldMobileNetworkCode:
		return m.OldMobileNetworkCode(ctx)
	case surveycellscan.FieldPrimaryScramblingCode:
		return m.OldPrimaryScramblingCode(ctx)
	case surveycellscan.FieldOperator:
		return m.OldOperator(ctx)
	case surveycellscan.FieldArfcn:
		return m.OldArfcn(ctx)
	case surveycellscan.FieldPhysicalCellID:
		return m.OldPhysicalCellID(ctx)
	case surveycellscan.FieldTrackingAreaCode:
		return m.OldTrackingAreaCode(ctx)
	case surveycellscan.FieldTimingAdvance:
		return m.OldTimingAdvance(ctx)
	case surveycellscan.FieldEarfcn:
		return m.OldEarfcn(ctx)
	case surveycellscan.FieldUarfcn:
		return m.OldUarfcn(ctx)
	case surveycellscan.FieldLatitude:
		return m.OldLatitude(ctx)
	case surveycellscan.FieldLongitude:
		return m.OldLongitude(ctx)
	case surveycellscan.FieldAltitude:
		return m.OldAltitude(ctx)
	case surveycellscan.FieldHeading:
		return m.OldHeading(ctx)
	case surveycellscan.FieldRssi:
		return m.OldRssi(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyCellScan field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyCellScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveycellscan.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case surveycellscan.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case surveycellscan.FieldNetworkType:
		v, ok := value.(surveycellscan.NetworkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkType(v)
		return nil
	case surveycellscan.FieldSignalStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignalStrength(v)
		return nil
	case surveycellscan.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case surveycellscan.FieldBaseStationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseStationID(v)
		return nil
	case surveycellscan.FieldNetworkID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkID(v)
		return nil
	case surveycellscan.FieldSystemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemID(v)
		return nil
	case surveycellscan.FieldCellID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCellID(v)
		return nil
	case surveycellscan.FieldLocationAreaCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationAreaCode(v)
		return nil
	case surveycellscan.FieldMobileCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileCountryCode(v)
		return nil
	case surveycellscan.FieldMobileNetworkCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNetworkCode(v)
		return nil
	case surveycellscan.FieldPrimaryScramblingCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryScramblingCode(v)
		return nil
	case surveycellscan.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case surveycellscan.FieldArfcn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArfcn(v)
		return nil
	case surveycellscan.FieldPhysicalCellID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicalCellID(v)
		return nil
	case surveycellscan.FieldTrackingAreaCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingAreaCode(v)
		return nil
	case surveycellscan.FieldTimingAdvance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimingAdvance(v)
		return nil
	case surveycellscan.FieldEarfcn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarfcn(v)
		return nil
	case surveycellscan.FieldUarfcn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUarfcn(v)
		return nil
	case surveycellscan.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case surveycellscan.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case surveycellscan.FieldAltitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltitude(v)
		return nil
	case surveycellscan.FieldHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeading(v)
		return nil
	case surveycellscan.FieldRssi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRssi(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyCellScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SurveyCellScanMutation) AddedFields() []string {
	var fields []string
	if m.addsignal_strength != nil {
		fields = append(fields, surveycellscan.FieldSignalStrength)
	}
	if m.addarfcn != nil {
		fields = append(fields, surveycellscan.FieldArfcn)
	}
	if m.addtiming_advance != nil {
		fields = append(fields, surveycellscan.FieldTimingAdvance)
	}
	if m.addearfcn != nil {
		fields = append(fields, surveycellscan.FieldEarfcn)
	}
	if m.adduarfcn != nil {
		fields = append(fields, surveycellscan.FieldUarfcn)
	}
	if m.addlatitude != nil {
		fields = append(fields, surveycellscan.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, surveycellscan.FieldLongitude)
	}
	if m.addaltitude != nil {
		fields = append(fields, surveycellscan.FieldAltitude)
	}
	if m.addheading != nil {
		fields = append(fields, surveycellscan.FieldHeading)
	}
	if m.addrssi != nil {
		fields = append(fields, surveycellscan.FieldRssi)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SurveyCellScanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveycellscan.FieldSignalStrength:
		return m.AddedSignalStrength()
	case surveycellscan.FieldArfcn:
		return m.AddedArfcn()
	case surveycellscan.FieldTimingAdvance:
		return m.AddedTimingAdvance()
	case surveycellscan.FieldEarfcn:
		return m.AddedEarfcn()
	case surveycellscan.FieldUarfcn:
		return m.AddedUarfcn()
	case surveycellscan.FieldLatitude:
		return m.AddedLatitude()
	case surveycellscan.FieldLongitude:
		return m.AddedLongitude()
	case surveycellscan.FieldAltitude:
		return m.AddedAltitude()
	case surveycellscan.FieldHeading:
		return m.AddedHeading()
	case surveycellscan.FieldRssi:
		return m.AddedRssi()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyCellScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveycellscan.FieldSignalStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignalStrength(v)
		return nil
	case surveycellscan.FieldArfcn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArfcn(v)
		return nil
	case surveycellscan.FieldTimingAdvance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimingAdvance(v)
		return nil
	case surveycellscan.FieldEarfcn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEarfcn(v)
		return nil
	case surveycellscan.FieldUarfcn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUarfcn(v)
		return nil
	case surveycellscan.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case surveycellscan.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case surveycellscan.FieldAltitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAltitude(v)
		return nil
	case surveycellscan.FieldHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeading(v)
		return nil
	case surveycellscan.FieldRssi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRssi(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyCellScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SurveyCellScanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveycellscan.FieldTimestamp) {
		fields = append(fields, surveycellscan.FieldTimestamp)
	}
	if m.FieldCleared(surveycellscan.FieldBaseStationID) {
		fields = append(fields, surveycellscan.FieldBaseStationID)
	}
	if m.FieldCleared(surveycellscan.FieldNetworkID) {
		fields = append(fields, surveycellscan.FieldNetworkID)
	}
	if m.FieldCleared(surveycellscan.FieldSystemID) {
		fields = append(fields, surveycellscan.FieldSystemID)
	}
	if m.FieldCleared(surveycellscan.FieldCellID) {
		fields = append(fields, surveycellscan.FieldCellID)
	}
	if m.FieldCleared(surveycellscan.FieldLocationAreaCode) {
		fields = append(fields, surveycellscan.FieldLocationAreaCode)
	}
	if m.FieldCleared(surveycellscan.FieldMobileCountryCode) {
		fields = append(fields, surveycellscan.FieldMobileCountryCode)
	}
	if m.FieldCleared(surveycellscan.FieldMobileNetworkCode) {
		fields = append(fields, surveycellscan.FieldMobileNetworkCode)
	}
	if m.FieldCleared(surveycellscan.FieldPrimaryScramblingCode) {
		fields = append(fields, surveycellscan.FieldPrimaryScramblingCode)
	}
	if m.FieldCleared(surveycellscan.FieldOperator) {
		fields = append(fields, surveycellscan.FieldOperator)
	}
	if m.FieldCleared(surveycellscan.FieldArfcn) {
		fields = append(fields, surveycellscan.FieldArfcn)
	}
	if m.FieldCleared(surveycellscan.FieldPhysicalCellID) {
		fields = append(fields, surveycellscan.FieldPhysicalCellID)
	}
	if m.FieldCleared(surveycellscan.FieldTrackingAreaCode) {
		fields = append(fields, surveycellscan.FieldTrackingAreaCode)
	}
	if m.FieldCleared(surveycellscan.FieldTimingAdvance) {
		fields = append(fields, surveycellscan.FieldTimingAdvance)
	}
	if m.FieldCleared(surveycellscan.FieldEarfcn) {
		fields = append(fields, surveycellscan.FieldEarfcn)
	}
	if m.FieldCleared(surveycellscan.FieldUarfcn) {
		fields = append(fields, surveycellscan.FieldUarfcn)
	}
	if m.FieldCleared(surveycellscan.FieldLatitude) {
		fields = append(fields, surveycellscan.FieldLatitude)
	}
	if m.FieldCleared(surveycellscan.FieldLongitude) {
		fields = append(fields, surveycellscan.FieldLongitude)
	}
	if m.FieldCleared(surveycellscan.FieldAltitude) {
		fields = append(fields, surveycellscan.FieldAltitude)
	}
	if m.FieldCleared(surveycellscan.FieldHeading) {
		fields = append(fields, surveycellscan.FieldHeading)
	}
	if m.FieldCleared(surveycellscan.FieldRssi) {
		fields = append(fields, surveycellscan.FieldRssi)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SurveyCellScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyCellScanMutation) ClearField(name string) error {
	switch name {
	case surveycellscan.FieldTimestamp:
		m.ClearTimestamp()
		return nil
	case surveycellscan.FieldBaseStationID:
		m.ClearBaseStationID()
		return nil
	case surveycellscan.FieldNetworkID:
		m.ClearNetworkID()
		return nil
	case surveycellscan.FieldSystemID:
		m.ClearSystemID()
		return nil
	case surveycellscan.FieldCellID:
		m.ClearCellID()
		return nil
	case surveycellscan.FieldLocationAreaCode:
		m.ClearLocationAreaCode()
		return nil
	case surveycellscan.FieldMobileCountryCode:
		m.ClearMobileCountryCode()
		return nil
	case surveycellscan.FieldMobileNetworkCode:
		m.ClearMobileNetworkCode()
		return nil
	case surveycellscan.FieldPrimaryScramblingCode:
		m.ClearPrimaryScramblingCode()
		return nil
	case surveycellscan.FieldOperator:
		m.ClearOperator()
		return nil
	case surveycellscan.FieldArfcn:
		m.ClearArfcn()
		return nil
	case surveycellscan.FieldPhysicalCellID:
		m.ClearPhysicalCellID()
		return nil
	case surveycellscan.FieldTrackingAreaCode:
		m.ClearTrackingAreaCode()
		return nil
	case surveycellscan.FieldTimingAdvance:
		m.ClearTimingAdvance()
		return nil
	case surveycellscan.FieldEarfcn:
		m.ClearEarfcn()
		return nil
	case surveycellscan.FieldUarfcn:
		m.ClearUarfcn()
		return nil
	case surveycellscan.FieldLatitude:
		m.ClearLatitude()
		return nil
	case surveycellscan.FieldLongitude:
		m.ClearLongitude()
		return nil
	case surveycellscan.FieldAltitude:
		m.ClearAltitude()
		return nil
	case surveycellscan.FieldHeading:
		m.ClearHeading()
		return nil
	case surveycellscan.FieldRssi:
		m.ClearRssi()
		return nil
	}
	return fmt.Errorf("unknown SurveyCellScan nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SurveyCellScanMutation) ResetField(name string) error {
	switch name {
	case surveycellscan.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case surveycellscan.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case surveycellscan.FieldNetworkType:
		m.ResetNetworkType()
		return nil
	case surveycellscan.FieldSignalStrength:
		m.ResetSignalStrength()
		return nil
	case surveycellscan.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case surveycellscan.FieldBaseStationID:
		m.ResetBaseStationID()
		return nil
	case surveycellscan.FieldNetworkID:
		m.ResetNetworkID()
		return nil
	case surveycellscan.FieldSystemID:
		m.ResetSystemID()
		return nil
	case surveycellscan.FieldCellID:
		m.ResetCellID()
		return nil
	case surveycellscan.FieldLocationAreaCode:
		m.ResetLocationAreaCode()
		return nil
	case surveycellscan.FieldMobileCountryCode:
		m.ResetMobileCountryCode()
		return nil
	case surveycellscan.FieldMobileNetworkCode:
		m.ResetMobileNetworkCode()
		return nil
	case surveycellscan.FieldPrimaryScramblingCode:
		m.ResetPrimaryScramblingCode()
		return nil
	case surveycellscan.FieldOperator:
		m.ResetOperator()
		return nil
	case surveycellscan.FieldArfcn:
		m.ResetArfcn()
		return nil
	case surveycellscan.FieldPhysicalCellID:
		m.ResetPhysicalCellID()
		return nil
	case surveycellscan.FieldTrackingAreaCode:
		m.ResetTrackingAreaCode()
		return nil
	case surveycellscan.FieldTimingAdvance:
		m.ResetTimingAdvance()
		return nil
	case surveycellscan.FieldEarfcn:
		m.ResetEarfcn()
		return nil
	case surveycellscan.FieldUarfcn:
		m.ResetUarfcn()
		return nil
	case surveycellscan.FieldLatitude:
		m.ResetLatitude()
		return nil
	case surveycellscan.FieldLongitude:
		m.ResetLongitude()
		return nil
	case surveycellscan.FieldAltitude:
		m.ResetAltitude()
		return nil
	case surveycellscan.FieldHeading:
		m.ResetHeading()
		return nil
	case surveycellscan.FieldRssi:
		m.ResetRssi()
		return nil
	}
	return fmt.Errorf("unknown SurveyCellScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SurveyCellScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.checklist_item != nil {
		edges = append(edges, surveycellscan.EdgeChecklistItem)
	}
	if m.survey_question != nil {
		edges = append(edges, surveycellscan.EdgeSurveyQuestion)
	}
	if m.location != nil {
		edges = append(edges, surveycellscan.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SurveyCellScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveycellscan.EdgeChecklistItem:
		if id := m.checklist_item; id != nil {
			return []ent.Value{*id}
		}
	case surveycellscan.EdgeSurveyQuestion:
		if id := m.survey_question; id != nil {
			return []ent.Value{*id}
		}
	case surveycellscan.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SurveyCellScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SurveyCellScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SurveyCellScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchecklist_item {
		edges = append(edges, surveycellscan.EdgeChecklistItem)
	}
	if m.clearedsurvey_question {
		edges = append(edges, surveycellscan.EdgeSurveyQuestion)
	}
	if m.clearedlocation {
		edges = append(edges, surveycellscan.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SurveyCellScanMutation) EdgeCleared(name string) bool {
	switch name {
	case surveycellscan.EdgeChecklistItem:
		return m.clearedchecklist_item
	case surveycellscan.EdgeSurveyQuestion:
		return m.clearedsurvey_question
	case surveycellscan.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SurveyCellScanMutation) ClearEdge(name string) error {
	switch name {
	case surveycellscan.EdgeChecklistItem:
		m.ClearChecklistItem()
		return nil
	case surveycellscan.EdgeSurveyQuestion:
		m.ClearSurveyQuestion()
		return nil
	case surveycellscan.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown SurveyCellScan unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SurveyCellScanMutation) ResetEdge(name string) error {
	switch name {
	case surveycellscan.EdgeChecklistItem:
		m.ResetChecklistItem()
		return nil
	case surveycellscan.EdgeSurveyQuestion:
		m.ResetSurveyQuestion()
		return nil
	case surveycellscan.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown SurveyCellScan edge %s", name)
}

// SurveyQuestionMutation represents an operation that mutate the SurveyQuestions
// nodes in the graph.
type SurveyQuestionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	form_name            *string
	form_description     *string
	form_index           *int
	addform_index        *int
	question_type        *string
	question_format      *string
	question_text        *string
	question_index       *int
	addquestion_index    *int
	bool_data            *bool
	email_data           *string
	latitude             *float64
	addlatitude          *float64
	longitude            *float64
	addlongitude         *float64
	location_accuracy    *float64
	addlocation_accuracy *float64
	altitude             *float64
	addaltitude          *float64
	phone_data           *string
	text_data            *string
	float_data           *float64
	addfloat_data        *float64
	int_data             *int
	addint_data          *int
	date_data            *time.Time
	clearedFields        map[string]struct{}
	survey               *int
	clearedsurvey        bool
	wifi_scan            map[int]struct{}
	removedwifi_scan     map[int]struct{}
	clearedwifi_scan     bool
	cell_scan            map[int]struct{}
	removedcell_scan     map[int]struct{}
	clearedcell_scan     bool
	photo_data           map[int]struct{}
	removedphoto_data    map[int]struct{}
	clearedphoto_data    bool
	images               map[int]struct{}
	removedimages        map[int]struct{}
	clearedimages        bool
	done                 bool
	oldValue             func(context.Context) (*SurveyQuestion, error)
	predicates           []predicate.SurveyQuestion
}

var _ ent.Mutation = (*SurveyQuestionMutation)(nil)

// surveyquestionOption allows to manage the mutation configuration using functional options.
type surveyquestionOption func(*SurveyQuestionMutation)

// newSurveyQuestionMutation creates new mutation for SurveyQuestion.
func newSurveyQuestionMutation(c config, op Op, opts ...surveyquestionOption) *SurveyQuestionMutation {
	m := &SurveyQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyQuestionID sets the id field of the mutation.
func withSurveyQuestionID(id int) surveyquestionOption {
	return func(m *SurveyQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyQuestion
		)
		m.oldValue = func(ctx context.Context) (*SurveyQuestion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyQuestion sets the old SurveyQuestion of the mutation.
func withSurveyQuestion(node *SurveyQuestion) surveyquestionOption {
	return func(m *SurveyQuestionMutation) {
		m.oldValue = func(context.Context) (*SurveyQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SurveyQuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *SurveyQuestionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *SurveyQuestionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *SurveyQuestionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *SurveyQuestionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *SurveyQuestionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *SurveyQuestionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFormName sets the form_name field.
func (m *SurveyQuestionMutation) SetFormName(s string) {
	m.form_name = &s
}

// FormName returns the form_name value in the mutation.
func (m *SurveyQuestionMutation) FormName() (r string, exists bool) {
	v := m.form_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFormName returns the old form_name value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldFormName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormName: %w", err)
	}
	return oldValue.FormName, nil
}

// ClearFormName clears the value of form_name.
func (m *SurveyQuestionMutation) ClearFormName() {
	m.form_name = nil
	m.clearedFields[surveyquestion.FieldFormName] = struct{}{}
}

// FormNameCleared returns if the field form_name was cleared in this mutation.
func (m *SurveyQuestionMutation) FormNameCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldFormName]
	return ok
}

// ResetFormName reset all changes of the "form_name" field.
func (m *SurveyQuestionMutation) ResetFormName() {
	m.form_name = nil
	delete(m.clearedFields, surveyquestion.FieldFormName)
}

// SetFormDescription sets the form_description field.
func (m *SurveyQuestionMutation) SetFormDescription(s string) {
	m.form_description = &s
}

// FormDescription returns the form_description value in the mutation.
func (m *SurveyQuestionMutation) FormDescription() (r string, exists bool) {
	v := m.form_description
	if v == nil {
		return
	}
	return *v, true
}

// OldFormDescription returns the old form_description value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldFormDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormDescription: %w", err)
	}
	return oldValue.FormDescription, nil
}

// ClearFormDescription clears the value of form_description.
func (m *SurveyQuestionMutation) ClearFormDescription() {
	m.form_description = nil
	m.clearedFields[surveyquestion.FieldFormDescription] = struct{}{}
}

// FormDescriptionCleared returns if the field form_description was cleared in this mutation.
func (m *SurveyQuestionMutation) FormDescriptionCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldFormDescription]
	return ok
}

// ResetFormDescription reset all changes of the "form_description" field.
func (m *SurveyQuestionMutation) ResetFormDescription() {
	m.form_description = nil
	delete(m.clearedFields, surveyquestion.FieldFormDescription)
}

// SetFormIndex sets the form_index field.
func (m *SurveyQuestionMutation) SetFormIndex(i int) {
	m.form_index = &i
	m.addform_index = nil
}

// FormIndex returns the form_index value in the mutation.
func (m *SurveyQuestionMutation) FormIndex() (r int, exists bool) {
	v := m.form_index
	if v == nil {
		return
	}
	return *v, true
}

// OldFormIndex returns the old form_index value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldFormIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormIndex: %w", err)
	}
	return oldValue.FormIndex, nil
}

// AddFormIndex adds i to form_index.
func (m *SurveyQuestionMutation) AddFormIndex(i int) {
	if m.addform_index != nil {
		*m.addform_index += i
	} else {
		m.addform_index = &i
	}
}

// AddedFormIndex returns the value that was added to the form_index field in this mutation.
func (m *SurveyQuestionMutation) AddedFormIndex() (r int, exists bool) {
	v := m.addform_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetFormIndex reset all changes of the "form_index" field.
func (m *SurveyQuestionMutation) ResetFormIndex() {
	m.form_index = nil
	m.addform_index = nil
}

// SetQuestionType sets the question_type field.
func (m *SurveyQuestionMutation) SetQuestionType(s string) {
	m.question_type = &s
}

// QuestionType returns the question_type value in the mutation.
func (m *SurveyQuestionMutation) QuestionType() (r string, exists bool) {
	v := m.question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionType returns the old question_type value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldQuestionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionType: %w", err)
	}
	return oldValue.QuestionType, nil
}

// ClearQuestionType clears the value of question_type.
func (m *SurveyQuestionMutation) ClearQuestionType() {
	m.question_type = nil
	m.clearedFields[surveyquestion.FieldQuestionType] = struct{}{}
}

// QuestionTypeCleared returns if the field question_type was cleared in this mutation.
func (m *SurveyQuestionMutation) QuestionTypeCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldQuestionType]
	return ok
}

// ResetQuestionType reset all changes of the "question_type" field.
func (m *SurveyQuestionMutation) ResetQuestionType() {
	m.question_type = nil
	delete(m.clearedFields, surveyquestion.FieldQuestionType)
}

// SetQuestionFormat sets the question_format field.
func (m *SurveyQuestionMutation) SetQuestionFormat(s string) {
	m.question_format = &s
}

// QuestionFormat returns the question_format value in the mutation.
func (m *SurveyQuestionMutation) QuestionFormat() (r string, exists bool) {
	v := m.question_format
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionFormat returns the old question_format value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldQuestionFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionFormat is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionFormat: %w", err)
	}
	return oldValue.QuestionFormat, nil
}

// ClearQuestionFormat clears the value of question_format.
func (m *SurveyQuestionMutation) ClearQuestionFormat() {
	m.question_format = nil
	m.clearedFields[surveyquestion.FieldQuestionFormat] = struct{}{}
}

// QuestionFormatCleared returns if the field question_format was cleared in this mutation.
func (m *SurveyQuestionMutation) QuestionFormatCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldQuestionFormat]
	return ok
}

// ResetQuestionFormat reset all changes of the "question_format" field.
func (m *SurveyQuestionMutation) ResetQuestionFormat() {
	m.question_format = nil
	delete(m.clearedFields, surveyquestion.FieldQuestionFormat)
}

// SetQuestionText sets the question_text field.
func (m *SurveyQuestionMutation) SetQuestionText(s string) {
	m.question_text = &s
}

// QuestionText returns the question_text value in the mutation.
func (m *SurveyQuestionMutation) QuestionText() (r string, exists bool) {
	v := m.question_text
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionText returns the old question_text value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldQuestionText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionText is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionText: %w", err)
	}
	return oldValue.QuestionText, nil
}

// ClearQuestionText clears the value of question_text.
func (m *SurveyQuestionMutation) ClearQuestionText() {
	m.question_text = nil
	m.clearedFields[surveyquestion.FieldQuestionText] = struct{}{}
}

// QuestionTextCleared returns if the field question_text was cleared in this mutation.
func (m *SurveyQuestionMutation) QuestionTextCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldQuestionText]
	return ok
}

// ResetQuestionText reset all changes of the "question_text" field.
func (m *SurveyQuestionMutation) ResetQuestionText() {
	m.question_text = nil
	delete(m.clearedFields, surveyquestion.FieldQuestionText)
}

// SetQuestionIndex sets the question_index field.
func (m *SurveyQuestionMutation) SetQuestionIndex(i int) {
	m.question_index = &i
	m.addquestion_index = nil
}

// QuestionIndex returns the question_index value in the mutation.
func (m *SurveyQuestionMutation) QuestionIndex() (r int, exists bool) {
	v := m.question_index
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionIndex returns the old question_index value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldQuestionIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionIndex: %w", err)
	}
	return oldValue.QuestionIndex, nil
}

// AddQuestionIndex adds i to question_index.
func (m *SurveyQuestionMutation) AddQuestionIndex(i int) {
	if m.addquestion_index != nil {
		*m.addquestion_index += i
	} else {
		m.addquestion_index = &i
	}
}

// AddedQuestionIndex returns the value that was added to the question_index field in this mutation.
func (m *SurveyQuestionMutation) AddedQuestionIndex() (r int, exists bool) {
	v := m.addquestion_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionIndex reset all changes of the "question_index" field.
func (m *SurveyQuestionMutation) ResetQuestionIndex() {
	m.question_index = nil
	m.addquestion_index = nil
}

// SetBoolData sets the bool_data field.
func (m *SurveyQuestionMutation) SetBoolData(b bool) {
	m.bool_data = &b
}

// BoolData returns the bool_data value in the mutation.
func (m *SurveyQuestionMutation) BoolData() (r bool, exists bool) {
	v := m.bool_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolData returns the old bool_data value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldBoolData(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBoolData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBoolData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolData: %w", err)
	}
	return oldValue.BoolData, nil
}

// ClearBoolData clears the value of bool_data.
func (m *SurveyQuestionMutation) ClearBoolData() {
	m.bool_data = nil
	m.clearedFields[surveyquestion.FieldBoolData] = struct{}{}
}

// BoolDataCleared returns if the field bool_data was cleared in this mutation.
func (m *SurveyQuestionMutation) BoolDataCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldBoolData]
	return ok
}

// ResetBoolData reset all changes of the "bool_data" field.
func (m *SurveyQuestionMutation) ResetBoolData() {
	m.bool_data = nil
	delete(m.clearedFields, surveyquestion.FieldBoolData)
}

// SetEmailData sets the email_data field.
func (m *SurveyQuestionMutation) SetEmailData(s string) {
	m.email_data = &s
}

// EmailData returns the email_data value in the mutation.
func (m *SurveyQuestionMutation) EmailData() (r string, exists bool) {
	v := m.email_data
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailData returns the old email_data value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldEmailData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmailData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmailData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailData: %w", err)
	}
	return oldValue.EmailData, nil
}

// ClearEmailData clears the value of email_data.
func (m *SurveyQuestionMutation) ClearEmailData() {
	m.email_data = nil
	m.clearedFields[surveyquestion.FieldEmailData] = struct{}{}
}

// EmailDataCleared returns if the field email_data was cleared in this mutation.
func (m *SurveyQuestionMutation) EmailDataCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldEmailData]
	return ok
}

// ResetEmailData reset all changes of the "email_data" field.
func (m *SurveyQuestionMutation) ResetEmailData() {
	m.email_data = nil
	delete(m.clearedFields, surveyquestion.FieldEmailData)
}

// SetLatitude sets the latitude field.
func (m *SurveyQuestionMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the latitude value in the mutation.
func (m *SurveyQuestionMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old latitude value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to latitude.
func (m *SurveyQuestionMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the latitude field in this mutation.
func (m *SurveyQuestionMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of latitude.
func (m *SurveyQuestionMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[surveyquestion.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the field latitude was cleared in this mutation.
func (m *SurveyQuestionMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldLatitude]
	return ok
}

// ResetLatitude reset all changes of the "latitude" field.
func (m *SurveyQuestionMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, surveyquestion.FieldLatitude)
}

// SetLongitude sets the longitude field.
func (m *SurveyQuestionMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the longitude value in the mutation.
func (m *SurveyQuestionMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old longitude value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to longitude.
func (m *SurveyQuestionMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the longitude field in this mutation.
func (m *SurveyQuestionMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of longitude.
func (m *SurveyQuestionMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[surveyquestion.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the field longitude was cleared in this mutation.
func (m *SurveyQuestionMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldLongitude]
	return ok
}

// ResetLongitude reset all changes of the "longitude" field.
func (m *SurveyQuestionMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, surveyquestion.FieldLongitude)
}

// SetLocationAccuracy sets the location_accuracy field.
func (m *SurveyQuestionMutation) SetLocationAccuracy(f float64) {
	m.location_accuracy = &f
	m.addlocation_accuracy = nil
}

// LocationAccuracy returns the location_accuracy value in the mutation.
func (m *SurveyQuestionMutation) LocationAccuracy() (r float64, exists bool) {
	v := m.location_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationAccuracy returns the old location_accuracy value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldLocationAccuracy(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocationAccuracy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocationAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationAccuracy: %w", err)
	}
	return oldValue.LocationAccuracy, nil
}

// AddLocationAccuracy adds f to location_accuracy.
func (m *SurveyQuestionMutation) AddLocationAccuracy(f float64) {
	if m.addlocation_accuracy != nil {
		*m.addlocation_accuracy += f
	} else {
		m.addlocation_accuracy = &f
	}
}

// AddedLocationAccuracy returns the value that was added to the location_accuracy field in this mutation.
func (m *SurveyQuestionMutation) AddedLocationAccuracy() (r float64, exists bool) {
	v := m.addlocation_accuracy
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationAccuracy clears the value of location_accuracy.
func (m *SurveyQuestionMutation) ClearLocationAccuracy() {
	m.location_accuracy = nil
	m.addlocation_accuracy = nil
	m.clearedFields[surveyquestion.FieldLocationAccuracy] = struct{}{}
}

// LocationAccuracyCleared returns if the field location_accuracy was cleared in this mutation.
func (m *SurveyQuestionMutation) LocationAccuracyCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldLocationAccuracy]
	return ok
}

// ResetLocationAccuracy reset all changes of the "location_accuracy" field.
func (m *SurveyQuestionMutation) ResetLocationAccuracy() {
	m.location_accuracy = nil
	m.addlocation_accuracy = nil
	delete(m.clearedFields, surveyquestion.FieldLocationAccuracy)
}

// SetAltitude sets the altitude field.
func (m *SurveyQuestionMutation) SetAltitude(f float64) {
	m.altitude = &f
	m.addaltitude = nil
}

// Altitude returns the altitude value in the mutation.
func (m *SurveyQuestionMutation) Altitude() (r float64, exists bool) {
	v := m.altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldAltitude returns the old altitude value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldAltitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAltitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltitude: %w", err)
	}
	return oldValue.Altitude, nil
}

// AddAltitude adds f to altitude.
func (m *SurveyQuestionMutation) AddAltitude(f float64) {
	if m.addaltitude != nil {
		*m.addaltitude += f
	} else {
		m.addaltitude = &f
	}
}

// AddedAltitude returns the value that was added to the altitude field in this mutation.
func (m *SurveyQuestionMutation) AddedAltitude() (r float64, exists bool) {
	v := m.addaltitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearAltitude clears the value of altitude.
func (m *SurveyQuestionMutation) ClearAltitude() {
	m.altitude = nil
	m.addaltitude = nil
	m.clearedFields[surveyquestion.FieldAltitude] = struct{}{}
}

// AltitudeCleared returns if the field altitude was cleared in this mutation.
func (m *SurveyQuestionMutation) AltitudeCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldAltitude]
	return ok
}

// ResetAltitude reset all changes of the "altitude" field.
func (m *SurveyQuestionMutation) ResetAltitude() {
	m.altitude = nil
	m.addaltitude = nil
	delete(m.clearedFields, surveyquestion.FieldAltitude)
}

// SetPhoneData sets the phone_data field.
func (m *SurveyQuestionMutation) SetPhoneData(s string) {
	m.phone_data = &s
}

// PhoneData returns the phone_data value in the mutation.
func (m *SurveyQuestionMutation) PhoneData() (r string, exists bool) {
	v := m.phone_data
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneData returns the old phone_data value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldPhoneData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneData: %w", err)
	}
	return oldValue.PhoneData, nil
}

// ClearPhoneData clears the value of phone_data.
func (m *SurveyQuestionMutation) ClearPhoneData() {
	m.phone_data = nil
	m.clearedFields[surveyquestion.FieldPhoneData] = struct{}{}
}

// PhoneDataCleared returns if the field phone_data was cleared in this mutation.
func (m *SurveyQuestionMutation) PhoneDataCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldPhoneData]
	return ok
}

// ResetPhoneData reset all changes of the "phone_data" field.
func (m *SurveyQuestionMutation) ResetPhoneData() {
	m.phone_data = nil
	delete(m.clearedFields, surveyquestion.FieldPhoneData)
}

// SetTextData sets the text_data field.
func (m *SurveyQuestionMutation) SetTextData(s string) {
	m.text_data = &s
}

// TextData returns the text_data value in the mutation.
func (m *SurveyQuestionMutation) TextData() (r string, exists bool) {
	v := m.text_data
	if v == nil {
		return
	}
	return *v, true
}

// OldTextData returns the old text_data value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldTextData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTextData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTextData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextData: %w", err)
	}
	return oldValue.TextData, nil
}

// ClearTextData clears the value of text_data.
func (m *SurveyQuestionMutation) ClearTextData() {
	m.text_data = nil
	m.clearedFields[surveyquestion.FieldTextData] = struct{}{}
}

// TextDataCleared returns if the field text_data was cleared in this mutation.
func (m *SurveyQuestionMutation) TextDataCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldTextData]
	return ok
}

// ResetTextData reset all changes of the "text_data" field.
func (m *SurveyQuestionMutation) ResetTextData() {
	m.text_data = nil
	delete(m.clearedFields, surveyquestion.FieldTextData)
}

// SetFloatData sets the float_data field.
func (m *SurveyQuestionMutation) SetFloatData(f float64) {
	m.float_data = &f
	m.addfloat_data = nil
}

// FloatData returns the float_data value in the mutation.
func (m *SurveyQuestionMutation) FloatData() (r float64, exists bool) {
	v := m.float_data
	if v == nil {
		return
	}
	return *v, true
}

// OldFloatData returns the old float_data value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldFloatData(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloatData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloatData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloatData: %w", err)
	}
	return oldValue.FloatData, nil
}

// AddFloatData adds f to float_data.
func (m *SurveyQuestionMutation) AddFloatData(f float64) {
	if m.addfloat_data != nil {
		*m.addfloat_data += f
	} else {
		m.addfloat_data = &f
	}
}

// AddedFloatData returns the value that was added to the float_data field in this mutation.
func (m *SurveyQuestionMutation) AddedFloatData() (r float64, exists bool) {
	v := m.addfloat_data
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloatData clears the value of float_data.
func (m *SurveyQuestionMutation) ClearFloatData() {
	m.float_data = nil
	m.addfloat_data = nil
	m.clearedFields[surveyquestion.FieldFloatData] = struct{}{}
}

// FloatDataCleared returns if the field float_data was cleared in this mutation.
func (m *SurveyQuestionMutation) FloatDataCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldFloatData]
	return ok
}

// ResetFloatData reset all changes of the "float_data" field.
func (m *SurveyQuestionMutation) ResetFloatData() {
	m.float_data = nil
	m.addfloat_data = nil
	delete(m.clearedFields, surveyquestion.FieldFloatData)
}

// SetIntData sets the int_data field.
func (m *SurveyQuestionMutation) SetIntData(i int) {
	m.int_data = &i
	m.addint_data = nil
}

// IntData returns the int_data value in the mutation.
func (m *SurveyQuestionMutation) IntData() (r int, exists bool) {
	v := m.int_data
	if v == nil {
		return
	}
	return *v, true
}

// OldIntData returns the old int_data value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldIntData(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntData: %w", err)
	}
	return oldValue.IntData, nil
}

// AddIntData adds i to int_data.
func (m *SurveyQuestionMutation) AddIntData(i int) {
	if m.addint_data != nil {
		*m.addint_data += i
	} else {
		m.addint_data = &i
	}
}

// AddedIntData returns the value that was added to the int_data field in this mutation.
func (m *SurveyQuestionMutation) AddedIntData() (r int, exists bool) {
	v := m.addint_data
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntData clears the value of int_data.
func (m *SurveyQuestionMutation) ClearIntData() {
	m.int_data = nil
	m.addint_data = nil
	m.clearedFields[surveyquestion.FieldIntData] = struct{}{}
}

// IntDataCleared returns if the field int_data was cleared in this mutation.
func (m *SurveyQuestionMutation) IntDataCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldIntData]
	return ok
}

// ResetIntData reset all changes of the "int_data" field.
func (m *SurveyQuestionMutation) ResetIntData() {
	m.int_data = nil
	m.addint_data = nil
	delete(m.clearedFields, surveyquestion.FieldIntData)
}

// SetDateData sets the date_data field.
func (m *SurveyQuestionMutation) SetDateData(t time.Time) {
	m.date_data = &t
}

// DateData returns the date_data value in the mutation.
func (m *SurveyQuestionMutation) DateData() (r time.Time, exists bool) {
	v := m.date_data
	if v == nil {
		return
	}
	return *v, true
}

// OldDateData returns the old date_data value of the SurveyQuestion.
// If the SurveyQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyQuestionMutation) OldDateData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateData: %w", err)
	}
	return oldValue.DateData, nil
}

// ClearDateData clears the value of date_data.
func (m *SurveyQuestionMutation) ClearDateData() {
	m.date_data = nil
	m.clearedFields[surveyquestion.FieldDateData] = struct{}{}
}

// DateDataCleared returns if the field date_data was cleared in this mutation.
func (m *SurveyQuestionMutation) DateDataCleared() bool {
	_, ok := m.clearedFields[surveyquestion.FieldDateData]
	return ok
}

// ResetDateData reset all changes of the "date_data" field.
func (m *SurveyQuestionMutation) ResetDateData() {
	m.date_data = nil
	delete(m.clearedFields, surveyquestion.FieldDateData)
}

// SetSurveyID sets the survey edge to Survey by id.
func (m *SurveyQuestionMutation) SetSurveyID(id int) {
	m.survey = &id
}

// ClearSurvey clears the survey edge to Survey.
func (m *SurveyQuestionMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared returns if the edge survey was cleared.
func (m *SurveyQuestionMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyID returns the survey id in the mutation.
func (m *SurveyQuestionMutation) SurveyID() (id int, exists bool) {
	if m.survey != nil {
		return *m.survey, true
	}
	return
}

// SurveyIDs returns the survey ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *SurveyQuestionMutation) SurveyIDs() (ids []int) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey reset all changes of the "survey" edge.
func (m *SurveyQuestionMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// AddWifiScanIDs adds the wifi_scan edge to SurveyWiFiScan by ids.
func (m *SurveyQuestionMutation) AddWifiScanIDs(ids ...int) {
	if m.wifi_scan == nil {
		m.wifi_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.wifi_scan[ids[i]] = struct{}{}
	}
}

// ClearWifiScan clears the wifi_scan edge to SurveyWiFiScan.
func (m *SurveyQuestionMutation) ClearWifiScan() {
	m.clearedwifi_scan = true
}

// WifiScanCleared returns if the edge wifi_scan was cleared.
func (m *SurveyQuestionMutation) WifiScanCleared() bool {
	return m.clearedwifi_scan
}

// RemoveWifiScanIDs removes the wifi_scan edge to SurveyWiFiScan by ids.
func (m *SurveyQuestionMutation) RemoveWifiScanIDs(ids ...int) {
	if m.removedwifi_scan == nil {
		m.removedwifi_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwifi_scan[ids[i]] = struct{}{}
	}
}

// RemovedWifiScan returns the removed ids of wifi_scan.
func (m *SurveyQuestionMutation) RemovedWifiScanIDs() (ids []int) {
	for id := range m.removedwifi_scan {
		ids = append(ids, id)
	}
	return
}

// WifiScanIDs returns the wifi_scan ids in the mutation.
func (m *SurveyQuestionMutation) WifiScanIDs() (ids []int) {
	for id := range m.wifi_scan {
		ids = append(ids, id)
	}
	return
}

// ResetWifiScan reset all changes of the "wifi_scan" edge.
func (m *SurveyQuestionMutation) ResetWifiScan() {
	m.wifi_scan = nil
	m.clearedwifi_scan = false
	m.removedwifi_scan = nil
}

// AddCellScanIDs adds the cell_scan edge to SurveyCellScan by ids.
func (m *SurveyQuestionMutation) AddCellScanIDs(ids ...int) {
	if m.cell_scan == nil {
		m.cell_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.cell_scan[ids[i]] = struct{}{}
	}
}

// ClearCellScan clears the cell_scan edge to SurveyCellScan.
func (m *SurveyQuestionMutation) ClearCellScan() {
	m.clearedcell_scan = true
}

// CellScanCleared returns if the edge cell_scan was cleared.
func (m *SurveyQuestionMutation) CellScanCleared() bool {
	return m.clearedcell_scan
}

// RemoveCellScanIDs removes the cell_scan edge to SurveyCellScan by ids.
func (m *SurveyQuestionMutation) RemoveCellScanIDs(ids ...int) {
	if m.removedcell_scan == nil {
		m.removedcell_scan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcell_scan[ids[i]] = struct{}{}
	}
}

// RemovedCellScan returns the removed ids of cell_scan.
func (m *SurveyQuestionMutation) RemovedCellScanIDs() (ids []int) {
	for id := range m.removedcell_scan {
		ids = append(ids, id)
	}
	return
}

// CellScanIDs returns the cell_scan ids in the mutation.
func (m *SurveyQuestionMutation) CellScanIDs() (ids []int) {
	for id := range m.cell_scan {
		ids = append(ids, id)
	}
	return
}

// ResetCellScan reset all changes of the "cell_scan" edge.
func (m *SurveyQuestionMutation) ResetCellScan() {
	m.cell_scan = nil
	m.clearedcell_scan = false
	m.removedcell_scan = nil
}

// AddPhotoDatumIDs adds the photo_data edge to File by ids.
func (m *SurveyQuestionMutation) AddPhotoDatumIDs(ids ...int) {
	if m.photo_data == nil {
		m.photo_data = make(map[int]struct{})
	}
	for i := range ids {
		m.photo_data[ids[i]] = struct{}{}
	}
}

// ClearPhotoData clears the photo_data edge to File.
func (m *SurveyQuestionMutation) ClearPhotoData() {
	m.clearedphoto_data = true
}

// PhotoDataCleared returns if the edge photo_data was cleared.
func (m *SurveyQuestionMutation) PhotoDataCleared() bool {
	return m.clearedphoto_data
}

// RemovePhotoDatumIDs removes the photo_data edge to File by ids.
func (m *SurveyQuestionMutation) RemovePhotoDatumIDs(ids ...int) {
	if m.removedphoto_data == nil {
		m.removedphoto_data = make(map[int]struct{})
	}
	for i := range ids {
		m.removedphoto_data[ids[i]] = struct{}{}
	}
}

// RemovedPhotoData returns the removed ids of photo_data.
func (m *SurveyQuestionMutation) RemovedPhotoDataIDs() (ids []int) {
	for id := range m.removedphoto_data {
		ids = append(ids, id)
	}
	return
}

// PhotoDataIDs returns the photo_data ids in the mutation.
func (m *SurveyQuestionMutation) PhotoDataIDs() (ids []int) {
	for id := range m.photo_data {
		ids = append(ids, id)
	}
	return
}

// ResetPhotoData reset all changes of the "photo_data" edge.
func (m *SurveyQuestionMutation) ResetPhotoData() {
	m.photo_data = nil
	m.clearedphoto_data = false
	m.removedphoto_data = nil
}

// AddImageIDs adds the images edge to File by ids.
func (m *SurveyQuestionMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the images edge to File.
func (m *SurveyQuestionMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared returns if the edge images was cleared.
func (m *SurveyQuestionMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the images edge to File by ids.
func (m *SurveyQuestionMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed ids of images.
func (m *SurveyQuestionMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the images ids in the mutation.
func (m *SurveyQuestionMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages reset all changes of the "images" edge.
func (m *SurveyQuestionMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Op returns the operation name.
func (m *SurveyQuestionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SurveyQuestion).
func (m *SurveyQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SurveyQuestionMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.create_time != nil {
		fields = append(fields, surveyquestion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, surveyquestion.FieldUpdateTime)
	}
	if m.form_name != nil {
		fields = append(fields, surveyquestion.FieldFormName)
	}
	if m.form_description != nil {
		fields = append(fields, surveyquestion.FieldFormDescription)
	}
	if m.form_index != nil {
		fields = append(fields, surveyquestion.FieldFormIndex)
	}
	if m.question_type != nil {
		fields = append(fields, surveyquestion.FieldQuestionType)
	}
	if m.question_format != nil {
		fields = append(fields, surveyquestion.FieldQuestionFormat)
	}
	if m.question_text != nil {
		fields = append(fields, surveyquestion.FieldQuestionText)
	}
	if m.question_index != nil {
		fields = append(fields, surveyquestion.FieldQuestionIndex)
	}
	if m.bool_data != nil {
		fields = append(fields, surveyquestion.FieldBoolData)
	}
	if m.email_data != nil {
		fields = append(fields, surveyquestion.FieldEmailData)
	}
	if m.latitude != nil {
		fields = append(fields, surveyquestion.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, surveyquestion.FieldLongitude)
	}
	if m.location_accuracy != nil {
		fields = append(fields, surveyquestion.FieldLocationAccuracy)
	}
	if m.altitude != nil {
		fields = append(fields, surveyquestion.FieldAltitude)
	}
	if m.phone_data != nil {
		fields = append(fields, surveyquestion.FieldPhoneData)
	}
	if m.text_data != nil {
		fields = append(fields, surveyquestion.FieldTextData)
	}
	if m.float_data != nil {
		fields = append(fields, surveyquestion.FieldFloatData)
	}
	if m.int_data != nil {
		fields = append(fields, surveyquestion.FieldIntData)
	}
	if m.date_data != nil {
		fields = append(fields, surveyquestion.FieldDateData)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SurveyQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyquestion.FieldCreateTime:
		return m.CreateTime()
	case surveyquestion.FieldUpdateTime:
		return m.UpdateTime()
	case surveyquestion.FieldFormName:
		return m.FormName()
	case surveyquestion.FieldFormDescription:
		return m.FormDescription()
	case surveyquestion.FieldFormIndex:
		return m.FormIndex()
	case surveyquestion.FieldQuestionType:
		return m.QuestionType()
	case surveyquestion.FieldQuestionFormat:
		return m.QuestionFormat()
	case surveyquestion.FieldQuestionText:
		return m.QuestionText()
	case surveyquestion.FieldQuestionIndex:
		return m.QuestionIndex()
	case surveyquestion.FieldBoolData:
		return m.BoolData()
	case surveyquestion.FieldEmailData:
		return m.EmailData()
	case surveyquestion.FieldLatitude:
		return m.Latitude()
	case surveyquestion.FieldLongitude:
		return m.Longitude()
	case surveyquestion.FieldLocationAccuracy:
		return m.LocationAccuracy()
	case surveyquestion.FieldAltitude:
		return m.Altitude()
	case surveyquestion.FieldPhoneData:
		return m.PhoneData()
	case surveyquestion.FieldTextData:
		return m.TextData()
	case surveyquestion.FieldFloatData:
		return m.FloatData()
	case surveyquestion.FieldIntData:
		return m.IntData()
	case surveyquestion.FieldDateData:
		return m.DateData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SurveyQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyquestion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case surveyquestion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case surveyquestion.FieldFormName:
		return m.OldFormName(ctx)
	case surveyquestion.FieldFormDescription:
		return m.OldFormDescription(ctx)
	case surveyquestion.FieldFormIndex:
		return m.OldFormIndex(ctx)
	case surveyquestion.FieldQuestionType:
		return m.OldQuestionType(ctx)
	case surveyquestion.FieldQuestionFormat:
		return m.OldQuestionFormat(ctx)
	case surveyquestion.FieldQuestionText:
		return m.OldQuestionText(ctx)
	case surveyquestion.FieldQuestionIndex:
		return m.OldQuestionIndex(ctx)
	case surveyquestion.FieldBoolData:
		return m.OldBoolData(ctx)
	case surveyquestion.FieldEmailData:
		return m.OldEmailData(ctx)
	case surveyquestion.FieldLatitude:
		return m.OldLatitude(ctx)
	case surveyquestion.FieldLongitude:
		return m.OldLongitude(ctx)
	case surveyquestion.FieldLocationAccuracy:
		return m.OldLocationAccuracy(ctx)
	case surveyquestion.FieldAltitude:
		return m.OldAltitude(ctx)
	case surveyquestion.FieldPhoneData:
		return m.OldPhoneData(ctx)
	case surveyquestion.FieldTextData:
		return m.OldTextData(ctx)
	case surveyquestion.FieldFloatData:
		return m.OldFloatData(ctx)
	case surveyquestion.FieldIntData:
		return m.OldIntData(ctx)
	case surveyquestion.FieldDateData:
		return m.OldDateData(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyquestion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case surveyquestion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case surveyquestion.FieldFormName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormName(v)
		return nil
	case surveyquestion.FieldFormDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormDescription(v)
		return nil
	case surveyquestion.FieldFormIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormIndex(v)
		return nil
	case surveyquestion.FieldQuestionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionType(v)
		return nil
	case surveyquestion.FieldQuestionFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionFormat(v)
		return nil
	case surveyquestion.FieldQuestionText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionText(v)
		return nil
	case surveyquestion.FieldQuestionIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionIndex(v)
		return nil
	case surveyquestion.FieldBoolData:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolData(v)
		return nil
	case surveyquestion.FieldEmailData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailData(v)
		return nil
	case surveyquestion.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case surveyquestion.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case surveyquestion.FieldLocationAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationAccuracy(v)
		return nil
	case surveyquestion.FieldAltitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltitude(v)
		return nil
	case surveyquestion.FieldPhoneData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneData(v)
		return nil
	case surveyquestion.FieldTextData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextData(v)
		return nil
	case surveyquestion.FieldFloatData:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloatData(v)
		return nil
	case surveyquestion.FieldIntData:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntData(v)
		return nil
	case surveyquestion.FieldDateData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateData(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SurveyQuestionMutation) AddedFields() []string {
	var fields []string
	if m.addform_index != nil {
		fields = append(fields, surveyquestion.FieldFormIndex)
	}
	if m.addquestion_index != nil {
		fields = append(fields, surveyquestion.FieldQuestionIndex)
	}
	if m.addlatitude != nil {
		fields = append(fields, surveyquestion.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, surveyquestion.FieldLongitude)
	}
	if m.addlocation_accuracy != nil {
		fields = append(fields, surveyquestion.FieldLocationAccuracy)
	}
	if m.addaltitude != nil {
		fields = append(fields, surveyquestion.FieldAltitude)
	}
	if m.addfloat_data != nil {
		fields = append(fields, surveyquestion.FieldFloatData)
	}
	if m.addint_data != nil {
		fields = append(fields, surveyquestion.FieldIntData)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SurveyQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveyquestion.FieldFormIndex:
		return m.AddedFormIndex()
	case surveyquestion.FieldQuestionIndex:
		return m.AddedQuestionIndex()
	case surveyquestion.FieldLatitude:
		return m.AddedLatitude()
	case surveyquestion.FieldLongitude:
		return m.AddedLongitude()
	case surveyquestion.FieldLocationAccuracy:
		return m.AddedLocationAccuracy()
	case surveyquestion.FieldAltitude:
		return m.AddedAltitude()
	case surveyquestion.FieldFloatData:
		return m.AddedFloatData()
	case surveyquestion.FieldIntData:
		return m.AddedIntData()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveyquestion.FieldFormIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFormIndex(v)
		return nil
	case surveyquestion.FieldQuestionIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionIndex(v)
		return nil
	case surveyquestion.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case surveyquestion.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case surveyquestion.FieldLocationAccuracy:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationAccuracy(v)
		return nil
	case surveyquestion.FieldAltitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAltitude(v)
		return nil
	case surveyquestion.FieldFloatData:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloatData(v)
		return nil
	case surveyquestion.FieldIntData:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntData(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SurveyQuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveyquestion.FieldFormName) {
		fields = append(fields, surveyquestion.FieldFormName)
	}
	if m.FieldCleared(surveyquestion.FieldFormDescription) {
		fields = append(fields, surveyquestion.FieldFormDescription)
	}
	if m.FieldCleared(surveyquestion.FieldQuestionType) {
		fields = append(fields, surveyquestion.FieldQuestionType)
	}
	if m.FieldCleared(surveyquestion.FieldQuestionFormat) {
		fields = append(fields, surveyquestion.FieldQuestionFormat)
	}
	if m.FieldCleared(surveyquestion.FieldQuestionText) {
		fields = append(fields, surveyquestion.FieldQuestionText)
	}
	if m.FieldCleared(surveyquestion.FieldBoolData) {
		fields = append(fields, surveyquestion.FieldBoolData)
	}
	if m.FieldCleared(surveyquestion.FieldEmailData) {
		fields = append(fields, surveyquestion.FieldEmailData)
	}
	if m.FieldCleared(surveyquestion.FieldLatitude) {
		fields = append(fields, surveyquestion.FieldLatitude)
	}
	if m.FieldCleared(surveyquestion.FieldLongitude) {
		fields = append(fields, surveyquestion.FieldLongitude)
	}
	if m.FieldCleared(surveyquestion.FieldLocationAccuracy) {
		fields = append(fields, surveyquestion.FieldLocationAccuracy)
	}
	if m.FieldCleared(surveyquestion.FieldAltitude) {
		fields = append(fields, surveyquestion.FieldAltitude)
	}
	if m.FieldCleared(surveyquestion.FieldPhoneData) {
		fields = append(fields, surveyquestion.FieldPhoneData)
	}
	if m.FieldCleared(surveyquestion.FieldTextData) {
		fields = append(fields, surveyquestion.FieldTextData)
	}
	if m.FieldCleared(surveyquestion.FieldFloatData) {
		fields = append(fields, surveyquestion.FieldFloatData)
	}
	if m.FieldCleared(surveyquestion.FieldIntData) {
		fields = append(fields, surveyquestion.FieldIntData)
	}
	if m.FieldCleared(surveyquestion.FieldDateData) {
		fields = append(fields, surveyquestion.FieldDateData)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SurveyQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyQuestionMutation) ClearField(name string) error {
	switch name {
	case surveyquestion.FieldFormName:
		m.ClearFormName()
		return nil
	case surveyquestion.FieldFormDescription:
		m.ClearFormDescription()
		return nil
	case surveyquestion.FieldQuestionType:
		m.ClearQuestionType()
		return nil
	case surveyquestion.FieldQuestionFormat:
		m.ClearQuestionFormat()
		return nil
	case surveyquestion.FieldQuestionText:
		m.ClearQuestionText()
		return nil
	case surveyquestion.FieldBoolData:
		m.ClearBoolData()
		return nil
	case surveyquestion.FieldEmailData:
		m.ClearEmailData()
		return nil
	case surveyquestion.FieldLatitude:
		m.ClearLatitude()
		return nil
	case surveyquestion.FieldLongitude:
		m.ClearLongitude()
		return nil
	case surveyquestion.FieldLocationAccuracy:
		m.ClearLocationAccuracy()
		return nil
	case surveyquestion.FieldAltitude:
		m.ClearAltitude()
		return nil
	case surveyquestion.FieldPhoneData:
		m.ClearPhoneData()
		return nil
	case surveyquestion.FieldTextData:
		m.ClearTextData()
		return nil
	case surveyquestion.FieldFloatData:
		m.ClearFloatData()
		return nil
	case surveyquestion.FieldIntData:
		m.ClearIntData()
		return nil
	case surveyquestion.FieldDateData:
		m.ClearDateData()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SurveyQuestionMutation) ResetField(name string) error {
	switch name {
	case surveyquestion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case surveyquestion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case surveyquestion.FieldFormName:
		m.ResetFormName()
		return nil
	case surveyquestion.FieldFormDescription:
		m.ResetFormDescription()
		return nil
	case surveyquestion.FieldFormIndex:
		m.ResetFormIndex()
		return nil
	case surveyquestion.FieldQuestionType:
		m.ResetQuestionType()
		return nil
	case surveyquestion.FieldQuestionFormat:
		m.ResetQuestionFormat()
		return nil
	case surveyquestion.FieldQuestionText:
		m.ResetQuestionText()
		return nil
	case surveyquestion.FieldQuestionIndex:
		m.ResetQuestionIndex()
		return nil
	case surveyquestion.FieldBoolData:
		m.ResetBoolData()
		return nil
	case surveyquestion.FieldEmailData:
		m.ResetEmailData()
		return nil
	case surveyquestion.FieldLatitude:
		m.ResetLatitude()
		return nil
	case surveyquestion.FieldLongitude:
		m.ResetLongitude()
		return nil
	case surveyquestion.FieldLocationAccuracy:
		m.ResetLocationAccuracy()
		return nil
	case surveyquestion.FieldAltitude:
		m.ResetAltitude()
		return nil
	case surveyquestion.FieldPhoneData:
		m.ResetPhoneData()
		return nil
	case surveyquestion.FieldTextData:
		m.ResetTextData()
		return nil
	case surveyquestion.FieldFloatData:
		m.ResetFloatData()
		return nil
	case surveyquestion.FieldIntData:
		m.ResetIntData()
		return nil
	case surveyquestion.FieldDateData:
		m.ResetDateData()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SurveyQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.survey != nil {
		edges = append(edges, surveyquestion.EdgeSurvey)
	}
	if m.wifi_scan != nil {
		edges = append(edges, surveyquestion.EdgeWifiScan)
	}
	if m.cell_scan != nil {
		edges = append(edges, surveyquestion.EdgeCellScan)
	}
	if m.photo_data != nil {
		edges = append(edges, surveyquestion.EdgePhotoData)
	}
	if m.images != nil {
		edges = append(edges, surveyquestion.EdgeImages)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SurveyQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveyquestion.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	case surveyquestion.EdgeWifiScan:
		ids := make([]ent.Value, 0, len(m.wifi_scan))
		for id := range m.wifi_scan {
			ids = append(ids, id)
		}
		return ids
	case surveyquestion.EdgeCellScan:
		ids := make([]ent.Value, 0, len(m.cell_scan))
		for id := range m.cell_scan {
			ids = append(ids, id)
		}
		return ids
	case surveyquestion.EdgePhotoData:
		ids := make([]ent.Value, 0, len(m.photo_data))
		for id := range m.photo_data {
			ids = append(ids, id)
		}
		return ids
	case surveyquestion.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SurveyQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedwifi_scan != nil {
		edges = append(edges, surveyquestion.EdgeWifiScan)
	}
	if m.removedcell_scan != nil {
		edges = append(edges, surveyquestion.EdgeCellScan)
	}
	if m.removedphoto_data != nil {
		edges = append(edges, surveyquestion.EdgePhotoData)
	}
	if m.removedimages != nil {
		edges = append(edges, surveyquestion.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SurveyQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case surveyquestion.EdgeWifiScan:
		ids := make([]ent.Value, 0, len(m.removedwifi_scan))
		for id := range m.removedwifi_scan {
			ids = append(ids, id)
		}
		return ids
	case surveyquestion.EdgeCellScan:
		ids := make([]ent.Value, 0, len(m.removedcell_scan))
		for id := range m.removedcell_scan {
			ids = append(ids, id)
		}
		return ids
	case surveyquestion.EdgePhotoData:
		ids := make([]ent.Value, 0, len(m.removedphoto_data))
		for id := range m.removedphoto_data {
			ids = append(ids, id)
		}
		return ids
	case surveyquestion.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SurveyQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsurvey {
		edges = append(edges, surveyquestion.EdgeSurvey)
	}
	if m.clearedwifi_scan {
		edges = append(edges, surveyquestion.EdgeWifiScan)
	}
	if m.clearedcell_scan {
		edges = append(edges, surveyquestion.EdgeCellScan)
	}
	if m.clearedphoto_data {
		edges = append(edges, surveyquestion.EdgePhotoData)
	}
	if m.clearedimages {
		edges = append(edges, surveyquestion.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SurveyQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case surveyquestion.EdgeSurvey:
		return m.clearedsurvey
	case surveyquestion.EdgeWifiScan:
		return m.clearedwifi_scan
	case surveyquestion.EdgeCellScan:
		return m.clearedcell_scan
	case surveyquestion.EdgePhotoData:
		return m.clearedphoto_data
	case surveyquestion.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SurveyQuestionMutation) ClearEdge(name string) error {
	switch name {
	case surveyquestion.EdgeSurvey:
		m.ClearSurvey()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SurveyQuestionMutation) ResetEdge(name string) error {
	switch name {
	case surveyquestion.EdgeSurvey:
		m.ResetSurvey()
		return nil
	case surveyquestion.EdgeWifiScan:
		m.ResetWifiScan()
		return nil
	case surveyquestion.EdgeCellScan:
		m.ResetCellScan()
		return nil
	case surveyquestion.EdgePhotoData:
		m.ResetPhotoData()
		return nil
	case surveyquestion.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown SurveyQuestion edge %s", name)
}

// SurveyTemplateCategoryMutation represents an operation that mutate the SurveyTemplateCategories
// nodes in the graph.
type SurveyTemplateCategoryMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	create_time                      *time.Time
	update_time                      *time.Time
	category_title                   *string
	category_description             *string
	clearedFields                    map[string]struct{}
	survey_template_questions        map[int]struct{}
	removedsurvey_template_questions map[int]struct{}
	clearedsurvey_template_questions bool
	location_type                    *int
	clearedlocation_type             bool
	done                             bool
	oldValue                         func(context.Context) (*SurveyTemplateCategory, error)
	predicates                       []predicate.SurveyTemplateCategory
}

var _ ent.Mutation = (*SurveyTemplateCategoryMutation)(nil)

// surveytemplatecategoryOption allows to manage the mutation configuration using functional options.
type surveytemplatecategoryOption func(*SurveyTemplateCategoryMutation)

// newSurveyTemplateCategoryMutation creates new mutation for SurveyTemplateCategory.
func newSurveyTemplateCategoryMutation(c config, op Op, opts ...surveytemplatecategoryOption) *SurveyTemplateCategoryMutation {
	m := &SurveyTemplateCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyTemplateCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyTemplateCategoryID sets the id field of the mutation.
func withSurveyTemplateCategoryID(id int) surveytemplatecategoryOption {
	return func(m *SurveyTemplateCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyTemplateCategory
		)
		m.oldValue = func(ctx context.Context) (*SurveyTemplateCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyTemplateCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyTemplateCategory sets the old SurveyTemplateCategory of the mutation.
func withSurveyTemplateCategory(node *SurveyTemplateCategory) surveytemplatecategoryOption {
	return func(m *SurveyTemplateCategoryMutation) {
		m.oldValue = func(context.Context) (*SurveyTemplateCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyTemplateCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyTemplateCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SurveyTemplateCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *SurveyTemplateCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *SurveyTemplateCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the SurveyTemplateCategory.
// If the SurveyTemplateCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *SurveyTemplateCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *SurveyTemplateCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *SurveyTemplateCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the SurveyTemplateCategory.
// If the SurveyTemplateCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *SurveyTemplateCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCategoryTitle sets the category_title field.
func (m *SurveyTemplateCategoryMutation) SetCategoryTitle(s string) {
	m.category_title = &s
}

// CategoryTitle returns the category_title value in the mutation.
func (m *SurveyTemplateCategoryMutation) CategoryTitle() (r string, exists bool) {
	v := m.category_title
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryTitle returns the old category_title value of the SurveyTemplateCategory.
// If the SurveyTemplateCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateCategoryMutation) OldCategoryTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryTitle: %w", err)
	}
	return oldValue.CategoryTitle, nil
}

// ResetCategoryTitle reset all changes of the "category_title" field.
func (m *SurveyTemplateCategoryMutation) ResetCategoryTitle() {
	m.category_title = nil
}

// SetCategoryDescription sets the category_description field.
func (m *SurveyTemplateCategoryMutation) SetCategoryDescription(s string) {
	m.category_description = &s
}

// CategoryDescription returns the category_description value in the mutation.
func (m *SurveyTemplateCategoryMutation) CategoryDescription() (r string, exists bool) {
	v := m.category_description
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryDescription returns the old category_description value of the SurveyTemplateCategory.
// If the SurveyTemplateCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateCategoryMutation) OldCategoryDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryDescription: %w", err)
	}
	return oldValue.CategoryDescription, nil
}

// ResetCategoryDescription reset all changes of the "category_description" field.
func (m *SurveyTemplateCategoryMutation) ResetCategoryDescription() {
	m.category_description = nil
}

// AddSurveyTemplateQuestionIDs adds the survey_template_questions edge to SurveyTemplateQuestion by ids.
func (m *SurveyTemplateCategoryMutation) AddSurveyTemplateQuestionIDs(ids ...int) {
	if m.survey_template_questions == nil {
		m.survey_template_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.survey_template_questions[ids[i]] = struct{}{}
	}
}

// ClearSurveyTemplateQuestions clears the survey_template_questions edge to SurveyTemplateQuestion.
func (m *SurveyTemplateCategoryMutation) ClearSurveyTemplateQuestions() {
	m.clearedsurvey_template_questions = true
}

// SurveyTemplateQuestionsCleared returns if the edge survey_template_questions was cleared.
func (m *SurveyTemplateCategoryMutation) SurveyTemplateQuestionsCleared() bool {
	return m.clearedsurvey_template_questions
}

// RemoveSurveyTemplateQuestionIDs removes the survey_template_questions edge to SurveyTemplateQuestion by ids.
func (m *SurveyTemplateCategoryMutation) RemoveSurveyTemplateQuestionIDs(ids ...int) {
	if m.removedsurvey_template_questions == nil {
		m.removedsurvey_template_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsurvey_template_questions[ids[i]] = struct{}{}
	}
}

// RemovedSurveyTemplateQuestions returns the removed ids of survey_template_questions.
func (m *SurveyTemplateCategoryMutation) RemovedSurveyTemplateQuestionsIDs() (ids []int) {
	for id := range m.removedsurvey_template_questions {
		ids = append(ids, id)
	}
	return
}

// SurveyTemplateQuestionsIDs returns the survey_template_questions ids in the mutation.
func (m *SurveyTemplateCategoryMutation) SurveyTemplateQuestionsIDs() (ids []int) {
	for id := range m.survey_template_questions {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyTemplateQuestions reset all changes of the "survey_template_questions" edge.
func (m *SurveyTemplateCategoryMutation) ResetSurveyTemplateQuestions() {
	m.survey_template_questions = nil
	m.clearedsurvey_template_questions = false
	m.removedsurvey_template_questions = nil
}

// SetLocationTypeID sets the location_type edge to LocationType by id.
func (m *SurveyTemplateCategoryMutation) SetLocationTypeID(id int) {
	m.location_type = &id
}

// ClearLocationType clears the location_type edge to LocationType.
func (m *SurveyTemplateCategoryMutation) ClearLocationType() {
	m.clearedlocation_type = true
}

// LocationTypeCleared returns if the edge location_type was cleared.
func (m *SurveyTemplateCategoryMutation) LocationTypeCleared() bool {
	return m.clearedlocation_type
}

// LocationTypeID returns the location_type id in the mutation.
func (m *SurveyTemplateCategoryMutation) LocationTypeID() (id int, exists bool) {
	if m.location_type != nil {
		return *m.location_type, true
	}
	return
}

// LocationTypeIDs returns the location_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationTypeID instead. It exists only for internal usage by the builders.
func (m *SurveyTemplateCategoryMutation) LocationTypeIDs() (ids []int) {
	if id := m.location_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocationType reset all changes of the "location_type" edge.
func (m *SurveyTemplateCategoryMutation) ResetLocationType() {
	m.location_type = nil
	m.clearedlocation_type = false
}

// Op returns the operation name.
func (m *SurveyTemplateCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SurveyTemplateCategory).
func (m *SurveyTemplateCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SurveyTemplateCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, surveytemplatecategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, surveytemplatecategory.FieldUpdateTime)
	}
	if m.category_title != nil {
		fields = append(fields, surveytemplatecategory.FieldCategoryTitle)
	}
	if m.category_description != nil {
		fields = append(fields, surveytemplatecategory.FieldCategoryDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SurveyTemplateCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveytemplatecategory.FieldCreateTime:
		return m.CreateTime()
	case surveytemplatecategory.FieldUpdateTime:
		return m.UpdateTime()
	case surveytemplatecategory.FieldCategoryTitle:
		return m.CategoryTitle()
	case surveytemplatecategory.FieldCategoryDescription:
		return m.CategoryDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SurveyTemplateCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveytemplatecategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case surveytemplatecategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case surveytemplatecategory.FieldCategoryTitle:
		return m.OldCategoryTitle(ctx)
	case surveytemplatecategory.FieldCategoryDescription:
		return m.OldCategoryDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyTemplateCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyTemplateCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveytemplatecategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case surveytemplatecategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case surveytemplatecategory.FieldCategoryTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryTitle(v)
		return nil
	case surveytemplatecategory.FieldCategoryDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SurveyTemplateCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SurveyTemplateCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyTemplateCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SurveyTemplateCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SurveyTemplateCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SurveyTemplateCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyTemplateCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SurveyTemplateCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SurveyTemplateCategoryMutation) ResetField(name string) error {
	switch name {
	case surveytemplatecategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case surveytemplatecategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case surveytemplatecategory.FieldCategoryTitle:
		m.ResetCategoryTitle()
		return nil
	case surveytemplatecategory.FieldCategoryDescription:
		m.ResetCategoryDescription()
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SurveyTemplateCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.survey_template_questions != nil {
		edges = append(edges, surveytemplatecategory.EdgeSurveyTemplateQuestions)
	}
	if m.location_type != nil {
		edges = append(edges, surveytemplatecategory.EdgeLocationType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SurveyTemplateCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveytemplatecategory.EdgeSurveyTemplateQuestions:
		ids := make([]ent.Value, 0, len(m.survey_template_questions))
		for id := range m.survey_template_questions {
			ids = append(ids, id)
		}
		return ids
	case surveytemplatecategory.EdgeLocationType:
		if id := m.location_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SurveyTemplateCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsurvey_template_questions != nil {
		edges = append(edges, surveytemplatecategory.EdgeSurveyTemplateQuestions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SurveyTemplateCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case surveytemplatecategory.EdgeSurveyTemplateQuestions:
		ids := make([]ent.Value, 0, len(m.removedsurvey_template_questions))
		for id := range m.removedsurvey_template_questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SurveyTemplateCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsurvey_template_questions {
		edges = append(edges, surveytemplatecategory.EdgeSurveyTemplateQuestions)
	}
	if m.clearedlocation_type {
		edges = append(edges, surveytemplatecategory.EdgeLocationType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SurveyTemplateCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case surveytemplatecategory.EdgeSurveyTemplateQuestions:
		return m.clearedsurvey_template_questions
	case surveytemplatecategory.EdgeLocationType:
		return m.clearedlocation_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SurveyTemplateCategoryMutation) ClearEdge(name string) error {
	switch name {
	case surveytemplatecategory.EdgeLocationType:
		m.ClearLocationType()
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SurveyTemplateCategoryMutation) ResetEdge(name string) error {
	switch name {
	case surveytemplatecategory.EdgeSurveyTemplateQuestions:
		m.ResetSurveyTemplateQuestions()
		return nil
	case surveytemplatecategory.EdgeLocationType:
		m.ResetLocationType()
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateCategory edge %s", name)
}

// SurveyTemplateQuestionMutation represents an operation that mutate the SurveyTemplateQuestions
// nodes in the graph.
type SurveyTemplateQuestionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	question_title       *string
	question_description *string
	question_type        *string
	index                *int
	addindex             *int
	clearedFields        map[string]struct{}
	category             *int
	clearedcategory      bool
	done                 bool
	oldValue             func(context.Context) (*SurveyTemplateQuestion, error)
	predicates           []predicate.SurveyTemplateQuestion
}

var _ ent.Mutation = (*SurveyTemplateQuestionMutation)(nil)

// surveytemplatequestionOption allows to manage the mutation configuration using functional options.
type surveytemplatequestionOption func(*SurveyTemplateQuestionMutation)

// newSurveyTemplateQuestionMutation creates new mutation for SurveyTemplateQuestion.
func newSurveyTemplateQuestionMutation(c config, op Op, opts ...surveytemplatequestionOption) *SurveyTemplateQuestionMutation {
	m := &SurveyTemplateQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyTemplateQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyTemplateQuestionID sets the id field of the mutation.
func withSurveyTemplateQuestionID(id int) surveytemplatequestionOption {
	return func(m *SurveyTemplateQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyTemplateQuestion
		)
		m.oldValue = func(ctx context.Context) (*SurveyTemplateQuestion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyTemplateQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyTemplateQuestion sets the old SurveyTemplateQuestion of the mutation.
func withSurveyTemplateQuestion(node *SurveyTemplateQuestion) surveytemplatequestionOption {
	return func(m *SurveyTemplateQuestionMutation) {
		m.oldValue = func(context.Context) (*SurveyTemplateQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyTemplateQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyTemplateQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SurveyTemplateQuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *SurveyTemplateQuestionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *SurveyTemplateQuestionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the SurveyTemplateQuestion.
// If the SurveyTemplateQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateQuestionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *SurveyTemplateQuestionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *SurveyTemplateQuestionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *SurveyTemplateQuestionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the SurveyTemplateQuestion.
// If the SurveyTemplateQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateQuestionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *SurveyTemplateQuestionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetQuestionTitle sets the question_title field.
func (m *SurveyTemplateQuestionMutation) SetQuestionTitle(s string) {
	m.question_title = &s
}

// QuestionTitle returns the question_title value in the mutation.
func (m *SurveyTemplateQuestionMutation) QuestionTitle() (r string, exists bool) {
	v := m.question_title
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionTitle returns the old question_title value of the SurveyTemplateQuestion.
// If the SurveyTemplateQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateQuestionMutation) OldQuestionTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionTitle: %w", err)
	}
	return oldValue.QuestionTitle, nil
}

// ResetQuestionTitle reset all changes of the "question_title" field.
func (m *SurveyTemplateQuestionMutation) ResetQuestionTitle() {
	m.question_title = nil
}

// SetQuestionDescription sets the question_description field.
func (m *SurveyTemplateQuestionMutation) SetQuestionDescription(s string) {
	m.question_description = &s
}

// QuestionDescription returns the question_description value in the mutation.
func (m *SurveyTemplateQuestionMutation) QuestionDescription() (r string, exists bool) {
	v := m.question_description
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionDescription returns the old question_description value of the SurveyTemplateQuestion.
// If the SurveyTemplateQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateQuestionMutation) OldQuestionDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionDescription: %w", err)
	}
	return oldValue.QuestionDescription, nil
}

// ResetQuestionDescription reset all changes of the "question_description" field.
func (m *SurveyTemplateQuestionMutation) ResetQuestionDescription() {
	m.question_description = nil
}

// SetQuestionType sets the question_type field.
func (m *SurveyTemplateQuestionMutation) SetQuestionType(s string) {
	m.question_type = &s
}

// QuestionType returns the question_type value in the mutation.
func (m *SurveyTemplateQuestionMutation) QuestionType() (r string, exists bool) {
	v := m.question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionType returns the old question_type value of the SurveyTemplateQuestion.
// If the SurveyTemplateQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateQuestionMutation) OldQuestionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionType: %w", err)
	}
	return oldValue.QuestionType, nil
}

// ResetQuestionType reset all changes of the "question_type" field.
func (m *SurveyTemplateQuestionMutation) ResetQuestionType() {
	m.question_type = nil
}

// SetIndex sets the index field.
func (m *SurveyTemplateQuestionMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *SurveyTemplateQuestionMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the SurveyTemplateQuestion.
// If the SurveyTemplateQuestion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyTemplateQuestionMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *SurveyTemplateQuestionMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *SurveyTemplateQuestionMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex reset all changes of the "index" field.
func (m *SurveyTemplateQuestionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetCategoryID sets the category edge to SurveyTemplateCategory by id.
func (m *SurveyTemplateQuestionMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the category edge to SurveyTemplateCategory.
func (m *SurveyTemplateQuestionMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared returns if the edge category was cleared.
func (m *SurveyTemplateQuestionMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the category id in the mutation.
func (m *SurveyTemplateQuestionMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *SurveyTemplateQuestionMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory reset all changes of the "category" edge.
func (m *SurveyTemplateQuestionMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Op returns the operation name.
func (m *SurveyTemplateQuestionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SurveyTemplateQuestion).
func (m *SurveyTemplateQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SurveyTemplateQuestionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, surveytemplatequestion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, surveytemplatequestion.FieldUpdateTime)
	}
	if m.question_title != nil {
		fields = append(fields, surveytemplatequestion.FieldQuestionTitle)
	}
	if m.question_description != nil {
		fields = append(fields, surveytemplatequestion.FieldQuestionDescription)
	}
	if m.question_type != nil {
		fields = append(fields, surveytemplatequestion.FieldQuestionType)
	}
	if m.index != nil {
		fields = append(fields, surveytemplatequestion.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SurveyTemplateQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveytemplatequestion.FieldCreateTime:
		return m.CreateTime()
	case surveytemplatequestion.FieldUpdateTime:
		return m.UpdateTime()
	case surveytemplatequestion.FieldQuestionTitle:
		return m.QuestionTitle()
	case surveytemplatequestion.FieldQuestionDescription:
		return m.QuestionDescription()
	case surveytemplatequestion.FieldQuestionType:
		return m.QuestionType()
	case surveytemplatequestion.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SurveyTemplateQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveytemplatequestion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case surveytemplatequestion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case surveytemplatequestion.FieldQuestionTitle:
		return m.OldQuestionTitle(ctx)
	case surveytemplatequestion.FieldQuestionDescription:
		return m.OldQuestionDescription(ctx)
	case surveytemplatequestion.FieldQuestionType:
		return m.OldQuestionType(ctx)
	case surveytemplatequestion.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyTemplateQuestion field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyTemplateQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveytemplatequestion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case surveytemplatequestion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case surveytemplatequestion.FieldQuestionTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionTitle(v)
		return nil
	case surveytemplatequestion.FieldQuestionDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionDescription(v)
		return nil
	case surveytemplatequestion.FieldQuestionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionType(v)
		return nil
	case surveytemplatequestion.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SurveyTemplateQuestionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, surveytemplatequestion.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SurveyTemplateQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveytemplatequestion.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyTemplateQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveytemplatequestion.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SurveyTemplateQuestionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SurveyTemplateQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyTemplateQuestionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SurveyTemplateQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SurveyTemplateQuestionMutation) ResetField(name string) error {
	switch name {
	case surveytemplatequestion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case surveytemplatequestion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case surveytemplatequestion.FieldQuestionTitle:
		m.ResetQuestionTitle()
		return nil
	case surveytemplatequestion.FieldQuestionDescription:
		m.ResetQuestionDescription()
		return nil
	case surveytemplatequestion.FieldQuestionType:
		m.ResetQuestionType()
		return nil
	case surveytemplatequestion.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SurveyTemplateQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.category != nil {
		edges = append(edges, surveytemplatequestion.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SurveyTemplateQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveytemplatequestion.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SurveyTemplateQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SurveyTemplateQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SurveyTemplateQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategory {
		edges = append(edges, surveytemplatequestion.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SurveyTemplateQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case surveytemplatequestion.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SurveyTemplateQuestionMutation) ClearEdge(name string) error {
	switch name {
	case surveytemplatequestion.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateQuestion unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SurveyTemplateQuestionMutation) ResetEdge(name string) error {
	switch name {
	case surveytemplatequestion.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown SurveyTemplateQuestion edge %s", name)
}

// SurveyWiFiScanMutation represents an operation that mutate the SurveyWiFiScans
// nodes in the graph.
type SurveyWiFiScanMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	ssid                   *string
	bssid                  *string
	timestamp              *time.Time
	frequency              *int
	addfrequency           *int
	channel                *int
	addchannel             *int
	band                   *string
	channel_width          *int
	addchannel_width       *int
	capabilities           *string
	strength               *int
	addstrength            *int
	latitude               *float64
	addlatitude            *float64
	longitude              *float64
	addlongitude           *float64
	altitude               *float64
	addaltitude            *float64
	heading                *float64
	addheading             *float64
	rssi                   *float64
	addrssi                *float64
	clearedFields          map[string]struct{}
	checklist_item         *int
	clearedchecklist_item  bool
	survey_question        *int
	clearedsurvey_question bool
	location               *int
	clearedlocation        bool
	done                   bool
	oldValue               func(context.Context) (*SurveyWiFiScan, error)
	predicates             []predicate.SurveyWiFiScan
}

var _ ent.Mutation = (*SurveyWiFiScanMutation)(nil)

// surveywifiscanOption allows to manage the mutation configuration using functional options.
type surveywifiscanOption func(*SurveyWiFiScanMutation)

// newSurveyWiFiScanMutation creates new mutation for SurveyWiFiScan.
func newSurveyWiFiScanMutation(c config, op Op, opts ...surveywifiscanOption) *SurveyWiFiScanMutation {
	m := &SurveyWiFiScanMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyWiFiScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyWiFiScanID sets the id field of the mutation.
func withSurveyWiFiScanID(id int) surveywifiscanOption {
	return func(m *SurveyWiFiScanMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyWiFiScan
		)
		m.oldValue = func(ctx context.Context) (*SurveyWiFiScan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyWiFiScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyWiFiScan sets the old SurveyWiFiScan of the mutation.
func withSurveyWiFiScan(node *SurveyWiFiScan) surveywifiscanOption {
	return func(m *SurveyWiFiScanMutation) {
		m.oldValue = func(context.Context) (*SurveyWiFiScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyWiFiScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyWiFiScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SurveyWiFiScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *SurveyWiFiScanMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *SurveyWiFiScanMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *SurveyWiFiScanMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *SurveyWiFiScanMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *SurveyWiFiScanMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *SurveyWiFiScanMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSsid sets the ssid field.
func (m *SurveyWiFiScanMutation) SetSsid(s string) {
	m.ssid = &s
}

// Ssid returns the ssid value in the mutation.
func (m *SurveyWiFiScanMutation) Ssid() (r string, exists bool) {
	v := m.ssid
	if v == nil {
		return
	}
	return *v, true
}

// OldSsid returns the old ssid value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldSsid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSsid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSsid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSsid: %w", err)
	}
	return oldValue.Ssid, nil
}

// ClearSsid clears the value of ssid.
func (m *SurveyWiFiScanMutation) ClearSsid() {
	m.ssid = nil
	m.clearedFields[surveywifiscan.FieldSsid] = struct{}{}
}

// SsidCleared returns if the field ssid was cleared in this mutation.
func (m *SurveyWiFiScanMutation) SsidCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldSsid]
	return ok
}

// ResetSsid reset all changes of the "ssid" field.
func (m *SurveyWiFiScanMutation) ResetSsid() {
	m.ssid = nil
	delete(m.clearedFields, surveywifiscan.FieldSsid)
}

// SetBssid sets the bssid field.
func (m *SurveyWiFiScanMutation) SetBssid(s string) {
	m.bssid = &s
}

// Bssid returns the bssid value in the mutation.
func (m *SurveyWiFiScanMutation) Bssid() (r string, exists bool) {
	v := m.bssid
	if v == nil {
		return
	}
	return *v, true
}

// OldBssid returns the old bssid value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldBssid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBssid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBssid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBssid: %w", err)
	}
	return oldValue.Bssid, nil
}

// ResetBssid reset all changes of the "bssid" field.
func (m *SurveyWiFiScanMutation) ResetBssid() {
	m.bssid = nil
}

// SetTimestamp sets the timestamp field.
func (m *SurveyWiFiScanMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the timestamp value in the mutation.
func (m *SurveyWiFiScanMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old timestamp value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimestamp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp reset all changes of the "timestamp" field.
func (m *SurveyWiFiScanMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetFrequency sets the frequency field.
func (m *SurveyWiFiScanMutation) SetFrequency(i int) {
	m.frequency = &i
	m.addfrequency = nil
}

// Frequency returns the frequency value in the mutation.
func (m *SurveyWiFiScanMutation) Frequency() (r int, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old frequency value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldFrequency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFrequency is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// AddFrequency adds i to frequency.
func (m *SurveyWiFiScanMutation) AddFrequency(i int) {
	if m.addfrequency != nil {
		*m.addfrequency += i
	} else {
		m.addfrequency = &i
	}
}

// AddedFrequency returns the value that was added to the frequency field in this mutation.
func (m *SurveyWiFiScanMutation) AddedFrequency() (r int, exists bool) {
	v := m.addfrequency
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrequency reset all changes of the "frequency" field.
func (m *SurveyWiFiScanMutation) ResetFrequency() {
	m.frequency = nil
	m.addfrequency = nil
}

// SetChannel sets the channel field.
func (m *SurveyWiFiScanMutation) SetChannel(i int) {
	m.channel = &i
	m.addchannel = nil
}

// Channel returns the channel value in the mutation.
func (m *SurveyWiFiScanMutation) Channel() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old channel value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldChannel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChannel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// AddChannel adds i to channel.
func (m *SurveyWiFiScanMutation) AddChannel(i int) {
	if m.addchannel != nil {
		*m.addchannel += i
	} else {
		m.addchannel = &i
	}
}

// AddedChannel returns the value that was added to the channel field in this mutation.
func (m *SurveyWiFiScanMutation) AddedChannel() (r int, exists bool) {
	v := m.addchannel
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannel reset all changes of the "channel" field.
func (m *SurveyWiFiScanMutation) ResetChannel() {
	m.channel = nil
	m.addchannel = nil
}

// SetBand sets the band field.
func (m *SurveyWiFiScanMutation) SetBand(s string) {
	m.band = &s
}

// Band returns the band value in the mutation.
func (m *SurveyWiFiScanMutation) Band() (r string, exists bool) {
	v := m.band
	if v == nil {
		return
	}
	return *v, true
}

// OldBand returns the old band value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldBand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBand is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBand: %w", err)
	}
	return oldValue.Band, nil
}

// ClearBand clears the value of band.
func (m *SurveyWiFiScanMutation) ClearBand() {
	m.band = nil
	m.clearedFields[surveywifiscan.FieldBand] = struct{}{}
}

// BandCleared returns if the field band was cleared in this mutation.
func (m *SurveyWiFiScanMutation) BandCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldBand]
	return ok
}

// ResetBand reset all changes of the "band" field.
func (m *SurveyWiFiScanMutation) ResetBand() {
	m.band = nil
	delete(m.clearedFields, surveywifiscan.FieldBand)
}

// SetChannelWidth sets the channel_width field.
func (m *SurveyWiFiScanMutation) SetChannelWidth(i int) {
	m.channel_width = &i
	m.addchannel_width = nil
}

// ChannelWidth returns the channel_width value in the mutation.
func (m *SurveyWiFiScanMutation) ChannelWidth() (r int, exists bool) {
	v := m.channel_width
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelWidth returns the old channel_width value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldChannelWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChannelWidth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChannelWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelWidth: %w", err)
	}
	return oldValue.ChannelWidth, nil
}

// AddChannelWidth adds i to channel_width.
func (m *SurveyWiFiScanMutation) AddChannelWidth(i int) {
	if m.addchannel_width != nil {
		*m.addchannel_width += i
	} else {
		m.addchannel_width = &i
	}
}

// AddedChannelWidth returns the value that was added to the channel_width field in this mutation.
func (m *SurveyWiFiScanMutation) AddedChannelWidth() (r int, exists bool) {
	v := m.addchannel_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearChannelWidth clears the value of channel_width.
func (m *SurveyWiFiScanMutation) ClearChannelWidth() {
	m.channel_width = nil
	m.addchannel_width = nil
	m.clearedFields[surveywifiscan.FieldChannelWidth] = struct{}{}
}

// ChannelWidthCleared returns if the field channel_width was cleared in this mutation.
func (m *SurveyWiFiScanMutation) ChannelWidthCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldChannelWidth]
	return ok
}

// ResetChannelWidth reset all changes of the "channel_width" field.
func (m *SurveyWiFiScanMutation) ResetChannelWidth() {
	m.channel_width = nil
	m.addchannel_width = nil
	delete(m.clearedFields, surveywifiscan.FieldChannelWidth)
}

// SetCapabilities sets the capabilities field.
func (m *SurveyWiFiScanMutation) SetCapabilities(s string) {
	m.capabilities = &s
}

// Capabilities returns the capabilities value in the mutation.
func (m *SurveyWiFiScanMutation) Capabilities() (r string, exists bool) {
	v := m.capabilities
	if v == nil {
		return
	}
	return *v, true
}

// OldCapabilities returns the old capabilities value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldCapabilities(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCapabilities is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCapabilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapabilities: %w", err)
	}
	return oldValue.Capabilities, nil
}

// ClearCapabilities clears the value of capabilities.
func (m *SurveyWiFiScanMutation) ClearCapabilities() {
	m.capabilities = nil
	m.clearedFields[surveywifiscan.FieldCapabilities] = struct{}{}
}

// CapabilitiesCleared returns if the field capabilities was cleared in this mutation.
func (m *SurveyWiFiScanMutation) CapabilitiesCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldCapabilities]
	return ok
}

// ResetCapabilities reset all changes of the "capabilities" field.
func (m *SurveyWiFiScanMutation) ResetCapabilities() {
	m.capabilities = nil
	delete(m.clearedFields, surveywifiscan.FieldCapabilities)
}

// SetStrength sets the strength field.
func (m *SurveyWiFiScanMutation) SetStrength(i int) {
	m.strength = &i
	m.addstrength = nil
}

// Strength returns the strength value in the mutation.
func (m *SurveyWiFiScanMutation) Strength() (r int, exists bool) {
	v := m.strength
	if v == nil {
		return
	}
	return *v, true
}

// OldStrength returns the old strength value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldStrength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStrength is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStrength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrength: %w", err)
	}
	return oldValue.Strength, nil
}

// AddStrength adds i to strength.
func (m *SurveyWiFiScanMutation) AddStrength(i int) {
	if m.addstrength != nil {
		*m.addstrength += i
	} else {
		m.addstrength = &i
	}
}

// AddedStrength returns the value that was added to the strength field in this mutation.
func (m *SurveyWiFiScanMutation) AddedStrength() (r int, exists bool) {
	v := m.addstrength
	if v == nil {
		return
	}
	return *v, true
}

// ResetStrength reset all changes of the "strength" field.
func (m *SurveyWiFiScanMutation) ResetStrength() {
	m.strength = nil
	m.addstrength = nil
}

// SetLatitude sets the latitude field.
func (m *SurveyWiFiScanMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the latitude value in the mutation.
func (m *SurveyWiFiScanMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old latitude value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to latitude.
func (m *SurveyWiFiScanMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the latitude field in this mutation.
func (m *SurveyWiFiScanMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of latitude.
func (m *SurveyWiFiScanMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[surveywifiscan.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the field latitude was cleared in this mutation.
func (m *SurveyWiFiScanMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldLatitude]
	return ok
}

// ResetLatitude reset all changes of the "latitude" field.
func (m *SurveyWiFiScanMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, surveywifiscan.FieldLatitude)
}

// SetLongitude sets the longitude field.
func (m *SurveyWiFiScanMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the longitude value in the mutation.
func (m *SurveyWiFiScanMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old longitude value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to longitude.
func (m *SurveyWiFiScanMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the longitude field in this mutation.
func (m *SurveyWiFiScanMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of longitude.
func (m *SurveyWiFiScanMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[surveywifiscan.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the field longitude was cleared in this mutation.
func (m *SurveyWiFiScanMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldLongitude]
	return ok
}

// ResetLongitude reset all changes of the "longitude" field.
func (m *SurveyWiFiScanMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, surveywifiscan.FieldLongitude)
}

// SetAltitude sets the altitude field.
func (m *SurveyWiFiScanMutation) SetAltitude(f float64) {
	m.altitude = &f
	m.addaltitude = nil
}

// Altitude returns the altitude value in the mutation.
func (m *SurveyWiFiScanMutation) Altitude() (r float64, exists bool) {
	v := m.altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldAltitude returns the old altitude value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldAltitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAltitude is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltitude: %w", err)
	}
	return oldValue.Altitude, nil
}

// AddAltitude adds f to altitude.
func (m *SurveyWiFiScanMutation) AddAltitude(f float64) {
	if m.addaltitude != nil {
		*m.addaltitude += f
	} else {
		m.addaltitude = &f
	}
}

// AddedAltitude returns the value that was added to the altitude field in this mutation.
func (m *SurveyWiFiScanMutation) AddedAltitude() (r float64, exists bool) {
	v := m.addaltitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearAltitude clears the value of altitude.
func (m *SurveyWiFiScanMutation) ClearAltitude() {
	m.altitude = nil
	m.addaltitude = nil
	m.clearedFields[surveywifiscan.FieldAltitude] = struct{}{}
}

// AltitudeCleared returns if the field altitude was cleared in this mutation.
func (m *SurveyWiFiScanMutation) AltitudeCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldAltitude]
	return ok
}

// ResetAltitude reset all changes of the "altitude" field.
func (m *SurveyWiFiScanMutation) ResetAltitude() {
	m.altitude = nil
	m.addaltitude = nil
	delete(m.clearedFields, surveywifiscan.FieldAltitude)
}

// SetHeading sets the heading field.
func (m *SurveyWiFiScanMutation) SetHeading(f float64) {
	m.heading = &f
	m.addheading = nil
}

// Heading returns the heading value in the mutation.
func (m *SurveyWiFiScanMutation) Heading() (r float64, exists bool) {
	v := m.heading
	if v == nil {
		return
	}
	return *v, true
}

// OldHeading returns the old heading value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldHeading(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeading is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeading: %w", err)
	}
	return oldValue.Heading, nil
}

// AddHeading adds f to heading.
func (m *SurveyWiFiScanMutation) AddHeading(f float64) {
	if m.addheading != nil {
		*m.addheading += f
	} else {
		m.addheading = &f
	}
}

// AddedHeading returns the value that was added to the heading field in this mutation.
func (m *SurveyWiFiScanMutation) AddedHeading() (r float64, exists bool) {
	v := m.addheading
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeading clears the value of heading.
func (m *SurveyWiFiScanMutation) ClearHeading() {
	m.heading = nil
	m.addheading = nil
	m.clearedFields[surveywifiscan.FieldHeading] = struct{}{}
}

// HeadingCleared returns if the field heading was cleared in this mutation.
func (m *SurveyWiFiScanMutation) HeadingCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldHeading]
	return ok
}

// ResetHeading reset all changes of the "heading" field.
func (m *SurveyWiFiScanMutation) ResetHeading() {
	m.heading = nil
	m.addheading = nil
	delete(m.clearedFields, surveywifiscan.FieldHeading)
}

// SetRssi sets the rssi field.
func (m *SurveyWiFiScanMutation) SetRssi(f float64) {
	m.rssi = &f
	m.addrssi = nil
}

// Rssi returns the rssi value in the mutation.
func (m *SurveyWiFiScanMutation) Rssi() (r float64, exists bool) {
	v := m.rssi
	if v == nil {
		return
	}
	return *v, true
}

// OldRssi returns the old rssi value of the SurveyWiFiScan.
// If the SurveyWiFiScan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SurveyWiFiScanMutation) OldRssi(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRssi is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRssi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRssi: %w", err)
	}
	return oldValue.Rssi, nil
}

// AddRssi adds f to rssi.
func (m *SurveyWiFiScanMutation) AddRssi(f float64) {
	if m.addrssi != nil {
		*m.addrssi += f
	} else {
		m.addrssi = &f
	}
}

// AddedRssi returns the value that was added to the rssi field in this mutation.
func (m *SurveyWiFiScanMutation) AddedRssi() (r float64, exists bool) {
	v := m.addrssi
	if v == nil {
		return
	}
	return *v, true
}

// ClearRssi clears the value of rssi.
func (m *SurveyWiFiScanMutation) ClearRssi() {
	m.rssi = nil
	m.addrssi = nil
	m.clearedFields[surveywifiscan.FieldRssi] = struct{}{}
}

// RssiCleared returns if the field rssi was cleared in this mutation.
func (m *SurveyWiFiScanMutation) RssiCleared() bool {
	_, ok := m.clearedFields[surveywifiscan.FieldRssi]
	return ok
}

// ResetRssi reset all changes of the "rssi" field.
func (m *SurveyWiFiScanMutation) ResetRssi() {
	m.rssi = nil
	m.addrssi = nil
	delete(m.clearedFields, surveywifiscan.FieldRssi)
}

// SetChecklistItemID sets the checklist_item edge to CheckListItem by id.
func (m *SurveyWiFiScanMutation) SetChecklistItemID(id int) {
	m.checklist_item = &id
}

// ClearChecklistItem clears the checklist_item edge to CheckListItem.
func (m *SurveyWiFiScanMutation) ClearChecklistItem() {
	m.clearedchecklist_item = true
}

// ChecklistItemCleared returns if the edge checklist_item was cleared.
func (m *SurveyWiFiScanMutation) ChecklistItemCleared() bool {
	return m.clearedchecklist_item
}

// ChecklistItemID returns the checklist_item id in the mutation.
func (m *SurveyWiFiScanMutation) ChecklistItemID() (id int, exists bool) {
	if m.checklist_item != nil {
		return *m.checklist_item, true
	}
	return
}

// ChecklistItemIDs returns the checklist_item ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ChecklistItemID instead. It exists only for internal usage by the builders.
func (m *SurveyWiFiScanMutation) ChecklistItemIDs() (ids []int) {
	if id := m.checklist_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChecklistItem reset all changes of the "checklist_item" edge.
func (m *SurveyWiFiScanMutation) ResetChecklistItem() {
	m.checklist_item = nil
	m.clearedchecklist_item = false
}

// SetSurveyQuestionID sets the survey_question edge to SurveyQuestion by id.
func (m *SurveyWiFiScanMutation) SetSurveyQuestionID(id int) {
	m.survey_question = &id
}

// ClearSurveyQuestion clears the survey_question edge to SurveyQuestion.
func (m *SurveyWiFiScanMutation) ClearSurveyQuestion() {
	m.clearedsurvey_question = true
}

// SurveyQuestionCleared returns if the edge survey_question was cleared.
func (m *SurveyWiFiScanMutation) SurveyQuestionCleared() bool {
	return m.clearedsurvey_question
}

// SurveyQuestionID returns the survey_question id in the mutation.
func (m *SurveyWiFiScanMutation) SurveyQuestionID() (id int, exists bool) {
	if m.survey_question != nil {
		return *m.survey_question, true
	}
	return
}

// SurveyQuestionIDs returns the survey_question ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SurveyQuestionID instead. It exists only for internal usage by the builders.
func (m *SurveyWiFiScanMutation) SurveyQuestionIDs() (ids []int) {
	if id := m.survey_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurveyQuestion reset all changes of the "survey_question" edge.
func (m *SurveyWiFiScanMutation) ResetSurveyQuestion() {
	m.survey_question = nil
	m.clearedsurvey_question = false
}

// SetLocationID sets the location edge to Location by id.
func (m *SurveyWiFiScanMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *SurveyWiFiScanMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *SurveyWiFiScanMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *SurveyWiFiScanMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *SurveyWiFiScanMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *SurveyWiFiScanMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Op returns the operation name.
func (m *SurveyWiFiScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SurveyWiFiScan).
func (m *SurveyWiFiScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SurveyWiFiScanMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.create_time != nil {
		fields = append(fields, surveywifiscan.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, surveywifiscan.FieldUpdateTime)
	}
	if m.ssid != nil {
		fields = append(fields, surveywifiscan.FieldSsid)
	}
	if m.bssid != nil {
		fields = append(fields, surveywifiscan.FieldBssid)
	}
	if m.timestamp != nil {
		fields = append(fields, surveywifiscan.FieldTimestamp)
	}
	if m.frequency != nil {
		fields = append(fields, surveywifiscan.FieldFrequency)
	}
	if m.channel != nil {
		fields = append(fields, surveywifiscan.FieldChannel)
	}
	if m.band != nil {
		fields = append(fields, surveywifiscan.FieldBand)
	}
	if m.channel_width != nil {
		fields = append(fields, surveywifiscan.FieldChannelWidth)
	}
	if m.capabilities != nil {
		fields = append(fields, surveywifiscan.FieldCapabilities)
	}
	if m.strength != nil {
		fields = append(fields, surveywifiscan.FieldStrength)
	}
	if m.latitude != nil {
		fields = append(fields, surveywifiscan.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, surveywifiscan.FieldLongitude)
	}
	if m.altitude != nil {
		fields = append(fields, surveywifiscan.FieldAltitude)
	}
	if m.heading != nil {
		fields = append(fields, surveywifiscan.FieldHeading)
	}
	if m.rssi != nil {
		fields = append(fields, surveywifiscan.FieldRssi)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SurveyWiFiScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveywifiscan.FieldCreateTime:
		return m.CreateTime()
	case surveywifiscan.FieldUpdateTime:
		return m.UpdateTime()
	case surveywifiscan.FieldSsid:
		return m.Ssid()
	case surveywifiscan.FieldBssid:
		return m.Bssid()
	case surveywifiscan.FieldTimestamp:
		return m.Timestamp()
	case surveywifiscan.FieldFrequency:
		return m.Frequency()
	case surveywifiscan.FieldChannel:
		return m.Channel()
	case surveywifiscan.FieldBand:
		return m.Band()
	case surveywifiscan.FieldChannelWidth:
		return m.ChannelWidth()
	case surveywifiscan.FieldCapabilities:
		return m.Capabilities()
	case surveywifiscan.FieldStrength:
		return m.Strength()
	case surveywifiscan.FieldLatitude:
		return m.Latitude()
	case surveywifiscan.FieldLongitude:
		return m.Longitude()
	case surveywifiscan.FieldAltitude:
		return m.Altitude()
	case surveywifiscan.FieldHeading:
		return m.Heading()
	case surveywifiscan.FieldRssi:
		return m.Rssi()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SurveyWiFiScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveywifiscan.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case surveywifiscan.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case surveywifiscan.FieldSsid:
		return m.OldSsid(ctx)
	case surveywifiscan.FieldBssid:
		return m.OldBssid(ctx)
	case surveywifiscan.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case surveywifiscan.FieldFrequency:
		return m.OldFrequency(ctx)
	case surveywifiscan.FieldChannel:
		return m.OldChannel(ctx)
	case surveywifiscan.FieldBand:
		return m.OldBand(ctx)
	case surveywifiscan.FieldChannelWidth:
		return m.OldChannelWidth(ctx)
	case surveywifiscan.FieldCapabilities:
		return m.OldCapabilities(ctx)
	case surveywifiscan.FieldStrength:
		return m.OldStrength(ctx)
	case surveywifiscan.FieldLatitude:
		return m.OldLatitude(ctx)
	case surveywifiscan.FieldLongitude:
		return m.OldLongitude(ctx)
	case surveywifiscan.FieldAltitude:
		return m.OldAltitude(ctx)
	case surveywifiscan.FieldHeading:
		return m.OldHeading(ctx)
	case surveywifiscan.FieldRssi:
		return m.OldRssi(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyWiFiScan field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyWiFiScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveywifiscan.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case surveywifiscan.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case surveywifiscan.FieldSsid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSsid(v)
		return nil
	case surveywifiscan.FieldBssid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBssid(v)
		return nil
	case surveywifiscan.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case surveywifiscan.FieldFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case surveywifiscan.FieldChannel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case surveywifiscan.FieldBand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBand(v)
		return nil
	case surveywifiscan.FieldChannelWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelWidth(v)
		return nil
	case surveywifiscan.FieldCapabilities:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapabilities(v)
		return nil
	case surveywifiscan.FieldStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrength(v)
		return nil
	case surveywifiscan.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case surveywifiscan.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case surveywifiscan.FieldAltitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltitude(v)
		return nil
	case surveywifiscan.FieldHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeading(v)
		return nil
	case surveywifiscan.FieldRssi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRssi(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyWiFiScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SurveyWiFiScanMutation) AddedFields() []string {
	var fields []string
	if m.addfrequency != nil {
		fields = append(fields, surveywifiscan.FieldFrequency)
	}
	if m.addchannel != nil {
		fields = append(fields, surveywifiscan.FieldChannel)
	}
	if m.addchannel_width != nil {
		fields = append(fields, surveywifiscan.FieldChannelWidth)
	}
	if m.addstrength != nil {
		fields = append(fields, surveywifiscan.FieldStrength)
	}
	if m.addlatitude != nil {
		fields = append(fields, surveywifiscan.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, surveywifiscan.FieldLongitude)
	}
	if m.addaltitude != nil {
		fields = append(fields, surveywifiscan.FieldAltitude)
	}
	if m.addheading != nil {
		fields = append(fields, surveywifiscan.FieldHeading)
	}
	if m.addrssi != nil {
		fields = append(fields, surveywifiscan.FieldRssi)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SurveyWiFiScanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case surveywifiscan.FieldFrequency:
		return m.AddedFrequency()
	case surveywifiscan.FieldChannel:
		return m.AddedChannel()
	case surveywifiscan.FieldChannelWidth:
		return m.AddedChannelWidth()
	case surveywifiscan.FieldStrength:
		return m.AddedStrength()
	case surveywifiscan.FieldLatitude:
		return m.AddedLatitude()
	case surveywifiscan.FieldLongitude:
		return m.AddedLongitude()
	case surveywifiscan.FieldAltitude:
		return m.AddedAltitude()
	case surveywifiscan.FieldHeading:
		return m.AddedHeading()
	case surveywifiscan.FieldRssi:
		return m.AddedRssi()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SurveyWiFiScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case surveywifiscan.FieldFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrequency(v)
		return nil
	case surveywifiscan.FieldChannel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannel(v)
		return nil
	case surveywifiscan.FieldChannelWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelWidth(v)
		return nil
	case surveywifiscan.FieldStrength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrength(v)
		return nil
	case surveywifiscan.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case surveywifiscan.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case surveywifiscan.FieldAltitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAltitude(v)
		return nil
	case surveywifiscan.FieldHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeading(v)
		return nil
	case surveywifiscan.FieldRssi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRssi(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyWiFiScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SurveyWiFiScanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveywifiscan.FieldSsid) {
		fields = append(fields, surveywifiscan.FieldSsid)
	}
	if m.FieldCleared(surveywifiscan.FieldBand) {
		fields = append(fields, surveywifiscan.FieldBand)
	}
	if m.FieldCleared(surveywifiscan.FieldChannelWidth) {
		fields = append(fields, surveywifiscan.FieldChannelWidth)
	}
	if m.FieldCleared(surveywifiscan.FieldCapabilities) {
		fields = append(fields, surveywifiscan.FieldCapabilities)
	}
	if m.FieldCleared(surveywifiscan.FieldLatitude) {
		fields = append(fields, surveywifiscan.FieldLatitude)
	}
	if m.FieldCleared(surveywifiscan.FieldLongitude) {
		fields = append(fields, surveywifiscan.FieldLongitude)
	}
	if m.FieldCleared(surveywifiscan.FieldAltitude) {
		fields = append(fields, surveywifiscan.FieldAltitude)
	}
	if m.FieldCleared(surveywifiscan.FieldHeading) {
		fields = append(fields, surveywifiscan.FieldHeading)
	}
	if m.FieldCleared(surveywifiscan.FieldRssi) {
		fields = append(fields, surveywifiscan.FieldRssi)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SurveyWiFiScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyWiFiScanMutation) ClearField(name string) error {
	switch name {
	case surveywifiscan.FieldSsid:
		m.ClearSsid()
		return nil
	case surveywifiscan.FieldBand:
		m.ClearBand()
		return nil
	case surveywifiscan.FieldChannelWidth:
		m.ClearChannelWidth()
		return nil
	case surveywifiscan.FieldCapabilities:
		m.ClearCapabilities()
		return nil
	case surveywifiscan.FieldLatitude:
		m.ClearLatitude()
		return nil
	case surveywifiscan.FieldLongitude:
		m.ClearLongitude()
		return nil
	case surveywifiscan.FieldAltitude:
		m.ClearAltitude()
		return nil
	case surveywifiscan.FieldHeading:
		m.ClearHeading()
		return nil
	case surveywifiscan.FieldRssi:
		m.ClearRssi()
		return nil
	}
	return fmt.Errorf("unknown SurveyWiFiScan nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SurveyWiFiScanMutation) ResetField(name string) error {
	switch name {
	case surveywifiscan.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case surveywifiscan.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case surveywifiscan.FieldSsid:
		m.ResetSsid()
		return nil
	case surveywifiscan.FieldBssid:
		m.ResetBssid()
		return nil
	case surveywifiscan.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case surveywifiscan.FieldFrequency:
		m.ResetFrequency()
		return nil
	case surveywifiscan.FieldChannel:
		m.ResetChannel()
		return nil
	case surveywifiscan.FieldBand:
		m.ResetBand()
		return nil
	case surveywifiscan.FieldChannelWidth:
		m.ResetChannelWidth()
		return nil
	case surveywifiscan.FieldCapabilities:
		m.ResetCapabilities()
		return nil
	case surveywifiscan.FieldStrength:
		m.ResetStrength()
		return nil
	case surveywifiscan.FieldLatitude:
		m.ResetLatitude()
		return nil
	case surveywifiscan.FieldLongitude:
		m.ResetLongitude()
		return nil
	case surveywifiscan.FieldAltitude:
		m.ResetAltitude()
		return nil
	case surveywifiscan.FieldHeading:
		m.ResetHeading()
		return nil
	case surveywifiscan.FieldRssi:
		m.ResetRssi()
		return nil
	}
	return fmt.Errorf("unknown SurveyWiFiScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SurveyWiFiScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.checklist_item != nil {
		edges = append(edges, surveywifiscan.EdgeChecklistItem)
	}
	if m.survey_question != nil {
		edges = append(edges, surveywifiscan.EdgeSurveyQuestion)
	}
	if m.location != nil {
		edges = append(edges, surveywifiscan.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SurveyWiFiScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveywifiscan.EdgeChecklistItem:
		if id := m.checklist_item; id != nil {
			return []ent.Value{*id}
		}
	case surveywifiscan.EdgeSurveyQuestion:
		if id := m.survey_question; id != nil {
			return []ent.Value{*id}
		}
	case surveywifiscan.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SurveyWiFiScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SurveyWiFiScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SurveyWiFiScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchecklist_item {
		edges = append(edges, surveywifiscan.EdgeChecklistItem)
	}
	if m.clearedsurvey_question {
		edges = append(edges, surveywifiscan.EdgeSurveyQuestion)
	}
	if m.clearedlocation {
		edges = append(edges, surveywifiscan.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SurveyWiFiScanMutation) EdgeCleared(name string) bool {
	switch name {
	case surveywifiscan.EdgeChecklistItem:
		return m.clearedchecklist_item
	case surveywifiscan.EdgeSurveyQuestion:
		return m.clearedsurvey_question
	case surveywifiscan.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SurveyWiFiScanMutation) ClearEdge(name string) error {
	switch name {
	case surveywifiscan.EdgeChecklistItem:
		m.ClearChecklistItem()
		return nil
	case surveywifiscan.EdgeSurveyQuestion:
		m.ClearSurveyQuestion()
		return nil
	case surveywifiscan.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown SurveyWiFiScan unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SurveyWiFiScanMutation) ResetEdge(name string) error {
	switch name {
	case surveywifiscan.EdgeChecklistItem:
		m.ResetChecklistItem()
		return nil
	case surveywifiscan.EdgeSurveyQuestion:
		m.ResetSurveyQuestion()
		return nil
	case surveywifiscan.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown SurveyWiFiScan edge %s", name)
}

// TechMutation represents an operation that mutate the Teches
// nodes in the graph.
type TechMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	clearedFields      map[string]struct{}
	domain             *int
	cleareddomain      bool
	formulatech        map[int]struct{}
	removedformulatech map[int]struct{}
	clearedformulatech bool
	done               bool
	oldValue           func(context.Context) (*Tech, error)
	predicates         []predicate.Tech
}

var _ ent.Mutation = (*TechMutation)(nil)

// techOption allows to manage the mutation configuration using functional options.
type techOption func(*TechMutation)

// newTechMutation creates new mutation for Tech.
func newTechMutation(c config, op Op, opts ...techOption) *TechMutation {
	m := &TechMutation{
		config:        c,
		op:            op,
		typ:           TypeTech,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTechID sets the id field of the mutation.
func withTechID(id int) techOption {
	return func(m *TechMutation) {
		var (
			err   error
			once  sync.Once
			value *Tech
		)
		m.oldValue = func(ctx context.Context) (*Tech, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tech.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTech sets the old Tech of the mutation.
func withTech(node *Tech) techOption {
	return func(m *TechMutation) {
		m.oldValue = func(context.Context) (*Tech, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TechMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TechMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TechMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *TechMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *TechMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Tech.
// If the Tech object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TechMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *TechMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *TechMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *TechMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Tech.
// If the Tech object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TechMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *TechMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *TechMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TechMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Tech.
// If the Tech object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TechMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TechMutation) ResetName() {
	m.name = nil
}

// SetDomainID sets the domain edge to Domain by id.
func (m *TechMutation) SetDomainID(id int) {
	m.domain = &id
}

// ClearDomain clears the domain edge to Domain.
func (m *TechMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared returns if the edge domain was cleared.
func (m *TechMutation) DomainCleared() bool {
	return m.cleareddomain
}

// DomainID returns the domain id in the mutation.
func (m *TechMutation) DomainID() (id int, exists bool) {
	if m.domain != nil {
		return *m.domain, true
	}
	return
}

// DomainIDs returns the domain ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DomainID instead. It exists only for internal usage by the builders.
func (m *TechMutation) DomainIDs() (ids []int) {
	if id := m.domain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomain reset all changes of the "domain" edge.
func (m *TechMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
}

// AddFormulatechIDs adds the formulatech edge to Formula by ids.
func (m *TechMutation) AddFormulatechIDs(ids ...int) {
	if m.formulatech == nil {
		m.formulatech = make(map[int]struct{})
	}
	for i := range ids {
		m.formulatech[ids[i]] = struct{}{}
	}
}

// ClearFormulatech clears the formulatech edge to Formula.
func (m *TechMutation) ClearFormulatech() {
	m.clearedformulatech = true
}

// FormulatechCleared returns if the edge formulatech was cleared.
func (m *TechMutation) FormulatechCleared() bool {
	return m.clearedformulatech
}

// RemoveFormulatechIDs removes the formulatech edge to Formula by ids.
func (m *TechMutation) RemoveFormulatechIDs(ids ...int) {
	if m.removedformulatech == nil {
		m.removedformulatech = make(map[int]struct{})
	}
	for i := range ids {
		m.removedformulatech[ids[i]] = struct{}{}
	}
}

// RemovedFormulatech returns the removed ids of formulatech.
func (m *TechMutation) RemovedFormulatechIDs() (ids []int) {
	for id := range m.removedformulatech {
		ids = append(ids, id)
	}
	return
}

// FormulatechIDs returns the formulatech ids in the mutation.
func (m *TechMutation) FormulatechIDs() (ids []int) {
	for id := range m.formulatech {
		ids = append(ids, id)
	}
	return
}

// ResetFormulatech reset all changes of the "formulatech" edge.
func (m *TechMutation) ResetFormulatech() {
	m.formulatech = nil
	m.clearedformulatech = false
	m.removedformulatech = nil
}

// Op returns the operation name.
func (m *TechMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tech).
func (m *TechMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TechMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, tech.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tech.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, tech.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TechMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tech.FieldCreateTime:
		return m.CreateTime()
	case tech.FieldUpdateTime:
		return m.UpdateTime()
	case tech.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TechMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tech.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tech.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tech.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tech field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TechMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tech.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tech.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tech.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tech field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TechMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TechMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TechMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tech numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TechMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TechMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TechMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tech nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TechMutation) ResetField(name string) error {
	switch name {
	case tech.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tech.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tech.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tech field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TechMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.domain != nil {
		edges = append(edges, tech.EdgeDomain)
	}
	if m.formulatech != nil {
		edges = append(edges, tech.EdgeFormulatech)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TechMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tech.EdgeDomain:
		if id := m.domain; id != nil {
			return []ent.Value{*id}
		}
	case tech.EdgeFormulatech:
		ids := make([]ent.Value, 0, len(m.formulatech))
		for id := range m.formulatech {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TechMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedformulatech != nil {
		edges = append(edges, tech.EdgeFormulatech)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TechMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tech.EdgeFormulatech:
		ids := make([]ent.Value, 0, len(m.removedformulatech))
		for id := range m.removedformulatech {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TechMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddomain {
		edges = append(edges, tech.EdgeDomain)
	}
	if m.clearedformulatech {
		edges = append(edges, tech.EdgeFormulatech)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TechMutation) EdgeCleared(name string) bool {
	switch name {
	case tech.EdgeDomain:
		return m.cleareddomain
	case tech.EdgeFormulatech:
		return m.clearedformulatech
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TechMutation) ClearEdge(name string) error {
	switch name {
	case tech.EdgeDomain:
		m.ClearDomain()
		return nil
	}
	return fmt.Errorf("unknown Tech unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TechMutation) ResetEdge(name string) error {
	switch name {
	case tech.EdgeDomain:
		m.ResetDomain()
		return nil
	case tech.EdgeFormulatech:
		m.ResetFormulatech()
		return nil
	}
	return fmt.Errorf("unknown Tech edge %s", name)
}

// ThresholdMutation represents an operation that mutate the Thresholds
// nodes in the graph.
type ThresholdMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	description          *string
	status               *bool
	clearedFields        map[string]struct{}
	kpi                  *int
	clearedkpi           bool
	rulethreshold        map[int]struct{}
	removedrulethreshold map[int]struct{}
	clearedrulethreshold bool
	done                 bool
	oldValue             func(context.Context) (*Threshold, error)
	predicates           []predicate.Threshold
}

var _ ent.Mutation = (*ThresholdMutation)(nil)

// thresholdOption allows to manage the mutation configuration using functional options.
type thresholdOption func(*ThresholdMutation)

// newThresholdMutation creates new mutation for Threshold.
func newThresholdMutation(c config, op Op, opts ...thresholdOption) *ThresholdMutation {
	m := &ThresholdMutation{
		config:        c,
		op:            op,
		typ:           TypeThreshold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThresholdID sets the id field of the mutation.
func withThresholdID(id int) thresholdOption {
	return func(m *ThresholdMutation) {
		var (
			err   error
			once  sync.Once
			value *Threshold
		)
		m.oldValue = func(ctx context.Context) (*Threshold, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Threshold.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreshold sets the old Threshold of the mutation.
func withThreshold(node *Threshold) thresholdOption {
	return func(m *ThresholdMutation) {
		m.oldValue = func(context.Context) (*Threshold, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThresholdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThresholdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ThresholdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *ThresholdMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *ThresholdMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Threshold.
// If the Threshold object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ThresholdMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *ThresholdMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *ThresholdMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *ThresholdMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Threshold.
// If the Threshold object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ThresholdMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *ThresholdMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *ThresholdMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ThresholdMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Threshold.
// If the Threshold object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ThresholdMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ThresholdMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *ThresholdMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ThresholdMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Threshold.
// If the Threshold object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ThresholdMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *ThresholdMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the status field.
func (m *ThresholdMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the status value in the mutation.
func (m *ThresholdMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Threshold.
// If the Threshold object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ThresholdMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *ThresholdMutation) ResetStatus() {
	m.status = nil
}

// SetKpiID sets the kpi edge to Kpi by id.
func (m *ThresholdMutation) SetKpiID(id int) {
	m.kpi = &id
}

// ClearKpi clears the kpi edge to Kpi.
func (m *ThresholdMutation) ClearKpi() {
	m.clearedkpi = true
}

// KpiCleared returns if the edge kpi was cleared.
func (m *ThresholdMutation) KpiCleared() bool {
	return m.clearedkpi
}

// KpiID returns the kpi id in the mutation.
func (m *ThresholdMutation) KpiID() (id int, exists bool) {
	if m.kpi != nil {
		return *m.kpi, true
	}
	return
}

// KpiIDs returns the kpi ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KpiID instead. It exists only for internal usage by the builders.
func (m *ThresholdMutation) KpiIDs() (ids []int) {
	if id := m.kpi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKpi reset all changes of the "kpi" edge.
func (m *ThresholdMutation) ResetKpi() {
	m.kpi = nil
	m.clearedkpi = false
}

// AddRulethresholdIDs adds the rulethreshold edge to Rule by ids.
func (m *ThresholdMutation) AddRulethresholdIDs(ids ...int) {
	if m.rulethreshold == nil {
		m.rulethreshold = make(map[int]struct{})
	}
	for i := range ids {
		m.rulethreshold[ids[i]] = struct{}{}
	}
}

// ClearRulethreshold clears the rulethreshold edge to Rule.
func (m *ThresholdMutation) ClearRulethreshold() {
	m.clearedrulethreshold = true
}

// RulethresholdCleared returns if the edge rulethreshold was cleared.
func (m *ThresholdMutation) RulethresholdCleared() bool {
	return m.clearedrulethreshold
}

// RemoveRulethresholdIDs removes the rulethreshold edge to Rule by ids.
func (m *ThresholdMutation) RemoveRulethresholdIDs(ids ...int) {
	if m.removedrulethreshold == nil {
		m.removedrulethreshold = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrulethreshold[ids[i]] = struct{}{}
	}
}

// RemovedRulethreshold returns the removed ids of rulethreshold.
func (m *ThresholdMutation) RemovedRulethresholdIDs() (ids []int) {
	for id := range m.removedrulethreshold {
		ids = append(ids, id)
	}
	return
}

// RulethresholdIDs returns the rulethreshold ids in the mutation.
func (m *ThresholdMutation) RulethresholdIDs() (ids []int) {
	for id := range m.rulethreshold {
		ids = append(ids, id)
	}
	return
}

// ResetRulethreshold reset all changes of the "rulethreshold" edge.
func (m *ThresholdMutation) ResetRulethreshold() {
	m.rulethreshold = nil
	m.clearedrulethreshold = false
	m.removedrulethreshold = nil
}

// Op returns the operation name.
func (m *ThresholdMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Threshold).
func (m *ThresholdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ThresholdMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, threshold.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, threshold.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, threshold.FieldName)
	}
	if m.description != nil {
		fields = append(fields, threshold.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, threshold.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ThresholdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threshold.FieldCreateTime:
		return m.CreateTime()
	case threshold.FieldUpdateTime:
		return m.UpdateTime()
	case threshold.FieldName:
		return m.Name()
	case threshold.FieldDescription:
		return m.Description()
	case threshold.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ThresholdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threshold.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case threshold.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case threshold.FieldName:
		return m.OldName(ctx)
	case threshold.FieldDescription:
		return m.OldDescription(ctx)
	case threshold.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Threshold field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ThresholdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threshold.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case threshold.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case threshold.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case threshold.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case threshold.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Threshold field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ThresholdMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ThresholdMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ThresholdMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Threshold numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ThresholdMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ThresholdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThresholdMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Threshold nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ThresholdMutation) ResetField(name string) error {
	switch name {
	case threshold.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case threshold.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case threshold.FieldName:
		m.ResetName()
		return nil
	case threshold.FieldDescription:
		m.ResetDescription()
		return nil
	case threshold.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Threshold field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ThresholdMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.kpi != nil {
		edges = append(edges, threshold.EdgeKpi)
	}
	if m.rulethreshold != nil {
		edges = append(edges, threshold.EdgeRulethreshold)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ThresholdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threshold.EdgeKpi:
		if id := m.kpi; id != nil {
			return []ent.Value{*id}
		}
	case threshold.EdgeRulethreshold:
		ids := make([]ent.Value, 0, len(m.rulethreshold))
		for id := range m.rulethreshold {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ThresholdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrulethreshold != nil {
		edges = append(edges, threshold.EdgeRulethreshold)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ThresholdMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case threshold.EdgeRulethreshold:
		ids := make([]ent.Value, 0, len(m.removedrulethreshold))
		for id := range m.removedrulethreshold {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ThresholdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedkpi {
		edges = append(edges, threshold.EdgeKpi)
	}
	if m.clearedrulethreshold {
		edges = append(edges, threshold.EdgeRulethreshold)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ThresholdMutation) EdgeCleared(name string) bool {
	switch name {
	case threshold.EdgeKpi:
		return m.clearedkpi
	case threshold.EdgeRulethreshold:
		return m.clearedrulethreshold
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ThresholdMutation) ClearEdge(name string) error {
	switch name {
	case threshold.EdgeKpi:
		m.ClearKpi()
		return nil
	}
	return fmt.Errorf("unknown Threshold unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ThresholdMutation) ResetEdge(name string) error {
	switch name {
	case threshold.EdgeKpi:
		m.ResetKpi()
		return nil
	case threshold.EdgeRulethreshold:
		m.ResetRulethreshold()
		return nil
	}
	return fmt.Errorf("unknown Threshold edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	auth_id                     *string
	first_name                  *string
	last_name                   *string
	email                       *string
	status                      *user.Status
	role                        *user.Role
	distance_unit               *user.DistanceUnit
	clearedFields               map[string]struct{}
	profile_photo               *int
	clearedprofile_photo        bool
	_User_create                map[int]struct{}
	removed_User_create         map[int]struct{}
	cleared_User_create         bool
	_User_approved              map[int]struct{}
	removed_User_approved       map[int]struct{}
	cleared_User_approved       bool
	groups                      map[int]struct{}
	removedgroups               map[int]struct{}
	clearedgroups               bool
	organization                *int
	clearedorganization         bool
	owned_work_orders           map[int]struct{}
	removedowned_work_orders    map[int]struct{}
	clearedowned_work_orders    bool
	assigned_work_orders        map[int]struct{}
	removedassigned_work_orders map[int]struct{}
	clearedassigned_work_orders bool
	created_projects            map[int]struct{}
	removedcreated_projects     map[int]struct{}
	clearedcreated_projects     bool
	features                    map[int]struct{}
	removedfeatures             map[int]struct{}
	clearedfeatures             bool
	appointment                 map[int]struct{}
	removedappointment          map[int]struct{}
	clearedappointment          bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for User.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAuthID sets the auth_id field.
func (m *UserMutation) SetAuthID(s string) {
	m.auth_id = &s
}

// AuthID returns the auth_id value in the mutation.
func (m *UserMutation) AuthID() (r string, exists bool) {
	v := m.auth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthID returns the old auth_id value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAuthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthID: %w", err)
	}
	return oldValue.AuthID, nil
}

// ResetAuthID reset all changes of the "auth_id" field.
func (m *UserMutation) ResetAuthID() {
	m.auth_id = nil
}

// SetFirstName sets the first_name field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the first_name value in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old first_name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of first_name.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the field first_name was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName reset all changes of the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the last_name field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the last_name value in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old last_name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of last_name.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the field last_name was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName reset all changes of the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of email.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the field email was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetStatus sets the status field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the status value in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetRole sets the role field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the role value in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old role value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole reset all changes of the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetDistanceUnit sets the distance_unit field.
func (m *UserMutation) SetDistanceUnit(uu user.DistanceUnit) {
	m.distance_unit = &uu
}

// DistanceUnit returns the distance_unit value in the mutation.
func (m *UserMutation) DistanceUnit() (r user.DistanceUnit, exists bool) {
	v := m.distance_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceUnit returns the old distance_unit value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDistanceUnit(ctx context.Context) (v user.DistanceUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistanceUnit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistanceUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceUnit: %w", err)
	}
	return oldValue.DistanceUnit, nil
}

// ResetDistanceUnit reset all changes of the "distance_unit" field.
func (m *UserMutation) ResetDistanceUnit() {
	m.distance_unit = nil
}

// SetProfilePhotoID sets the profile_photo edge to File by id.
func (m *UserMutation) SetProfilePhotoID(id int) {
	m.profile_photo = &id
}

// ClearProfilePhoto clears the profile_photo edge to File.
func (m *UserMutation) ClearProfilePhoto() {
	m.clearedprofile_photo = true
}

// ProfilePhotoCleared returns if the edge profile_photo was cleared.
func (m *UserMutation) ProfilePhotoCleared() bool {
	return m.clearedprofile_photo
}

// ProfilePhotoID returns the profile_photo id in the mutation.
func (m *UserMutation) ProfilePhotoID() (id int, exists bool) {
	if m.profile_photo != nil {
		return *m.profile_photo, true
	}
	return
}

// ProfilePhotoIDs returns the profile_photo ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProfilePhotoID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfilePhotoIDs() (ids []int) {
	if id := m.profile_photo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfilePhoto reset all changes of the "profile_photo" edge.
func (m *UserMutation) ResetProfilePhoto() {
	m.profile_photo = nil
	m.clearedprofile_photo = false
}

// AddUserCreateIDs adds the User_create edge to Recommendations by ids.
func (m *UserMutation) AddUserCreateIDs(ids ...int) {
	if m._User_create == nil {
		m._User_create = make(map[int]struct{})
	}
	for i := range ids {
		m._User_create[ids[i]] = struct{}{}
	}
}

// ClearUserCreate clears the User_create edge to Recommendations.
func (m *UserMutation) ClearUserCreate() {
	m.cleared_User_create = true
}

// UserCreateCleared returns if the edge User_create was cleared.
func (m *UserMutation) UserCreateCleared() bool {
	return m.cleared_User_create
}

// RemoveUserCreateIDs removes the User_create edge to Recommendations by ids.
func (m *UserMutation) RemoveUserCreateIDs(ids ...int) {
	if m.removed_User_create == nil {
		m.removed_User_create = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_User_create[ids[i]] = struct{}{}
	}
}

// RemovedUserCreate returns the removed ids of User_create.
func (m *UserMutation) RemovedUserCreateIDs() (ids []int) {
	for id := range m.removed_User_create {
		ids = append(ids, id)
	}
	return
}

// UserCreateIDs returns the User_create ids in the mutation.
func (m *UserMutation) UserCreateIDs() (ids []int) {
	for id := range m._User_create {
		ids = append(ids, id)
	}
	return
}

// ResetUserCreate reset all changes of the "User_create" edge.
func (m *UserMutation) ResetUserCreate() {
	m._User_create = nil
	m.cleared_User_create = false
	m.removed_User_create = nil
}

// AddUserApprovedIDs adds the User_approved edge to Recommendations by ids.
func (m *UserMutation) AddUserApprovedIDs(ids ...int) {
	if m._User_approved == nil {
		m._User_approved = make(map[int]struct{})
	}
	for i := range ids {
		m._User_approved[ids[i]] = struct{}{}
	}
}

// ClearUserApproved clears the User_approved edge to Recommendations.
func (m *UserMutation) ClearUserApproved() {
	m.cleared_User_approved = true
}

// UserApprovedCleared returns if the edge User_approved was cleared.
func (m *UserMutation) UserApprovedCleared() bool {
	return m.cleared_User_approved
}

// RemoveUserApprovedIDs removes the User_approved edge to Recommendations by ids.
func (m *UserMutation) RemoveUserApprovedIDs(ids ...int) {
	if m.removed_User_approved == nil {
		m.removed_User_approved = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_User_approved[ids[i]] = struct{}{}
	}
}

// RemovedUserApproved returns the removed ids of User_approved.
func (m *UserMutation) RemovedUserApprovedIDs() (ids []int) {
	for id := range m.removed_User_approved {
		ids = append(ids, id)
	}
	return
}

// UserApprovedIDs returns the User_approved ids in the mutation.
func (m *UserMutation) UserApprovedIDs() (ids []int) {
	for id := range m._User_approved {
		ids = append(ids, id)
	}
	return
}

// ResetUserApproved reset all changes of the "User_approved" edge.
func (m *UserMutation) ResetUserApproved() {
	m._User_approved = nil
	m.cleared_User_approved = false
	m.removed_User_approved = nil
}

// AddGroupIDs adds the groups edge to UsersGroup by ids.
func (m *UserMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the groups edge to UsersGroup.
func (m *UserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared returns if the edge groups was cleared.
func (m *UserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the groups edge to UsersGroup by ids.
func (m *UserMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed ids of groups.
func (m *UserMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the groups ids in the mutation.
func (m *UserMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups reset all changes of the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// SetOrganizationID sets the organization edge to Organization by id.
func (m *UserMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the organization edge to Organization.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the edge organization was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the organization id in the mutation.
func (m *UserMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the organization ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization reset all changes of the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddOwnedWorkOrderIDs adds the owned_work_orders edge to WorkOrder by ids.
func (m *UserMutation) AddOwnedWorkOrderIDs(ids ...int) {
	if m.owned_work_orders == nil {
		m.owned_work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_work_orders[ids[i]] = struct{}{}
	}
}

// ClearOwnedWorkOrders clears the owned_work_orders edge to WorkOrder.
func (m *UserMutation) ClearOwnedWorkOrders() {
	m.clearedowned_work_orders = true
}

// OwnedWorkOrdersCleared returns if the edge owned_work_orders was cleared.
func (m *UserMutation) OwnedWorkOrdersCleared() bool {
	return m.clearedowned_work_orders
}

// RemoveOwnedWorkOrderIDs removes the owned_work_orders edge to WorkOrder by ids.
func (m *UserMutation) RemoveOwnedWorkOrderIDs(ids ...int) {
	if m.removedowned_work_orders == nil {
		m.removedowned_work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedowned_work_orders[ids[i]] = struct{}{}
	}
}

// RemovedOwnedWorkOrders returns the removed ids of owned_work_orders.
func (m *UserMutation) RemovedOwnedWorkOrdersIDs() (ids []int) {
	for id := range m.removedowned_work_orders {
		ids = append(ids, id)
	}
	return
}

// OwnedWorkOrdersIDs returns the owned_work_orders ids in the mutation.
func (m *UserMutation) OwnedWorkOrdersIDs() (ids []int) {
	for id := range m.owned_work_orders {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedWorkOrders reset all changes of the "owned_work_orders" edge.
func (m *UserMutation) ResetOwnedWorkOrders() {
	m.owned_work_orders = nil
	m.clearedowned_work_orders = false
	m.removedowned_work_orders = nil
}

// AddAssignedWorkOrderIDs adds the assigned_work_orders edge to WorkOrder by ids.
func (m *UserMutation) AddAssignedWorkOrderIDs(ids ...int) {
	if m.assigned_work_orders == nil {
		m.assigned_work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_work_orders[ids[i]] = struct{}{}
	}
}

// ClearAssignedWorkOrders clears the assigned_work_orders edge to WorkOrder.
func (m *UserMutation) ClearAssignedWorkOrders() {
	m.clearedassigned_work_orders = true
}

// AssignedWorkOrdersCleared returns if the edge assigned_work_orders was cleared.
func (m *UserMutation) AssignedWorkOrdersCleared() bool {
	return m.clearedassigned_work_orders
}

// RemoveAssignedWorkOrderIDs removes the assigned_work_orders edge to WorkOrder by ids.
func (m *UserMutation) RemoveAssignedWorkOrderIDs(ids ...int) {
	if m.removedassigned_work_orders == nil {
		m.removedassigned_work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedassigned_work_orders[ids[i]] = struct{}{}
	}
}

// RemovedAssignedWorkOrders returns the removed ids of assigned_work_orders.
func (m *UserMutation) RemovedAssignedWorkOrdersIDs() (ids []int) {
	for id := range m.removedassigned_work_orders {
		ids = append(ids, id)
	}
	return
}

// AssignedWorkOrdersIDs returns the assigned_work_orders ids in the mutation.
func (m *UserMutation) AssignedWorkOrdersIDs() (ids []int) {
	for id := range m.assigned_work_orders {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedWorkOrders reset all changes of the "assigned_work_orders" edge.
func (m *UserMutation) ResetAssignedWorkOrders() {
	m.assigned_work_orders = nil
	m.clearedassigned_work_orders = false
	m.removedassigned_work_orders = nil
}

// AddCreatedProjectIDs adds the created_projects edge to Project by ids.
func (m *UserMutation) AddCreatedProjectIDs(ids ...int) {
	if m.created_projects == nil {
		m.created_projects = make(map[int]struct{})
	}
	for i := range ids {
		m.created_projects[ids[i]] = struct{}{}
	}
}

// ClearCreatedProjects clears the created_projects edge to Project.
func (m *UserMutation) ClearCreatedProjects() {
	m.clearedcreated_projects = true
}

// CreatedProjectsCleared returns if the edge created_projects was cleared.
func (m *UserMutation) CreatedProjectsCleared() bool {
	return m.clearedcreated_projects
}

// RemoveCreatedProjectIDs removes the created_projects edge to Project by ids.
func (m *UserMutation) RemoveCreatedProjectIDs(ids ...int) {
	if m.removedcreated_projects == nil {
		m.removedcreated_projects = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcreated_projects[ids[i]] = struct{}{}
	}
}

// RemovedCreatedProjects returns the removed ids of created_projects.
func (m *UserMutation) RemovedCreatedProjectsIDs() (ids []int) {
	for id := range m.removedcreated_projects {
		ids = append(ids, id)
	}
	return
}

// CreatedProjectsIDs returns the created_projects ids in the mutation.
func (m *UserMutation) CreatedProjectsIDs() (ids []int) {
	for id := range m.created_projects {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedProjects reset all changes of the "created_projects" edge.
func (m *UserMutation) ResetCreatedProjects() {
	m.created_projects = nil
	m.clearedcreated_projects = false
	m.removedcreated_projects = nil
}

// AddFeatureIDs adds the features edge to Feature by ids.
func (m *UserMutation) AddFeatureIDs(ids ...int) {
	if m.features == nil {
		m.features = make(map[int]struct{})
	}
	for i := range ids {
		m.features[ids[i]] = struct{}{}
	}
}

// ClearFeatures clears the features edge to Feature.
func (m *UserMutation) ClearFeatures() {
	m.clearedfeatures = true
}

// FeaturesCleared returns if the edge features was cleared.
func (m *UserMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// RemoveFeatureIDs removes the features edge to Feature by ids.
func (m *UserMutation) RemoveFeatureIDs(ids ...int) {
	if m.removedfeatures == nil {
		m.removedfeatures = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfeatures[ids[i]] = struct{}{}
	}
}

// RemovedFeatures returns the removed ids of features.
func (m *UserMutation) RemovedFeaturesIDs() (ids []int) {
	for id := range m.removedfeatures {
		ids = append(ids, id)
	}
	return
}

// FeaturesIDs returns the features ids in the mutation.
func (m *UserMutation) FeaturesIDs() (ids []int) {
	for id := range m.features {
		ids = append(ids, id)
	}
	return
}

// ResetFeatures reset all changes of the "features" edge.
func (m *UserMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
	m.removedfeatures = nil
}

// AddAppointmentIDs adds the appointment edge to Appointment by ids.
func (m *UserMutation) AddAppointmentIDs(ids ...int) {
	if m.appointment == nil {
		m.appointment = make(map[int]struct{})
	}
	for i := range ids {
		m.appointment[ids[i]] = struct{}{}
	}
}

// ClearAppointment clears the appointment edge to Appointment.
func (m *UserMutation) ClearAppointment() {
	m.clearedappointment = true
}

// AppointmentCleared returns if the edge appointment was cleared.
func (m *UserMutation) AppointmentCleared() bool {
	return m.clearedappointment
}

// RemoveAppointmentIDs removes the appointment edge to Appointment by ids.
func (m *UserMutation) RemoveAppointmentIDs(ids ...int) {
	if m.removedappointment == nil {
		m.removedappointment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedappointment[ids[i]] = struct{}{}
	}
}

// RemovedAppointment returns the removed ids of appointment.
func (m *UserMutation) RemovedAppointmentIDs() (ids []int) {
	for id := range m.removedappointment {
		ids = append(ids, id)
	}
	return
}

// AppointmentIDs returns the appointment ids in the mutation.
func (m *UserMutation) AppointmentIDs() (ids []int) {
	for id := range m.appointment {
		ids = append(ids, id)
	}
	return
}

// ResetAppointment reset all changes of the "appointment" edge.
func (m *UserMutation) ResetAppointment() {
	m.appointment = nil
	m.clearedappointment = false
	m.removedappointment = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.auth_id != nil {
		fields = append(fields, user.FieldAuthID)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.distance_unit != nil {
		fields = append(fields, user.FieldDistanceUnit)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldAuthID:
		return m.AuthID()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRole:
		return m.Role()
	case user.FieldDistanceUnit:
		return m.DistanceUnit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldAuthID:
		return m.OldAuthID(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldDistanceUnit:
		return m.OldDistanceUnit(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthID(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldDistanceUnit:
		v, ok := value.(user.DistanceUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceUnit(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldAuthID:
		m.ResetAuthID()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldDistanceUnit:
		m.ResetDistanceUnit()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.profile_photo != nil {
		edges = append(edges, user.EdgeProfilePhoto)
	}
	if m._User_create != nil {
		edges = append(edges, user.EdgeUserCreate)
	}
	if m._User_approved != nil {
		edges = append(edges, user.EdgeUserApproved)
	}
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.owned_work_orders != nil {
		edges = append(edges, user.EdgeOwnedWorkOrders)
	}
	if m.assigned_work_orders != nil {
		edges = append(edges, user.EdgeAssignedWorkOrders)
	}
	if m.created_projects != nil {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.features != nil {
		edges = append(edges, user.EdgeFeatures)
	}
	if m.appointment != nil {
		edges = append(edges, user.EdgeAppointment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProfilePhoto:
		if id := m.profile_photo; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserCreate:
		ids := make([]ent.Value, 0, len(m._User_create))
		for id := range m._User_create {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserApproved:
		ids := make([]ent.Value, 0, len(m._User_approved))
		for id := range m._User_approved {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOwnedWorkOrders:
		ids := make([]ent.Value, 0, len(m.owned_work_orders))
		for id := range m.owned_work_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedWorkOrders:
		ids := make([]ent.Value, 0, len(m.assigned_work_orders))
		for id := range m.assigned_work_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProjects:
		ids := make([]ent.Value, 0, len(m.created_projects))
		for id := range m.created_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.features))
		for id := range m.features {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppointment:
		ids := make([]ent.Value, 0, len(m.appointment))
		for id := range m.appointment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removed_User_create != nil {
		edges = append(edges, user.EdgeUserCreate)
	}
	if m.removed_User_approved != nil {
		edges = append(edges, user.EdgeUserApproved)
	}
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.removedowned_work_orders != nil {
		edges = append(edges, user.EdgeOwnedWorkOrders)
	}
	if m.removedassigned_work_orders != nil {
		edges = append(edges, user.EdgeAssignedWorkOrders)
	}
	if m.removedcreated_projects != nil {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.removedfeatures != nil {
		edges = append(edges, user.EdgeFeatures)
	}
	if m.removedappointment != nil {
		edges = append(edges, user.EdgeAppointment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserCreate:
		ids := make([]ent.Value, 0, len(m.removed_User_create))
		for id := range m.removed_User_create {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserApproved:
		ids := make([]ent.Value, 0, len(m.removed_User_approved))
		for id := range m.removed_User_approved {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedWorkOrders:
		ids := make([]ent.Value, 0, len(m.removedowned_work_orders))
		for id := range m.removedowned_work_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedWorkOrders:
		ids := make([]ent.Value, 0, len(m.removedassigned_work_orders))
		for id := range m.removedassigned_work_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProjects:
		ids := make([]ent.Value, 0, len(m.removedcreated_projects))
		for id := range m.removedcreated_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.removedfeatures))
		for id := range m.removedfeatures {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppointment:
		ids := make([]ent.Value, 0, len(m.removedappointment))
		for id := range m.removedappointment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedprofile_photo {
		edges = append(edges, user.EdgeProfilePhoto)
	}
	if m.cleared_User_create {
		edges = append(edges, user.EdgeUserCreate)
	}
	if m.cleared_User_approved {
		edges = append(edges, user.EdgeUserApproved)
	}
	if m.clearedgroups {
		edges = append(edges, user.EdgeGroups)
	}
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.clearedowned_work_orders {
		edges = append(edges, user.EdgeOwnedWorkOrders)
	}
	if m.clearedassigned_work_orders {
		edges = append(edges, user.EdgeAssignedWorkOrders)
	}
	if m.clearedcreated_projects {
		edges = append(edges, user.EdgeCreatedProjects)
	}
	if m.clearedfeatures {
		edges = append(edges, user.EdgeFeatures)
	}
	if m.clearedappointment {
		edges = append(edges, user.EdgeAppointment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProfilePhoto:
		return m.clearedprofile_photo
	case user.EdgeUserCreate:
		return m.cleared_User_create
	case user.EdgeUserApproved:
		return m.cleared_User_approved
	case user.EdgeGroups:
		return m.clearedgroups
	case user.EdgeOrganization:
		return m.clearedorganization
	case user.EdgeOwnedWorkOrders:
		return m.clearedowned_work_orders
	case user.EdgeAssignedWorkOrders:
		return m.clearedassigned_work_orders
	case user.EdgeCreatedProjects:
		return m.clearedcreated_projects
	case user.EdgeFeatures:
		return m.clearedfeatures
	case user.EdgeAppointment:
		return m.clearedappointment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfilePhoto:
		m.ClearProfilePhoto()
		return nil
	case user.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProfilePhoto:
		m.ResetProfilePhoto()
		return nil
	case user.EdgeUserCreate:
		m.ResetUserCreate()
		return nil
	case user.EdgeUserApproved:
		m.ResetUserApproved()
		return nil
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case user.EdgeOwnedWorkOrders:
		m.ResetOwnedWorkOrders()
		return nil
	case user.EdgeAssignedWorkOrders:
		m.ResetAssignedWorkOrders()
		return nil
	case user.EdgeCreatedProjects:
		m.ResetCreatedProjects()
		return nil
	case user.EdgeFeatures:
		m.ResetFeatures()
		return nil
	case user.EdgeAppointment:
		m.ResetAppointment()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UsersGroupMutation represents an operation that mutate the UsersGroups
// nodes in the graph.
type UsersGroupMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	description     *string
	status          *usersgroup.Status
	clearedFields   map[string]struct{}
	members         map[int]struct{}
	removedmembers  map[int]struct{}
	clearedmembers  bool
	policies        map[int]struct{}
	removedpolicies map[int]struct{}
	clearedpolicies bool
	features        map[int]struct{}
	removedfeatures map[int]struct{}
	clearedfeatures bool
	done            bool
	oldValue        func(context.Context) (*UsersGroup, error)
	predicates      []predicate.UsersGroup
}

var _ ent.Mutation = (*UsersGroupMutation)(nil)

// usersgroupOption allows to manage the mutation configuration using functional options.
type usersgroupOption func(*UsersGroupMutation)

// newUsersGroupMutation creates new mutation for UsersGroup.
func newUsersGroupMutation(c config, op Op, opts ...usersgroupOption) *UsersGroupMutation {
	m := &UsersGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUsersGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsersGroupID sets the id field of the mutation.
func withUsersGroupID(id int) usersgroupOption {
	return func(m *UsersGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UsersGroup
		)
		m.oldValue = func(ctx context.Context) (*UsersGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsersGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsersGroup sets the old UsersGroup of the mutation.
func withUsersGroup(node *UsersGroup) usersgroupOption {
	return func(m *UsersGroupMutation) {
		m.oldValue = func(context.Context) (*UsersGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsersGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsersGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UsersGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *UsersGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *UsersGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the UsersGroup.
// If the UsersGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UsersGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *UsersGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *UsersGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *UsersGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the UsersGroup.
// If the UsersGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UsersGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *UsersGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *UsersGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UsersGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the UsersGroup.
// If the UsersGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UsersGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UsersGroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *UsersGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *UsersGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the UsersGroup.
// If the UsersGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UsersGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *UsersGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[usersgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *UsersGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[usersgroup.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *UsersGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, usersgroup.FieldDescription)
}

// SetStatus sets the status field.
func (m *UsersGroupMutation) SetStatus(u usersgroup.Status) {
	m.status = &u
}

// Status returns the status value in the mutation.
func (m *UsersGroupMutation) Status() (r usersgroup.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the UsersGroup.
// If the UsersGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UsersGroupMutation) OldStatus(ctx context.Context) (v usersgroup.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *UsersGroupMutation) ResetStatus() {
	m.status = nil
}

// AddMemberIDs adds the members edge to User by ids.
func (m *UsersGroupMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the members edge to User.
func (m *UsersGroupMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared returns if the edge members was cleared.
func (m *UsersGroupMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the members edge to User by ids.
func (m *UsersGroupMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed ids of members.
func (m *UsersGroupMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the members ids in the mutation.
func (m *UsersGroupMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers reset all changes of the "members" edge.
func (m *UsersGroupMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddPolicyIDs adds the policies edge to PermissionsPolicy by ids.
func (m *UsersGroupMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the policies edge to PermissionsPolicy.
func (m *UsersGroupMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared returns if the edge policies was cleared.
func (m *UsersGroupMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the policies edge to PermissionsPolicy by ids.
func (m *UsersGroupMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed ids of policies.
func (m *UsersGroupMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the policies ids in the mutation.
func (m *UsersGroupMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies reset all changes of the "policies" edge.
func (m *UsersGroupMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// AddFeatureIDs adds the features edge to Feature by ids.
func (m *UsersGroupMutation) AddFeatureIDs(ids ...int) {
	if m.features == nil {
		m.features = make(map[int]struct{})
	}
	for i := range ids {
		m.features[ids[i]] = struct{}{}
	}
}

// ClearFeatures clears the features edge to Feature.
func (m *UsersGroupMutation) ClearFeatures() {
	m.clearedfeatures = true
}

// FeaturesCleared returns if the edge features was cleared.
func (m *UsersGroupMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// RemoveFeatureIDs removes the features edge to Feature by ids.
func (m *UsersGroupMutation) RemoveFeatureIDs(ids ...int) {
	if m.removedfeatures == nil {
		m.removedfeatures = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfeatures[ids[i]] = struct{}{}
	}
}

// RemovedFeatures returns the removed ids of features.
func (m *UsersGroupMutation) RemovedFeaturesIDs() (ids []int) {
	for id := range m.removedfeatures {
		ids = append(ids, id)
	}
	return
}

// FeaturesIDs returns the features ids in the mutation.
func (m *UsersGroupMutation) FeaturesIDs() (ids []int) {
	for id := range m.features {
		ids = append(ids, id)
	}
	return
}

// ResetFeatures reset all changes of the "features" edge.
func (m *UsersGroupMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
	m.removedfeatures = nil
}

// Op returns the operation name.
func (m *UsersGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UsersGroup).
func (m *UsersGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UsersGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, usersgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usersgroup.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, usersgroup.FieldName)
	}
	if m.description != nil {
		fields = append(fields, usersgroup.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, usersgroup.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UsersGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersgroup.FieldCreateTime:
		return m.CreateTime()
	case usersgroup.FieldUpdateTime:
		return m.UpdateTime()
	case usersgroup.FieldName:
		return m.Name()
	case usersgroup.FieldDescription:
		return m.Description()
	case usersgroup.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UsersGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usersgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usersgroup.FieldName:
		return m.OldName(ctx)
	case usersgroup.FieldDescription:
		return m.OldDescription(ctx)
	case usersgroup.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UsersGroup field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UsersGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersgroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usersgroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usersgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usersgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case usersgroup.FieldStatus:
		v, ok := value.(usersgroup.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UsersGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UsersGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UsersGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UsersGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsersGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UsersGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersgroup.FieldDescription) {
		fields = append(fields, usersgroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UsersGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsersGroupMutation) ClearField(name string) error {
	switch name {
	case usersgroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown UsersGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UsersGroupMutation) ResetField(name string) error {
	switch name {
	case usersgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usersgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usersgroup.FieldName:
		m.ResetName()
		return nil
	case usersgroup.FieldDescription:
		m.ResetDescription()
		return nil
	case usersgroup.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UsersGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UsersGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.members != nil {
		edges = append(edges, usersgroup.EdgeMembers)
	}
	if m.policies != nil {
		edges = append(edges, usersgroup.EdgePolicies)
	}
	if m.features != nil {
		edges = append(edges, usersgroup.EdgeFeatures)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UsersGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersgroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case usersgroup.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	case usersgroup.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.features))
		for id := range m.features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UsersGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmembers != nil {
		edges = append(edges, usersgroup.EdgeMembers)
	}
	if m.removedpolicies != nil {
		edges = append(edges, usersgroup.EdgePolicies)
	}
	if m.removedfeatures != nil {
		edges = append(edges, usersgroup.EdgeFeatures)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UsersGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usersgroup.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case usersgroup.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	case usersgroup.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.removedfeatures))
		for id := range m.removedfeatures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UsersGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmembers {
		edges = append(edges, usersgroup.EdgeMembers)
	}
	if m.clearedpolicies {
		edges = append(edges, usersgroup.EdgePolicies)
	}
	if m.clearedfeatures {
		edges = append(edges, usersgroup.EdgeFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UsersGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case usersgroup.EdgeMembers:
		return m.clearedmembers
	case usersgroup.EdgePolicies:
		return m.clearedpolicies
	case usersgroup.EdgeFeatures:
		return m.clearedfeatures
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UsersGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UsersGroup unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UsersGroupMutation) ResetEdge(name string) error {
	switch name {
	case usersgroup.EdgeMembers:
		m.ResetMembers()
		return nil
	case usersgroup.EdgePolicies:
		m.ResetPolicies()
		return nil
	case usersgroup.EdgeFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown UsersGroup edge %s", name)
}

// VendorMutation represents an operation that mutate the Vendors
// nodes in the graph.
type VendorMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	name                          *string
	clearedFields                 map[string]struct{}
	vendor_fk                     map[int]struct{}
	removedvendor_fk              map[int]struct{}
	clearedvendor_fk              bool
	vendors_recomendations        map[int]struct{}
	removedvendors_recomendations map[int]struct{}
	clearedvendors_recomendations bool
	done                          bool
	oldValue                      func(context.Context) (*Vendor, error)
	predicates                    []predicate.Vendor
}

var _ ent.Mutation = (*VendorMutation)(nil)

// vendorOption allows to manage the mutation configuration using functional options.
type vendorOption func(*VendorMutation)

// newVendorMutation creates new mutation for Vendor.
func newVendorMutation(c config, op Op, opts ...vendorOption) *VendorMutation {
	m := &VendorMutation{
		config:        c,
		op:            op,
		typ:           TypeVendor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorID sets the id field of the mutation.
func withVendorID(id int) vendorOption {
	return func(m *VendorMutation) {
		var (
			err   error
			once  sync.Once
			value *Vendor
		)
		m.oldValue = func(ctx context.Context) (*Vendor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vendor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendor sets the old Vendor of the mutation.
func withVendor(node *Vendor) vendorOption {
	return func(m *VendorMutation) {
		m.oldValue = func(context.Context) (*Vendor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *VendorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *VendorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *VendorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Vendor.
// If the Vendor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VendorMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *VendorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *VendorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *VendorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Vendor.
// If the Vendor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VendorMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *VendorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *VendorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *VendorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Vendor.
// If the Vendor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VendorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *VendorMutation) ResetName() {
	m.name = nil
}

// AddVendorFkIDs adds the vendor_fk edge to Counter by ids.
func (m *VendorMutation) AddVendorFkIDs(ids ...int) {
	if m.vendor_fk == nil {
		m.vendor_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.vendor_fk[ids[i]] = struct{}{}
	}
}

// ClearVendorFk clears the vendor_fk edge to Counter.
func (m *VendorMutation) ClearVendorFk() {
	m.clearedvendor_fk = true
}

// VendorFkCleared returns if the edge vendor_fk was cleared.
func (m *VendorMutation) VendorFkCleared() bool {
	return m.clearedvendor_fk
}

// RemoveVendorFkIDs removes the vendor_fk edge to Counter by ids.
func (m *VendorMutation) RemoveVendorFkIDs(ids ...int) {
	if m.removedvendor_fk == nil {
		m.removedvendor_fk = make(map[int]struct{})
	}
	for i := range ids {
		m.removedvendor_fk[ids[i]] = struct{}{}
	}
}

// RemovedVendorFk returns the removed ids of vendor_fk.
func (m *VendorMutation) RemovedVendorFkIDs() (ids []int) {
	for id := range m.removedvendor_fk {
		ids = append(ids, id)
	}
	return
}

// VendorFkIDs returns the vendor_fk ids in the mutation.
func (m *VendorMutation) VendorFkIDs() (ids []int) {
	for id := range m.vendor_fk {
		ids = append(ids, id)
	}
	return
}

// ResetVendorFk reset all changes of the "vendor_fk" edge.
func (m *VendorMutation) ResetVendorFk() {
	m.vendor_fk = nil
	m.clearedvendor_fk = false
	m.removedvendor_fk = nil
}

// AddVendorsRecomendationIDs adds the vendors_recomendations edge to Recommendations by ids.
func (m *VendorMutation) AddVendorsRecomendationIDs(ids ...int) {
	if m.vendors_recomendations == nil {
		m.vendors_recomendations = make(map[int]struct{})
	}
	for i := range ids {
		m.vendors_recomendations[ids[i]] = struct{}{}
	}
}

// ClearVendorsRecomendations clears the vendors_recomendations edge to Recommendations.
func (m *VendorMutation) ClearVendorsRecomendations() {
	m.clearedvendors_recomendations = true
}

// VendorsRecomendationsCleared returns if the edge vendors_recomendations was cleared.
func (m *VendorMutation) VendorsRecomendationsCleared() bool {
	return m.clearedvendors_recomendations
}

// RemoveVendorsRecomendationIDs removes the vendors_recomendations edge to Recommendations by ids.
func (m *VendorMutation) RemoveVendorsRecomendationIDs(ids ...int) {
	if m.removedvendors_recomendations == nil {
		m.removedvendors_recomendations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedvendors_recomendations[ids[i]] = struct{}{}
	}
}

// RemovedVendorsRecomendations returns the removed ids of vendors_recomendations.
func (m *VendorMutation) RemovedVendorsRecomendationsIDs() (ids []int) {
	for id := range m.removedvendors_recomendations {
		ids = append(ids, id)
	}
	return
}

// VendorsRecomendationsIDs returns the vendors_recomendations ids in the mutation.
func (m *VendorMutation) VendorsRecomendationsIDs() (ids []int) {
	for id := range m.vendors_recomendations {
		ids = append(ids, id)
	}
	return
}

// ResetVendorsRecomendations reset all changes of the "vendors_recomendations" edge.
func (m *VendorMutation) ResetVendorsRecomendations() {
	m.vendors_recomendations = nil
	m.clearedvendors_recomendations = false
	m.removedvendors_recomendations = nil
}

// Op returns the operation name.
func (m *VendorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vendor).
func (m *VendorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *VendorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, vendor.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, vendor.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, vendor.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *VendorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendor.FieldCreateTime:
		return m.CreateTime()
	case vendor.FieldUpdateTime:
		return m.UpdateTime()
	case vendor.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *VendorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendor.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case vendor.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case vendor.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Vendor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VendorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendor.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case vendor.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case vendor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Vendor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *VendorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *VendorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VendorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vendor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *VendorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *VendorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vendor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *VendorMutation) ResetField(name string) error {
	switch name {
	case vendor.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case vendor.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case vendor.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Vendor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *VendorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vendor_fk != nil {
		edges = append(edges, vendor.EdgeVendorFk)
	}
	if m.vendors_recomendations != nil {
		edges = append(edges, vendor.EdgeVendorsRecomendations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *VendorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vendor.EdgeVendorFk:
		ids := make([]ent.Value, 0, len(m.vendor_fk))
		for id := range m.vendor_fk {
			ids = append(ids, id)
		}
		return ids
	case vendor.EdgeVendorsRecomendations:
		ids := make([]ent.Value, 0, len(m.vendors_recomendations))
		for id := range m.vendors_recomendations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *VendorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvendor_fk != nil {
		edges = append(edges, vendor.EdgeVendorFk)
	}
	if m.removedvendors_recomendations != nil {
		edges = append(edges, vendor.EdgeVendorsRecomendations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *VendorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vendor.EdgeVendorFk:
		ids := make([]ent.Value, 0, len(m.removedvendor_fk))
		for id := range m.removedvendor_fk {
			ids = append(ids, id)
		}
		return ids
	case vendor.EdgeVendorsRecomendations:
		ids := make([]ent.Value, 0, len(m.removedvendors_recomendations))
		for id := range m.removedvendors_recomendations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *VendorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvendor_fk {
		edges = append(edges, vendor.EdgeVendorFk)
	}
	if m.clearedvendors_recomendations {
		edges = append(edges, vendor.EdgeVendorsRecomendations)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *VendorMutation) EdgeCleared(name string) bool {
	switch name {
	case vendor.EdgeVendorFk:
		return m.clearedvendor_fk
	case vendor.EdgeVendorsRecomendations:
		return m.clearedvendors_recomendations
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *VendorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vendor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *VendorMutation) ResetEdge(name string) error {
	switch name {
	case vendor.EdgeVendorFk:
		m.ResetVendorFk()
		return nil
	case vendor.EdgeVendorsRecomendations:
		m.ResetVendorsRecomendations()
		return nil
	}
	return fmt.Errorf("unknown Vendor edge %s", name)
}

// WorkOrderMutation represents an operation that mutate the WorkOrders
// nodes in the graph.
type WorkOrderMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	name                         *string
	status                       *workorder.Status
	priority                     *workorder.Priority
	description                  *string
	install_date                 *time.Time
	creation_date                *time.Time
	index                        *int
	addindex                     *int
	close_date                   *time.Time
	duration                     *float64
	addduration                  *float64
	schedulled_at                *time.Time
	due_date                     *time.Time
	clearedFields                map[string]struct{}
	_type                        *int
	cleared_type                 bool
	template                     *int
	clearedtemplate              bool
	equipment                    map[int]struct{}
	removedequipment             map[int]struct{}
	clearedequipment             bool
	links                        map[int]struct{}
	removedlinks                 map[int]struct{}
	clearedlinks                 bool
	organization                 *int
	clearedorganization          bool
	files                        map[int]struct{}
	removedfiles                 map[int]struct{}
	clearedfiles                 bool
	hyperlinks                   map[int]struct{}
	removedhyperlinks            map[int]struct{}
	clearedhyperlinks            bool
	location                     *int
	clearedlocation              bool
	comments                     map[int]struct{}
	removedcomments              map[int]struct{}
	clearedcomments              bool
	activities                   map[int]struct{}
	removedactivities            map[int]struct{}
	clearedactivities            bool
	properties                   map[int]struct{}
	removedproperties            map[int]struct{}
	clearedproperties            bool
	check_list_categories        map[int]struct{}
	removedcheck_list_categories map[int]struct{}
	clearedcheck_list_categories bool
	project                      *int
	clearedproject               bool
	owner                        *int
	clearedowner                 bool
	assignee                     *int
	clearedassignee              bool
	appointment                  map[int]struct{}
	removedappointment           map[int]struct{}
	clearedappointment           bool
	done                         bool
	oldValue                     func(context.Context) (*WorkOrder, error)
	predicates                   []predicate.WorkOrder
}

var _ ent.Mutation = (*WorkOrderMutation)(nil)

// workorderOption allows to manage the mutation configuration using functional options.
type workorderOption func(*WorkOrderMutation)

// newWorkOrderMutation creates new mutation for WorkOrder.
func newWorkOrderMutation(c config, op Op, opts ...workorderOption) *WorkOrderMutation {
	m := &WorkOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkOrderID sets the id field of the mutation.
func withWorkOrderID(id int) workorderOption {
	return func(m *WorkOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkOrder
		)
		m.oldValue = func(ctx context.Context) (*WorkOrder, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkOrder sets the old WorkOrder of the mutation.
func withWorkOrder(node *WorkOrder) workorderOption {
	return func(m *WorkOrderMutation) {
		m.oldValue = func(context.Context) (*WorkOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WorkOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *WorkOrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *WorkOrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *WorkOrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *WorkOrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *WorkOrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *WorkOrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *WorkOrderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WorkOrderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WorkOrderMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the status field.
func (m *WorkOrderMutation) SetStatus(w workorder.Status) {
	m.status = &w
}

// Status returns the status value in the mutation.
func (m *WorkOrderMutation) Status() (r workorder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldStatus(ctx context.Context) (v workorder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *WorkOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the priority field.
func (m *WorkOrderMutation) SetPriority(w workorder.Priority) {
	m.priority = &w
}

// Priority returns the priority value in the mutation.
func (m *WorkOrderMutation) Priority() (r workorder.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old priority value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldPriority(ctx context.Context) (v workorder.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriority is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority reset all changes of the "priority" field.
func (m *WorkOrderMutation) ResetPriority() {
	m.priority = nil
}

// SetDescription sets the description field.
func (m *WorkOrderMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *WorkOrderMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *WorkOrderMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workorder.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *WorkOrderMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workorder.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *WorkOrderMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workorder.FieldDescription)
}

// SetInstallDate sets the install_date field.
func (m *WorkOrderMutation) SetInstallDate(t time.Time) {
	m.install_date = &t
}

// InstallDate returns the install_date value in the mutation.
func (m *WorkOrderMutation) InstallDate() (r time.Time, exists bool) {
	v := m.install_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallDate returns the old install_date value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldInstallDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstallDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstallDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallDate: %w", err)
	}
	return oldValue.InstallDate, nil
}

// ClearInstallDate clears the value of install_date.
func (m *WorkOrderMutation) ClearInstallDate() {
	m.install_date = nil
	m.clearedFields[workorder.FieldInstallDate] = struct{}{}
}

// InstallDateCleared returns if the field install_date was cleared in this mutation.
func (m *WorkOrderMutation) InstallDateCleared() bool {
	_, ok := m.clearedFields[workorder.FieldInstallDate]
	return ok
}

// ResetInstallDate reset all changes of the "install_date" field.
func (m *WorkOrderMutation) ResetInstallDate() {
	m.install_date = nil
	delete(m.clearedFields, workorder.FieldInstallDate)
}

// SetCreationDate sets the creation_date field.
func (m *WorkOrderMutation) SetCreationDate(t time.Time) {
	m.creation_date = &t
}

// CreationDate returns the creation_date value in the mutation.
func (m *WorkOrderMutation) CreationDate() (r time.Time, exists bool) {
	v := m.creation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationDate returns the old creation_date value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldCreationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreationDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationDate: %w", err)
	}
	return oldValue.CreationDate, nil
}

// ResetCreationDate reset all changes of the "creation_date" field.
func (m *WorkOrderMutation) ResetCreationDate() {
	m.creation_date = nil
}

// SetIndex sets the index field.
func (m *WorkOrderMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *WorkOrderMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *WorkOrderMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *WorkOrderMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *WorkOrderMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[workorder.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *WorkOrderMutation) IndexCleared() bool {
	_, ok := m.clearedFields[workorder.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *WorkOrderMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, workorder.FieldIndex)
}

// SetCloseDate sets the close_date field.
func (m *WorkOrderMutation) SetCloseDate(t time.Time) {
	m.close_date = &t
}

// CloseDate returns the close_date value in the mutation.
func (m *WorkOrderMutation) CloseDate() (r time.Time, exists bool) {
	v := m.close_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseDate returns the old close_date value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldCloseDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCloseDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCloseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseDate: %w", err)
	}
	return oldValue.CloseDate, nil
}

// ClearCloseDate clears the value of close_date.
func (m *WorkOrderMutation) ClearCloseDate() {
	m.close_date = nil
	m.clearedFields[workorder.FieldCloseDate] = struct{}{}
}

// CloseDateCleared returns if the field close_date was cleared in this mutation.
func (m *WorkOrderMutation) CloseDateCleared() bool {
	_, ok := m.clearedFields[workorder.FieldCloseDate]
	return ok
}

// ResetCloseDate reset all changes of the "close_date" field.
func (m *WorkOrderMutation) ResetCloseDate() {
	m.close_date = nil
	delete(m.clearedFields, workorder.FieldCloseDate)
}

// SetDuration sets the duration field.
func (m *WorkOrderMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *WorkOrderMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldDuration(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to duration.
func (m *WorkOrderMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *WorkOrderMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of duration.
func (m *WorkOrderMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[workorder.FieldDuration] = struct{}{}
}

// DurationCleared returns if the field duration was cleared in this mutation.
func (m *WorkOrderMutation) DurationCleared() bool {
	_, ok := m.clearedFields[workorder.FieldDuration]
	return ok
}

// ResetDuration reset all changes of the "duration" field.
func (m *WorkOrderMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, workorder.FieldDuration)
}

// SetSchedulledAt sets the schedulled_at field.
func (m *WorkOrderMutation) SetSchedulledAt(t time.Time) {
	m.schedulled_at = &t
}

// SchedulledAt returns the schedulled_at value in the mutation.
func (m *WorkOrderMutation) SchedulledAt() (r time.Time, exists bool) {
	v := m.schedulled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedulledAt returns the old schedulled_at value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldSchedulledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchedulledAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchedulledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedulledAt: %w", err)
	}
	return oldValue.SchedulledAt, nil
}

// ClearSchedulledAt clears the value of schedulled_at.
func (m *WorkOrderMutation) ClearSchedulledAt() {
	m.schedulled_at = nil
	m.clearedFields[workorder.FieldSchedulledAt] = struct{}{}
}

// SchedulledAtCleared returns if the field schedulled_at was cleared in this mutation.
func (m *WorkOrderMutation) SchedulledAtCleared() bool {
	_, ok := m.clearedFields[workorder.FieldSchedulledAt]
	return ok
}

// ResetSchedulledAt reset all changes of the "schedulled_at" field.
func (m *WorkOrderMutation) ResetSchedulledAt() {
	m.schedulled_at = nil
	delete(m.clearedFields, workorder.FieldSchedulledAt)
}

// SetDueDate sets the due_date field.
func (m *WorkOrderMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the due_date value in the mutation.
func (m *WorkOrderMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old due_date value of the WorkOrder.
// If the WorkOrder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDueDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of due_date.
func (m *WorkOrderMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[workorder.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the field due_date was cleared in this mutation.
func (m *WorkOrderMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[workorder.FieldDueDate]
	return ok
}

// ResetDueDate reset all changes of the "due_date" field.
func (m *WorkOrderMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, workorder.FieldDueDate)
}

// SetTypeID sets the type edge to WorkOrderType by id.
func (m *WorkOrderMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to WorkOrderType.
func (m *WorkOrderMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *WorkOrderMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *WorkOrderMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *WorkOrderMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *WorkOrderMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetTemplateID sets the template edge to WorkOrderTemplate by id.
func (m *WorkOrderMutation) SetTemplateID(id int) {
	m.template = &id
}

// ClearTemplate clears the template edge to WorkOrderTemplate.
func (m *WorkOrderMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared returns if the edge template was cleared.
func (m *WorkOrderMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateID returns the template id in the mutation.
func (m *WorkOrderMutation) TemplateID() (id int, exists bool) {
	if m.template != nil {
		return *m.template, true
	}
	return
}

// TemplateIDs returns the template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *WorkOrderMutation) TemplateIDs() (ids []int) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate reset all changes of the "template" edge.
func (m *WorkOrderMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// AddEquipmentIDs adds the equipment edge to Equipment by ids.
func (m *WorkOrderMutation) AddEquipmentIDs(ids ...int) {
	if m.equipment == nil {
		m.equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment[ids[i]] = struct{}{}
	}
}

// ClearEquipment clears the equipment edge to Equipment.
func (m *WorkOrderMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared returns if the edge equipment was cleared.
func (m *WorkOrderMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// RemoveEquipmentIDs removes the equipment edge to Equipment by ids.
func (m *WorkOrderMutation) RemoveEquipmentIDs(ids ...int) {
	if m.removedequipment == nil {
		m.removedequipment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedequipment[ids[i]] = struct{}{}
	}
}

// RemovedEquipment returns the removed ids of equipment.
func (m *WorkOrderMutation) RemovedEquipmentIDs() (ids []int) {
	for id := range m.removedequipment {
		ids = append(ids, id)
	}
	return
}

// EquipmentIDs returns the equipment ids in the mutation.
func (m *WorkOrderMutation) EquipmentIDs() (ids []int) {
	for id := range m.equipment {
		ids = append(ids, id)
	}
	return
}

// ResetEquipment reset all changes of the "equipment" edge.
func (m *WorkOrderMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
	m.removedequipment = nil
}

// AddLinkIDs adds the links edge to Link by ids.
func (m *WorkOrderMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the links edge to Link.
func (m *WorkOrderMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared returns if the edge links was cleared.
func (m *WorkOrderMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the links edge to Link by ids.
func (m *WorkOrderMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed ids of links.
func (m *WorkOrderMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the links ids in the mutation.
func (m *WorkOrderMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks reset all changes of the "links" edge.
func (m *WorkOrderMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// SetOrganizationID sets the organization edge to Organization by id.
func (m *WorkOrderMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the organization edge to Organization.
func (m *WorkOrderMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared returns if the edge organization was cleared.
func (m *WorkOrderMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the organization id in the mutation.
func (m *WorkOrderMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the organization ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkOrderMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization reset all changes of the "organization" edge.
func (m *WorkOrderMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddFileIDs adds the files edge to File by ids.
func (m *WorkOrderMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the files edge to File.
func (m *WorkOrderMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared returns if the edge files was cleared.
func (m *WorkOrderMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the files edge to File by ids.
func (m *WorkOrderMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed ids of files.
func (m *WorkOrderMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the files ids in the mutation.
func (m *WorkOrderMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles reset all changes of the "files" edge.
func (m *WorkOrderMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddHyperlinkIDs adds the hyperlinks edge to Hyperlink by ids.
func (m *WorkOrderMutation) AddHyperlinkIDs(ids ...int) {
	if m.hyperlinks == nil {
		m.hyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.hyperlinks[ids[i]] = struct{}{}
	}
}

// ClearHyperlinks clears the hyperlinks edge to Hyperlink.
func (m *WorkOrderMutation) ClearHyperlinks() {
	m.clearedhyperlinks = true
}

// HyperlinksCleared returns if the edge hyperlinks was cleared.
func (m *WorkOrderMutation) HyperlinksCleared() bool {
	return m.clearedhyperlinks
}

// RemoveHyperlinkIDs removes the hyperlinks edge to Hyperlink by ids.
func (m *WorkOrderMutation) RemoveHyperlinkIDs(ids ...int) {
	if m.removedhyperlinks == nil {
		m.removedhyperlinks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhyperlinks[ids[i]] = struct{}{}
	}
}

// RemovedHyperlinks returns the removed ids of hyperlinks.
func (m *WorkOrderMutation) RemovedHyperlinksIDs() (ids []int) {
	for id := range m.removedhyperlinks {
		ids = append(ids, id)
	}
	return
}

// HyperlinksIDs returns the hyperlinks ids in the mutation.
func (m *WorkOrderMutation) HyperlinksIDs() (ids []int) {
	for id := range m.hyperlinks {
		ids = append(ids, id)
	}
	return
}

// ResetHyperlinks reset all changes of the "hyperlinks" edge.
func (m *WorkOrderMutation) ResetHyperlinks() {
	m.hyperlinks = nil
	m.clearedhyperlinks = false
	m.removedhyperlinks = nil
}

// SetLocationID sets the location edge to Location by id.
func (m *WorkOrderMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *WorkOrderMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *WorkOrderMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *WorkOrderMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *WorkOrderMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *WorkOrderMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// AddCommentIDs adds the comments edge to Comment by ids.
func (m *WorkOrderMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the comments edge to Comment.
func (m *WorkOrderMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared returns if the edge comments was cleared.
func (m *WorkOrderMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the comments edge to Comment by ids.
func (m *WorkOrderMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed ids of comments.
func (m *WorkOrderMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the comments ids in the mutation.
func (m *WorkOrderMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments reset all changes of the "comments" edge.
func (m *WorkOrderMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddActivityIDs adds the activities edge to Activity by ids.
func (m *WorkOrderMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the activities edge to Activity.
func (m *WorkOrderMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared returns if the edge activities was cleared.
func (m *WorkOrderMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the activities edge to Activity by ids.
func (m *WorkOrderMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed ids of activities.
func (m *WorkOrderMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the activities ids in the mutation.
func (m *WorkOrderMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities reset all changes of the "activities" edge.
func (m *WorkOrderMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *WorkOrderMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the properties edge to Property.
func (m *WorkOrderMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared returns if the edge properties was cleared.
func (m *WorkOrderMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *WorkOrderMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *WorkOrderMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *WorkOrderMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *WorkOrderMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddCheckListCategoryIDs adds the check_list_categories edge to CheckListCategory by ids.
func (m *WorkOrderMutation) AddCheckListCategoryIDs(ids ...int) {
	if m.check_list_categories == nil {
		m.check_list_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.check_list_categories[ids[i]] = struct{}{}
	}
}

// ClearCheckListCategories clears the check_list_categories edge to CheckListCategory.
func (m *WorkOrderMutation) ClearCheckListCategories() {
	m.clearedcheck_list_categories = true
}

// CheckListCategoriesCleared returns if the edge check_list_categories was cleared.
func (m *WorkOrderMutation) CheckListCategoriesCleared() bool {
	return m.clearedcheck_list_categories
}

// RemoveCheckListCategoryIDs removes the check_list_categories edge to CheckListCategory by ids.
func (m *WorkOrderMutation) RemoveCheckListCategoryIDs(ids ...int) {
	if m.removedcheck_list_categories == nil {
		m.removedcheck_list_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheck_list_categories[ids[i]] = struct{}{}
	}
}

// RemovedCheckListCategories returns the removed ids of check_list_categories.
func (m *WorkOrderMutation) RemovedCheckListCategoriesIDs() (ids []int) {
	for id := range m.removedcheck_list_categories {
		ids = append(ids, id)
	}
	return
}

// CheckListCategoriesIDs returns the check_list_categories ids in the mutation.
func (m *WorkOrderMutation) CheckListCategoriesIDs() (ids []int) {
	for id := range m.check_list_categories {
		ids = append(ids, id)
	}
	return
}

// ResetCheckListCategories reset all changes of the "check_list_categories" edge.
func (m *WorkOrderMutation) ResetCheckListCategories() {
	m.check_list_categories = nil
	m.clearedcheck_list_categories = false
	m.removedcheck_list_categories = nil
}

// SetProjectID sets the project edge to Project by id.
func (m *WorkOrderMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the project edge to Project.
func (m *WorkOrderMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared returns if the edge project was cleared.
func (m *WorkOrderMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the project id in the mutation.
func (m *WorkOrderMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the project ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkOrderMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject reset all changes of the "project" edge.
func (m *WorkOrderMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetOwnerID sets the owner edge to User by id.
func (m *WorkOrderMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *WorkOrderMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *WorkOrderMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *WorkOrderMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *WorkOrderMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *WorkOrderMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetAssigneeID sets the assignee edge to User by id.
func (m *WorkOrderMutation) SetAssigneeID(id int) {
	m.assignee = &id
}

// ClearAssignee clears the assignee edge to User.
func (m *WorkOrderMutation) ClearAssignee() {
	m.clearedassignee = true
}

// AssigneeCleared returns if the edge assignee was cleared.
func (m *WorkOrderMutation) AssigneeCleared() bool {
	return m.clearedassignee
}

// AssigneeID returns the assignee id in the mutation.
func (m *WorkOrderMutation) AssigneeID() (id int, exists bool) {
	if m.assignee != nil {
		return *m.assignee, true
	}
	return
}

// AssigneeIDs returns the assignee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *WorkOrderMutation) AssigneeIDs() (ids []int) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee reset all changes of the "assignee" edge.
func (m *WorkOrderMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// AddAppointmentIDs adds the appointment edge to Appointment by ids.
func (m *WorkOrderMutation) AddAppointmentIDs(ids ...int) {
	if m.appointment == nil {
		m.appointment = make(map[int]struct{})
	}
	for i := range ids {
		m.appointment[ids[i]] = struct{}{}
	}
}

// ClearAppointment clears the appointment edge to Appointment.
func (m *WorkOrderMutation) ClearAppointment() {
	m.clearedappointment = true
}

// AppointmentCleared returns if the edge appointment was cleared.
func (m *WorkOrderMutation) AppointmentCleared() bool {
	return m.clearedappointment
}

// RemoveAppointmentIDs removes the appointment edge to Appointment by ids.
func (m *WorkOrderMutation) RemoveAppointmentIDs(ids ...int) {
	if m.removedappointment == nil {
		m.removedappointment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedappointment[ids[i]] = struct{}{}
	}
}

// RemovedAppointment returns the removed ids of appointment.
func (m *WorkOrderMutation) RemovedAppointmentIDs() (ids []int) {
	for id := range m.removedappointment {
		ids = append(ids, id)
	}
	return
}

// AppointmentIDs returns the appointment ids in the mutation.
func (m *WorkOrderMutation) AppointmentIDs() (ids []int) {
	for id := range m.appointment {
		ids = append(ids, id)
	}
	return
}

// ResetAppointment reset all changes of the "appointment" edge.
func (m *WorkOrderMutation) ResetAppointment() {
	m.appointment = nil
	m.clearedappointment = false
	m.removedappointment = nil
}

// Op returns the operation name.
func (m *WorkOrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkOrder).
func (m *WorkOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WorkOrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, workorder.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workorder.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, workorder.FieldName)
	}
	if m.status != nil {
		fields = append(fields, workorder.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, workorder.FieldPriority)
	}
	if m.description != nil {
		fields = append(fields, workorder.FieldDescription)
	}
	if m.install_date != nil {
		fields = append(fields, workorder.FieldInstallDate)
	}
	if m.creation_date != nil {
		fields = append(fields, workorder.FieldCreationDate)
	}
	if m.index != nil {
		fields = append(fields, workorder.FieldIndex)
	}
	if m.close_date != nil {
		fields = append(fields, workorder.FieldCloseDate)
	}
	if m.duration != nil {
		fields = append(fields, workorder.FieldDuration)
	}
	if m.schedulled_at != nil {
		fields = append(fields, workorder.FieldSchedulledAt)
	}
	if m.due_date != nil {
		fields = append(fields, workorder.FieldDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WorkOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workorder.FieldCreateTime:
		return m.CreateTime()
	case workorder.FieldUpdateTime:
		return m.UpdateTime()
	case workorder.FieldName:
		return m.Name()
	case workorder.FieldStatus:
		return m.Status()
	case workorder.FieldPriority:
		return m.Priority()
	case workorder.FieldDescription:
		return m.Description()
	case workorder.FieldInstallDate:
		return m.InstallDate()
	case workorder.FieldCreationDate:
		return m.CreationDate()
	case workorder.FieldIndex:
		return m.Index()
	case workorder.FieldCloseDate:
		return m.CloseDate()
	case workorder.FieldDuration:
		return m.Duration()
	case workorder.FieldSchedulledAt:
		return m.SchedulledAt()
	case workorder.FieldDueDate:
		return m.DueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WorkOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workorder.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workorder.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workorder.FieldName:
		return m.OldName(ctx)
	case workorder.FieldStatus:
		return m.OldStatus(ctx)
	case workorder.FieldPriority:
		return m.OldPriority(ctx)
	case workorder.FieldDescription:
		return m.OldDescription(ctx)
	case workorder.FieldInstallDate:
		return m.OldInstallDate(ctx)
	case workorder.FieldCreationDate:
		return m.OldCreationDate(ctx)
	case workorder.FieldIndex:
		return m.OldIndex(ctx)
	case workorder.FieldCloseDate:
		return m.OldCloseDate(ctx)
	case workorder.FieldDuration:
		return m.OldDuration(ctx)
	case workorder.FieldSchedulledAt:
		return m.OldSchedulledAt(ctx)
	case workorder.FieldDueDate:
		return m.OldDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown WorkOrder field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workorder.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workorder.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workorder.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workorder.FieldStatus:
		v, ok := value.(workorder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workorder.FieldPriority:
		v, ok := value.(workorder.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case workorder.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workorder.FieldInstallDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallDate(v)
		return nil
	case workorder.FieldCreationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationDate(v)
		return nil
	case workorder.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case workorder.FieldCloseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseDate(v)
		return nil
	case workorder.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case workorder.FieldSchedulledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedulledAt(v)
		return nil
	case workorder.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WorkOrderMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, workorder.FieldIndex)
	}
	if m.addduration != nil {
		fields = append(fields, workorder.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WorkOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workorder.FieldIndex:
		return m.AddedIndex()
	case workorder.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workorder.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case workorder.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WorkOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workorder.FieldDescription) {
		fields = append(fields, workorder.FieldDescription)
	}
	if m.FieldCleared(workorder.FieldInstallDate) {
		fields = append(fields, workorder.FieldInstallDate)
	}
	if m.FieldCleared(workorder.FieldIndex) {
		fields = append(fields, workorder.FieldIndex)
	}
	if m.FieldCleared(workorder.FieldCloseDate) {
		fields = append(fields, workorder.FieldCloseDate)
	}
	if m.FieldCleared(workorder.FieldDuration) {
		fields = append(fields, workorder.FieldDuration)
	}
	if m.FieldCleared(workorder.FieldSchedulledAt) {
		fields = append(fields, workorder.FieldSchedulledAt)
	}
	if m.FieldCleared(workorder.FieldDueDate) {
		fields = append(fields, workorder.FieldDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WorkOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkOrderMutation) ClearField(name string) error {
	switch name {
	case workorder.FieldDescription:
		m.ClearDescription()
		return nil
	case workorder.FieldInstallDate:
		m.ClearInstallDate()
		return nil
	case workorder.FieldIndex:
		m.ClearIndex()
		return nil
	case workorder.FieldCloseDate:
		m.ClearCloseDate()
		return nil
	case workorder.FieldDuration:
		m.ClearDuration()
		return nil
	case workorder.FieldSchedulledAt:
		m.ClearSchedulledAt()
		return nil
	case workorder.FieldDueDate:
		m.ClearDueDate()
		return nil
	}
	return fmt.Errorf("unknown WorkOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WorkOrderMutation) ResetField(name string) error {
	switch name {
	case workorder.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workorder.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workorder.FieldName:
		m.ResetName()
		return nil
	case workorder.FieldStatus:
		m.ResetStatus()
		return nil
	case workorder.FieldPriority:
		m.ResetPriority()
		return nil
	case workorder.FieldDescription:
		m.ResetDescription()
		return nil
	case workorder.FieldInstallDate:
		m.ResetInstallDate()
		return nil
	case workorder.FieldCreationDate:
		m.ResetCreationDate()
		return nil
	case workorder.FieldIndex:
		m.ResetIndex()
		return nil
	case workorder.FieldCloseDate:
		m.ResetCloseDate()
		return nil
	case workorder.FieldDuration:
		m.ResetDuration()
		return nil
	case workorder.FieldSchedulledAt:
		m.ResetSchedulledAt()
		return nil
	case workorder.FieldDueDate:
		m.ResetDueDate()
		return nil
	}
	return fmt.Errorf("unknown WorkOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WorkOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m._type != nil {
		edges = append(edges, workorder.EdgeType)
	}
	if m.template != nil {
		edges = append(edges, workorder.EdgeTemplate)
	}
	if m.equipment != nil {
		edges = append(edges, workorder.EdgeEquipment)
	}
	if m.links != nil {
		edges = append(edges, workorder.EdgeLinks)
	}
	if m.organization != nil {
		edges = append(edges, workorder.EdgeOrganization)
	}
	if m.files != nil {
		edges = append(edges, workorder.EdgeFiles)
	}
	if m.hyperlinks != nil {
		edges = append(edges, workorder.EdgeHyperlinks)
	}
	if m.location != nil {
		edges = append(edges, workorder.EdgeLocation)
	}
	if m.comments != nil {
		edges = append(edges, workorder.EdgeComments)
	}
	if m.activities != nil {
		edges = append(edges, workorder.EdgeActivities)
	}
	if m.properties != nil {
		edges = append(edges, workorder.EdgeProperties)
	}
	if m.check_list_categories != nil {
		edges = append(edges, workorder.EdgeCheckListCategories)
	}
	if m.project != nil {
		edges = append(edges, workorder.EdgeProject)
	}
	if m.owner != nil {
		edges = append(edges, workorder.EdgeOwner)
	}
	if m.assignee != nil {
		edges = append(edges, workorder.EdgeAssignee)
	}
	if m.appointment != nil {
		edges = append(edges, workorder.EdgeAppointment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WorkOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workorder.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case workorder.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case workorder.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.equipment))
		for id := range m.equipment {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workorder.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.hyperlinks))
		for id := range m.hyperlinks {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case workorder.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeCheckListCategories:
		ids := make([]ent.Value, 0, len(m.check_list_categories))
		for id := range m.check_list_categories {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workorder.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case workorder.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case workorder.EdgeAppointment:
		ids := make([]ent.Value, 0, len(m.appointment))
		for id := range m.appointment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WorkOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedequipment != nil {
		edges = append(edges, workorder.EdgeEquipment)
	}
	if m.removedlinks != nil {
		edges = append(edges, workorder.EdgeLinks)
	}
	if m.removedfiles != nil {
		edges = append(edges, workorder.EdgeFiles)
	}
	if m.removedhyperlinks != nil {
		edges = append(edges, workorder.EdgeHyperlinks)
	}
	if m.removedcomments != nil {
		edges = append(edges, workorder.EdgeComments)
	}
	if m.removedactivities != nil {
		edges = append(edges, workorder.EdgeActivities)
	}
	if m.removedproperties != nil {
		edges = append(edges, workorder.EdgeProperties)
	}
	if m.removedcheck_list_categories != nil {
		edges = append(edges, workorder.EdgeCheckListCategories)
	}
	if m.removedappointment != nil {
		edges = append(edges, workorder.EdgeAppointment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WorkOrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workorder.EdgeEquipment:
		ids := make([]ent.Value, 0, len(m.removedequipment))
		for id := range m.removedequipment {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeHyperlinks:
		ids := make([]ent.Value, 0, len(m.removedhyperlinks))
		for id := range m.removedhyperlinks {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeCheckListCategories:
		ids := make([]ent.Value, 0, len(m.removedcheck_list_categories))
		for id := range m.removedcheck_list_categories {
			ids = append(ids, id)
		}
		return ids
	case workorder.EdgeAppointment:
		ids := make([]ent.Value, 0, len(m.removedappointment))
		for id := range m.removedappointment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WorkOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.cleared_type {
		edges = append(edges, workorder.EdgeType)
	}
	if m.clearedtemplate {
		edges = append(edges, workorder.EdgeTemplate)
	}
	if m.clearedequipment {
		edges = append(edges, workorder.EdgeEquipment)
	}
	if m.clearedlinks {
		edges = append(edges, workorder.EdgeLinks)
	}
	if m.clearedorganization {
		edges = append(edges, workorder.EdgeOrganization)
	}
	if m.clearedfiles {
		edges = append(edges, workorder.EdgeFiles)
	}
	if m.clearedhyperlinks {
		edges = append(edges, workorder.EdgeHyperlinks)
	}
	if m.clearedlocation {
		edges = append(edges, workorder.EdgeLocation)
	}
	if m.clearedcomments {
		edges = append(edges, workorder.EdgeComments)
	}
	if m.clearedactivities {
		edges = append(edges, workorder.EdgeActivities)
	}
	if m.clearedproperties {
		edges = append(edges, workorder.EdgeProperties)
	}
	if m.clearedcheck_list_categories {
		edges = append(edges, workorder.EdgeCheckListCategories)
	}
	if m.clearedproject {
		edges = append(edges, workorder.EdgeProject)
	}
	if m.clearedowner {
		edges = append(edges, workorder.EdgeOwner)
	}
	if m.clearedassignee {
		edges = append(edges, workorder.EdgeAssignee)
	}
	if m.clearedappointment {
		edges = append(edges, workorder.EdgeAppointment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WorkOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case workorder.EdgeType:
		return m.cleared_type
	case workorder.EdgeTemplate:
		return m.clearedtemplate
	case workorder.EdgeEquipment:
		return m.clearedequipment
	case workorder.EdgeLinks:
		return m.clearedlinks
	case workorder.EdgeOrganization:
		return m.clearedorganization
	case workorder.EdgeFiles:
		return m.clearedfiles
	case workorder.EdgeHyperlinks:
		return m.clearedhyperlinks
	case workorder.EdgeLocation:
		return m.clearedlocation
	case workorder.EdgeComments:
		return m.clearedcomments
	case workorder.EdgeActivities:
		return m.clearedactivities
	case workorder.EdgeProperties:
		return m.clearedproperties
	case workorder.EdgeCheckListCategories:
		return m.clearedcheck_list_categories
	case workorder.EdgeProject:
		return m.clearedproject
	case workorder.EdgeOwner:
		return m.clearedowner
	case workorder.EdgeAssignee:
		return m.clearedassignee
	case workorder.EdgeAppointment:
		return m.clearedappointment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WorkOrderMutation) ClearEdge(name string) error {
	switch name {
	case workorder.EdgeType:
		m.ClearType()
		return nil
	case workorder.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case workorder.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workorder.EdgeLocation:
		m.ClearLocation()
		return nil
	case workorder.EdgeProject:
		m.ClearProject()
		return nil
	case workorder.EdgeOwner:
		m.ClearOwner()
		return nil
	case workorder.EdgeAssignee:
		m.ClearAssignee()
		return nil
	}
	return fmt.Errorf("unknown WorkOrder unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WorkOrderMutation) ResetEdge(name string) error {
	switch name {
	case workorder.EdgeType:
		m.ResetType()
		return nil
	case workorder.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case workorder.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case workorder.EdgeLinks:
		m.ResetLinks()
		return nil
	case workorder.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workorder.EdgeFiles:
		m.ResetFiles()
		return nil
	case workorder.EdgeHyperlinks:
		m.ResetHyperlinks()
		return nil
	case workorder.EdgeLocation:
		m.ResetLocation()
		return nil
	case workorder.EdgeComments:
		m.ResetComments()
		return nil
	case workorder.EdgeActivities:
		m.ResetActivities()
		return nil
	case workorder.EdgeProperties:
		m.ResetProperties()
		return nil
	case workorder.EdgeCheckListCategories:
		m.ResetCheckListCategories()
		return nil
	case workorder.EdgeProject:
		m.ResetProject()
		return nil
	case workorder.EdgeOwner:
		m.ResetOwner()
		return nil
	case workorder.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case workorder.EdgeAppointment:
		m.ResetAppointment()
		return nil
	}
	return fmt.Errorf("unknown WorkOrder edge %s", name)
}

// WorkOrderDefinitionMutation represents an operation that mutate the WorkOrderDefinitions
// nodes in the graph.
type WorkOrderDefinitionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	index                   *int
	addindex                *int
	clearedFields           map[string]struct{}
	_type                   *int
	cleared_type            bool
	project_type            *int
	clearedproject_type     bool
	project_template        *int
	clearedproject_template bool
	done                    bool
	oldValue                func(context.Context) (*WorkOrderDefinition, error)
	predicates              []predicate.WorkOrderDefinition
}

var _ ent.Mutation = (*WorkOrderDefinitionMutation)(nil)

// workorderdefinitionOption allows to manage the mutation configuration using functional options.
type workorderdefinitionOption func(*WorkOrderDefinitionMutation)

// newWorkOrderDefinitionMutation creates new mutation for WorkOrderDefinition.
func newWorkOrderDefinitionMutation(c config, op Op, opts ...workorderdefinitionOption) *WorkOrderDefinitionMutation {
	m := &WorkOrderDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkOrderDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkOrderDefinitionID sets the id field of the mutation.
func withWorkOrderDefinitionID(id int) workorderdefinitionOption {
	return func(m *WorkOrderDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkOrderDefinition
		)
		m.oldValue = func(ctx context.Context) (*WorkOrderDefinition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkOrderDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkOrderDefinition sets the old WorkOrderDefinition of the mutation.
func withWorkOrderDefinition(node *WorkOrderDefinition) workorderdefinitionOption {
	return func(m *WorkOrderDefinitionMutation) {
		m.oldValue = func(context.Context) (*WorkOrderDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkOrderDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkOrderDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WorkOrderDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *WorkOrderDefinitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *WorkOrderDefinitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the WorkOrderDefinition.
// If the WorkOrderDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderDefinitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *WorkOrderDefinitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *WorkOrderDefinitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *WorkOrderDefinitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the WorkOrderDefinition.
// If the WorkOrderDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderDefinitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *WorkOrderDefinitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIndex sets the index field.
func (m *WorkOrderDefinitionMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *WorkOrderDefinitionMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the WorkOrderDefinition.
// If the WorkOrderDefinition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderDefinitionMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *WorkOrderDefinitionMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *WorkOrderDefinitionMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *WorkOrderDefinitionMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[workorderdefinition.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *WorkOrderDefinitionMutation) IndexCleared() bool {
	_, ok := m.clearedFields[workorderdefinition.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *WorkOrderDefinitionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, workorderdefinition.FieldIndex)
}

// SetTypeID sets the type edge to WorkOrderType by id.
func (m *WorkOrderDefinitionMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to WorkOrderType.
func (m *WorkOrderDefinitionMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *WorkOrderDefinitionMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *WorkOrderDefinitionMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *WorkOrderDefinitionMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *WorkOrderDefinitionMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// SetProjectTypeID sets the project_type edge to ProjectType by id.
func (m *WorkOrderDefinitionMutation) SetProjectTypeID(id int) {
	m.project_type = &id
}

// ClearProjectType clears the project_type edge to ProjectType.
func (m *WorkOrderDefinitionMutation) ClearProjectType() {
	m.clearedproject_type = true
}

// ProjectTypeCleared returns if the edge project_type was cleared.
func (m *WorkOrderDefinitionMutation) ProjectTypeCleared() bool {
	return m.clearedproject_type
}

// ProjectTypeID returns the project_type id in the mutation.
func (m *WorkOrderDefinitionMutation) ProjectTypeID() (id int, exists bool) {
	if m.project_type != nil {
		return *m.project_type, true
	}
	return
}

// ProjectTypeIDs returns the project_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectTypeID instead. It exists only for internal usage by the builders.
func (m *WorkOrderDefinitionMutation) ProjectTypeIDs() (ids []int) {
	if id := m.project_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectType reset all changes of the "project_type" edge.
func (m *WorkOrderDefinitionMutation) ResetProjectType() {
	m.project_type = nil
	m.clearedproject_type = false
}

// SetProjectTemplateID sets the project_template edge to ProjectTemplate by id.
func (m *WorkOrderDefinitionMutation) SetProjectTemplateID(id int) {
	m.project_template = &id
}

// ClearProjectTemplate clears the project_template edge to ProjectTemplate.
func (m *WorkOrderDefinitionMutation) ClearProjectTemplate() {
	m.clearedproject_template = true
}

// ProjectTemplateCleared returns if the edge project_template was cleared.
func (m *WorkOrderDefinitionMutation) ProjectTemplateCleared() bool {
	return m.clearedproject_template
}

// ProjectTemplateID returns the project_template id in the mutation.
func (m *WorkOrderDefinitionMutation) ProjectTemplateID() (id int, exists bool) {
	if m.project_template != nil {
		return *m.project_template, true
	}
	return
}

// ProjectTemplateIDs returns the project_template ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ProjectTemplateID instead. It exists only for internal usage by the builders.
func (m *WorkOrderDefinitionMutation) ProjectTemplateIDs() (ids []int) {
	if id := m.project_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectTemplate reset all changes of the "project_template" edge.
func (m *WorkOrderDefinitionMutation) ResetProjectTemplate() {
	m.project_template = nil
	m.clearedproject_template = false
}

// Op returns the operation name.
func (m *WorkOrderDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkOrderDefinition).
func (m *WorkOrderDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WorkOrderDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, workorderdefinition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workorderdefinition.FieldUpdateTime)
	}
	if m.index != nil {
		fields = append(fields, workorderdefinition.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WorkOrderDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workorderdefinition.FieldCreateTime:
		return m.CreateTime()
	case workorderdefinition.FieldUpdateTime:
		return m.UpdateTime()
	case workorderdefinition.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WorkOrderDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workorderdefinition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workorderdefinition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workorderdefinition.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown WorkOrderDefinition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workorderdefinition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workorderdefinition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workorderdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrderDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WorkOrderDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, workorderdefinition.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WorkOrderDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workorderdefinition.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workorderdefinition.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrderDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WorkOrderDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workorderdefinition.FieldIndex) {
		fields = append(fields, workorderdefinition.FieldIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WorkOrderDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkOrderDefinitionMutation) ClearField(name string) error {
	switch name {
	case workorderdefinition.FieldIndex:
		m.ClearIndex()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WorkOrderDefinitionMutation) ResetField(name string) error {
	switch name {
	case workorderdefinition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workorderdefinition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workorderdefinition.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WorkOrderDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._type != nil {
		edges = append(edges, workorderdefinition.EdgeType)
	}
	if m.project_type != nil {
		edges = append(edges, workorderdefinition.EdgeProjectType)
	}
	if m.project_template != nil {
		edges = append(edges, workorderdefinition.EdgeProjectTemplate)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WorkOrderDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workorderdefinition.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case workorderdefinition.EdgeProjectType:
		if id := m.project_type; id != nil {
			return []ent.Value{*id}
		}
	case workorderdefinition.EdgeProjectTemplate:
		if id := m.project_template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WorkOrderDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WorkOrderDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WorkOrderDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_type {
		edges = append(edges, workorderdefinition.EdgeType)
	}
	if m.clearedproject_type {
		edges = append(edges, workorderdefinition.EdgeProjectType)
	}
	if m.clearedproject_template {
		edges = append(edges, workorderdefinition.EdgeProjectTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WorkOrderDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case workorderdefinition.EdgeType:
		return m.cleared_type
	case workorderdefinition.EdgeProjectType:
		return m.clearedproject_type
	case workorderdefinition.EdgeProjectTemplate:
		return m.clearedproject_template
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WorkOrderDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case workorderdefinition.EdgeType:
		m.ClearType()
		return nil
	case workorderdefinition.EdgeProjectType:
		m.ClearProjectType()
		return nil
	case workorderdefinition.EdgeProjectTemplate:
		m.ClearProjectTemplate()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderDefinition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WorkOrderDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case workorderdefinition.EdgeType:
		m.ResetType()
		return nil
	case workorderdefinition.EdgeProjectType:
		m.ResetProjectType()
		return nil
	case workorderdefinition.EdgeProjectTemplate:
		m.ResetProjectTemplate()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderDefinition edge %s", name)
}

// WorkOrderTemplateMutation represents an operation that mutate the WorkOrderTemplates
// nodes in the graph.
type WorkOrderTemplateMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	create_time                            *time.Time
	update_time                            *time.Time
	name                                   *string
	description                            *string
	assignee_can_complete_work_order       *bool
	duration                               *float64
	addduration                            *float64
	clearedFields                          map[string]struct{}
	property_types                         map[int]struct{}
	removedproperty_types                  map[int]struct{}
	clearedproperty_types                  bool
	check_list_category_definitions        map[int]struct{}
	removedcheck_list_category_definitions map[int]struct{}
	clearedcheck_list_category_definitions bool
	_type                                  *int
	cleared_type                           bool
	done                                   bool
	oldValue                               func(context.Context) (*WorkOrderTemplate, error)
	predicates                             []predicate.WorkOrderTemplate
}

var _ ent.Mutation = (*WorkOrderTemplateMutation)(nil)

// workordertemplateOption allows to manage the mutation configuration using functional options.
type workordertemplateOption func(*WorkOrderTemplateMutation)

// newWorkOrderTemplateMutation creates new mutation for WorkOrderTemplate.
func newWorkOrderTemplateMutation(c config, op Op, opts ...workordertemplateOption) *WorkOrderTemplateMutation {
	m := &WorkOrderTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkOrderTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkOrderTemplateID sets the id field of the mutation.
func withWorkOrderTemplateID(id int) workordertemplateOption {
	return func(m *WorkOrderTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkOrderTemplate
		)
		m.oldValue = func(ctx context.Context) (*WorkOrderTemplate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkOrderTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkOrderTemplate sets the old WorkOrderTemplate of the mutation.
func withWorkOrderTemplate(node *WorkOrderTemplate) workordertemplateOption {
	return func(m *WorkOrderTemplateMutation) {
		m.oldValue = func(context.Context) (*WorkOrderTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkOrderTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkOrderTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WorkOrderTemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *WorkOrderTemplateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *WorkOrderTemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the WorkOrderTemplate.
// If the WorkOrderTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTemplateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *WorkOrderTemplateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *WorkOrderTemplateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *WorkOrderTemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the WorkOrderTemplate.
// If the WorkOrderTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTemplateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *WorkOrderTemplateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *WorkOrderTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WorkOrderTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the WorkOrderTemplate.
// If the WorkOrderTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WorkOrderTemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *WorkOrderTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *WorkOrderTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the WorkOrderTemplate.
// If the WorkOrderTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTemplateMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *WorkOrderTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workordertemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *WorkOrderTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workordertemplate.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *WorkOrderTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workordertemplate.FieldDescription)
}

// SetAssigneeCanCompleteWorkOrder sets the assignee_can_complete_work_order field.
func (m *WorkOrderTemplateMutation) SetAssigneeCanCompleteWorkOrder(b bool) {
	m.assignee_can_complete_work_order = &b
}

// AssigneeCanCompleteWorkOrder returns the assignee_can_complete_work_order value in the mutation.
func (m *WorkOrderTemplateMutation) AssigneeCanCompleteWorkOrder() (r bool, exists bool) {
	v := m.assignee_can_complete_work_order
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeCanCompleteWorkOrder returns the old assignee_can_complete_work_order value of the WorkOrderTemplate.
// If the WorkOrderTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTemplateMutation) OldAssigneeCanCompleteWorkOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAssigneeCanCompleteWorkOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAssigneeCanCompleteWorkOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeCanCompleteWorkOrder: %w", err)
	}
	return oldValue.AssigneeCanCompleteWorkOrder, nil
}

// ClearAssigneeCanCompleteWorkOrder clears the value of assignee_can_complete_work_order.
func (m *WorkOrderTemplateMutation) ClearAssigneeCanCompleteWorkOrder() {
	m.assignee_can_complete_work_order = nil
	m.clearedFields[workordertemplate.FieldAssigneeCanCompleteWorkOrder] = struct{}{}
}

// AssigneeCanCompleteWorkOrderCleared returns if the field assignee_can_complete_work_order was cleared in this mutation.
func (m *WorkOrderTemplateMutation) AssigneeCanCompleteWorkOrderCleared() bool {
	_, ok := m.clearedFields[workordertemplate.FieldAssigneeCanCompleteWorkOrder]
	return ok
}

// ResetAssigneeCanCompleteWorkOrder reset all changes of the "assignee_can_complete_work_order" field.
func (m *WorkOrderTemplateMutation) ResetAssigneeCanCompleteWorkOrder() {
	m.assignee_can_complete_work_order = nil
	delete(m.clearedFields, workordertemplate.FieldAssigneeCanCompleteWorkOrder)
}

// SetDuration sets the duration field.
func (m *WorkOrderTemplateMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *WorkOrderTemplateMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the WorkOrderTemplate.
// If the WorkOrderTemplate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTemplateMutation) OldDuration(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to duration.
func (m *WorkOrderTemplateMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *WorkOrderTemplateMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of duration.
func (m *WorkOrderTemplateMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[workordertemplate.FieldDuration] = struct{}{}
}

// DurationCleared returns if the field duration was cleared in this mutation.
func (m *WorkOrderTemplateMutation) DurationCleared() bool {
	_, ok := m.clearedFields[workordertemplate.FieldDuration]
	return ok
}

// ResetDuration reset all changes of the "duration" field.
func (m *WorkOrderTemplateMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, workordertemplate.FieldDuration)
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *WorkOrderTemplateMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// ClearPropertyTypes clears the property_types edge to PropertyType.
func (m *WorkOrderTemplateMutation) ClearPropertyTypes() {
	m.clearedproperty_types = true
}

// PropertyTypesCleared returns if the edge property_types was cleared.
func (m *WorkOrderTemplateMutation) PropertyTypesCleared() bool {
	return m.clearedproperty_types
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *WorkOrderTemplateMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *WorkOrderTemplateMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *WorkOrderTemplateMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *WorkOrderTemplateMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.clearedproperty_types = false
	m.removedproperty_types = nil
}

// AddCheckListCategoryDefinitionIDs adds the check_list_category_definitions edge to CheckListCategoryDefinition by ids.
func (m *WorkOrderTemplateMutation) AddCheckListCategoryDefinitionIDs(ids ...int) {
	if m.check_list_category_definitions == nil {
		m.check_list_category_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.check_list_category_definitions[ids[i]] = struct{}{}
	}
}

// ClearCheckListCategoryDefinitions clears the check_list_category_definitions edge to CheckListCategoryDefinition.
func (m *WorkOrderTemplateMutation) ClearCheckListCategoryDefinitions() {
	m.clearedcheck_list_category_definitions = true
}

// CheckListCategoryDefinitionsCleared returns if the edge check_list_category_definitions was cleared.
func (m *WorkOrderTemplateMutation) CheckListCategoryDefinitionsCleared() bool {
	return m.clearedcheck_list_category_definitions
}

// RemoveCheckListCategoryDefinitionIDs removes the check_list_category_definitions edge to CheckListCategoryDefinition by ids.
func (m *WorkOrderTemplateMutation) RemoveCheckListCategoryDefinitionIDs(ids ...int) {
	if m.removedcheck_list_category_definitions == nil {
		m.removedcheck_list_category_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheck_list_category_definitions[ids[i]] = struct{}{}
	}
}

// RemovedCheckListCategoryDefinitions returns the removed ids of check_list_category_definitions.
func (m *WorkOrderTemplateMutation) RemovedCheckListCategoryDefinitionsIDs() (ids []int) {
	for id := range m.removedcheck_list_category_definitions {
		ids = append(ids, id)
	}
	return
}

// CheckListCategoryDefinitionsIDs returns the check_list_category_definitions ids in the mutation.
func (m *WorkOrderTemplateMutation) CheckListCategoryDefinitionsIDs() (ids []int) {
	for id := range m.check_list_category_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetCheckListCategoryDefinitions reset all changes of the "check_list_category_definitions" edge.
func (m *WorkOrderTemplateMutation) ResetCheckListCategoryDefinitions() {
	m.check_list_category_definitions = nil
	m.clearedcheck_list_category_definitions = false
	m.removedcheck_list_category_definitions = nil
}

// SetTypeID sets the type edge to WorkOrderType by id.
func (m *WorkOrderTemplateMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to WorkOrderType.
func (m *WorkOrderTemplateMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *WorkOrderTemplateMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *WorkOrderTemplateMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *WorkOrderTemplateMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *WorkOrderTemplateMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Op returns the operation name.
func (m *WorkOrderTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkOrderTemplate).
func (m *WorkOrderTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WorkOrderTemplateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, workordertemplate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workordertemplate.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, workordertemplate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workordertemplate.FieldDescription)
	}
	if m.assignee_can_complete_work_order != nil {
		fields = append(fields, workordertemplate.FieldAssigneeCanCompleteWorkOrder)
	}
	if m.duration != nil {
		fields = append(fields, workordertemplate.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WorkOrderTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workordertemplate.FieldCreateTime:
		return m.CreateTime()
	case workordertemplate.FieldUpdateTime:
		return m.UpdateTime()
	case workordertemplate.FieldName:
		return m.Name()
	case workordertemplate.FieldDescription:
		return m.Description()
	case workordertemplate.FieldAssigneeCanCompleteWorkOrder:
		return m.AssigneeCanCompleteWorkOrder()
	case workordertemplate.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WorkOrderTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workordertemplate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workordertemplate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workordertemplate.FieldName:
		return m.OldName(ctx)
	case workordertemplate.FieldDescription:
		return m.OldDescription(ctx)
	case workordertemplate.FieldAssigneeCanCompleteWorkOrder:
		return m.OldAssigneeCanCompleteWorkOrder(ctx)
	case workordertemplate.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown WorkOrderTemplate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workordertemplate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workordertemplate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workordertemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workordertemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workordertemplate.FieldAssigneeCanCompleteWorkOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeCanCompleteWorkOrder(v)
		return nil
	case workordertemplate.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrderTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WorkOrderTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, workordertemplate.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WorkOrderTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workordertemplate.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workordertemplate.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrderTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WorkOrderTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workordertemplate.FieldDescription) {
		fields = append(fields, workordertemplate.FieldDescription)
	}
	if m.FieldCleared(workordertemplate.FieldAssigneeCanCompleteWorkOrder) {
		fields = append(fields, workordertemplate.FieldAssigneeCanCompleteWorkOrder)
	}
	if m.FieldCleared(workordertemplate.FieldDuration) {
		fields = append(fields, workordertemplate.FieldDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WorkOrderTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkOrderTemplateMutation) ClearField(name string) error {
	switch name {
	case workordertemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case workordertemplate.FieldAssigneeCanCompleteWorkOrder:
		m.ClearAssigneeCanCompleteWorkOrder()
		return nil
	case workordertemplate.FieldDuration:
		m.ClearDuration()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WorkOrderTemplateMutation) ResetField(name string) error {
	switch name {
	case workordertemplate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workordertemplate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workordertemplate.FieldName:
		m.ResetName()
		return nil
	case workordertemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case workordertemplate.FieldAssigneeCanCompleteWorkOrder:
		m.ResetAssigneeCanCompleteWorkOrder()
		return nil
	case workordertemplate.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WorkOrderTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.property_types != nil {
		edges = append(edges, workordertemplate.EdgePropertyTypes)
	}
	if m.check_list_category_definitions != nil {
		edges = append(edges, workordertemplate.EdgeCheckListCategoryDefinitions)
	}
	if m._type != nil {
		edges = append(edges, workordertemplate.EdgeType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WorkOrderTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workordertemplate.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	case workordertemplate.EdgeCheckListCategoryDefinitions:
		ids := make([]ent.Value, 0, len(m.check_list_category_definitions))
		for id := range m.check_list_category_definitions {
			ids = append(ids, id)
		}
		return ids
	case workordertemplate.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WorkOrderTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperty_types != nil {
		edges = append(edges, workordertemplate.EdgePropertyTypes)
	}
	if m.removedcheck_list_category_definitions != nil {
		edges = append(edges, workordertemplate.EdgeCheckListCategoryDefinitions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WorkOrderTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workordertemplate.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	case workordertemplate.EdgeCheckListCategoryDefinitions:
		ids := make([]ent.Value, 0, len(m.removedcheck_list_category_definitions))
		for id := range m.removedcheck_list_category_definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WorkOrderTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproperty_types {
		edges = append(edges, workordertemplate.EdgePropertyTypes)
	}
	if m.clearedcheck_list_category_definitions {
		edges = append(edges, workordertemplate.EdgeCheckListCategoryDefinitions)
	}
	if m.cleared_type {
		edges = append(edges, workordertemplate.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WorkOrderTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case workordertemplate.EdgePropertyTypes:
		return m.clearedproperty_types
	case workordertemplate.EdgeCheckListCategoryDefinitions:
		return m.clearedcheck_list_category_definitions
	case workordertemplate.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WorkOrderTemplateMutation) ClearEdge(name string) error {
	switch name {
	case workordertemplate.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderTemplate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WorkOrderTemplateMutation) ResetEdge(name string) error {
	switch name {
	case workordertemplate.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	case workordertemplate.EdgeCheckListCategoryDefinitions:
		m.ResetCheckListCategoryDefinitions()
		return nil
	case workordertemplate.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderTemplate edge %s", name)
}

// WorkOrderTypeMutation represents an operation that mutate the WorkOrderTypes
// nodes in the graph.
type WorkOrderTypeMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	create_time                            *time.Time
	update_time                            *time.Time
	name                                   *string
	description                            *string
	assignee_can_complete_work_order       *bool
	duration                               *float64
	addduration                            *float64
	clearedFields                          map[string]struct{}
	property_types                         map[int]struct{}
	removedproperty_types                  map[int]struct{}
	clearedproperty_types                  bool
	check_list_category_definitions        map[int]struct{}
	removedcheck_list_category_definitions map[int]struct{}
	clearedcheck_list_category_definitions bool
	work_orders                            map[int]struct{}
	removedwork_orders                     map[int]struct{}
	clearedwork_orders                     bool
	definitions                            map[int]struct{}
	removeddefinitions                     map[int]struct{}
	cleareddefinitions                     bool
	done                                   bool
	oldValue                               func(context.Context) (*WorkOrderType, error)
	predicates                             []predicate.WorkOrderType
}

var _ ent.Mutation = (*WorkOrderTypeMutation)(nil)

// workordertypeOption allows to manage the mutation configuration using functional options.
type workordertypeOption func(*WorkOrderTypeMutation)

// newWorkOrderTypeMutation creates new mutation for WorkOrderType.
func newWorkOrderTypeMutation(c config, op Op, opts ...workordertypeOption) *WorkOrderTypeMutation {
	m := &WorkOrderTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkOrderType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkOrderTypeID sets the id field of the mutation.
func withWorkOrderTypeID(id int) workordertypeOption {
	return func(m *WorkOrderTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkOrderType
		)
		m.oldValue = func(ctx context.Context) (*WorkOrderType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkOrderType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkOrderType sets the old WorkOrderType of the mutation.
func withWorkOrderType(node *WorkOrderType) workordertypeOption {
	return func(m *WorkOrderTypeMutation) {
		m.oldValue = func(context.Context) (*WorkOrderType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkOrderTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkOrderTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WorkOrderTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *WorkOrderTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *WorkOrderTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the WorkOrderType.
// If the WorkOrderType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *WorkOrderTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *WorkOrderTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *WorkOrderTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the WorkOrderType.
// If the WorkOrderType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *WorkOrderTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *WorkOrderTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WorkOrderTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the WorkOrderType.
// If the WorkOrderType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WorkOrderTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *WorkOrderTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *WorkOrderTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the WorkOrderType.
// If the WorkOrderType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *WorkOrderTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workordertype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *WorkOrderTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workordertype.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *WorkOrderTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workordertype.FieldDescription)
}

// SetAssigneeCanCompleteWorkOrder sets the assignee_can_complete_work_order field.
func (m *WorkOrderTypeMutation) SetAssigneeCanCompleteWorkOrder(b bool) {
	m.assignee_can_complete_work_order = &b
}

// AssigneeCanCompleteWorkOrder returns the assignee_can_complete_work_order value in the mutation.
func (m *WorkOrderTypeMutation) AssigneeCanCompleteWorkOrder() (r bool, exists bool) {
	v := m.assignee_can_complete_work_order
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeCanCompleteWorkOrder returns the old assignee_can_complete_work_order value of the WorkOrderType.
// If the WorkOrderType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTypeMutation) OldAssigneeCanCompleteWorkOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAssigneeCanCompleteWorkOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAssigneeCanCompleteWorkOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeCanCompleteWorkOrder: %w", err)
	}
	return oldValue.AssigneeCanCompleteWorkOrder, nil
}

// ClearAssigneeCanCompleteWorkOrder clears the value of assignee_can_complete_work_order.
func (m *WorkOrderTypeMutation) ClearAssigneeCanCompleteWorkOrder() {
	m.assignee_can_complete_work_order = nil
	m.clearedFields[workordertype.FieldAssigneeCanCompleteWorkOrder] = struct{}{}
}

// AssigneeCanCompleteWorkOrderCleared returns if the field assignee_can_complete_work_order was cleared in this mutation.
func (m *WorkOrderTypeMutation) AssigneeCanCompleteWorkOrderCleared() bool {
	_, ok := m.clearedFields[workordertype.FieldAssigneeCanCompleteWorkOrder]
	return ok
}

// ResetAssigneeCanCompleteWorkOrder reset all changes of the "assignee_can_complete_work_order" field.
func (m *WorkOrderTypeMutation) ResetAssigneeCanCompleteWorkOrder() {
	m.assignee_can_complete_work_order = nil
	delete(m.clearedFields, workordertype.FieldAssigneeCanCompleteWorkOrder)
}

// SetDuration sets the duration field.
func (m *WorkOrderTypeMutation) SetDuration(f float64) {
	m.duration = &f
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *WorkOrderTypeMutation) Duration() (r float64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the WorkOrderType.
// If the WorkOrderType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkOrderTypeMutation) OldDuration(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds f to duration.
func (m *WorkOrderTypeMutation) AddDuration(f float64) {
	if m.addduration != nil {
		*m.addduration += f
	} else {
		m.addduration = &f
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *WorkOrderTypeMutation) AddedDuration() (r float64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of duration.
func (m *WorkOrderTypeMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[workordertype.FieldDuration] = struct{}{}
}

// DurationCleared returns if the field duration was cleared in this mutation.
func (m *WorkOrderTypeMutation) DurationCleared() bool {
	_, ok := m.clearedFields[workordertype.FieldDuration]
	return ok
}

// ResetDuration reset all changes of the "duration" field.
func (m *WorkOrderTypeMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, workordertype.FieldDuration)
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *WorkOrderTypeMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// ClearPropertyTypes clears the property_types edge to PropertyType.
func (m *WorkOrderTypeMutation) ClearPropertyTypes() {
	m.clearedproperty_types = true
}

// PropertyTypesCleared returns if the edge property_types was cleared.
func (m *WorkOrderTypeMutation) PropertyTypesCleared() bool {
	return m.clearedproperty_types
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *WorkOrderTypeMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *WorkOrderTypeMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *WorkOrderTypeMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *WorkOrderTypeMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.clearedproperty_types = false
	m.removedproperty_types = nil
}

// AddCheckListCategoryDefinitionIDs adds the check_list_category_definitions edge to CheckListCategoryDefinition by ids.
func (m *WorkOrderTypeMutation) AddCheckListCategoryDefinitionIDs(ids ...int) {
	if m.check_list_category_definitions == nil {
		m.check_list_category_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.check_list_category_definitions[ids[i]] = struct{}{}
	}
}

// ClearCheckListCategoryDefinitions clears the check_list_category_definitions edge to CheckListCategoryDefinition.
func (m *WorkOrderTypeMutation) ClearCheckListCategoryDefinitions() {
	m.clearedcheck_list_category_definitions = true
}

// CheckListCategoryDefinitionsCleared returns if the edge check_list_category_definitions was cleared.
func (m *WorkOrderTypeMutation) CheckListCategoryDefinitionsCleared() bool {
	return m.clearedcheck_list_category_definitions
}

// RemoveCheckListCategoryDefinitionIDs removes the check_list_category_definitions edge to CheckListCategoryDefinition by ids.
func (m *WorkOrderTypeMutation) RemoveCheckListCategoryDefinitionIDs(ids ...int) {
	if m.removedcheck_list_category_definitions == nil {
		m.removedcheck_list_category_definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcheck_list_category_definitions[ids[i]] = struct{}{}
	}
}

// RemovedCheckListCategoryDefinitions returns the removed ids of check_list_category_definitions.
func (m *WorkOrderTypeMutation) RemovedCheckListCategoryDefinitionsIDs() (ids []int) {
	for id := range m.removedcheck_list_category_definitions {
		ids = append(ids, id)
	}
	return
}

// CheckListCategoryDefinitionsIDs returns the check_list_category_definitions ids in the mutation.
func (m *WorkOrderTypeMutation) CheckListCategoryDefinitionsIDs() (ids []int) {
	for id := range m.check_list_category_definitions {
		ids = append(ids, id)
	}
	return
}

// ResetCheckListCategoryDefinitions reset all changes of the "check_list_category_definitions" edge.
func (m *WorkOrderTypeMutation) ResetCheckListCategoryDefinitions() {
	m.check_list_category_definitions = nil
	m.clearedcheck_list_category_definitions = false
	m.removedcheck_list_category_definitions = nil
}

// AddWorkOrderIDs adds the work_orders edge to WorkOrder by ids.
func (m *WorkOrderTypeMutation) AddWorkOrderIDs(ids ...int) {
	if m.work_orders == nil {
		m.work_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.work_orders[ids[i]] = struct{}{}
	}
}

// ClearWorkOrders clears the work_orders edge to WorkOrder.
func (m *WorkOrderTypeMutation) ClearWorkOrders() {
	m.clearedwork_orders = true
}

// WorkOrdersCleared returns if the edge work_orders was cleared.
func (m *WorkOrderTypeMutation) WorkOrdersCleared() bool {
	return m.clearedwork_orders
}

// RemoveWorkOrderIDs removes the work_orders edge to WorkOrder by ids.
func (m *WorkOrderTypeMutation) RemoveWorkOrderIDs(ids ...int) {
	if m.removedwork_orders == nil {
		m.removedwork_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_orders[ids[i]] = struct{}{}
	}
}

// RemovedWorkOrders returns the removed ids of work_orders.
func (m *WorkOrderTypeMutation) RemovedWorkOrdersIDs() (ids []int) {
	for id := range m.removedwork_orders {
		ids = append(ids, id)
	}
	return
}

// WorkOrdersIDs returns the work_orders ids in the mutation.
func (m *WorkOrderTypeMutation) WorkOrdersIDs() (ids []int) {
	for id := range m.work_orders {
		ids = append(ids, id)
	}
	return
}

// ResetWorkOrders reset all changes of the "work_orders" edge.
func (m *WorkOrderTypeMutation) ResetWorkOrders() {
	m.work_orders = nil
	m.clearedwork_orders = false
	m.removedwork_orders = nil
}

// AddDefinitionIDs adds the definitions edge to WorkOrderDefinition by ids.
func (m *WorkOrderTypeMutation) AddDefinitionIDs(ids ...int) {
	if m.definitions == nil {
		m.definitions = make(map[int]struct{})
	}
	for i := range ids {
		m.definitions[ids[i]] = struct{}{}
	}
}

// ClearDefinitions clears the definitions edge to WorkOrderDefinition.
func (m *WorkOrderTypeMutation) ClearDefinitions() {
	m.cleareddefinitions = true
}

// DefinitionsCleared returns if the edge definitions was cleared.
func (m *WorkOrderTypeMutation) DefinitionsCleared() bool {
	return m.cleareddefinitions
}

// RemoveDefinitionIDs removes the definitions edge to WorkOrderDefinition by ids.
func (m *WorkOrderTypeMutation) RemoveDefinitionIDs(ids ...int) {
	if m.removeddefinitions == nil {
		m.removeddefinitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddefinitions[ids[i]] = struct{}{}
	}
}

// RemovedDefinitions returns the removed ids of definitions.
func (m *WorkOrderTypeMutation) RemovedDefinitionsIDs() (ids []int) {
	for id := range m.removeddefinitions {
		ids = append(ids, id)
	}
	return
}

// DefinitionsIDs returns the definitions ids in the mutation.
func (m *WorkOrderTypeMutation) DefinitionsIDs() (ids []int) {
	for id := range m.definitions {
		ids = append(ids, id)
	}
	return
}

// ResetDefinitions reset all changes of the "definitions" edge.
func (m *WorkOrderTypeMutation) ResetDefinitions() {
	m.definitions = nil
	m.cleareddefinitions = false
	m.removeddefinitions = nil
}

// Op returns the operation name.
func (m *WorkOrderTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkOrderType).
func (m *WorkOrderTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WorkOrderTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, workordertype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workordertype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, workordertype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workordertype.FieldDescription)
	}
	if m.assignee_can_complete_work_order != nil {
		fields = append(fields, workordertype.FieldAssigneeCanCompleteWorkOrder)
	}
	if m.duration != nil {
		fields = append(fields, workordertype.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WorkOrderTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workordertype.FieldCreateTime:
		return m.CreateTime()
	case workordertype.FieldUpdateTime:
		return m.UpdateTime()
	case workordertype.FieldName:
		return m.Name()
	case workordertype.FieldDescription:
		return m.Description()
	case workordertype.FieldAssigneeCanCompleteWorkOrder:
		return m.AssigneeCanCompleteWorkOrder()
	case workordertype.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WorkOrderTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workordertype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workordertype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workordertype.FieldName:
		return m.OldName(ctx)
	case workordertype.FieldDescription:
		return m.OldDescription(ctx)
	case workordertype.FieldAssigneeCanCompleteWorkOrder:
		return m.OldAssigneeCanCompleteWorkOrder(ctx)
	case workordertype.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown WorkOrderType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workordertype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workordertype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workordertype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workordertype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workordertype.FieldAssigneeCanCompleteWorkOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeCanCompleteWorkOrder(v)
		return nil
	case workordertype.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrderType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WorkOrderTypeMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, workordertype.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WorkOrderTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workordertype.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkOrderTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workordertype.FieldDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown WorkOrderType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WorkOrderTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workordertype.FieldDescription) {
		fields = append(fields, workordertype.FieldDescription)
	}
	if m.FieldCleared(workordertype.FieldAssigneeCanCompleteWorkOrder) {
		fields = append(fields, workordertype.FieldAssigneeCanCompleteWorkOrder)
	}
	if m.FieldCleared(workordertype.FieldDuration) {
		fields = append(fields, workordertype.FieldDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WorkOrderTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkOrderTypeMutation) ClearField(name string) error {
	switch name {
	case workordertype.FieldDescription:
		m.ClearDescription()
		return nil
	case workordertype.FieldAssigneeCanCompleteWorkOrder:
		m.ClearAssigneeCanCompleteWorkOrder()
		return nil
	case workordertype.FieldDuration:
		m.ClearDuration()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WorkOrderTypeMutation) ResetField(name string) error {
	switch name {
	case workordertype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workordertype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workordertype.FieldName:
		m.ResetName()
		return nil
	case workordertype.FieldDescription:
		m.ResetDescription()
		return nil
	case workordertype.FieldAssigneeCanCompleteWorkOrder:
		m.ResetAssigneeCanCompleteWorkOrder()
		return nil
	case workordertype.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WorkOrderTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.property_types != nil {
		edges = append(edges, workordertype.EdgePropertyTypes)
	}
	if m.check_list_category_definitions != nil {
		edges = append(edges, workordertype.EdgeCheckListCategoryDefinitions)
	}
	if m.work_orders != nil {
		edges = append(edges, workordertype.EdgeWorkOrders)
	}
	if m.definitions != nil {
		edges = append(edges, workordertype.EdgeDefinitions)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WorkOrderTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workordertype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	case workordertype.EdgeCheckListCategoryDefinitions:
		ids := make([]ent.Value, 0, len(m.check_list_category_definitions))
		for id := range m.check_list_category_definitions {
			ids = append(ids, id)
		}
		return ids
	case workordertype.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.work_orders))
		for id := range m.work_orders {
			ids = append(ids, id)
		}
		return ids
	case workordertype.EdgeDefinitions:
		ids := make([]ent.Value, 0, len(m.definitions))
		for id := range m.definitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WorkOrderTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproperty_types != nil {
		edges = append(edges, workordertype.EdgePropertyTypes)
	}
	if m.removedcheck_list_category_definitions != nil {
		edges = append(edges, workordertype.EdgeCheckListCategoryDefinitions)
	}
	if m.removedwork_orders != nil {
		edges = append(edges, workordertype.EdgeWorkOrders)
	}
	if m.removeddefinitions != nil {
		edges = append(edges, workordertype.EdgeDefinitions)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WorkOrderTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workordertype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	case workordertype.EdgeCheckListCategoryDefinitions:
		ids := make([]ent.Value, 0, len(m.removedcheck_list_category_definitions))
		for id := range m.removedcheck_list_category_definitions {
			ids = append(ids, id)
		}
		return ids
	case workordertype.EdgeWorkOrders:
		ids := make([]ent.Value, 0, len(m.removedwork_orders))
		for id := range m.removedwork_orders {
			ids = append(ids, id)
		}
		return ids
	case workordertype.EdgeDefinitions:
		ids := make([]ent.Value, 0, len(m.removeddefinitions))
		for id := range m.removeddefinitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WorkOrderTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproperty_types {
		edges = append(edges, workordertype.EdgePropertyTypes)
	}
	if m.clearedcheck_list_category_definitions {
		edges = append(edges, workordertype.EdgeCheckListCategoryDefinitions)
	}
	if m.clearedwork_orders {
		edges = append(edges, workordertype.EdgeWorkOrders)
	}
	if m.cleareddefinitions {
		edges = append(edges, workordertype.EdgeDefinitions)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WorkOrderTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case workordertype.EdgePropertyTypes:
		return m.clearedproperty_types
	case workordertype.EdgeCheckListCategoryDefinitions:
		return m.clearedcheck_list_category_definitions
	case workordertype.EdgeWorkOrders:
		return m.clearedwork_orders
	case workordertype.EdgeDefinitions:
		return m.cleareddefinitions
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WorkOrderTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkOrderType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WorkOrderTypeMutation) ResetEdge(name string) error {
	switch name {
	case workordertype.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	case workordertype.EdgeCheckListCategoryDefinitions:
		m.ResetCheckListCategoryDefinitions()
		return nil
	case workordertype.EdgeWorkOrders:
		m.ResetWorkOrders()
		return nil
	case workordertype.EdgeDefinitions:
		m.ResetDefinitions()
		return nil
	}
	return fmt.Errorf("unknown WorkOrderType edge %s", name)
}

// WorkerTypeMutation represents an operation that mutate the WorkerTypes
// nodes in the graph.
type WorkerTypeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	description           *string
	clearedFields         map[string]struct{}
	property_types        map[int]struct{}
	removedproperty_types map[int]struct{}
	clearedproperty_types bool
	done                  bool
	oldValue              func(context.Context) (*WorkerType, error)
	predicates            []predicate.WorkerType
}

var _ ent.Mutation = (*WorkerTypeMutation)(nil)

// workertypeOption allows to manage the mutation configuration using functional options.
type workertypeOption func(*WorkerTypeMutation)

// newWorkerTypeMutation creates new mutation for WorkerType.
func newWorkerTypeMutation(c config, op Op, opts ...workertypeOption) *WorkerTypeMutation {
	m := &WorkerTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkerType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerTypeID sets the id field of the mutation.
func withWorkerTypeID(id int) workertypeOption {
	return func(m *WorkerTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkerType
		)
		m.oldValue = func(ctx context.Context) (*WorkerType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkerType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkerType sets the old WorkerType of the mutation.
func withWorkerType(node *WorkerType) workertypeOption {
	return func(m *WorkerTypeMutation) {
		m.oldValue = func(context.Context) (*WorkerType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WorkerTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *WorkerTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *WorkerTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the WorkerType.
// If the WorkerType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkerTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *WorkerTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *WorkerTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *WorkerTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the WorkerType.
// If the WorkerType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkerTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *WorkerTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the name field.
func (m *WorkerTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WorkerTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the WorkerType.
// If the WorkerType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkerTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WorkerTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *WorkerTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *WorkerTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the WorkerType.
// If the WorkerType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WorkerTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *WorkerTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workertype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *WorkerTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workertype.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *WorkerTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workertype.FieldDescription)
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *WorkerTypeMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// ClearPropertyTypes clears the property_types edge to PropertyType.
func (m *WorkerTypeMutation) ClearPropertyTypes() {
	m.clearedproperty_types = true
}

// PropertyTypesCleared returns if the edge property_types was cleared.
func (m *WorkerTypeMutation) PropertyTypesCleared() bool {
	return m.clearedproperty_types
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *WorkerTypeMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *WorkerTypeMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *WorkerTypeMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *WorkerTypeMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.clearedproperty_types = false
	m.removedproperty_types = nil
}

// Op returns the operation name.
func (m *WorkerTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkerType).
func (m *WorkerTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WorkerTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, workertype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workertype.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, workertype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workertype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WorkerTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workertype.FieldCreateTime:
		return m.CreateTime()
	case workertype.FieldUpdateTime:
		return m.UpdateTime()
	case workertype.FieldName:
		return m.Name()
	case workertype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WorkerTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workertype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workertype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workertype.FieldName:
		return m.OldName(ctx)
	case workertype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown WorkerType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkerTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workertype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workertype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workertype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workertype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WorkerTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WorkerTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WorkerTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkerType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WorkerTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workertype.FieldDescription) {
		fields = append(fields, workertype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WorkerTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerTypeMutation) ClearField(name string) error {
	switch name {
	case workertype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkerType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WorkerTypeMutation) ResetField(name string) error {
	switch name {
	case workertype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workertype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workertype.FieldName:
		m.ResetName()
		return nil
	case workertype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkerType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WorkerTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.property_types != nil {
		edges = append(edges, workertype.EdgePropertyTypes)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WorkerTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workertype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WorkerTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproperty_types != nil {
		edges = append(edges, workertype.EdgePropertyTypes)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WorkerTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workertype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WorkerTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproperty_types {
		edges = append(edges, workertype.EdgePropertyTypes)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WorkerTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case workertype.EdgePropertyTypes:
		return m.clearedproperty_types
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WorkerTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkerType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WorkerTypeMutation) ResetEdge(name string) error {
	switch name {
	case workertype.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	}
	return fmt.Errorf("unknown WorkerType edge %s", name)
}
