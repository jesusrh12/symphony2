// Copyright (c) 2004-present Facebook All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebookincubator/symphony/pkg/ent/activity"
	"github.com/facebookincubator/symphony/pkg/ent/alarmfilter"
	"github.com/facebookincubator/symphony/pkg/ent/alarmstatus"
	"github.com/facebookincubator/symphony/pkg/ent/appointment"
	"github.com/facebookincubator/symphony/pkg/ent/block"
	"github.com/facebookincubator/symphony/pkg/ent/blockinstance"
	"github.com/facebookincubator/symphony/pkg/ent/checklistcategory"
	"github.com/facebookincubator/symphony/pkg/ent/checklistcategorydefinition"
	"github.com/facebookincubator/symphony/pkg/ent/checklistitem"
	"github.com/facebookincubator/symphony/pkg/ent/checklistitemdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/comment"
	"github.com/facebookincubator/symphony/pkg/ent/comparator"
	"github.com/facebookincubator/symphony/pkg/ent/counter"
	"github.com/facebookincubator/symphony/pkg/ent/counterfamily"
	"github.com/facebookincubator/symphony/pkg/ent/counterformula"
	"github.com/facebookincubator/symphony/pkg/ent/customer"
	"github.com/facebookincubator/symphony/pkg/ent/documentcategory"
	"github.com/facebookincubator/symphony/pkg/ent/domain"
	"github.com/facebookincubator/symphony/pkg/ent/entrypoint"
	"github.com/facebookincubator/symphony/pkg/ent/equipment"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentcategory"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentport"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentportdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentporttype"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentposition"
	"github.com/facebookincubator/symphony/pkg/ent/equipmentpositiondefinition"
	"github.com/facebookincubator/symphony/pkg/ent/equipmenttype"
	"github.com/facebookincubator/symphony/pkg/ent/eventseverity"
	"github.com/facebookincubator/symphony/pkg/ent/exitpoint"
	"github.com/facebookincubator/symphony/pkg/ent/exporttask"
	"github.com/facebookincubator/symphony/pkg/ent/feature"
	"github.com/facebookincubator/symphony/pkg/ent/file"
	"github.com/facebookincubator/symphony/pkg/ent/floorplan"
	"github.com/facebookincubator/symphony/pkg/ent/floorplanreferencepoint"
	"github.com/facebookincubator/symphony/pkg/ent/floorplanscale"
	"github.com/facebookincubator/symphony/pkg/ent/flow"
	"github.com/facebookincubator/symphony/pkg/ent/flowdraft"
	"github.com/facebookincubator/symphony/pkg/ent/flowexecutiontemplate"
	"github.com/facebookincubator/symphony/pkg/ent/flowinstance"
	"github.com/facebookincubator/symphony/pkg/ent/formula"
	"github.com/facebookincubator/symphony/pkg/ent/hyperlink"
	"github.com/facebookincubator/symphony/pkg/ent/kpi"
	"github.com/facebookincubator/symphony/pkg/ent/kpicategory"
	"github.com/facebookincubator/symphony/pkg/ent/kqi"
	"github.com/facebookincubator/symphony/pkg/ent/kqicategory"
	"github.com/facebookincubator/symphony/pkg/ent/kqicomparator"
	"github.com/facebookincubator/symphony/pkg/ent/kqiperspective"
	"github.com/facebookincubator/symphony/pkg/ent/kqisource"
	"github.com/facebookincubator/symphony/pkg/ent/kqitarget"
	"github.com/facebookincubator/symphony/pkg/ent/kqitemporalfrequency"
	"github.com/facebookincubator/symphony/pkg/ent/link"
	"github.com/facebookincubator/symphony/pkg/ent/location"
	"github.com/facebookincubator/symphony/pkg/ent/locationtype"
	"github.com/facebookincubator/symphony/pkg/ent/networktype"
	"github.com/facebookincubator/symphony/pkg/ent/organization"
	"github.com/facebookincubator/symphony/pkg/ent/parametercatalog"
	"github.com/facebookincubator/symphony/pkg/ent/permissionspolicy"
	"github.com/facebookincubator/symphony/pkg/ent/project"
	"github.com/facebookincubator/symphony/pkg/ent/projecttemplate"
	"github.com/facebookincubator/symphony/pkg/ent/projecttype"
	"github.com/facebookincubator/symphony/pkg/ent/property"
	"github.com/facebookincubator/symphony/pkg/ent/propertycategory"
	"github.com/facebookincubator/symphony/pkg/ent/propertytype"
	"github.com/facebookincubator/symphony/pkg/ent/recommendations"
	"github.com/facebookincubator/symphony/pkg/ent/recommendationscategory"
	"github.com/facebookincubator/symphony/pkg/ent/recommendationssources"
	"github.com/facebookincubator/symphony/pkg/ent/reportfilter"
	"github.com/facebookincubator/symphony/pkg/ent/rule"
	"github.com/facebookincubator/symphony/pkg/ent/rulelimit"
	"github.com/facebookincubator/symphony/pkg/ent/ruletype"
	"github.com/facebookincubator/symphony/pkg/ent/service"
	"github.com/facebookincubator/symphony/pkg/ent/serviceendpoint"
	"github.com/facebookincubator/symphony/pkg/ent/serviceendpointdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/servicetype"
	"github.com/facebookincubator/symphony/pkg/ent/survey"
	"github.com/facebookincubator/symphony/pkg/ent/surveycellscan"
	"github.com/facebookincubator/symphony/pkg/ent/surveyquestion"
	"github.com/facebookincubator/symphony/pkg/ent/surveytemplatecategory"
	"github.com/facebookincubator/symphony/pkg/ent/surveytemplatequestion"
	"github.com/facebookincubator/symphony/pkg/ent/surveywifiscan"
	"github.com/facebookincubator/symphony/pkg/ent/tech"
	"github.com/facebookincubator/symphony/pkg/ent/threshold"
	"github.com/facebookincubator/symphony/pkg/ent/user"
	"github.com/facebookincubator/symphony/pkg/ent/usersgroup"
	"github.com/facebookincubator/symphony/pkg/ent/vendor"
	"github.com/facebookincubator/symphony/pkg/ent/workertype"
	"github.com/facebookincubator/symphony/pkg/ent/workorder"
	"github.com/facebookincubator/symphony/pkg/ent/workorderdefinition"
	"github.com/facebookincubator/symphony/pkg/ent/workordertemplate"
	"github.com/facebookincubator/symphony/pkg/ent/workordertype"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// ActivityEdge is the edge representation of Activity.
type ActivityEdge struct {
	Node   *Activity `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ActivityConnection is the connection containing edges to Activity.
type ActivityConnection struct {
	Edges      []*ActivityEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// ActivityPaginateOption enables pagination customization.
type ActivityPaginateOption func(*activityPager) error

// WithActivityOrder configures pagination ordering.
func WithActivityOrder(order *ActivityOrder) ActivityPaginateOption {
	if order == nil {
		order = DefaultActivityOrder
	}
	o := *order
	return func(pager *activityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultActivityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithActivityFilter configures pagination filter.
func WithActivityFilter(filter func(*ActivityQuery) (*ActivityQuery, error)) ActivityPaginateOption {
	return func(pager *activityPager) error {
		if filter == nil {
			return errors.New("ActivityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type activityPager struct {
	order  *ActivityOrder
	filter func(*ActivityQuery) (*ActivityQuery, error)
}

func newActivityPager(opts []ActivityPaginateOption) (*activityPager, error) {
	pager := &activityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultActivityOrder
	}
	return pager, nil
}

func (p *activityPager) applyFilter(query *ActivityQuery) (*ActivityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *activityPager) toCursor(a *Activity) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *activityPager) applyCursors(query *ActivityQuery, after, before *Cursor) *ActivityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultActivityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *activityPager) applyOrder(query *ActivityQuery, reverse bool) *ActivityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultActivityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultActivityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Activity.
func (a *ActivityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActivityPaginateOption,
) (*ActivityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActivityPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &ActivityConnection{Edges: []*ActivityEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Activity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Activity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Activity {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ActivityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ActivityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ActivityOrderField defines the ordering field of Activity.
type ActivityOrderField struct {
	field    string
	toCursor func(*Activity) Cursor
}

// ActivityOrder defines the ordering of Activity.
type ActivityOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ActivityOrderField `json:"field"`
}

// DefaultActivityOrder is the default ordering of Activity.
var DefaultActivityOrder = &ActivityOrder{
	Direction: OrderDirectionAsc,
	Field: &ActivityOrderField{
		field: activity.FieldID,
		toCursor: func(a *Activity) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// AlarmFilterEdge is the edge representation of AlarmFilter.
type AlarmFilterEdge struct {
	Node   *AlarmFilter `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AlarmFilterConnection is the connection containing edges to AlarmFilter.
type AlarmFilterConnection struct {
	Edges      []*AlarmFilterEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// AlarmFilterPaginateOption enables pagination customization.
type AlarmFilterPaginateOption func(*alarmFilterPager) error

// WithAlarmFilterOrder configures pagination ordering.
func WithAlarmFilterOrder(order *AlarmFilterOrder) AlarmFilterPaginateOption {
	if order == nil {
		order = DefaultAlarmFilterOrder
	}
	o := *order
	return func(pager *alarmFilterPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAlarmFilterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAlarmFilterFilter configures pagination filter.
func WithAlarmFilterFilter(filter func(*AlarmFilterQuery) (*AlarmFilterQuery, error)) AlarmFilterPaginateOption {
	return func(pager *alarmFilterPager) error {
		if filter == nil {
			return errors.New("AlarmFilterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type alarmFilterPager struct {
	order  *AlarmFilterOrder
	filter func(*AlarmFilterQuery) (*AlarmFilterQuery, error)
}

func newAlarmFilterPager(opts []AlarmFilterPaginateOption) (*alarmFilterPager, error) {
	pager := &alarmFilterPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAlarmFilterOrder
	}
	return pager, nil
}

func (p *alarmFilterPager) applyFilter(query *AlarmFilterQuery) (*AlarmFilterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *alarmFilterPager) toCursor(af *AlarmFilter) Cursor {
	return p.order.Field.toCursor(af)
}

func (p *alarmFilterPager) applyCursors(query *AlarmFilterQuery, after, before *Cursor) *AlarmFilterQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAlarmFilterOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *alarmFilterPager) applyOrder(query *AlarmFilterQuery, reverse bool) *AlarmFilterQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAlarmFilterOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAlarmFilterOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AlarmFilter.
func (af *AlarmFilterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AlarmFilterPaginateOption,
) (*AlarmFilterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAlarmFilterPager(opts)
	if err != nil {
		return nil, err
	}

	if af, err = pager.applyFilter(af); err != nil {
		return nil, err
	}

	conn := &AlarmFilterConnection{Edges: []*AlarmFilterEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := af.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := af.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	af = pager.applyCursors(af, after, before)
	af = pager.applyOrder(af, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		af = af.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		af = af.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := af.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AlarmFilter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AlarmFilter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AlarmFilter {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AlarmFilterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AlarmFilterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// AlarmFilterOrderFieldName orders AlarmFilter by name.
	AlarmFilterOrderFieldName = &AlarmFilterOrderField{
		field: alarmfilter.FieldName,
		toCursor: func(af *AlarmFilter) Cursor {
			return Cursor{
				ID:    af.ID,
				Value: af.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AlarmFilterOrderField) String() string {
	var str string
	switch f.field {
	case alarmfilter.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AlarmFilterOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AlarmFilterOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AlarmFilterOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *AlarmFilterOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid AlarmFilterOrderField", str)
	}
	return nil
}

// AlarmFilterOrderField defines the ordering field of AlarmFilter.
type AlarmFilterOrderField struct {
	field    string
	toCursor func(*AlarmFilter) Cursor
}

// AlarmFilterOrder defines the ordering of AlarmFilter.
type AlarmFilterOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AlarmFilterOrderField `json:"field"`
}

// DefaultAlarmFilterOrder is the default ordering of AlarmFilter.
var DefaultAlarmFilterOrder = &AlarmFilterOrder{
	Direction: OrderDirectionAsc,
	Field: &AlarmFilterOrderField{
		field: alarmfilter.FieldID,
		toCursor: func(af *AlarmFilter) Cursor {
			return Cursor{ID: af.ID}
		},
	},
}

// AlarmStatusEdge is the edge representation of AlarmStatus.
type AlarmStatusEdge struct {
	Node   *AlarmStatus `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AlarmStatusConnection is the connection containing edges to AlarmStatus.
type AlarmStatusConnection struct {
	Edges      []*AlarmStatusEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// AlarmStatusPaginateOption enables pagination customization.
type AlarmStatusPaginateOption func(*alarmStatusPager) error

// WithAlarmStatusOrder configures pagination ordering.
func WithAlarmStatusOrder(order *AlarmStatusOrder) AlarmStatusPaginateOption {
	if order == nil {
		order = DefaultAlarmStatusOrder
	}
	o := *order
	return func(pager *alarmStatusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAlarmStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAlarmStatusFilter configures pagination filter.
func WithAlarmStatusFilter(filter func(*AlarmStatusQuery) (*AlarmStatusQuery, error)) AlarmStatusPaginateOption {
	return func(pager *alarmStatusPager) error {
		if filter == nil {
			return errors.New("AlarmStatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type alarmStatusPager struct {
	order  *AlarmStatusOrder
	filter func(*AlarmStatusQuery) (*AlarmStatusQuery, error)
}

func newAlarmStatusPager(opts []AlarmStatusPaginateOption) (*alarmStatusPager, error) {
	pager := &alarmStatusPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAlarmStatusOrder
	}
	return pager, nil
}

func (p *alarmStatusPager) applyFilter(query *AlarmStatusQuery) (*AlarmStatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *alarmStatusPager) toCursor(as *AlarmStatus) Cursor {
	return p.order.Field.toCursor(as)
}

func (p *alarmStatusPager) applyCursors(query *AlarmStatusQuery, after, before *Cursor) *AlarmStatusQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAlarmStatusOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *alarmStatusPager) applyOrder(query *AlarmStatusQuery, reverse bool) *AlarmStatusQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAlarmStatusOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAlarmStatusOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AlarmStatus.
func (as *AlarmStatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AlarmStatusPaginateOption,
) (*AlarmStatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAlarmStatusPager(opts)
	if err != nil {
		return nil, err
	}

	if as, err = pager.applyFilter(as); err != nil {
		return nil, err
	}

	conn := &AlarmStatusConnection{Edges: []*AlarmStatusEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := as.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := as.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	as = pager.applyCursors(as, after, before)
	as = pager.applyOrder(as, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		as = as.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		as = as.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := as.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AlarmStatus
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AlarmStatus {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AlarmStatus {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AlarmStatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AlarmStatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// AlarmStatusOrderFieldName orders AlarmStatus by name.
	AlarmStatusOrderFieldName = &AlarmStatusOrderField{
		field: alarmstatus.FieldName,
		toCursor: func(as *AlarmStatus) Cursor {
			return Cursor{
				ID:    as.ID,
				Value: as.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AlarmStatusOrderField) String() string {
	var str string
	switch f.field {
	case alarmstatus.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AlarmStatusOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AlarmStatusOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AlarmStatusOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *AlarmStatusOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid AlarmStatusOrderField", str)
	}
	return nil
}

// AlarmStatusOrderField defines the ordering field of AlarmStatus.
type AlarmStatusOrderField struct {
	field    string
	toCursor func(*AlarmStatus) Cursor
}

// AlarmStatusOrder defines the ordering of AlarmStatus.
type AlarmStatusOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AlarmStatusOrderField `json:"field"`
}

// DefaultAlarmStatusOrder is the default ordering of AlarmStatus.
var DefaultAlarmStatusOrder = &AlarmStatusOrder{
	Direction: OrderDirectionAsc,
	Field: &AlarmStatusOrderField{
		field: alarmstatus.FieldID,
		toCursor: func(as *AlarmStatus) Cursor {
			return Cursor{ID: as.ID}
		},
	},
}

// AppointmentEdge is the edge representation of Appointment.
type AppointmentEdge struct {
	Node   *Appointment `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AppointmentConnection is the connection containing edges to Appointment.
type AppointmentConnection struct {
	Edges      []*AppointmentEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// AppointmentPaginateOption enables pagination customization.
type AppointmentPaginateOption func(*appointmentPager) error

// WithAppointmentOrder configures pagination ordering.
func WithAppointmentOrder(order *AppointmentOrder) AppointmentPaginateOption {
	if order == nil {
		order = DefaultAppointmentOrder
	}
	o := *order
	return func(pager *appointmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAppointmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAppointmentFilter configures pagination filter.
func WithAppointmentFilter(filter func(*AppointmentQuery) (*AppointmentQuery, error)) AppointmentPaginateOption {
	return func(pager *appointmentPager) error {
		if filter == nil {
			return errors.New("AppointmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type appointmentPager struct {
	order  *AppointmentOrder
	filter func(*AppointmentQuery) (*AppointmentQuery, error)
}

func newAppointmentPager(opts []AppointmentPaginateOption) (*appointmentPager, error) {
	pager := &appointmentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAppointmentOrder
	}
	return pager, nil
}

func (p *appointmentPager) applyFilter(query *AppointmentQuery) (*AppointmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *appointmentPager) toCursor(a *Appointment) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *appointmentPager) applyCursors(query *AppointmentQuery, after, before *Cursor) *AppointmentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAppointmentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *appointmentPager) applyOrder(query *AppointmentQuery, reverse bool) *AppointmentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAppointmentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAppointmentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Appointment.
func (a *AppointmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppointmentPaginateOption,
) (*AppointmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppointmentPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &AppointmentConnection{Edges: []*AppointmentEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Appointment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Appointment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Appointment {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AppointmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AppointmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// AppointmentOrderFieldCreationDate orders Appointment by creation_date.
	AppointmentOrderFieldCreationDate = &AppointmentOrderField{
		field: appointment.FieldCreationDate,
		toCursor: func(a *Appointment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreationDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AppointmentOrderField) String() string {
	var str string
	switch f.field {
	case appointment.FieldCreationDate:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AppointmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AppointmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AppointmentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AppointmentOrderFieldCreationDate
	default:
		return fmt.Errorf("%s is not a valid AppointmentOrderField", str)
	}
	return nil
}

// AppointmentOrderField defines the ordering field of Appointment.
type AppointmentOrderField struct {
	field    string
	toCursor func(*Appointment) Cursor
}

// AppointmentOrder defines the ordering of Appointment.
type AppointmentOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AppointmentOrderField `json:"field"`
}

// DefaultAppointmentOrder is the default ordering of Appointment.
var DefaultAppointmentOrder = &AppointmentOrder{
	Direction: OrderDirectionAsc,
	Field: &AppointmentOrderField{
		field: appointment.FieldID,
		toCursor: func(a *Appointment) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// BlockEdge is the edge representation of Block.
type BlockEdge struct {
	Node   *Block `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BlockConnection is the connection containing edges to Block.
type BlockConnection struct {
	Edges      []*BlockEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// BlockPaginateOption enables pagination customization.
type BlockPaginateOption func(*blockPager) error

// WithBlockOrder configures pagination ordering.
func WithBlockOrder(order *BlockOrder) BlockPaginateOption {
	if order == nil {
		order = DefaultBlockOrder
	}
	o := *order
	return func(pager *blockPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBlockOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBlockFilter configures pagination filter.
func WithBlockFilter(filter func(*BlockQuery) (*BlockQuery, error)) BlockPaginateOption {
	return func(pager *blockPager) error {
		if filter == nil {
			return errors.New("BlockQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type blockPager struct {
	order  *BlockOrder
	filter func(*BlockQuery) (*BlockQuery, error)
}

func newBlockPager(opts []BlockPaginateOption) (*blockPager, error) {
	pager := &blockPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBlockOrder
	}
	return pager, nil
}

func (p *blockPager) applyFilter(query *BlockQuery) (*BlockQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *blockPager) toCursor(b *Block) Cursor {
	return p.order.Field.toCursor(b)
}

func (p *blockPager) applyCursors(query *BlockQuery, after, before *Cursor) *BlockQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBlockOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *blockPager) applyOrder(query *BlockQuery, reverse bool) *BlockQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBlockOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBlockOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Block.
func (b *BlockQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BlockPaginateOption,
) (*BlockConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBlockPager(opts)
	if err != nil {
		return nil, err
	}

	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}

	conn := &BlockConnection{Edges: []*BlockEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := b.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := b.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	b = pager.applyCursors(b, after, before)
	b = pager.applyOrder(b, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		b = b.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		b = b.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := b.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Block
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Block {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Block {
			return nodes[i]
		}
	}

	conn.Edges = make([]*BlockEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &BlockEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// BlockOrderField defines the ordering field of Block.
type BlockOrderField struct {
	field    string
	toCursor func(*Block) Cursor
}

// BlockOrder defines the ordering of Block.
type BlockOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *BlockOrderField `json:"field"`
}

// DefaultBlockOrder is the default ordering of Block.
var DefaultBlockOrder = &BlockOrder{
	Direction: OrderDirectionAsc,
	Field: &BlockOrderField{
		field: block.FieldID,
		toCursor: func(b *Block) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// BlockInstanceEdge is the edge representation of BlockInstance.
type BlockInstanceEdge struct {
	Node   *BlockInstance `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// BlockInstanceConnection is the connection containing edges to BlockInstance.
type BlockInstanceConnection struct {
	Edges      []*BlockInstanceEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// BlockInstancePaginateOption enables pagination customization.
type BlockInstancePaginateOption func(*blockInstancePager) error

// WithBlockInstanceOrder configures pagination ordering.
func WithBlockInstanceOrder(order *BlockInstanceOrder) BlockInstancePaginateOption {
	if order == nil {
		order = DefaultBlockInstanceOrder
	}
	o := *order
	return func(pager *blockInstancePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBlockInstanceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBlockInstanceFilter configures pagination filter.
func WithBlockInstanceFilter(filter func(*BlockInstanceQuery) (*BlockInstanceQuery, error)) BlockInstancePaginateOption {
	return func(pager *blockInstancePager) error {
		if filter == nil {
			return errors.New("BlockInstanceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type blockInstancePager struct {
	order  *BlockInstanceOrder
	filter func(*BlockInstanceQuery) (*BlockInstanceQuery, error)
}

func newBlockInstancePager(opts []BlockInstancePaginateOption) (*blockInstancePager, error) {
	pager := &blockInstancePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBlockInstanceOrder
	}
	return pager, nil
}

func (p *blockInstancePager) applyFilter(query *BlockInstanceQuery) (*BlockInstanceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *blockInstancePager) toCursor(bi *BlockInstance) Cursor {
	return p.order.Field.toCursor(bi)
}

func (p *blockInstancePager) applyCursors(query *BlockInstanceQuery, after, before *Cursor) *BlockInstanceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBlockInstanceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *blockInstancePager) applyOrder(query *BlockInstanceQuery, reverse bool) *BlockInstanceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBlockInstanceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBlockInstanceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to BlockInstance.
func (bi *BlockInstanceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BlockInstancePaginateOption,
) (*BlockInstanceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBlockInstancePager(opts)
	if err != nil {
		return nil, err
	}

	if bi, err = pager.applyFilter(bi); err != nil {
		return nil, err
	}

	conn := &BlockInstanceConnection{Edges: []*BlockInstanceEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := bi.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := bi.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	bi = pager.applyCursors(bi, after, before)
	bi = pager.applyOrder(bi, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		bi = bi.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		bi = bi.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := bi.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *BlockInstance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BlockInstance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BlockInstance {
			return nodes[i]
		}
	}

	conn.Edges = make([]*BlockInstanceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &BlockInstanceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// BlockInstanceOrderFieldUpdateTime orders BlockInstance by update_time.
	BlockInstanceOrderFieldUpdateTime = &BlockInstanceOrderField{
		field: blockinstance.FieldUpdateTime,
		toCursor: func(bi *BlockInstance) Cursor {
			return Cursor{
				ID:    bi.ID,
				Value: bi.UpdateTime,
			}
		},
	}
	// BlockInstanceOrderFieldStartDate orders BlockInstance by start_date.
	BlockInstanceOrderFieldStartDate = &BlockInstanceOrderField{
		field: blockinstance.FieldStartDate,
		toCursor: func(bi *BlockInstance) Cursor {
			return Cursor{
				ID:    bi.ID,
				Value: bi.StartDate,
			}
		},
	}
	// BlockInstanceOrderFieldEndDate orders BlockInstance by end_date.
	BlockInstanceOrderFieldEndDate = &BlockInstanceOrderField{
		field: blockinstance.FieldEndDate,
		toCursor: func(bi *BlockInstance) Cursor {
			return Cursor{
				ID:    bi.ID,
				Value: bi.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BlockInstanceOrderField) String() string {
	var str string
	switch f.field {
	case blockinstance.FieldUpdateTime:
		str = "UPDATED_AT"
	case blockinstance.FieldStartDate:
		str = "START_AT"
	case blockinstance.FieldEndDate:
		str = "END_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BlockInstanceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BlockInstanceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BlockInstanceOrderField %T must be a string", v)
	}
	switch str {
	case "UPDATED_AT":
		*f = *BlockInstanceOrderFieldUpdateTime
	case "START_AT":
		*f = *BlockInstanceOrderFieldStartDate
	case "END_AT":
		*f = *BlockInstanceOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid BlockInstanceOrderField", str)
	}
	return nil
}

// BlockInstanceOrderField defines the ordering field of BlockInstance.
type BlockInstanceOrderField struct {
	field    string
	toCursor func(*BlockInstance) Cursor
}

// BlockInstanceOrder defines the ordering of BlockInstance.
type BlockInstanceOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *BlockInstanceOrderField `json:"field"`
}

// DefaultBlockInstanceOrder is the default ordering of BlockInstance.
var DefaultBlockInstanceOrder = &BlockInstanceOrder{
	Direction: OrderDirectionAsc,
	Field: &BlockInstanceOrderField{
		field: blockinstance.FieldID,
		toCursor: func(bi *BlockInstance) Cursor {
			return Cursor{ID: bi.ID}
		},
	},
}

// CheckListCategoryEdge is the edge representation of CheckListCategory.
type CheckListCategoryEdge struct {
	Node   *CheckListCategory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// CheckListCategoryConnection is the connection containing edges to CheckListCategory.
type CheckListCategoryConnection struct {
	Edges      []*CheckListCategoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// CheckListCategoryPaginateOption enables pagination customization.
type CheckListCategoryPaginateOption func(*checkListCategoryPager) error

// WithCheckListCategoryOrder configures pagination ordering.
func WithCheckListCategoryOrder(order *CheckListCategoryOrder) CheckListCategoryPaginateOption {
	if order == nil {
		order = DefaultCheckListCategoryOrder
	}
	o := *order
	return func(pager *checkListCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCheckListCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCheckListCategoryFilter configures pagination filter.
func WithCheckListCategoryFilter(filter func(*CheckListCategoryQuery) (*CheckListCategoryQuery, error)) CheckListCategoryPaginateOption {
	return func(pager *checkListCategoryPager) error {
		if filter == nil {
			return errors.New("CheckListCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type checkListCategoryPager struct {
	order  *CheckListCategoryOrder
	filter func(*CheckListCategoryQuery) (*CheckListCategoryQuery, error)
}

func newCheckListCategoryPager(opts []CheckListCategoryPaginateOption) (*checkListCategoryPager, error) {
	pager := &checkListCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCheckListCategoryOrder
	}
	return pager, nil
}

func (p *checkListCategoryPager) applyFilter(query *CheckListCategoryQuery) (*CheckListCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *checkListCategoryPager) toCursor(clc *CheckListCategory) Cursor {
	return p.order.Field.toCursor(clc)
}

func (p *checkListCategoryPager) applyCursors(query *CheckListCategoryQuery, after, before *Cursor) *CheckListCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCheckListCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *checkListCategoryPager) applyOrder(query *CheckListCategoryQuery, reverse bool) *CheckListCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCheckListCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCheckListCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CheckListCategory.
func (clc *CheckListCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CheckListCategoryPaginateOption,
) (*CheckListCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCheckListCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if clc, err = pager.applyFilter(clc); err != nil {
		return nil, err
	}

	conn := &CheckListCategoryConnection{Edges: []*CheckListCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := clc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := clc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	clc = pager.applyCursors(clc, after, before)
	clc = pager.applyOrder(clc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		clc = clc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		clc = clc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := clc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CheckListCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CheckListCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CheckListCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CheckListCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CheckListCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CheckListCategoryOrderField defines the ordering field of CheckListCategory.
type CheckListCategoryOrderField struct {
	field    string
	toCursor func(*CheckListCategory) Cursor
}

// CheckListCategoryOrder defines the ordering of CheckListCategory.
type CheckListCategoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *CheckListCategoryOrderField `json:"field"`
}

// DefaultCheckListCategoryOrder is the default ordering of CheckListCategory.
var DefaultCheckListCategoryOrder = &CheckListCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &CheckListCategoryOrderField{
		field: checklistcategory.FieldID,
		toCursor: func(clc *CheckListCategory) Cursor {
			return Cursor{ID: clc.ID}
		},
	},
}

// CheckListCategoryDefinitionEdge is the edge representation of CheckListCategoryDefinition.
type CheckListCategoryDefinitionEdge struct {
	Node   *CheckListCategoryDefinition `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// CheckListCategoryDefinitionConnection is the connection containing edges to CheckListCategoryDefinition.
type CheckListCategoryDefinitionConnection struct {
	Edges      []*CheckListCategoryDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

// CheckListCategoryDefinitionPaginateOption enables pagination customization.
type CheckListCategoryDefinitionPaginateOption func(*checkListCategoryDefinitionPager) error

// WithCheckListCategoryDefinitionOrder configures pagination ordering.
func WithCheckListCategoryDefinitionOrder(order *CheckListCategoryDefinitionOrder) CheckListCategoryDefinitionPaginateOption {
	if order == nil {
		order = DefaultCheckListCategoryDefinitionOrder
	}
	o := *order
	return func(pager *checkListCategoryDefinitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCheckListCategoryDefinitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCheckListCategoryDefinitionFilter configures pagination filter.
func WithCheckListCategoryDefinitionFilter(filter func(*CheckListCategoryDefinitionQuery) (*CheckListCategoryDefinitionQuery, error)) CheckListCategoryDefinitionPaginateOption {
	return func(pager *checkListCategoryDefinitionPager) error {
		if filter == nil {
			return errors.New("CheckListCategoryDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type checkListCategoryDefinitionPager struct {
	order  *CheckListCategoryDefinitionOrder
	filter func(*CheckListCategoryDefinitionQuery) (*CheckListCategoryDefinitionQuery, error)
}

func newCheckListCategoryDefinitionPager(opts []CheckListCategoryDefinitionPaginateOption) (*checkListCategoryDefinitionPager, error) {
	pager := &checkListCategoryDefinitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCheckListCategoryDefinitionOrder
	}
	return pager, nil
}

func (p *checkListCategoryDefinitionPager) applyFilter(query *CheckListCategoryDefinitionQuery) (*CheckListCategoryDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *checkListCategoryDefinitionPager) toCursor(clcd *CheckListCategoryDefinition) Cursor {
	return p.order.Field.toCursor(clcd)
}

func (p *checkListCategoryDefinitionPager) applyCursors(query *CheckListCategoryDefinitionQuery, after, before *Cursor) *CheckListCategoryDefinitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCheckListCategoryDefinitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *checkListCategoryDefinitionPager) applyOrder(query *CheckListCategoryDefinitionQuery, reverse bool) *CheckListCategoryDefinitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCheckListCategoryDefinitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCheckListCategoryDefinitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CheckListCategoryDefinition.
func (clcd *CheckListCategoryDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CheckListCategoryDefinitionPaginateOption,
) (*CheckListCategoryDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCheckListCategoryDefinitionPager(opts)
	if err != nil {
		return nil, err
	}

	if clcd, err = pager.applyFilter(clcd); err != nil {
		return nil, err
	}

	conn := &CheckListCategoryDefinitionConnection{Edges: []*CheckListCategoryDefinitionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := clcd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := clcd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	clcd = pager.applyCursors(clcd, after, before)
	clcd = pager.applyOrder(clcd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		clcd = clcd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		clcd = clcd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := clcd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CheckListCategoryDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CheckListCategoryDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CheckListCategoryDefinition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CheckListCategoryDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CheckListCategoryDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CheckListCategoryDefinitionOrderField defines the ordering field of CheckListCategoryDefinition.
type CheckListCategoryDefinitionOrderField struct {
	field    string
	toCursor func(*CheckListCategoryDefinition) Cursor
}

// CheckListCategoryDefinitionOrder defines the ordering of CheckListCategoryDefinition.
type CheckListCategoryDefinitionOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *CheckListCategoryDefinitionOrderField `json:"field"`
}

// DefaultCheckListCategoryDefinitionOrder is the default ordering of CheckListCategoryDefinition.
var DefaultCheckListCategoryDefinitionOrder = &CheckListCategoryDefinitionOrder{
	Direction: OrderDirectionAsc,
	Field: &CheckListCategoryDefinitionOrderField{
		field: checklistcategorydefinition.FieldID,
		toCursor: func(clcd *CheckListCategoryDefinition) Cursor {
			return Cursor{ID: clcd.ID}
		},
	},
}

// CheckListItemEdge is the edge representation of CheckListItem.
type CheckListItemEdge struct {
	Node   *CheckListItem `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// CheckListItemConnection is the connection containing edges to CheckListItem.
type CheckListItemConnection struct {
	Edges      []*CheckListItemEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// CheckListItemPaginateOption enables pagination customization.
type CheckListItemPaginateOption func(*checkListItemPager) error

// WithCheckListItemOrder configures pagination ordering.
func WithCheckListItemOrder(order *CheckListItemOrder) CheckListItemPaginateOption {
	if order == nil {
		order = DefaultCheckListItemOrder
	}
	o := *order
	return func(pager *checkListItemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCheckListItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCheckListItemFilter configures pagination filter.
func WithCheckListItemFilter(filter func(*CheckListItemQuery) (*CheckListItemQuery, error)) CheckListItemPaginateOption {
	return func(pager *checkListItemPager) error {
		if filter == nil {
			return errors.New("CheckListItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type checkListItemPager struct {
	order  *CheckListItemOrder
	filter func(*CheckListItemQuery) (*CheckListItemQuery, error)
}

func newCheckListItemPager(opts []CheckListItemPaginateOption) (*checkListItemPager, error) {
	pager := &checkListItemPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCheckListItemOrder
	}
	return pager, nil
}

func (p *checkListItemPager) applyFilter(query *CheckListItemQuery) (*CheckListItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *checkListItemPager) toCursor(cli *CheckListItem) Cursor {
	return p.order.Field.toCursor(cli)
}

func (p *checkListItemPager) applyCursors(query *CheckListItemQuery, after, before *Cursor) *CheckListItemQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCheckListItemOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *checkListItemPager) applyOrder(query *CheckListItemQuery, reverse bool) *CheckListItemQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCheckListItemOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCheckListItemOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CheckListItem.
func (cli *CheckListItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CheckListItemPaginateOption,
) (*CheckListItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCheckListItemPager(opts)
	if err != nil {
		return nil, err
	}

	if cli, err = pager.applyFilter(cli); err != nil {
		return nil, err
	}

	conn := &CheckListItemConnection{Edges: []*CheckListItemEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cli.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := cli.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cli = pager.applyCursors(cli, after, before)
	cli = pager.applyOrder(cli, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cli = cli.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cli = cli.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cli.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CheckListItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CheckListItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CheckListItem {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CheckListItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CheckListItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CheckListItemOrderField defines the ordering field of CheckListItem.
type CheckListItemOrderField struct {
	field    string
	toCursor func(*CheckListItem) Cursor
}

// CheckListItemOrder defines the ordering of CheckListItem.
type CheckListItemOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *CheckListItemOrderField `json:"field"`
}

// DefaultCheckListItemOrder is the default ordering of CheckListItem.
var DefaultCheckListItemOrder = &CheckListItemOrder{
	Direction: OrderDirectionAsc,
	Field: &CheckListItemOrderField{
		field: checklistitem.FieldID,
		toCursor: func(cli *CheckListItem) Cursor {
			return Cursor{ID: cli.ID}
		},
	},
}

// CheckListItemDefinitionEdge is the edge representation of CheckListItemDefinition.
type CheckListItemDefinitionEdge struct {
	Node   *CheckListItemDefinition `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// CheckListItemDefinitionConnection is the connection containing edges to CheckListItemDefinition.
type CheckListItemDefinitionConnection struct {
	Edges      []*CheckListItemDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

// CheckListItemDefinitionPaginateOption enables pagination customization.
type CheckListItemDefinitionPaginateOption func(*checkListItemDefinitionPager) error

// WithCheckListItemDefinitionOrder configures pagination ordering.
func WithCheckListItemDefinitionOrder(order *CheckListItemDefinitionOrder) CheckListItemDefinitionPaginateOption {
	if order == nil {
		order = DefaultCheckListItemDefinitionOrder
	}
	o := *order
	return func(pager *checkListItemDefinitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCheckListItemDefinitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCheckListItemDefinitionFilter configures pagination filter.
func WithCheckListItemDefinitionFilter(filter func(*CheckListItemDefinitionQuery) (*CheckListItemDefinitionQuery, error)) CheckListItemDefinitionPaginateOption {
	return func(pager *checkListItemDefinitionPager) error {
		if filter == nil {
			return errors.New("CheckListItemDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type checkListItemDefinitionPager struct {
	order  *CheckListItemDefinitionOrder
	filter func(*CheckListItemDefinitionQuery) (*CheckListItemDefinitionQuery, error)
}

func newCheckListItemDefinitionPager(opts []CheckListItemDefinitionPaginateOption) (*checkListItemDefinitionPager, error) {
	pager := &checkListItemDefinitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCheckListItemDefinitionOrder
	}
	return pager, nil
}

func (p *checkListItemDefinitionPager) applyFilter(query *CheckListItemDefinitionQuery) (*CheckListItemDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *checkListItemDefinitionPager) toCursor(clid *CheckListItemDefinition) Cursor {
	return p.order.Field.toCursor(clid)
}

func (p *checkListItemDefinitionPager) applyCursors(query *CheckListItemDefinitionQuery, after, before *Cursor) *CheckListItemDefinitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCheckListItemDefinitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *checkListItemDefinitionPager) applyOrder(query *CheckListItemDefinitionQuery, reverse bool) *CheckListItemDefinitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCheckListItemDefinitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCheckListItemDefinitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CheckListItemDefinition.
func (clid *CheckListItemDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CheckListItemDefinitionPaginateOption,
) (*CheckListItemDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCheckListItemDefinitionPager(opts)
	if err != nil {
		return nil, err
	}

	if clid, err = pager.applyFilter(clid); err != nil {
		return nil, err
	}

	conn := &CheckListItemDefinitionConnection{Edges: []*CheckListItemDefinitionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := clid.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := clid.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	clid = pager.applyCursors(clid, after, before)
	clid = pager.applyOrder(clid, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		clid = clid.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		clid = clid.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := clid.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CheckListItemDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CheckListItemDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CheckListItemDefinition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CheckListItemDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CheckListItemDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CheckListItemDefinitionOrderField defines the ordering field of CheckListItemDefinition.
type CheckListItemDefinitionOrderField struct {
	field    string
	toCursor func(*CheckListItemDefinition) Cursor
}

// CheckListItemDefinitionOrder defines the ordering of CheckListItemDefinition.
type CheckListItemDefinitionOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *CheckListItemDefinitionOrderField `json:"field"`
}

// DefaultCheckListItemDefinitionOrder is the default ordering of CheckListItemDefinition.
var DefaultCheckListItemDefinitionOrder = &CheckListItemDefinitionOrder{
	Direction: OrderDirectionAsc,
	Field: &CheckListItemDefinitionOrderField{
		field: checklistitemdefinition.FieldID,
		toCursor: func(clid *CheckListItemDefinition) Cursor {
			return Cursor{ID: clid.ID}
		},
	},
}

// CommentEdge is the edge representation of Comment.
type CommentEdge struct {
	Node   *Comment `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CommentConnection is the connection containing edges to Comment.
type CommentConnection struct {
	Edges      []*CommentEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// CommentPaginateOption enables pagination customization.
type CommentPaginateOption func(*commentPager) error

// WithCommentOrder configures pagination ordering.
func WithCommentOrder(order *CommentOrder) CommentPaginateOption {
	if order == nil {
		order = DefaultCommentOrder
	}
	o := *order
	return func(pager *commentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCommentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCommentFilter configures pagination filter.
func WithCommentFilter(filter func(*CommentQuery) (*CommentQuery, error)) CommentPaginateOption {
	return func(pager *commentPager) error {
		if filter == nil {
			return errors.New("CommentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type commentPager struct {
	order  *CommentOrder
	filter func(*CommentQuery) (*CommentQuery, error)
}

func newCommentPager(opts []CommentPaginateOption) (*commentPager, error) {
	pager := &commentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCommentOrder
	}
	return pager, nil
}

func (p *commentPager) applyFilter(query *CommentQuery) (*CommentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *commentPager) toCursor(c *Comment) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *commentPager) applyCursors(query *CommentQuery, after, before *Cursor) *CommentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCommentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *commentPager) applyOrder(query *CommentQuery, reverse bool) *CommentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCommentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCommentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Comment.
func (c *CommentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CommentPaginateOption,
) (*CommentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommentPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CommentConnection{Edges: []*CommentEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Comment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Comment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Comment {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CommentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CommentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CommentOrderField defines the ordering field of Comment.
type CommentOrderField struct {
	field    string
	toCursor func(*Comment) Cursor
}

// CommentOrder defines the ordering of Comment.
type CommentOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CommentOrderField `json:"field"`
}

// DefaultCommentOrder is the default ordering of Comment.
var DefaultCommentOrder = &CommentOrder{
	Direction: OrderDirectionAsc,
	Field: &CommentOrderField{
		field: comment.FieldID,
		toCursor: func(c *Comment) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ComparatorEdge is the edge representation of Comparator.
type ComparatorEdge struct {
	Node   *Comparator `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ComparatorConnection is the connection containing edges to Comparator.
type ComparatorConnection struct {
	Edges      []*ComparatorEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// ComparatorPaginateOption enables pagination customization.
type ComparatorPaginateOption func(*comparatorPager) error

// WithComparatorOrder configures pagination ordering.
func WithComparatorOrder(order *ComparatorOrder) ComparatorPaginateOption {
	if order == nil {
		order = DefaultComparatorOrder
	}
	o := *order
	return func(pager *comparatorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultComparatorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithComparatorFilter configures pagination filter.
func WithComparatorFilter(filter func(*ComparatorQuery) (*ComparatorQuery, error)) ComparatorPaginateOption {
	return func(pager *comparatorPager) error {
		if filter == nil {
			return errors.New("ComparatorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type comparatorPager struct {
	order  *ComparatorOrder
	filter func(*ComparatorQuery) (*ComparatorQuery, error)
}

func newComparatorPager(opts []ComparatorPaginateOption) (*comparatorPager, error) {
	pager := &comparatorPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultComparatorOrder
	}
	return pager, nil
}

func (p *comparatorPager) applyFilter(query *ComparatorQuery) (*ComparatorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *comparatorPager) toCursor(c *Comparator) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *comparatorPager) applyCursors(query *ComparatorQuery, after, before *Cursor) *ComparatorQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultComparatorOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *comparatorPager) applyOrder(query *ComparatorQuery, reverse bool) *ComparatorQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultComparatorOrder.Field {
		query = query.Order(direction.orderFunc(DefaultComparatorOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Comparator.
func (c *ComparatorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ComparatorPaginateOption,
) (*ComparatorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newComparatorPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &ComparatorConnection{Edges: []*ComparatorEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Comparator
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Comparator {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Comparator {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ComparatorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ComparatorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ComparatorOrderFieldName orders Comparator by name.
	ComparatorOrderFieldName = &ComparatorOrderField{
		field: comparator.FieldName,
		toCursor: func(c *Comparator) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ComparatorOrderField) String() string {
	var str string
	switch f.field {
	case comparator.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ComparatorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ComparatorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ComparatorOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ComparatorOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ComparatorOrderField", str)
	}
	return nil
}

// ComparatorOrderField defines the ordering field of Comparator.
type ComparatorOrderField struct {
	field    string
	toCursor func(*Comparator) Cursor
}

// ComparatorOrder defines the ordering of Comparator.
type ComparatorOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ComparatorOrderField `json:"field"`
}

// DefaultComparatorOrder is the default ordering of Comparator.
var DefaultComparatorOrder = &ComparatorOrder{
	Direction: OrderDirectionAsc,
	Field: &ComparatorOrderField{
		field: comparator.FieldID,
		toCursor: func(c *Comparator) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// CounterEdge is the edge representation of Counter.
type CounterEdge struct {
	Node   *Counter `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CounterConnection is the connection containing edges to Counter.
type CounterConnection struct {
	Edges      []*CounterEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// CounterPaginateOption enables pagination customization.
type CounterPaginateOption func(*counterPager) error

// WithCounterOrder configures pagination ordering.
func WithCounterOrder(order *CounterOrder) CounterPaginateOption {
	if order == nil {
		order = DefaultCounterOrder
	}
	o := *order
	return func(pager *counterPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCounterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCounterFilter configures pagination filter.
func WithCounterFilter(filter func(*CounterQuery) (*CounterQuery, error)) CounterPaginateOption {
	return func(pager *counterPager) error {
		if filter == nil {
			return errors.New("CounterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type counterPager struct {
	order  *CounterOrder
	filter func(*CounterQuery) (*CounterQuery, error)
}

func newCounterPager(opts []CounterPaginateOption) (*counterPager, error) {
	pager := &counterPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCounterOrder
	}
	return pager, nil
}

func (p *counterPager) applyFilter(query *CounterQuery) (*CounterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *counterPager) toCursor(c *Counter) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *counterPager) applyCursors(query *CounterQuery, after, before *Cursor) *CounterQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCounterOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *counterPager) applyOrder(query *CounterQuery, reverse bool) *CounterQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCounterOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCounterOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Counter.
func (c *CounterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CounterPaginateOption,
) (*CounterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCounterPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CounterConnection{Edges: []*CounterEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Counter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Counter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Counter {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CounterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CounterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CounterOrderFieldName orders Counter by name.
	CounterOrderFieldName = &CounterOrderField{
		field: counter.FieldName,
		toCursor: func(c *Counter) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CounterOrderFieldExternalId orders Counter by externalId.
	CounterOrderFieldExternalId = &CounterOrderField{
		field: counter.FieldExternalId,
		toCursor: func(c *Counter) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.ExternalId,
			}
		},
	}
	// CounterOrderFieldNetworkManagerSystem orders Counter by networkManagerSystem.
	CounterOrderFieldNetworkManagerSystem = &CounterOrderField{
		field: counter.FieldNetworkManagerSystem,
		toCursor: func(c *Counter) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.NetworkManagerSystem,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CounterOrderField) String() string {
	var str string
	switch f.field {
	case counter.FieldName:
		str = "NAME"
	case counter.FieldExternalId:
		str = "EXTERNALID"
	case counter.FieldNetworkManagerSystem:
		str = "NETWORKMANAGERSYSTEM"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CounterOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CounterOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CounterOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *CounterOrderFieldName
	case "EXTERNALID":
		*f = *CounterOrderFieldExternalId
	case "NETWORKMANAGERSYSTEM":
		*f = *CounterOrderFieldNetworkManagerSystem
	default:
		return fmt.Errorf("%s is not a valid CounterOrderField", str)
	}
	return nil
}

// CounterOrderField defines the ordering field of Counter.
type CounterOrderField struct {
	field    string
	toCursor func(*Counter) Cursor
}

// CounterOrder defines the ordering of Counter.
type CounterOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CounterOrderField `json:"field"`
}

// DefaultCounterOrder is the default ordering of Counter.
var DefaultCounterOrder = &CounterOrder{
	Direction: OrderDirectionAsc,
	Field: &CounterOrderField{
		field: counter.FieldID,
		toCursor: func(c *Counter) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// CounterFamilyEdge is the edge representation of CounterFamily.
type CounterFamilyEdge struct {
	Node   *CounterFamily `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// CounterFamilyConnection is the connection containing edges to CounterFamily.
type CounterFamilyConnection struct {
	Edges      []*CounterFamilyEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// CounterFamilyPaginateOption enables pagination customization.
type CounterFamilyPaginateOption func(*counterFamilyPager) error

// WithCounterFamilyOrder configures pagination ordering.
func WithCounterFamilyOrder(order *CounterFamilyOrder) CounterFamilyPaginateOption {
	if order == nil {
		order = DefaultCounterFamilyOrder
	}
	o := *order
	return func(pager *counterFamilyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCounterFamilyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCounterFamilyFilter configures pagination filter.
func WithCounterFamilyFilter(filter func(*CounterFamilyQuery) (*CounterFamilyQuery, error)) CounterFamilyPaginateOption {
	return func(pager *counterFamilyPager) error {
		if filter == nil {
			return errors.New("CounterFamilyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type counterFamilyPager struct {
	order  *CounterFamilyOrder
	filter func(*CounterFamilyQuery) (*CounterFamilyQuery, error)
}

func newCounterFamilyPager(opts []CounterFamilyPaginateOption) (*counterFamilyPager, error) {
	pager := &counterFamilyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCounterFamilyOrder
	}
	return pager, nil
}

func (p *counterFamilyPager) applyFilter(query *CounterFamilyQuery) (*CounterFamilyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *counterFamilyPager) toCursor(cf *CounterFamily) Cursor {
	return p.order.Field.toCursor(cf)
}

func (p *counterFamilyPager) applyCursors(query *CounterFamilyQuery, after, before *Cursor) *CounterFamilyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCounterFamilyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *counterFamilyPager) applyOrder(query *CounterFamilyQuery, reverse bool) *CounterFamilyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCounterFamilyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCounterFamilyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CounterFamily.
func (cf *CounterFamilyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CounterFamilyPaginateOption,
) (*CounterFamilyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCounterFamilyPager(opts)
	if err != nil {
		return nil, err
	}

	if cf, err = pager.applyFilter(cf); err != nil {
		return nil, err
	}

	conn := &CounterFamilyConnection{Edges: []*CounterFamilyEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cf.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := cf.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cf = pager.applyCursors(cf, after, before)
	cf = pager.applyOrder(cf, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cf = cf.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cf = cf.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cf.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CounterFamily
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CounterFamily {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CounterFamily {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CounterFamilyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CounterFamilyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CounterFamilyOrderFieldName orders CounterFamily by name.
	CounterFamilyOrderFieldName = &CounterFamilyOrderField{
		field: counterfamily.FieldName,
		toCursor: func(cf *CounterFamily) Cursor {
			return Cursor{
				ID:    cf.ID,
				Value: cf.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CounterFamilyOrderField) String() string {
	var str string
	switch f.field {
	case counterfamily.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CounterFamilyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CounterFamilyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CounterFamilyOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *CounterFamilyOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid CounterFamilyOrderField", str)
	}
	return nil
}

// CounterFamilyOrderField defines the ordering field of CounterFamily.
type CounterFamilyOrderField struct {
	field    string
	toCursor func(*CounterFamily) Cursor
}

// CounterFamilyOrder defines the ordering of CounterFamily.
type CounterFamilyOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *CounterFamilyOrderField `json:"field"`
}

// DefaultCounterFamilyOrder is the default ordering of CounterFamily.
var DefaultCounterFamilyOrder = &CounterFamilyOrder{
	Direction: OrderDirectionAsc,
	Field: &CounterFamilyOrderField{
		field: counterfamily.FieldID,
		toCursor: func(cf *CounterFamily) Cursor {
			return Cursor{ID: cf.ID}
		},
	},
}

// CounterFormulaEdge is the edge representation of CounterFormula.
type CounterFormulaEdge struct {
	Node   *CounterFormula `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CounterFormulaConnection is the connection containing edges to CounterFormula.
type CounterFormulaConnection struct {
	Edges      []*CounterFormulaEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// CounterFormulaPaginateOption enables pagination customization.
type CounterFormulaPaginateOption func(*counterFormulaPager) error

// WithCounterFormulaOrder configures pagination ordering.
func WithCounterFormulaOrder(order *CounterFormulaOrder) CounterFormulaPaginateOption {
	if order == nil {
		order = DefaultCounterFormulaOrder
	}
	o := *order
	return func(pager *counterFormulaPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCounterFormulaOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCounterFormulaFilter configures pagination filter.
func WithCounterFormulaFilter(filter func(*CounterFormulaQuery) (*CounterFormulaQuery, error)) CounterFormulaPaginateOption {
	return func(pager *counterFormulaPager) error {
		if filter == nil {
			return errors.New("CounterFormulaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type counterFormulaPager struct {
	order  *CounterFormulaOrder
	filter func(*CounterFormulaQuery) (*CounterFormulaQuery, error)
}

func newCounterFormulaPager(opts []CounterFormulaPaginateOption) (*counterFormulaPager, error) {
	pager := &counterFormulaPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCounterFormulaOrder
	}
	return pager, nil
}

func (p *counterFormulaPager) applyFilter(query *CounterFormulaQuery) (*CounterFormulaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *counterFormulaPager) toCursor(cf *CounterFormula) Cursor {
	return p.order.Field.toCursor(cf)
}

func (p *counterFormulaPager) applyCursors(query *CounterFormulaQuery, after, before *Cursor) *CounterFormulaQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCounterFormulaOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *counterFormulaPager) applyOrder(query *CounterFormulaQuery, reverse bool) *CounterFormulaQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCounterFormulaOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCounterFormulaOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CounterFormula.
func (cf *CounterFormulaQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CounterFormulaPaginateOption,
) (*CounterFormulaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCounterFormulaPager(opts)
	if err != nil {
		return nil, err
	}

	if cf, err = pager.applyFilter(cf); err != nil {
		return nil, err
	}

	conn := &CounterFormulaConnection{Edges: []*CounterFormulaEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cf.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := cf.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cf = pager.applyCursors(cf, after, before)
	cf = pager.applyOrder(cf, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cf = cf.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cf = cf.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cf.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CounterFormula
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CounterFormula {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CounterFormula {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CounterFormulaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CounterFormulaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CounterFormulaOrderField defines the ordering field of CounterFormula.
type CounterFormulaOrderField struct {
	field    string
	toCursor func(*CounterFormula) Cursor
}

// CounterFormulaOrder defines the ordering of CounterFormula.
type CounterFormulaOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CounterFormulaOrderField `json:"field"`
}

// DefaultCounterFormulaOrder is the default ordering of CounterFormula.
var DefaultCounterFormulaOrder = &CounterFormulaOrder{
	Direction: OrderDirectionAsc,
	Field: &CounterFormulaOrderField{
		field: counterformula.FieldID,
		toCursor: func(cf *CounterFormula) Cursor {
			return Cursor{ID: cf.ID}
		},
	},
}

// CustomerEdge is the edge representation of Customer.
type CustomerEdge struct {
	Node   *Customer `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CustomerConnection is the connection containing edges to Customer.
type CustomerConnection struct {
	Edges      []*CustomerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// CustomerPaginateOption enables pagination customization.
type CustomerPaginateOption func(*customerPager) error

// WithCustomerOrder configures pagination ordering.
func WithCustomerOrder(order *CustomerOrder) CustomerPaginateOption {
	if order == nil {
		order = DefaultCustomerOrder
	}
	o := *order
	return func(pager *customerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCustomerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCustomerFilter configures pagination filter.
func WithCustomerFilter(filter func(*CustomerQuery) (*CustomerQuery, error)) CustomerPaginateOption {
	return func(pager *customerPager) error {
		if filter == nil {
			return errors.New("CustomerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type customerPager struct {
	order  *CustomerOrder
	filter func(*CustomerQuery) (*CustomerQuery, error)
}

func newCustomerPager(opts []CustomerPaginateOption) (*customerPager, error) {
	pager := &customerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCustomerOrder
	}
	return pager, nil
}

func (p *customerPager) applyFilter(query *CustomerQuery) (*CustomerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *customerPager) toCursor(c *Customer) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *customerPager) applyCursors(query *CustomerQuery, after, before *Cursor) *CustomerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCustomerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *customerPager) applyOrder(query *CustomerQuery, reverse bool) *CustomerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCustomerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCustomerOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Customer.
func (c *CustomerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CustomerPaginateOption,
) (*CustomerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCustomerPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CustomerConnection{Edges: []*CustomerEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Customer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Customer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Customer {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CustomerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CustomerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CustomerOrderField defines the ordering field of Customer.
type CustomerOrderField struct {
	field    string
	toCursor func(*Customer) Cursor
}

// CustomerOrder defines the ordering of Customer.
type CustomerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CustomerOrderField `json:"field"`
}

// DefaultCustomerOrder is the default ordering of Customer.
var DefaultCustomerOrder = &CustomerOrder{
	Direction: OrderDirectionAsc,
	Field: &CustomerOrderField{
		field: customer.FieldID,
		toCursor: func(c *Customer) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// DocumentCategoryEdge is the edge representation of DocumentCategory.
type DocumentCategoryEdge struct {
	Node   *DocumentCategory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DocumentCategoryConnection is the connection containing edges to DocumentCategory.
type DocumentCategoryConnection struct {
	Edges      []*DocumentCategoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// DocumentCategoryPaginateOption enables pagination customization.
type DocumentCategoryPaginateOption func(*documentCategoryPager) error

// WithDocumentCategoryOrder configures pagination ordering.
func WithDocumentCategoryOrder(order *DocumentCategoryOrder) DocumentCategoryPaginateOption {
	if order == nil {
		order = DefaultDocumentCategoryOrder
	}
	o := *order
	return func(pager *documentCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentCategoryFilter configures pagination filter.
func WithDocumentCategoryFilter(filter func(*DocumentCategoryQuery) (*DocumentCategoryQuery, error)) DocumentCategoryPaginateOption {
	return func(pager *documentCategoryPager) error {
		if filter == nil {
			return errors.New("DocumentCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentCategoryPager struct {
	order  *DocumentCategoryOrder
	filter func(*DocumentCategoryQuery) (*DocumentCategoryQuery, error)
}

func newDocumentCategoryPager(opts []DocumentCategoryPaginateOption) (*documentCategoryPager, error) {
	pager := &documentCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentCategoryOrder
	}
	return pager, nil
}

func (p *documentCategoryPager) applyFilter(query *DocumentCategoryQuery) (*DocumentCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentCategoryPager) toCursor(dc *DocumentCategory) Cursor {
	return p.order.Field.toCursor(dc)
}

func (p *documentCategoryPager) applyCursors(query *DocumentCategoryQuery, after, before *Cursor) *DocumentCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDocumentCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *documentCategoryPager) applyOrder(query *DocumentCategoryQuery, reverse bool) *DocumentCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDocumentCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDocumentCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to DocumentCategory.
func (dc *DocumentCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentCategoryPaginateOption,
) (*DocumentCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if dc, err = pager.applyFilter(dc); err != nil {
		return nil, err
	}

	conn := &DocumentCategoryConnection{Edges: []*DocumentCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := dc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := dc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	dc = pager.applyCursors(dc, after, before)
	dc = pager.applyOrder(dc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		dc = dc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		dc = dc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := dc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *DocumentCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DocumentCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DocumentCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DocumentCategoryOrderField defines the ordering field of DocumentCategory.
type DocumentCategoryOrderField struct {
	field    string
	toCursor func(*DocumentCategory) Cursor
}

// DocumentCategoryOrder defines the ordering of DocumentCategory.
type DocumentCategoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DocumentCategoryOrderField `json:"field"`
}

// DefaultDocumentCategoryOrder is the default ordering of DocumentCategory.
var DefaultDocumentCategoryOrder = &DocumentCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &DocumentCategoryOrderField{
		field: documentcategory.FieldID,
		toCursor: func(dc *DocumentCategory) Cursor {
			return Cursor{ID: dc.ID}
		},
	},
}

// DomainEdge is the edge representation of Domain.
type DomainEdge struct {
	Node   *Domain `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// DomainConnection is the connection containing edges to Domain.
type DomainConnection struct {
	Edges      []*DomainEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// DomainPaginateOption enables pagination customization.
type DomainPaginateOption func(*domainPager) error

// WithDomainOrder configures pagination ordering.
func WithDomainOrder(order *DomainOrder) DomainPaginateOption {
	if order == nil {
		order = DefaultDomainOrder
	}
	o := *order
	return func(pager *domainPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDomainOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDomainFilter configures pagination filter.
func WithDomainFilter(filter func(*DomainQuery) (*DomainQuery, error)) DomainPaginateOption {
	return func(pager *domainPager) error {
		if filter == nil {
			return errors.New("DomainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type domainPager struct {
	order  *DomainOrder
	filter func(*DomainQuery) (*DomainQuery, error)
}

func newDomainPager(opts []DomainPaginateOption) (*domainPager, error) {
	pager := &domainPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDomainOrder
	}
	return pager, nil
}

func (p *domainPager) applyFilter(query *DomainQuery) (*DomainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *domainPager) toCursor(d *Domain) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *domainPager) applyCursors(query *DomainQuery, after, before *Cursor) *DomainQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDomainOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *domainPager) applyOrder(query *DomainQuery, reverse bool) *DomainQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDomainOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDomainOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Domain.
func (d *DomainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DomainPaginateOption,
) (*DomainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDomainPager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}

	conn := &DomainConnection{Edges: []*DomainEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := d.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := d.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	d = pager.applyCursors(d, after, before)
	d = pager.applyOrder(d, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		d = d.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		d = d.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := d.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Domain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Domain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Domain {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DomainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DomainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// DomainOrderFieldName orders Domain by name.
	DomainOrderFieldName = &DomainOrderField{
		field: domain.FieldName,
		toCursor: func(d *Domain) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DomainOrderField) String() string {
	var str string
	switch f.field {
	case domain.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DomainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DomainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DomainOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *DomainOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid DomainOrderField", str)
	}
	return nil
}

// DomainOrderField defines the ordering field of Domain.
type DomainOrderField struct {
	field    string
	toCursor func(*Domain) Cursor
}

// DomainOrder defines the ordering of Domain.
type DomainOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *DomainOrderField `json:"field"`
}

// DefaultDomainOrder is the default ordering of Domain.
var DefaultDomainOrder = &DomainOrder{
	Direction: OrderDirectionAsc,
	Field: &DomainOrderField{
		field: domain.FieldID,
		toCursor: func(d *Domain) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// EntryPointEdge is the edge representation of EntryPoint.
type EntryPointEdge struct {
	Node   *EntryPoint `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// EntryPointConnection is the connection containing edges to EntryPoint.
type EntryPointConnection struct {
	Edges      []*EntryPointEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// EntryPointPaginateOption enables pagination customization.
type EntryPointPaginateOption func(*entryPointPager) error

// WithEntryPointOrder configures pagination ordering.
func WithEntryPointOrder(order *EntryPointOrder) EntryPointPaginateOption {
	if order == nil {
		order = DefaultEntryPointOrder
	}
	o := *order
	return func(pager *entryPointPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntryPointOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntryPointFilter configures pagination filter.
func WithEntryPointFilter(filter func(*EntryPointQuery) (*EntryPointQuery, error)) EntryPointPaginateOption {
	return func(pager *entryPointPager) error {
		if filter == nil {
			return errors.New("EntryPointQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entryPointPager struct {
	order  *EntryPointOrder
	filter func(*EntryPointQuery) (*EntryPointQuery, error)
}

func newEntryPointPager(opts []EntryPointPaginateOption) (*entryPointPager, error) {
	pager := &entryPointPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntryPointOrder
	}
	return pager, nil
}

func (p *entryPointPager) applyFilter(query *EntryPointQuery) (*EntryPointQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entryPointPager) toCursor(ep *EntryPoint) Cursor {
	return p.order.Field.toCursor(ep)
}

func (p *entryPointPager) applyCursors(query *EntryPointQuery, after, before *Cursor) *EntryPointQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEntryPointOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *entryPointPager) applyOrder(query *EntryPointQuery, reverse bool) *EntryPointQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEntryPointOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEntryPointOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EntryPoint.
func (ep *EntryPointQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntryPointPaginateOption,
) (*EntryPointConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntryPointPager(opts)
	if err != nil {
		return nil, err
	}

	if ep, err = pager.applyFilter(ep); err != nil {
		return nil, err
	}

	conn := &EntryPointConnection{Edges: []*EntryPointEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ep.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ep.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ep = pager.applyCursors(ep, after, before)
	ep = pager.applyOrder(ep, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ep = ep.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ep = ep.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ep.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EntryPoint
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntryPoint {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntryPoint {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EntryPointEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EntryPointEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EntryPointOrderField defines the ordering field of EntryPoint.
type EntryPointOrderField struct {
	field    string
	toCursor func(*EntryPoint) Cursor
}

// EntryPointOrder defines the ordering of EntryPoint.
type EntryPointOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *EntryPointOrderField `json:"field"`
}

// DefaultEntryPointOrder is the default ordering of EntryPoint.
var DefaultEntryPointOrder = &EntryPointOrder{
	Direction: OrderDirectionAsc,
	Field: &EntryPointOrderField{
		field: entrypoint.FieldID,
		toCursor: func(ep *EntryPoint) Cursor {
			return Cursor{ID: ep.ID}
		},
	},
}

// EquipmentEdge is the edge representation of Equipment.
type EquipmentEdge struct {
	Node   *Equipment `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// EquipmentConnection is the connection containing edges to Equipment.
type EquipmentConnection struct {
	Edges      []*EquipmentEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// EquipmentPaginateOption enables pagination customization.
type EquipmentPaginateOption func(*equipmentPager) error

// WithEquipmentOrder configures pagination ordering.
func WithEquipmentOrder(order *EquipmentOrder) EquipmentPaginateOption {
	if order == nil {
		order = DefaultEquipmentOrder
	}
	o := *order
	return func(pager *equipmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentFilter configures pagination filter.
func WithEquipmentFilter(filter func(*EquipmentQuery) (*EquipmentQuery, error)) EquipmentPaginateOption {
	return func(pager *equipmentPager) error {
		if filter == nil {
			return errors.New("EquipmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPager struct {
	order  *EquipmentOrder
	filter func(*EquipmentQuery) (*EquipmentQuery, error)
}

func newEquipmentPager(opts []EquipmentPaginateOption) (*equipmentPager, error) {
	pager := &equipmentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentOrder
	}
	return pager, nil
}

func (p *equipmentPager) applyFilter(query *EquipmentQuery) (*EquipmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPager) toCursor(e *Equipment) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *equipmentPager) applyCursors(query *EquipmentQuery, after, before *Cursor) *EquipmentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentPager) applyOrder(query *EquipmentQuery, reverse bool) *EquipmentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Equipment.
func (e *EquipmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPaginateOption,
) (*EquipmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}

	conn := &EquipmentConnection{Edges: []*EquipmentEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := e.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := e.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		e = e.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := e.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Equipment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Equipment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Equipment {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// EquipmentOrderFieldName orders Equipment by name.
	EquipmentOrderFieldName = &EquipmentOrderField{
		field: equipment.FieldName,
		toCursor: func(e *Equipment) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Name,
			}
		},
	}
	// EquipmentOrderFieldFutureState orders Equipment by future_state.
	EquipmentOrderFieldFutureState = &EquipmentOrderField{
		field: equipment.FieldFutureState,
		toCursor: func(e *Equipment) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.FutureState,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EquipmentOrderField) String() string {
	var str string
	switch f.field {
	case equipment.FieldName:
		str = "NAME"
	case equipment.FieldFutureState:
		str = "FUTURE_STATE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EquipmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EquipmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EquipmentOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *EquipmentOrderFieldName
	case "FUTURE_STATE":
		*f = *EquipmentOrderFieldFutureState
	default:
		return fmt.Errorf("%s is not a valid EquipmentOrderField", str)
	}
	return nil
}

// EquipmentOrderField defines the ordering field of Equipment.
type EquipmentOrderField struct {
	field    string
	toCursor func(*Equipment) Cursor
}

// EquipmentOrder defines the ordering of Equipment.
type EquipmentOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *EquipmentOrderField `json:"field"`
}

// DefaultEquipmentOrder is the default ordering of Equipment.
var DefaultEquipmentOrder = &EquipmentOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentOrderField{
		field: equipment.FieldID,
		toCursor: func(e *Equipment) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// EquipmentCategoryEdge is the edge representation of EquipmentCategory.
type EquipmentCategoryEdge struct {
	Node   *EquipmentCategory `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// EquipmentCategoryConnection is the connection containing edges to EquipmentCategory.
type EquipmentCategoryConnection struct {
	Edges      []*EquipmentCategoryEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// EquipmentCategoryPaginateOption enables pagination customization.
type EquipmentCategoryPaginateOption func(*equipmentCategoryPager) error

// WithEquipmentCategoryOrder configures pagination ordering.
func WithEquipmentCategoryOrder(order *EquipmentCategoryOrder) EquipmentCategoryPaginateOption {
	if order == nil {
		order = DefaultEquipmentCategoryOrder
	}
	o := *order
	return func(pager *equipmentCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentCategoryFilter configures pagination filter.
func WithEquipmentCategoryFilter(filter func(*EquipmentCategoryQuery) (*EquipmentCategoryQuery, error)) EquipmentCategoryPaginateOption {
	return func(pager *equipmentCategoryPager) error {
		if filter == nil {
			return errors.New("EquipmentCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentCategoryPager struct {
	order  *EquipmentCategoryOrder
	filter func(*EquipmentCategoryQuery) (*EquipmentCategoryQuery, error)
}

func newEquipmentCategoryPager(opts []EquipmentCategoryPaginateOption) (*equipmentCategoryPager, error) {
	pager := &equipmentCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentCategoryOrder
	}
	return pager, nil
}

func (p *equipmentCategoryPager) applyFilter(query *EquipmentCategoryQuery) (*EquipmentCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentCategoryPager) toCursor(ec *EquipmentCategory) Cursor {
	return p.order.Field.toCursor(ec)
}

func (p *equipmentCategoryPager) applyCursors(query *EquipmentCategoryQuery, after, before *Cursor) *EquipmentCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentCategoryPager) applyOrder(query *EquipmentCategoryQuery, reverse bool) *EquipmentCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EquipmentCategory.
func (ec *EquipmentCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentCategoryPaginateOption,
) (*EquipmentCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if ec, err = pager.applyFilter(ec); err != nil {
		return nil, err
	}

	conn := &EquipmentCategoryConnection{Edges: []*EquipmentCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ec.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ec.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ec = pager.applyCursors(ec, after, before)
	ec = pager.applyOrder(ec, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ec = ec.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ec = ec.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ec.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EquipmentCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EquipmentCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EquipmentCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EquipmentCategoryOrderField defines the ordering field of EquipmentCategory.
type EquipmentCategoryOrderField struct {
	field    string
	toCursor func(*EquipmentCategory) Cursor
}

// EquipmentCategoryOrder defines the ordering of EquipmentCategory.
type EquipmentCategoryOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *EquipmentCategoryOrderField `json:"field"`
}

// DefaultEquipmentCategoryOrder is the default ordering of EquipmentCategory.
var DefaultEquipmentCategoryOrder = &EquipmentCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentCategoryOrderField{
		field: equipmentcategory.FieldID,
		toCursor: func(ec *EquipmentCategory) Cursor {
			return Cursor{ID: ec.ID}
		},
	},
}

// EquipmentPortEdge is the edge representation of EquipmentPort.
type EquipmentPortEdge struct {
	Node   *EquipmentPort `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EquipmentPortConnection is the connection containing edges to EquipmentPort.
type EquipmentPortConnection struct {
	Edges      []*EquipmentPortEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// EquipmentPortPaginateOption enables pagination customization.
type EquipmentPortPaginateOption func(*equipmentPortPager) error

// WithEquipmentPortOrder configures pagination ordering.
func WithEquipmentPortOrder(order *EquipmentPortOrder) EquipmentPortPaginateOption {
	if order == nil {
		order = DefaultEquipmentPortOrder
	}
	o := *order
	return func(pager *equipmentPortPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentPortOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentPortFilter configures pagination filter.
func WithEquipmentPortFilter(filter func(*EquipmentPortQuery) (*EquipmentPortQuery, error)) EquipmentPortPaginateOption {
	return func(pager *equipmentPortPager) error {
		if filter == nil {
			return errors.New("EquipmentPortQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPortPager struct {
	order  *EquipmentPortOrder
	filter func(*EquipmentPortQuery) (*EquipmentPortQuery, error)
}

func newEquipmentPortPager(opts []EquipmentPortPaginateOption) (*equipmentPortPager, error) {
	pager := &equipmentPortPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentPortOrder
	}
	return pager, nil
}

func (p *equipmentPortPager) applyFilter(query *EquipmentPortQuery) (*EquipmentPortQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPortPager) toCursor(ep *EquipmentPort) Cursor {
	return p.order.Field.toCursor(ep)
}

func (p *equipmentPortPager) applyCursors(query *EquipmentPortQuery, after, before *Cursor) *EquipmentPortQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentPortOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentPortPager) applyOrder(query *EquipmentPortQuery, reverse bool) *EquipmentPortQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentPortOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentPortOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EquipmentPort.
func (ep *EquipmentPortQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPortPaginateOption,
) (*EquipmentPortConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPortPager(opts)
	if err != nil {
		return nil, err
	}

	if ep, err = pager.applyFilter(ep); err != nil {
		return nil, err
	}

	conn := &EquipmentPortConnection{Edges: []*EquipmentPortEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ep.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ep.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ep = pager.applyCursors(ep, after, before)
	ep = pager.applyOrder(ep, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ep = ep.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ep = ep.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ep.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EquipmentPort
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EquipmentPort {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EquipmentPort {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentPortEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentPortEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EquipmentPortOrderField defines the ordering field of EquipmentPort.
type EquipmentPortOrderField struct {
	field    string
	toCursor func(*EquipmentPort) Cursor
}

// EquipmentPortOrder defines the ordering of EquipmentPort.
type EquipmentPortOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EquipmentPortOrderField `json:"field"`
}

// DefaultEquipmentPortOrder is the default ordering of EquipmentPort.
var DefaultEquipmentPortOrder = &EquipmentPortOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentPortOrderField{
		field: equipmentport.FieldID,
		toCursor: func(ep *EquipmentPort) Cursor {
			return Cursor{ID: ep.ID}
		},
	},
}

// EquipmentPortDefinitionEdge is the edge representation of EquipmentPortDefinition.
type EquipmentPortDefinitionEdge struct {
	Node   *EquipmentPortDefinition `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// EquipmentPortDefinitionConnection is the connection containing edges to EquipmentPortDefinition.
type EquipmentPortDefinitionConnection struct {
	Edges      []*EquipmentPortDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

// EquipmentPortDefinitionPaginateOption enables pagination customization.
type EquipmentPortDefinitionPaginateOption func(*equipmentPortDefinitionPager) error

// WithEquipmentPortDefinitionOrder configures pagination ordering.
func WithEquipmentPortDefinitionOrder(order *EquipmentPortDefinitionOrder) EquipmentPortDefinitionPaginateOption {
	if order == nil {
		order = DefaultEquipmentPortDefinitionOrder
	}
	o := *order
	return func(pager *equipmentPortDefinitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentPortDefinitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentPortDefinitionFilter configures pagination filter.
func WithEquipmentPortDefinitionFilter(filter func(*EquipmentPortDefinitionQuery) (*EquipmentPortDefinitionQuery, error)) EquipmentPortDefinitionPaginateOption {
	return func(pager *equipmentPortDefinitionPager) error {
		if filter == nil {
			return errors.New("EquipmentPortDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPortDefinitionPager struct {
	order  *EquipmentPortDefinitionOrder
	filter func(*EquipmentPortDefinitionQuery) (*EquipmentPortDefinitionQuery, error)
}

func newEquipmentPortDefinitionPager(opts []EquipmentPortDefinitionPaginateOption) (*equipmentPortDefinitionPager, error) {
	pager := &equipmentPortDefinitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentPortDefinitionOrder
	}
	return pager, nil
}

func (p *equipmentPortDefinitionPager) applyFilter(query *EquipmentPortDefinitionQuery) (*EquipmentPortDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPortDefinitionPager) toCursor(epd *EquipmentPortDefinition) Cursor {
	return p.order.Field.toCursor(epd)
}

func (p *equipmentPortDefinitionPager) applyCursors(query *EquipmentPortDefinitionQuery, after, before *Cursor) *EquipmentPortDefinitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentPortDefinitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentPortDefinitionPager) applyOrder(query *EquipmentPortDefinitionQuery, reverse bool) *EquipmentPortDefinitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentPortDefinitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentPortDefinitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EquipmentPortDefinition.
func (epd *EquipmentPortDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPortDefinitionPaginateOption,
) (*EquipmentPortDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPortDefinitionPager(opts)
	if err != nil {
		return nil, err
	}

	if epd, err = pager.applyFilter(epd); err != nil {
		return nil, err
	}

	conn := &EquipmentPortDefinitionConnection{Edges: []*EquipmentPortDefinitionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := epd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := epd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	epd = pager.applyCursors(epd, after, before)
	epd = pager.applyOrder(epd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		epd = epd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		epd = epd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := epd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EquipmentPortDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EquipmentPortDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EquipmentPortDefinition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentPortDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentPortDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EquipmentPortDefinitionOrderField defines the ordering field of EquipmentPortDefinition.
type EquipmentPortDefinitionOrderField struct {
	field    string
	toCursor func(*EquipmentPortDefinition) Cursor
}

// EquipmentPortDefinitionOrder defines the ordering of EquipmentPortDefinition.
type EquipmentPortDefinitionOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *EquipmentPortDefinitionOrderField `json:"field"`
}

// DefaultEquipmentPortDefinitionOrder is the default ordering of EquipmentPortDefinition.
var DefaultEquipmentPortDefinitionOrder = &EquipmentPortDefinitionOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentPortDefinitionOrderField{
		field: equipmentportdefinition.FieldID,
		toCursor: func(epd *EquipmentPortDefinition) Cursor {
			return Cursor{ID: epd.ID}
		},
	},
}

// EquipmentPortTypeEdge is the edge representation of EquipmentPortType.
type EquipmentPortTypeEdge struct {
	Node   *EquipmentPortType `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// EquipmentPortTypeConnection is the connection containing edges to EquipmentPortType.
type EquipmentPortTypeConnection struct {
	Edges      []*EquipmentPortTypeEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// EquipmentPortTypePaginateOption enables pagination customization.
type EquipmentPortTypePaginateOption func(*equipmentPortTypePager) error

// WithEquipmentPortTypeOrder configures pagination ordering.
func WithEquipmentPortTypeOrder(order *EquipmentPortTypeOrder) EquipmentPortTypePaginateOption {
	if order == nil {
		order = DefaultEquipmentPortTypeOrder
	}
	o := *order
	return func(pager *equipmentPortTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentPortTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentPortTypeFilter configures pagination filter.
func WithEquipmentPortTypeFilter(filter func(*EquipmentPortTypeQuery) (*EquipmentPortTypeQuery, error)) EquipmentPortTypePaginateOption {
	return func(pager *equipmentPortTypePager) error {
		if filter == nil {
			return errors.New("EquipmentPortTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPortTypePager struct {
	order  *EquipmentPortTypeOrder
	filter func(*EquipmentPortTypeQuery) (*EquipmentPortTypeQuery, error)
}

func newEquipmentPortTypePager(opts []EquipmentPortTypePaginateOption) (*equipmentPortTypePager, error) {
	pager := &equipmentPortTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentPortTypeOrder
	}
	return pager, nil
}

func (p *equipmentPortTypePager) applyFilter(query *EquipmentPortTypeQuery) (*EquipmentPortTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPortTypePager) toCursor(ept *EquipmentPortType) Cursor {
	return p.order.Field.toCursor(ept)
}

func (p *equipmentPortTypePager) applyCursors(query *EquipmentPortTypeQuery, after, before *Cursor) *EquipmentPortTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentPortTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentPortTypePager) applyOrder(query *EquipmentPortTypeQuery, reverse bool) *EquipmentPortTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentPortTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentPortTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EquipmentPortType.
func (ept *EquipmentPortTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPortTypePaginateOption,
) (*EquipmentPortTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPortTypePager(opts)
	if err != nil {
		return nil, err
	}

	if ept, err = pager.applyFilter(ept); err != nil {
		return nil, err
	}

	conn := &EquipmentPortTypeConnection{Edges: []*EquipmentPortTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ept.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ept.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ept = pager.applyCursors(ept, after, before)
	ept = pager.applyOrder(ept, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ept = ept.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ept = ept.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ept.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EquipmentPortType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EquipmentPortType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EquipmentPortType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentPortTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentPortTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EquipmentPortTypeOrderField defines the ordering field of EquipmentPortType.
type EquipmentPortTypeOrderField struct {
	field    string
	toCursor func(*EquipmentPortType) Cursor
}

// EquipmentPortTypeOrder defines the ordering of EquipmentPortType.
type EquipmentPortTypeOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *EquipmentPortTypeOrderField `json:"field"`
}

// DefaultEquipmentPortTypeOrder is the default ordering of EquipmentPortType.
var DefaultEquipmentPortTypeOrder = &EquipmentPortTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentPortTypeOrderField{
		field: equipmentporttype.FieldID,
		toCursor: func(ept *EquipmentPortType) Cursor {
			return Cursor{ID: ept.ID}
		},
	},
}

// EquipmentPositionEdge is the edge representation of EquipmentPosition.
type EquipmentPositionEdge struct {
	Node   *EquipmentPosition `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// EquipmentPositionConnection is the connection containing edges to EquipmentPosition.
type EquipmentPositionConnection struct {
	Edges      []*EquipmentPositionEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// EquipmentPositionPaginateOption enables pagination customization.
type EquipmentPositionPaginateOption func(*equipmentPositionPager) error

// WithEquipmentPositionOrder configures pagination ordering.
func WithEquipmentPositionOrder(order *EquipmentPositionOrder) EquipmentPositionPaginateOption {
	if order == nil {
		order = DefaultEquipmentPositionOrder
	}
	o := *order
	return func(pager *equipmentPositionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentPositionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentPositionFilter configures pagination filter.
func WithEquipmentPositionFilter(filter func(*EquipmentPositionQuery) (*EquipmentPositionQuery, error)) EquipmentPositionPaginateOption {
	return func(pager *equipmentPositionPager) error {
		if filter == nil {
			return errors.New("EquipmentPositionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPositionPager struct {
	order  *EquipmentPositionOrder
	filter func(*EquipmentPositionQuery) (*EquipmentPositionQuery, error)
}

func newEquipmentPositionPager(opts []EquipmentPositionPaginateOption) (*equipmentPositionPager, error) {
	pager := &equipmentPositionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentPositionOrder
	}
	return pager, nil
}

func (p *equipmentPositionPager) applyFilter(query *EquipmentPositionQuery) (*EquipmentPositionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPositionPager) toCursor(ep *EquipmentPosition) Cursor {
	return p.order.Field.toCursor(ep)
}

func (p *equipmentPositionPager) applyCursors(query *EquipmentPositionQuery, after, before *Cursor) *EquipmentPositionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentPositionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentPositionPager) applyOrder(query *EquipmentPositionQuery, reverse bool) *EquipmentPositionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentPositionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentPositionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EquipmentPosition.
func (ep *EquipmentPositionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPositionPaginateOption,
) (*EquipmentPositionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPositionPager(opts)
	if err != nil {
		return nil, err
	}

	if ep, err = pager.applyFilter(ep); err != nil {
		return nil, err
	}

	conn := &EquipmentPositionConnection{Edges: []*EquipmentPositionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ep.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ep.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ep = pager.applyCursors(ep, after, before)
	ep = pager.applyOrder(ep, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ep = ep.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ep = ep.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ep.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EquipmentPosition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EquipmentPosition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EquipmentPosition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentPositionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentPositionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EquipmentPositionOrderField defines the ordering field of EquipmentPosition.
type EquipmentPositionOrderField struct {
	field    string
	toCursor func(*EquipmentPosition) Cursor
}

// EquipmentPositionOrder defines the ordering of EquipmentPosition.
type EquipmentPositionOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *EquipmentPositionOrderField `json:"field"`
}

// DefaultEquipmentPositionOrder is the default ordering of EquipmentPosition.
var DefaultEquipmentPositionOrder = &EquipmentPositionOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentPositionOrderField{
		field: equipmentposition.FieldID,
		toCursor: func(ep *EquipmentPosition) Cursor {
			return Cursor{ID: ep.ID}
		},
	},
}

// EquipmentPositionDefinitionEdge is the edge representation of EquipmentPositionDefinition.
type EquipmentPositionDefinitionEdge struct {
	Node   *EquipmentPositionDefinition `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// EquipmentPositionDefinitionConnection is the connection containing edges to EquipmentPositionDefinition.
type EquipmentPositionDefinitionConnection struct {
	Edges      []*EquipmentPositionDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

// EquipmentPositionDefinitionPaginateOption enables pagination customization.
type EquipmentPositionDefinitionPaginateOption func(*equipmentPositionDefinitionPager) error

// WithEquipmentPositionDefinitionOrder configures pagination ordering.
func WithEquipmentPositionDefinitionOrder(order *EquipmentPositionDefinitionOrder) EquipmentPositionDefinitionPaginateOption {
	if order == nil {
		order = DefaultEquipmentPositionDefinitionOrder
	}
	o := *order
	return func(pager *equipmentPositionDefinitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentPositionDefinitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentPositionDefinitionFilter configures pagination filter.
func WithEquipmentPositionDefinitionFilter(filter func(*EquipmentPositionDefinitionQuery) (*EquipmentPositionDefinitionQuery, error)) EquipmentPositionDefinitionPaginateOption {
	return func(pager *equipmentPositionDefinitionPager) error {
		if filter == nil {
			return errors.New("EquipmentPositionDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPositionDefinitionPager struct {
	order  *EquipmentPositionDefinitionOrder
	filter func(*EquipmentPositionDefinitionQuery) (*EquipmentPositionDefinitionQuery, error)
}

func newEquipmentPositionDefinitionPager(opts []EquipmentPositionDefinitionPaginateOption) (*equipmentPositionDefinitionPager, error) {
	pager := &equipmentPositionDefinitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentPositionDefinitionOrder
	}
	return pager, nil
}

func (p *equipmentPositionDefinitionPager) applyFilter(query *EquipmentPositionDefinitionQuery) (*EquipmentPositionDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPositionDefinitionPager) toCursor(epd *EquipmentPositionDefinition) Cursor {
	return p.order.Field.toCursor(epd)
}

func (p *equipmentPositionDefinitionPager) applyCursors(query *EquipmentPositionDefinitionQuery, after, before *Cursor) *EquipmentPositionDefinitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentPositionDefinitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentPositionDefinitionPager) applyOrder(query *EquipmentPositionDefinitionQuery, reverse bool) *EquipmentPositionDefinitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentPositionDefinitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentPositionDefinitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EquipmentPositionDefinition.
func (epd *EquipmentPositionDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPositionDefinitionPaginateOption,
) (*EquipmentPositionDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPositionDefinitionPager(opts)
	if err != nil {
		return nil, err
	}

	if epd, err = pager.applyFilter(epd); err != nil {
		return nil, err
	}

	conn := &EquipmentPositionDefinitionConnection{Edges: []*EquipmentPositionDefinitionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := epd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := epd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	epd = pager.applyCursors(epd, after, before)
	epd = pager.applyOrder(epd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		epd = epd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		epd = epd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := epd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EquipmentPositionDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EquipmentPositionDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EquipmentPositionDefinition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentPositionDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentPositionDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EquipmentPositionDefinitionOrderField defines the ordering field of EquipmentPositionDefinition.
type EquipmentPositionDefinitionOrderField struct {
	field    string
	toCursor func(*EquipmentPositionDefinition) Cursor
}

// EquipmentPositionDefinitionOrder defines the ordering of EquipmentPositionDefinition.
type EquipmentPositionDefinitionOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *EquipmentPositionDefinitionOrderField `json:"field"`
}

// DefaultEquipmentPositionDefinitionOrder is the default ordering of EquipmentPositionDefinition.
var DefaultEquipmentPositionDefinitionOrder = &EquipmentPositionDefinitionOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentPositionDefinitionOrderField{
		field: equipmentpositiondefinition.FieldID,
		toCursor: func(epd *EquipmentPositionDefinition) Cursor {
			return Cursor{ID: epd.ID}
		},
	},
}

// EquipmentTypeEdge is the edge representation of EquipmentType.
type EquipmentTypeEdge struct {
	Node   *EquipmentType `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EquipmentTypeConnection is the connection containing edges to EquipmentType.
type EquipmentTypeConnection struct {
	Edges      []*EquipmentTypeEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// EquipmentTypePaginateOption enables pagination customization.
type EquipmentTypePaginateOption func(*equipmentTypePager) error

// WithEquipmentTypeOrder configures pagination ordering.
func WithEquipmentTypeOrder(order *EquipmentTypeOrder) EquipmentTypePaginateOption {
	if order == nil {
		order = DefaultEquipmentTypeOrder
	}
	o := *order
	return func(pager *equipmentTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentTypeFilter configures pagination filter.
func WithEquipmentTypeFilter(filter func(*EquipmentTypeQuery) (*EquipmentTypeQuery, error)) EquipmentTypePaginateOption {
	return func(pager *equipmentTypePager) error {
		if filter == nil {
			return errors.New("EquipmentTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentTypePager struct {
	order  *EquipmentTypeOrder
	filter func(*EquipmentTypeQuery) (*EquipmentTypeQuery, error)
}

func newEquipmentTypePager(opts []EquipmentTypePaginateOption) (*equipmentTypePager, error) {
	pager := &equipmentTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentTypeOrder
	}
	return pager, nil
}

func (p *equipmentTypePager) applyFilter(query *EquipmentTypeQuery) (*EquipmentTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentTypePager) toCursor(et *EquipmentType) Cursor {
	return p.order.Field.toCursor(et)
}

func (p *equipmentTypePager) applyCursors(query *EquipmentTypeQuery, after, before *Cursor) *EquipmentTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentTypePager) applyOrder(query *EquipmentTypeQuery, reverse bool) *EquipmentTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EquipmentType.
func (et *EquipmentTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentTypePaginateOption,
) (*EquipmentTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentTypePager(opts)
	if err != nil {
		return nil, err
	}

	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}

	conn := &EquipmentTypeConnection{Edges: []*EquipmentTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := et.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := et.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	et = pager.applyCursors(et, after, before)
	et = pager.applyOrder(et, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		et = et.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		et = et.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := et.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EquipmentType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EquipmentType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EquipmentType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EquipmentTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EquipmentTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EquipmentTypeOrderField defines the ordering field of EquipmentType.
type EquipmentTypeOrderField struct {
	field    string
	toCursor func(*EquipmentType) Cursor
}

// EquipmentTypeOrder defines the ordering of EquipmentType.
type EquipmentTypeOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EquipmentTypeOrderField `json:"field"`
}

// DefaultEquipmentTypeOrder is the default ordering of EquipmentType.
var DefaultEquipmentTypeOrder = &EquipmentTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentTypeOrderField{
		field: equipmenttype.FieldID,
		toCursor: func(et *EquipmentType) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// EventSeverityEdge is the edge representation of EventSeverity.
type EventSeverityEdge struct {
	Node   *EventSeverity `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EventSeverityConnection is the connection containing edges to EventSeverity.
type EventSeverityConnection struct {
	Edges      []*EventSeverityEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// EventSeverityPaginateOption enables pagination customization.
type EventSeverityPaginateOption func(*eventSeverityPager) error

// WithEventSeverityOrder configures pagination ordering.
func WithEventSeverityOrder(order *EventSeverityOrder) EventSeverityPaginateOption {
	if order == nil {
		order = DefaultEventSeverityOrder
	}
	o := *order
	return func(pager *eventSeverityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventSeverityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventSeverityFilter configures pagination filter.
func WithEventSeverityFilter(filter func(*EventSeverityQuery) (*EventSeverityQuery, error)) EventSeverityPaginateOption {
	return func(pager *eventSeverityPager) error {
		if filter == nil {
			return errors.New("EventSeverityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventSeverityPager struct {
	order  *EventSeverityOrder
	filter func(*EventSeverityQuery) (*EventSeverityQuery, error)
}

func newEventSeverityPager(opts []EventSeverityPaginateOption) (*eventSeverityPager, error) {
	pager := &eventSeverityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventSeverityOrder
	}
	return pager, nil
}

func (p *eventSeverityPager) applyFilter(query *EventSeverityQuery) (*EventSeverityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventSeverityPager) toCursor(es *EventSeverity) Cursor {
	return p.order.Field.toCursor(es)
}

func (p *eventSeverityPager) applyCursors(query *EventSeverityQuery, after, before *Cursor) *EventSeverityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEventSeverityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *eventSeverityPager) applyOrder(query *EventSeverityQuery, reverse bool) *EventSeverityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEventSeverityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEventSeverityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EventSeverity.
func (es *EventSeverityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventSeverityPaginateOption,
) (*EventSeverityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventSeverityPager(opts)
	if err != nil {
		return nil, err
	}

	if es, err = pager.applyFilter(es); err != nil {
		return nil, err
	}

	conn := &EventSeverityConnection{Edges: []*EventSeverityEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := es.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := es.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	es = pager.applyCursors(es, after, before)
	es = pager.applyOrder(es, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		es = es.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		es = es.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := es.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EventSeverity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EventSeverity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EventSeverity {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EventSeverityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EventSeverityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// EventSeverityOrderFieldName orders EventSeverity by name.
	EventSeverityOrderFieldName = &EventSeverityOrderField{
		field: eventseverity.FieldName,
		toCursor: func(es *EventSeverity) Cursor {
			return Cursor{
				ID:    es.ID,
				Value: es.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EventSeverityOrderField) String() string {
	var str string
	switch f.field {
	case eventseverity.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EventSeverityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EventSeverityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EventSeverityOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *EventSeverityOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid EventSeverityOrderField", str)
	}
	return nil
}

// EventSeverityOrderField defines the ordering field of EventSeverity.
type EventSeverityOrderField struct {
	field    string
	toCursor func(*EventSeverity) Cursor
}

// EventSeverityOrder defines the ordering of EventSeverity.
type EventSeverityOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EventSeverityOrderField `json:"field"`
}

// DefaultEventSeverityOrder is the default ordering of EventSeverity.
var DefaultEventSeverityOrder = &EventSeverityOrder{
	Direction: OrderDirectionAsc,
	Field: &EventSeverityOrderField{
		field: eventseverity.FieldID,
		toCursor: func(es *EventSeverity) Cursor {
			return Cursor{ID: es.ID}
		},
	},
}

// ExitPointEdge is the edge representation of ExitPoint.
type ExitPointEdge struct {
	Node   *ExitPoint `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ExitPointConnection is the connection containing edges to ExitPoint.
type ExitPointConnection struct {
	Edges      []*ExitPointEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// ExitPointPaginateOption enables pagination customization.
type ExitPointPaginateOption func(*exitPointPager) error

// WithExitPointOrder configures pagination ordering.
func WithExitPointOrder(order *ExitPointOrder) ExitPointPaginateOption {
	if order == nil {
		order = DefaultExitPointOrder
	}
	o := *order
	return func(pager *exitPointPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExitPointOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExitPointFilter configures pagination filter.
func WithExitPointFilter(filter func(*ExitPointQuery) (*ExitPointQuery, error)) ExitPointPaginateOption {
	return func(pager *exitPointPager) error {
		if filter == nil {
			return errors.New("ExitPointQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exitPointPager struct {
	order  *ExitPointOrder
	filter func(*ExitPointQuery) (*ExitPointQuery, error)
}

func newExitPointPager(opts []ExitPointPaginateOption) (*exitPointPager, error) {
	pager := &exitPointPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExitPointOrder
	}
	return pager, nil
}

func (p *exitPointPager) applyFilter(query *ExitPointQuery) (*ExitPointQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exitPointPager) toCursor(ep *ExitPoint) Cursor {
	return p.order.Field.toCursor(ep)
}

func (p *exitPointPager) applyCursors(query *ExitPointQuery, after, before *Cursor) *ExitPointQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultExitPointOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *exitPointPager) applyOrder(query *ExitPointQuery, reverse bool) *ExitPointQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultExitPointOrder.Field {
		query = query.Order(direction.orderFunc(DefaultExitPointOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ExitPoint.
func (ep *ExitPointQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExitPointPaginateOption,
) (*ExitPointConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExitPointPager(opts)
	if err != nil {
		return nil, err
	}

	if ep, err = pager.applyFilter(ep); err != nil {
		return nil, err
	}

	conn := &ExitPointConnection{Edges: []*ExitPointEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ep.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ep.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ep = pager.applyCursors(ep, after, before)
	ep = pager.applyOrder(ep, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ep = ep.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ep = ep.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ep.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ExitPoint
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ExitPoint {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ExitPoint {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ExitPointEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ExitPointEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ExitPointOrderField defines the ordering field of ExitPoint.
type ExitPointOrderField struct {
	field    string
	toCursor func(*ExitPoint) Cursor
}

// ExitPointOrder defines the ordering of ExitPoint.
type ExitPointOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ExitPointOrderField `json:"field"`
}

// DefaultExitPointOrder is the default ordering of ExitPoint.
var DefaultExitPointOrder = &ExitPointOrder{
	Direction: OrderDirectionAsc,
	Field: &ExitPointOrderField{
		field: exitpoint.FieldID,
		toCursor: func(ep *ExitPoint) Cursor {
			return Cursor{ID: ep.ID}
		},
	},
}

// ExportTaskEdge is the edge representation of ExportTask.
type ExportTaskEdge struct {
	Node   *ExportTask `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ExportTaskConnection is the connection containing edges to ExportTask.
type ExportTaskConnection struct {
	Edges      []*ExportTaskEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// ExportTaskPaginateOption enables pagination customization.
type ExportTaskPaginateOption func(*exportTaskPager) error

// WithExportTaskOrder configures pagination ordering.
func WithExportTaskOrder(order *ExportTaskOrder) ExportTaskPaginateOption {
	if order == nil {
		order = DefaultExportTaskOrder
	}
	o := *order
	return func(pager *exportTaskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExportTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExportTaskFilter configures pagination filter.
func WithExportTaskFilter(filter func(*ExportTaskQuery) (*ExportTaskQuery, error)) ExportTaskPaginateOption {
	return func(pager *exportTaskPager) error {
		if filter == nil {
			return errors.New("ExportTaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exportTaskPager struct {
	order  *ExportTaskOrder
	filter func(*ExportTaskQuery) (*ExportTaskQuery, error)
}

func newExportTaskPager(opts []ExportTaskPaginateOption) (*exportTaskPager, error) {
	pager := &exportTaskPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExportTaskOrder
	}
	return pager, nil
}

func (p *exportTaskPager) applyFilter(query *ExportTaskQuery) (*ExportTaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exportTaskPager) toCursor(et *ExportTask) Cursor {
	return p.order.Field.toCursor(et)
}

func (p *exportTaskPager) applyCursors(query *ExportTaskQuery, after, before *Cursor) *ExportTaskQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultExportTaskOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *exportTaskPager) applyOrder(query *ExportTaskQuery, reverse bool) *ExportTaskQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultExportTaskOrder.Field {
		query = query.Order(direction.orderFunc(DefaultExportTaskOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ExportTask.
func (et *ExportTaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExportTaskPaginateOption,
) (*ExportTaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExportTaskPager(opts)
	if err != nil {
		return nil, err
	}

	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}

	conn := &ExportTaskConnection{Edges: []*ExportTaskEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := et.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := et.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	et = pager.applyCursors(et, after, before)
	et = pager.applyOrder(et, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		et = et.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		et = et.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := et.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ExportTask
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ExportTask {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ExportTask {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ExportTaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ExportTaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ExportTaskOrderField defines the ordering field of ExportTask.
type ExportTaskOrderField struct {
	field    string
	toCursor func(*ExportTask) Cursor
}

// ExportTaskOrder defines the ordering of ExportTask.
type ExportTaskOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ExportTaskOrderField `json:"field"`
}

// DefaultExportTaskOrder is the default ordering of ExportTask.
var DefaultExportTaskOrder = &ExportTaskOrder{
	Direction: OrderDirectionAsc,
	Field: &ExportTaskOrderField{
		field: exporttask.FieldID,
		toCursor: func(et *ExportTask) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// FeatureEdge is the edge representation of Feature.
type FeatureEdge struct {
	Node   *Feature `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FeatureConnection is the connection containing edges to Feature.
type FeatureConnection struct {
	Edges      []*FeatureEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// FeaturePaginateOption enables pagination customization.
type FeaturePaginateOption func(*featurePager) error

// WithFeatureOrder configures pagination ordering.
func WithFeatureOrder(order *FeatureOrder) FeaturePaginateOption {
	if order == nil {
		order = DefaultFeatureOrder
	}
	o := *order
	return func(pager *featurePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFeatureOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFeatureFilter configures pagination filter.
func WithFeatureFilter(filter func(*FeatureQuery) (*FeatureQuery, error)) FeaturePaginateOption {
	return func(pager *featurePager) error {
		if filter == nil {
			return errors.New("FeatureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type featurePager struct {
	order  *FeatureOrder
	filter func(*FeatureQuery) (*FeatureQuery, error)
}

func newFeaturePager(opts []FeaturePaginateOption) (*featurePager, error) {
	pager := &featurePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFeatureOrder
	}
	return pager, nil
}

func (p *featurePager) applyFilter(query *FeatureQuery) (*FeatureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *featurePager) toCursor(f *Feature) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *featurePager) applyCursors(query *FeatureQuery, after, before *Cursor) *FeatureQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFeatureOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *featurePager) applyOrder(query *FeatureQuery, reverse bool) *FeatureQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFeatureOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFeatureOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Feature.
func (f *FeatureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FeaturePaginateOption,
) (*FeatureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFeaturePager(opts)
	if err != nil {
		return nil, err
	}

	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}

	conn := &FeatureConnection{Edges: []*FeatureEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := f.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := f.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		f = f.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		f = f.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := f.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Feature
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Feature {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Feature {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FeatureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FeatureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FeatureOrderField defines the ordering field of Feature.
type FeatureOrderField struct {
	field    string
	toCursor func(*Feature) Cursor
}

// FeatureOrder defines the ordering of Feature.
type FeatureOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FeatureOrderField `json:"field"`
}

// DefaultFeatureOrder is the default ordering of Feature.
var DefaultFeatureOrder = &FeatureOrder{
	Direction: OrderDirectionAsc,
	Field: &FeatureOrderField{
		field: feature.FieldID,
		toCursor: func(f *Feature) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	order  *FileOrder
	filter func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption) (*filePager, error) {
	pager := &filePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) *FileQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *filePager) applyOrder(query *FileQuery, reverse bool) *FileQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts)
	if err != nil {
		return nil, err
	}

	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}

	conn := &FileConnection{Edges: []*FileEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := f.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := f.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		f = f.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		f = f.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := f.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	field    string
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: OrderDirectionAsc,
	Field: &FileOrderField{
		field: file.FieldID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// FloorPlanEdge is the edge representation of FloorPlan.
type FloorPlanEdge struct {
	Node   *FloorPlan `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// FloorPlanConnection is the connection containing edges to FloorPlan.
type FloorPlanConnection struct {
	Edges      []*FloorPlanEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// FloorPlanPaginateOption enables pagination customization.
type FloorPlanPaginateOption func(*floorPlanPager) error

// WithFloorPlanOrder configures pagination ordering.
func WithFloorPlanOrder(order *FloorPlanOrder) FloorPlanPaginateOption {
	if order == nil {
		order = DefaultFloorPlanOrder
	}
	o := *order
	return func(pager *floorPlanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFloorPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFloorPlanFilter configures pagination filter.
func WithFloorPlanFilter(filter func(*FloorPlanQuery) (*FloorPlanQuery, error)) FloorPlanPaginateOption {
	return func(pager *floorPlanPager) error {
		if filter == nil {
			return errors.New("FloorPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type floorPlanPager struct {
	order  *FloorPlanOrder
	filter func(*FloorPlanQuery) (*FloorPlanQuery, error)
}

func newFloorPlanPager(opts []FloorPlanPaginateOption) (*floorPlanPager, error) {
	pager := &floorPlanPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFloorPlanOrder
	}
	return pager, nil
}

func (p *floorPlanPager) applyFilter(query *FloorPlanQuery) (*FloorPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *floorPlanPager) toCursor(fp *FloorPlan) Cursor {
	return p.order.Field.toCursor(fp)
}

func (p *floorPlanPager) applyCursors(query *FloorPlanQuery, after, before *Cursor) *FloorPlanQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFloorPlanOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *floorPlanPager) applyOrder(query *FloorPlanQuery, reverse bool) *FloorPlanQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFloorPlanOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFloorPlanOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FloorPlan.
func (fp *FloorPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FloorPlanPaginateOption,
) (*FloorPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFloorPlanPager(opts)
	if err != nil {
		return nil, err
	}

	if fp, err = pager.applyFilter(fp); err != nil {
		return nil, err
	}

	conn := &FloorPlanConnection{Edges: []*FloorPlanEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fp.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fp.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fp = pager.applyCursors(fp, after, before)
	fp = pager.applyOrder(fp, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fp = fp.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fp = fp.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fp.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FloorPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FloorPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FloorPlan {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FloorPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FloorPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FloorPlanOrderField defines the ordering field of FloorPlan.
type FloorPlanOrderField struct {
	field    string
	toCursor func(*FloorPlan) Cursor
}

// FloorPlanOrder defines the ordering of FloorPlan.
type FloorPlanOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *FloorPlanOrderField `json:"field"`
}

// DefaultFloorPlanOrder is the default ordering of FloorPlan.
var DefaultFloorPlanOrder = &FloorPlanOrder{
	Direction: OrderDirectionAsc,
	Field: &FloorPlanOrderField{
		field: floorplan.FieldID,
		toCursor: func(fp *FloorPlan) Cursor {
			return Cursor{ID: fp.ID}
		},
	},
}

// FloorPlanReferencePointEdge is the edge representation of FloorPlanReferencePoint.
type FloorPlanReferencePointEdge struct {
	Node   *FloorPlanReferencePoint `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// FloorPlanReferencePointConnection is the connection containing edges to FloorPlanReferencePoint.
type FloorPlanReferencePointConnection struct {
	Edges      []*FloorPlanReferencePointEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

// FloorPlanReferencePointPaginateOption enables pagination customization.
type FloorPlanReferencePointPaginateOption func(*floorPlanReferencePointPager) error

// WithFloorPlanReferencePointOrder configures pagination ordering.
func WithFloorPlanReferencePointOrder(order *FloorPlanReferencePointOrder) FloorPlanReferencePointPaginateOption {
	if order == nil {
		order = DefaultFloorPlanReferencePointOrder
	}
	o := *order
	return func(pager *floorPlanReferencePointPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFloorPlanReferencePointOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFloorPlanReferencePointFilter configures pagination filter.
func WithFloorPlanReferencePointFilter(filter func(*FloorPlanReferencePointQuery) (*FloorPlanReferencePointQuery, error)) FloorPlanReferencePointPaginateOption {
	return func(pager *floorPlanReferencePointPager) error {
		if filter == nil {
			return errors.New("FloorPlanReferencePointQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type floorPlanReferencePointPager struct {
	order  *FloorPlanReferencePointOrder
	filter func(*FloorPlanReferencePointQuery) (*FloorPlanReferencePointQuery, error)
}

func newFloorPlanReferencePointPager(opts []FloorPlanReferencePointPaginateOption) (*floorPlanReferencePointPager, error) {
	pager := &floorPlanReferencePointPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFloorPlanReferencePointOrder
	}
	return pager, nil
}

func (p *floorPlanReferencePointPager) applyFilter(query *FloorPlanReferencePointQuery) (*FloorPlanReferencePointQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *floorPlanReferencePointPager) toCursor(fprp *FloorPlanReferencePoint) Cursor {
	return p.order.Field.toCursor(fprp)
}

func (p *floorPlanReferencePointPager) applyCursors(query *FloorPlanReferencePointQuery, after, before *Cursor) *FloorPlanReferencePointQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFloorPlanReferencePointOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *floorPlanReferencePointPager) applyOrder(query *FloorPlanReferencePointQuery, reverse bool) *FloorPlanReferencePointQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFloorPlanReferencePointOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFloorPlanReferencePointOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FloorPlanReferencePoint.
func (fprp *FloorPlanReferencePointQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FloorPlanReferencePointPaginateOption,
) (*FloorPlanReferencePointConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFloorPlanReferencePointPager(opts)
	if err != nil {
		return nil, err
	}

	if fprp, err = pager.applyFilter(fprp); err != nil {
		return nil, err
	}

	conn := &FloorPlanReferencePointConnection{Edges: []*FloorPlanReferencePointEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fprp.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fprp.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fprp = pager.applyCursors(fprp, after, before)
	fprp = pager.applyOrder(fprp, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fprp = fprp.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fprp = fprp.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fprp.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FloorPlanReferencePoint
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FloorPlanReferencePoint {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FloorPlanReferencePoint {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FloorPlanReferencePointEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FloorPlanReferencePointEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FloorPlanReferencePointOrderField defines the ordering field of FloorPlanReferencePoint.
type FloorPlanReferencePointOrderField struct {
	field    string
	toCursor func(*FloorPlanReferencePoint) Cursor
}

// FloorPlanReferencePointOrder defines the ordering of FloorPlanReferencePoint.
type FloorPlanReferencePointOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *FloorPlanReferencePointOrderField `json:"field"`
}

// DefaultFloorPlanReferencePointOrder is the default ordering of FloorPlanReferencePoint.
var DefaultFloorPlanReferencePointOrder = &FloorPlanReferencePointOrder{
	Direction: OrderDirectionAsc,
	Field: &FloorPlanReferencePointOrderField{
		field: floorplanreferencepoint.FieldID,
		toCursor: func(fprp *FloorPlanReferencePoint) Cursor {
			return Cursor{ID: fprp.ID}
		},
	},
}

// FloorPlanScaleEdge is the edge representation of FloorPlanScale.
type FloorPlanScaleEdge struct {
	Node   *FloorPlanScale `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// FloorPlanScaleConnection is the connection containing edges to FloorPlanScale.
type FloorPlanScaleConnection struct {
	Edges      []*FloorPlanScaleEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// FloorPlanScalePaginateOption enables pagination customization.
type FloorPlanScalePaginateOption func(*floorPlanScalePager) error

// WithFloorPlanScaleOrder configures pagination ordering.
func WithFloorPlanScaleOrder(order *FloorPlanScaleOrder) FloorPlanScalePaginateOption {
	if order == nil {
		order = DefaultFloorPlanScaleOrder
	}
	o := *order
	return func(pager *floorPlanScalePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFloorPlanScaleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFloorPlanScaleFilter configures pagination filter.
func WithFloorPlanScaleFilter(filter func(*FloorPlanScaleQuery) (*FloorPlanScaleQuery, error)) FloorPlanScalePaginateOption {
	return func(pager *floorPlanScalePager) error {
		if filter == nil {
			return errors.New("FloorPlanScaleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type floorPlanScalePager struct {
	order  *FloorPlanScaleOrder
	filter func(*FloorPlanScaleQuery) (*FloorPlanScaleQuery, error)
}

func newFloorPlanScalePager(opts []FloorPlanScalePaginateOption) (*floorPlanScalePager, error) {
	pager := &floorPlanScalePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFloorPlanScaleOrder
	}
	return pager, nil
}

func (p *floorPlanScalePager) applyFilter(query *FloorPlanScaleQuery) (*FloorPlanScaleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *floorPlanScalePager) toCursor(fps *FloorPlanScale) Cursor {
	return p.order.Field.toCursor(fps)
}

func (p *floorPlanScalePager) applyCursors(query *FloorPlanScaleQuery, after, before *Cursor) *FloorPlanScaleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFloorPlanScaleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *floorPlanScalePager) applyOrder(query *FloorPlanScaleQuery, reverse bool) *FloorPlanScaleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFloorPlanScaleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFloorPlanScaleOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FloorPlanScale.
func (fps *FloorPlanScaleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FloorPlanScalePaginateOption,
) (*FloorPlanScaleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFloorPlanScalePager(opts)
	if err != nil {
		return nil, err
	}

	if fps, err = pager.applyFilter(fps); err != nil {
		return nil, err
	}

	conn := &FloorPlanScaleConnection{Edges: []*FloorPlanScaleEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fps.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fps.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fps = pager.applyCursors(fps, after, before)
	fps = pager.applyOrder(fps, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fps = fps.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fps = fps.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fps.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FloorPlanScale
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FloorPlanScale {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FloorPlanScale {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FloorPlanScaleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FloorPlanScaleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FloorPlanScaleOrderField defines the ordering field of FloorPlanScale.
type FloorPlanScaleOrderField struct {
	field    string
	toCursor func(*FloorPlanScale) Cursor
}

// FloorPlanScaleOrder defines the ordering of FloorPlanScale.
type FloorPlanScaleOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *FloorPlanScaleOrderField `json:"field"`
}

// DefaultFloorPlanScaleOrder is the default ordering of FloorPlanScale.
var DefaultFloorPlanScaleOrder = &FloorPlanScaleOrder{
	Direction: OrderDirectionAsc,
	Field: &FloorPlanScaleOrderField{
		field: floorplanscale.FieldID,
		toCursor: func(fps *FloorPlanScale) Cursor {
			return Cursor{ID: fps.ID}
		},
	},
}

// FlowEdge is the edge representation of Flow.
type FlowEdge struct {
	Node   *Flow  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FlowConnection is the connection containing edges to Flow.
type FlowConnection struct {
	Edges      []*FlowEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// FlowPaginateOption enables pagination customization.
type FlowPaginateOption func(*flowPager) error

// WithFlowOrder configures pagination ordering.
func WithFlowOrder(order *FlowOrder) FlowPaginateOption {
	if order == nil {
		order = DefaultFlowOrder
	}
	o := *order
	return func(pager *flowPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFlowOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFlowFilter configures pagination filter.
func WithFlowFilter(filter func(*FlowQuery) (*FlowQuery, error)) FlowPaginateOption {
	return func(pager *flowPager) error {
		if filter == nil {
			return errors.New("FlowQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type flowPager struct {
	order  *FlowOrder
	filter func(*FlowQuery) (*FlowQuery, error)
}

func newFlowPager(opts []FlowPaginateOption) (*flowPager, error) {
	pager := &flowPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFlowOrder
	}
	return pager, nil
}

func (p *flowPager) applyFilter(query *FlowQuery) (*FlowQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *flowPager) toCursor(f *Flow) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *flowPager) applyCursors(query *FlowQuery, after, before *Cursor) *FlowQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFlowOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *flowPager) applyOrder(query *FlowQuery, reverse bool) *FlowQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFlowOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFlowOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Flow.
func (f *FlowQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FlowPaginateOption,
) (*FlowConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFlowPager(opts)
	if err != nil {
		return nil, err
	}

	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}

	conn := &FlowConnection{Edges: []*FlowEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := f.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := f.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		f = f.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		f = f.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := f.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Flow
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Flow {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Flow {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FlowEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FlowEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FlowOrderField defines the ordering field of Flow.
type FlowOrderField struct {
	field    string
	toCursor func(*Flow) Cursor
}

// FlowOrder defines the ordering of Flow.
type FlowOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FlowOrderField `json:"field"`
}

// DefaultFlowOrder is the default ordering of Flow.
var DefaultFlowOrder = &FlowOrder{
	Direction: OrderDirectionAsc,
	Field: &FlowOrderField{
		field: flow.FieldID,
		toCursor: func(f *Flow) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// FlowDraftEdge is the edge representation of FlowDraft.
type FlowDraftEdge struct {
	Node   *FlowDraft `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// FlowDraftConnection is the connection containing edges to FlowDraft.
type FlowDraftConnection struct {
	Edges      []*FlowDraftEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// FlowDraftPaginateOption enables pagination customization.
type FlowDraftPaginateOption func(*flowDraftPager) error

// WithFlowDraftOrder configures pagination ordering.
func WithFlowDraftOrder(order *FlowDraftOrder) FlowDraftPaginateOption {
	if order == nil {
		order = DefaultFlowDraftOrder
	}
	o := *order
	return func(pager *flowDraftPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFlowDraftOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFlowDraftFilter configures pagination filter.
func WithFlowDraftFilter(filter func(*FlowDraftQuery) (*FlowDraftQuery, error)) FlowDraftPaginateOption {
	return func(pager *flowDraftPager) error {
		if filter == nil {
			return errors.New("FlowDraftQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type flowDraftPager struct {
	order  *FlowDraftOrder
	filter func(*FlowDraftQuery) (*FlowDraftQuery, error)
}

func newFlowDraftPager(opts []FlowDraftPaginateOption) (*flowDraftPager, error) {
	pager := &flowDraftPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFlowDraftOrder
	}
	return pager, nil
}

func (p *flowDraftPager) applyFilter(query *FlowDraftQuery) (*FlowDraftQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *flowDraftPager) toCursor(fd *FlowDraft) Cursor {
	return p.order.Field.toCursor(fd)
}

func (p *flowDraftPager) applyCursors(query *FlowDraftQuery, after, before *Cursor) *FlowDraftQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFlowDraftOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *flowDraftPager) applyOrder(query *FlowDraftQuery, reverse bool) *FlowDraftQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFlowDraftOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFlowDraftOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FlowDraft.
func (fd *FlowDraftQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FlowDraftPaginateOption,
) (*FlowDraftConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFlowDraftPager(opts)
	if err != nil {
		return nil, err
	}

	if fd, err = pager.applyFilter(fd); err != nil {
		return nil, err
	}

	conn := &FlowDraftConnection{Edges: []*FlowDraftEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fd = pager.applyCursors(fd, after, before)
	fd = pager.applyOrder(fd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fd = fd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fd = fd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FlowDraft
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FlowDraft {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FlowDraft {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FlowDraftEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FlowDraftEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FlowDraftOrderField defines the ordering field of FlowDraft.
type FlowDraftOrderField struct {
	field    string
	toCursor func(*FlowDraft) Cursor
}

// FlowDraftOrder defines the ordering of FlowDraft.
type FlowDraftOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *FlowDraftOrderField `json:"field"`
}

// DefaultFlowDraftOrder is the default ordering of FlowDraft.
var DefaultFlowDraftOrder = &FlowDraftOrder{
	Direction: OrderDirectionAsc,
	Field: &FlowDraftOrderField{
		field: flowdraft.FieldID,
		toCursor: func(fd *FlowDraft) Cursor {
			return Cursor{ID: fd.ID}
		},
	},
}

// FlowExecutionTemplateEdge is the edge representation of FlowExecutionTemplate.
type FlowExecutionTemplateEdge struct {
	Node   *FlowExecutionTemplate `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// FlowExecutionTemplateConnection is the connection containing edges to FlowExecutionTemplate.
type FlowExecutionTemplateConnection struct {
	Edges      []*FlowExecutionTemplateEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

// FlowExecutionTemplatePaginateOption enables pagination customization.
type FlowExecutionTemplatePaginateOption func(*flowExecutionTemplatePager) error

// WithFlowExecutionTemplateOrder configures pagination ordering.
func WithFlowExecutionTemplateOrder(order *FlowExecutionTemplateOrder) FlowExecutionTemplatePaginateOption {
	if order == nil {
		order = DefaultFlowExecutionTemplateOrder
	}
	o := *order
	return func(pager *flowExecutionTemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFlowExecutionTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFlowExecutionTemplateFilter configures pagination filter.
func WithFlowExecutionTemplateFilter(filter func(*FlowExecutionTemplateQuery) (*FlowExecutionTemplateQuery, error)) FlowExecutionTemplatePaginateOption {
	return func(pager *flowExecutionTemplatePager) error {
		if filter == nil {
			return errors.New("FlowExecutionTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type flowExecutionTemplatePager struct {
	order  *FlowExecutionTemplateOrder
	filter func(*FlowExecutionTemplateQuery) (*FlowExecutionTemplateQuery, error)
}

func newFlowExecutionTemplatePager(opts []FlowExecutionTemplatePaginateOption) (*flowExecutionTemplatePager, error) {
	pager := &flowExecutionTemplatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFlowExecutionTemplateOrder
	}
	return pager, nil
}

func (p *flowExecutionTemplatePager) applyFilter(query *FlowExecutionTemplateQuery) (*FlowExecutionTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *flowExecutionTemplatePager) toCursor(fet *FlowExecutionTemplate) Cursor {
	return p.order.Field.toCursor(fet)
}

func (p *flowExecutionTemplatePager) applyCursors(query *FlowExecutionTemplateQuery, after, before *Cursor) *FlowExecutionTemplateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFlowExecutionTemplateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *flowExecutionTemplatePager) applyOrder(query *FlowExecutionTemplateQuery, reverse bool) *FlowExecutionTemplateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFlowExecutionTemplateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFlowExecutionTemplateOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FlowExecutionTemplate.
func (fet *FlowExecutionTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FlowExecutionTemplatePaginateOption,
) (*FlowExecutionTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFlowExecutionTemplatePager(opts)
	if err != nil {
		return nil, err
	}

	if fet, err = pager.applyFilter(fet); err != nil {
		return nil, err
	}

	conn := &FlowExecutionTemplateConnection{Edges: []*FlowExecutionTemplateEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fet.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fet.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fet = pager.applyCursors(fet, after, before)
	fet = pager.applyOrder(fet, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fet = fet.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fet = fet.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fet.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FlowExecutionTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FlowExecutionTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FlowExecutionTemplate {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FlowExecutionTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FlowExecutionTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// FlowExecutionTemplateOrderField defines the ordering field of FlowExecutionTemplate.
type FlowExecutionTemplateOrderField struct {
	field    string
	toCursor func(*FlowExecutionTemplate) Cursor
}

// FlowExecutionTemplateOrder defines the ordering of FlowExecutionTemplate.
type FlowExecutionTemplateOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *FlowExecutionTemplateOrderField `json:"field"`
}

// DefaultFlowExecutionTemplateOrder is the default ordering of FlowExecutionTemplate.
var DefaultFlowExecutionTemplateOrder = &FlowExecutionTemplateOrder{
	Direction: OrderDirectionAsc,
	Field: &FlowExecutionTemplateOrderField{
		field: flowexecutiontemplate.FieldID,
		toCursor: func(fet *FlowExecutionTemplate) Cursor {
			return Cursor{ID: fet.ID}
		},
	},
}

// FlowInstanceEdge is the edge representation of FlowInstance.
type FlowInstanceEdge struct {
	Node   *FlowInstance `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// FlowInstanceConnection is the connection containing edges to FlowInstance.
type FlowInstanceConnection struct {
	Edges      []*FlowInstanceEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// FlowInstancePaginateOption enables pagination customization.
type FlowInstancePaginateOption func(*flowInstancePager) error

// WithFlowInstanceOrder configures pagination ordering.
func WithFlowInstanceOrder(order *FlowInstanceOrder) FlowInstancePaginateOption {
	if order == nil {
		order = DefaultFlowInstanceOrder
	}
	o := *order
	return func(pager *flowInstancePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFlowInstanceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFlowInstanceFilter configures pagination filter.
func WithFlowInstanceFilter(filter func(*FlowInstanceQuery) (*FlowInstanceQuery, error)) FlowInstancePaginateOption {
	return func(pager *flowInstancePager) error {
		if filter == nil {
			return errors.New("FlowInstanceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type flowInstancePager struct {
	order  *FlowInstanceOrder
	filter func(*FlowInstanceQuery) (*FlowInstanceQuery, error)
}

func newFlowInstancePager(opts []FlowInstancePaginateOption) (*flowInstancePager, error) {
	pager := &flowInstancePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFlowInstanceOrder
	}
	return pager, nil
}

func (p *flowInstancePager) applyFilter(query *FlowInstanceQuery) (*FlowInstanceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *flowInstancePager) toCursor(fi *FlowInstance) Cursor {
	return p.order.Field.toCursor(fi)
}

func (p *flowInstancePager) applyCursors(query *FlowInstanceQuery, after, before *Cursor) *FlowInstanceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFlowInstanceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *flowInstancePager) applyOrder(query *FlowInstanceQuery, reverse bool) *FlowInstanceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFlowInstanceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFlowInstanceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to FlowInstance.
func (fi *FlowInstanceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FlowInstancePaginateOption,
) (*FlowInstanceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFlowInstancePager(opts)
	if err != nil {
		return nil, err
	}

	if fi, err = pager.applyFilter(fi); err != nil {
		return nil, err
	}

	conn := &FlowInstanceConnection{Edges: []*FlowInstanceEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := fi.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := fi.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	fi = pager.applyCursors(fi, after, before)
	fi = pager.applyOrder(fi, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		fi = fi.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		fi = fi.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := fi.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *FlowInstance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FlowInstance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FlowInstance {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FlowInstanceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FlowInstanceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// FlowInstanceOrderFieldUpdateTime orders FlowInstance by update_time.
	FlowInstanceOrderFieldUpdateTime = &FlowInstanceOrderField{
		field: flowinstance.FieldUpdateTime,
		toCursor: func(fi *FlowInstance) Cursor {
			return Cursor{
				ID:    fi.ID,
				Value: fi.UpdateTime,
			}
		},
	}
	// FlowInstanceOrderFieldStartDate orders FlowInstance by start_date.
	FlowInstanceOrderFieldStartDate = &FlowInstanceOrderField{
		field: flowinstance.FieldStartDate,
		toCursor: func(fi *FlowInstance) Cursor {
			return Cursor{
				ID:    fi.ID,
				Value: fi.StartDate,
			}
		},
	}
	// FlowInstanceOrderFieldEndDate orders FlowInstance by end_date.
	FlowInstanceOrderFieldEndDate = &FlowInstanceOrderField{
		field: flowinstance.FieldEndDate,
		toCursor: func(fi *FlowInstance) Cursor {
			return Cursor{
				ID:    fi.ID,
				Value: fi.EndDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FlowInstanceOrderField) String() string {
	var str string
	switch f.field {
	case flowinstance.FieldUpdateTime:
		str = "UPDATED_AT"
	case flowinstance.FieldStartDate:
		str = "START_AT"
	case flowinstance.FieldEndDate:
		str = "END_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FlowInstanceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FlowInstanceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FlowInstanceOrderField %T must be a string", v)
	}
	switch str {
	case "UPDATED_AT":
		*f = *FlowInstanceOrderFieldUpdateTime
	case "START_AT":
		*f = *FlowInstanceOrderFieldStartDate
	case "END_AT":
		*f = *FlowInstanceOrderFieldEndDate
	default:
		return fmt.Errorf("%s is not a valid FlowInstanceOrderField", str)
	}
	return nil
}

// FlowInstanceOrderField defines the ordering field of FlowInstance.
type FlowInstanceOrderField struct {
	field    string
	toCursor func(*FlowInstance) Cursor
}

// FlowInstanceOrder defines the ordering of FlowInstance.
type FlowInstanceOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *FlowInstanceOrderField `json:"field"`
}

// DefaultFlowInstanceOrder is the default ordering of FlowInstance.
var DefaultFlowInstanceOrder = &FlowInstanceOrder{
	Direction: OrderDirectionAsc,
	Field: &FlowInstanceOrderField{
		field: flowinstance.FieldID,
		toCursor: func(fi *FlowInstance) Cursor {
			return Cursor{ID: fi.ID}
		},
	},
}

// FormulaEdge is the edge representation of Formula.
type FormulaEdge struct {
	Node   *Formula `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FormulaConnection is the connection containing edges to Formula.
type FormulaConnection struct {
	Edges      []*FormulaEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// FormulaPaginateOption enables pagination customization.
type FormulaPaginateOption func(*formulaPager) error

// WithFormulaOrder configures pagination ordering.
func WithFormulaOrder(order *FormulaOrder) FormulaPaginateOption {
	if order == nil {
		order = DefaultFormulaOrder
	}
	o := *order
	return func(pager *formulaPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFormulaOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFormulaFilter configures pagination filter.
func WithFormulaFilter(filter func(*FormulaQuery) (*FormulaQuery, error)) FormulaPaginateOption {
	return func(pager *formulaPager) error {
		if filter == nil {
			return errors.New("FormulaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type formulaPager struct {
	order  *FormulaOrder
	filter func(*FormulaQuery) (*FormulaQuery, error)
}

func newFormulaPager(opts []FormulaPaginateOption) (*formulaPager, error) {
	pager := &formulaPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFormulaOrder
	}
	return pager, nil
}

func (p *formulaPager) applyFilter(query *FormulaQuery) (*FormulaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *formulaPager) toCursor(f *Formula) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *formulaPager) applyCursors(query *FormulaQuery, after, before *Cursor) *FormulaQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFormulaOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *formulaPager) applyOrder(query *FormulaQuery, reverse bool) *FormulaQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFormulaOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFormulaOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Formula.
func (f *FormulaQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FormulaPaginateOption,
) (*FormulaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFormulaPager(opts)
	if err != nil {
		return nil, err
	}

	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}

	conn := &FormulaConnection{Edges: []*FormulaEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := f.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := f.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		f = f.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		f = f.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := f.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Formula
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Formula {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Formula {
			return nodes[i]
		}
	}

	conn.Edges = make([]*FormulaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &FormulaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// FormulaOrderFieldTextFormula orders Formula by textFormula.
	FormulaOrderFieldTextFormula = &FormulaOrderField{
		field: formula.FieldTextFormula,
		toCursor: func(f *Formula) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.TextFormula,
			}
		},
	}
	// FormulaOrderFieldStatus orders Formula by status.
	FormulaOrderFieldStatus = &FormulaOrderField{
		field: formula.FieldStatus,
		toCursor: func(f *Formula) Cursor {
			return Cursor{
				ID:    f.ID,
				Value: f.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FormulaOrderField) String() string {
	var str string
	switch f.field {
	case formula.FieldTextFormula:
		str = "TEXTFORMULA"
	case formula.FieldStatus:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FormulaOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FormulaOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FormulaOrderField %T must be a string", v)
	}
	switch str {
	case "TEXTFORMULA":
		*f = *FormulaOrderFieldTextFormula
	case "STATUS":
		*f = *FormulaOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid FormulaOrderField", str)
	}
	return nil
}

// FormulaOrderField defines the ordering field of Formula.
type FormulaOrderField struct {
	field    string
	toCursor func(*Formula) Cursor
}

// FormulaOrder defines the ordering of Formula.
type FormulaOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FormulaOrderField `json:"field"`
}

// DefaultFormulaOrder is the default ordering of Formula.
var DefaultFormulaOrder = &FormulaOrder{
	Direction: OrderDirectionAsc,
	Field: &FormulaOrderField{
		field: formula.FieldID,
		toCursor: func(f *Formula) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// HyperlinkEdge is the edge representation of Hyperlink.
type HyperlinkEdge struct {
	Node   *Hyperlink `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// HyperlinkConnection is the connection containing edges to Hyperlink.
type HyperlinkConnection struct {
	Edges      []*HyperlinkEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// HyperlinkPaginateOption enables pagination customization.
type HyperlinkPaginateOption func(*hyperlinkPager) error

// WithHyperlinkOrder configures pagination ordering.
func WithHyperlinkOrder(order *HyperlinkOrder) HyperlinkPaginateOption {
	if order == nil {
		order = DefaultHyperlinkOrder
	}
	o := *order
	return func(pager *hyperlinkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHyperlinkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHyperlinkFilter configures pagination filter.
func WithHyperlinkFilter(filter func(*HyperlinkQuery) (*HyperlinkQuery, error)) HyperlinkPaginateOption {
	return func(pager *hyperlinkPager) error {
		if filter == nil {
			return errors.New("HyperlinkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hyperlinkPager struct {
	order  *HyperlinkOrder
	filter func(*HyperlinkQuery) (*HyperlinkQuery, error)
}

func newHyperlinkPager(opts []HyperlinkPaginateOption) (*hyperlinkPager, error) {
	pager := &hyperlinkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHyperlinkOrder
	}
	return pager, nil
}

func (p *hyperlinkPager) applyFilter(query *HyperlinkQuery) (*HyperlinkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hyperlinkPager) toCursor(h *Hyperlink) Cursor {
	return p.order.Field.toCursor(h)
}

func (p *hyperlinkPager) applyCursors(query *HyperlinkQuery, after, before *Cursor) *HyperlinkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHyperlinkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hyperlinkPager) applyOrder(query *HyperlinkQuery, reverse bool) *HyperlinkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHyperlinkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHyperlinkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Hyperlink.
func (h *HyperlinkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HyperlinkPaginateOption,
) (*HyperlinkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHyperlinkPager(opts)
	if err != nil {
		return nil, err
	}

	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}

	conn := &HyperlinkConnection{Edges: []*HyperlinkEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := h.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := h.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	h = pager.applyCursors(h, after, before)
	h = pager.applyOrder(h, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		h = h.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		h = h.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := h.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Hyperlink
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Hyperlink {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Hyperlink {
			return nodes[i]
		}
	}

	conn.Edges = make([]*HyperlinkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &HyperlinkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// HyperlinkOrderField defines the ordering field of Hyperlink.
type HyperlinkOrderField struct {
	field    string
	toCursor func(*Hyperlink) Cursor
}

// HyperlinkOrder defines the ordering of Hyperlink.
type HyperlinkOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *HyperlinkOrderField `json:"field"`
}

// DefaultHyperlinkOrder is the default ordering of Hyperlink.
var DefaultHyperlinkOrder = &HyperlinkOrder{
	Direction: OrderDirectionAsc,
	Field: &HyperlinkOrderField{
		field: hyperlink.FieldID,
		toCursor: func(h *Hyperlink) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// KpiEdge is the edge representation of Kpi.
type KpiEdge struct {
	Node   *Kpi   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// KpiConnection is the connection containing edges to Kpi.
type KpiConnection struct {
	Edges      []*KpiEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// KpiPaginateOption enables pagination customization.
type KpiPaginateOption func(*kpiPager) error

// WithKpiOrder configures pagination ordering.
func WithKpiOrder(order *KpiOrder) KpiPaginateOption {
	if order == nil {
		order = DefaultKpiOrder
	}
	o := *order
	return func(pager *kpiPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKpiOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKpiFilter configures pagination filter.
func WithKpiFilter(filter func(*KpiQuery) (*KpiQuery, error)) KpiPaginateOption {
	return func(pager *kpiPager) error {
		if filter == nil {
			return errors.New("KpiQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kpiPager struct {
	order  *KpiOrder
	filter func(*KpiQuery) (*KpiQuery, error)
}

func newKpiPager(opts []KpiPaginateOption) (*kpiPager, error) {
	pager := &kpiPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKpiOrder
	}
	return pager, nil
}

func (p *kpiPager) applyFilter(query *KpiQuery) (*KpiQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kpiPager) toCursor(k *Kpi) Cursor {
	return p.order.Field.toCursor(k)
}

func (p *kpiPager) applyCursors(query *KpiQuery, after, before *Cursor) *KpiQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKpiOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kpiPager) applyOrder(query *KpiQuery, reverse bool) *KpiQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKpiOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKpiOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Kpi.
func (k *KpiQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KpiPaginateOption,
) (*KpiConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKpiPager(opts)
	if err != nil {
		return nil, err
	}

	if k, err = pager.applyFilter(k); err != nil {
		return nil, err
	}

	conn := &KpiConnection{Edges: []*KpiEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := k.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := k.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	k = pager.applyCursors(k, after, before)
	k = pager.applyOrder(k, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		k = k.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		k = k.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := k.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Kpi
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Kpi {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Kpi {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KpiEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KpiEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KpiOrderFieldName orders Kpi by name.
	KpiOrderFieldName = &KpiOrderField{
		field: kpi.FieldName,
		toCursor: func(k *Kpi) Cursor {
			return Cursor{
				ID:    k.ID,
				Value: k.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KpiOrderField) String() string {
	var str string
	switch f.field {
	case kpi.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KpiOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KpiOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KpiOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KpiOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KpiOrderField", str)
	}
	return nil
}

// KpiOrderField defines the ordering field of Kpi.
type KpiOrderField struct {
	field    string
	toCursor func(*Kpi) Cursor
}

// KpiOrder defines the ordering of Kpi.
type KpiOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *KpiOrderField `json:"field"`
}

// DefaultKpiOrder is the default ordering of Kpi.
var DefaultKpiOrder = &KpiOrder{
	Direction: OrderDirectionAsc,
	Field: &KpiOrderField{
		field: kpi.FieldID,
		toCursor: func(k *Kpi) Cursor {
			return Cursor{ID: k.ID}
		},
	},
}

// KpiCategoryEdge is the edge representation of KpiCategory.
type KpiCategoryEdge struct {
	Node   *KpiCategory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// KpiCategoryConnection is the connection containing edges to KpiCategory.
type KpiCategoryConnection struct {
	Edges      []*KpiCategoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// KpiCategoryPaginateOption enables pagination customization.
type KpiCategoryPaginateOption func(*kpiCategoryPager) error

// WithKpiCategoryOrder configures pagination ordering.
func WithKpiCategoryOrder(order *KpiCategoryOrder) KpiCategoryPaginateOption {
	if order == nil {
		order = DefaultKpiCategoryOrder
	}
	o := *order
	return func(pager *kpiCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKpiCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKpiCategoryFilter configures pagination filter.
func WithKpiCategoryFilter(filter func(*KpiCategoryQuery) (*KpiCategoryQuery, error)) KpiCategoryPaginateOption {
	return func(pager *kpiCategoryPager) error {
		if filter == nil {
			return errors.New("KpiCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kpiCategoryPager struct {
	order  *KpiCategoryOrder
	filter func(*KpiCategoryQuery) (*KpiCategoryQuery, error)
}

func newKpiCategoryPager(opts []KpiCategoryPaginateOption) (*kpiCategoryPager, error) {
	pager := &kpiCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKpiCategoryOrder
	}
	return pager, nil
}

func (p *kpiCategoryPager) applyFilter(query *KpiCategoryQuery) (*KpiCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kpiCategoryPager) toCursor(kc *KpiCategory) Cursor {
	return p.order.Field.toCursor(kc)
}

func (p *kpiCategoryPager) applyCursors(query *KpiCategoryQuery, after, before *Cursor) *KpiCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKpiCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kpiCategoryPager) applyOrder(query *KpiCategoryQuery, reverse bool) *KpiCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKpiCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKpiCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to KpiCategory.
func (kc *KpiCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KpiCategoryPaginateOption,
) (*KpiCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKpiCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if kc, err = pager.applyFilter(kc); err != nil {
		return nil, err
	}

	conn := &KpiCategoryConnection{Edges: []*KpiCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := kc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := kc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	kc = pager.applyCursors(kc, after, before)
	kc = pager.applyOrder(kc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		kc = kc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		kc = kc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := kc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *KpiCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *KpiCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *KpiCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KpiCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KpiCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KpiCategoryOrderFieldName orders KpiCategory by name.
	KpiCategoryOrderFieldName = &KpiCategoryOrderField{
		field: kpicategory.FieldName,
		toCursor: func(kc *KpiCategory) Cursor {
			return Cursor{
				ID:    kc.ID,
				Value: kc.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KpiCategoryOrderField) String() string {
	var str string
	switch f.field {
	case kpicategory.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KpiCategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KpiCategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KpiCategoryOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KpiCategoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KpiCategoryOrderField", str)
	}
	return nil
}

// KpiCategoryOrderField defines the ordering field of KpiCategory.
type KpiCategoryOrderField struct {
	field    string
	toCursor func(*KpiCategory) Cursor
}

// KpiCategoryOrder defines the ordering of KpiCategory.
type KpiCategoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *KpiCategoryOrderField `json:"field"`
}

// DefaultKpiCategoryOrder is the default ordering of KpiCategory.
var DefaultKpiCategoryOrder = &KpiCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &KpiCategoryOrderField{
		field: kpicategory.FieldID,
		toCursor: func(kc *KpiCategory) Cursor {
			return Cursor{ID: kc.ID}
		},
	},
}

// KqiEdge is the edge representation of Kqi.
type KqiEdge struct {
	Node   *Kqi   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// KqiConnection is the connection containing edges to Kqi.
type KqiConnection struct {
	Edges      []*KqiEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// KqiPaginateOption enables pagination customization.
type KqiPaginateOption func(*kqiPager) error

// WithKqiOrder configures pagination ordering.
func WithKqiOrder(order *KqiOrder) KqiPaginateOption {
	if order == nil {
		order = DefaultKqiOrder
	}
	o := *order
	return func(pager *kqiPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKqiOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKqiFilter configures pagination filter.
func WithKqiFilter(filter func(*KqiQuery) (*KqiQuery, error)) KqiPaginateOption {
	return func(pager *kqiPager) error {
		if filter == nil {
			return errors.New("KqiQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kqiPager struct {
	order  *KqiOrder
	filter func(*KqiQuery) (*KqiQuery, error)
}

func newKqiPager(opts []KqiPaginateOption) (*kqiPager, error) {
	pager := &kqiPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKqiOrder
	}
	return pager, nil
}

func (p *kqiPager) applyFilter(query *KqiQuery) (*KqiQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kqiPager) toCursor(k *Kqi) Cursor {
	return p.order.Field.toCursor(k)
}

func (p *kqiPager) applyCursors(query *KqiQuery, after, before *Cursor) *KqiQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKqiOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kqiPager) applyOrder(query *KqiQuery, reverse bool) *KqiQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKqiOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKqiOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Kqi.
func (k *KqiQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KqiPaginateOption,
) (*KqiConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKqiPager(opts)
	if err != nil {
		return nil, err
	}

	if k, err = pager.applyFilter(k); err != nil {
		return nil, err
	}

	conn := &KqiConnection{Edges: []*KqiEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := k.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := k.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	k = pager.applyCursors(k, after, before)
	k = pager.applyOrder(k, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		k = k.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		k = k.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := k.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Kqi
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Kqi {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Kqi {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KqiEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KqiEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KqiOrderFieldName orders Kqi by name.
	KqiOrderFieldName = &KqiOrderField{
		field: kqi.FieldName,
		toCursor: func(k *Kqi) Cursor {
			return Cursor{
				ID:    k.ID,
				Value: k.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KqiOrderField) String() string {
	var str string
	switch f.field {
	case kqi.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KqiOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KqiOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KqiOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KqiOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KqiOrderField", str)
	}
	return nil
}

// KqiOrderField defines the ordering field of Kqi.
type KqiOrderField struct {
	field    string
	toCursor func(*Kqi) Cursor
}

// KqiOrder defines the ordering of Kqi.
type KqiOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *KqiOrderField `json:"field"`
}

// DefaultKqiOrder is the default ordering of Kqi.
var DefaultKqiOrder = &KqiOrder{
	Direction: OrderDirectionAsc,
	Field: &KqiOrderField{
		field: kqi.FieldID,
		toCursor: func(k *Kqi) Cursor {
			return Cursor{ID: k.ID}
		},
	},
}

// KqiCategoryEdge is the edge representation of KqiCategory.
type KqiCategoryEdge struct {
	Node   *KqiCategory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// KqiCategoryConnection is the connection containing edges to KqiCategory.
type KqiCategoryConnection struct {
	Edges      []*KqiCategoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// KqiCategoryPaginateOption enables pagination customization.
type KqiCategoryPaginateOption func(*kqiCategoryPager) error

// WithKqiCategoryOrder configures pagination ordering.
func WithKqiCategoryOrder(order *KqiCategoryOrder) KqiCategoryPaginateOption {
	if order == nil {
		order = DefaultKqiCategoryOrder
	}
	o := *order
	return func(pager *kqiCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKqiCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKqiCategoryFilter configures pagination filter.
func WithKqiCategoryFilter(filter func(*KqiCategoryQuery) (*KqiCategoryQuery, error)) KqiCategoryPaginateOption {
	return func(pager *kqiCategoryPager) error {
		if filter == nil {
			return errors.New("KqiCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kqiCategoryPager struct {
	order  *KqiCategoryOrder
	filter func(*KqiCategoryQuery) (*KqiCategoryQuery, error)
}

func newKqiCategoryPager(opts []KqiCategoryPaginateOption) (*kqiCategoryPager, error) {
	pager := &kqiCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKqiCategoryOrder
	}
	return pager, nil
}

func (p *kqiCategoryPager) applyFilter(query *KqiCategoryQuery) (*KqiCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kqiCategoryPager) toCursor(kc *KqiCategory) Cursor {
	return p.order.Field.toCursor(kc)
}

func (p *kqiCategoryPager) applyCursors(query *KqiCategoryQuery, after, before *Cursor) *KqiCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKqiCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kqiCategoryPager) applyOrder(query *KqiCategoryQuery, reverse bool) *KqiCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKqiCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKqiCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to KqiCategory.
func (kc *KqiCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KqiCategoryPaginateOption,
) (*KqiCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKqiCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if kc, err = pager.applyFilter(kc); err != nil {
		return nil, err
	}

	conn := &KqiCategoryConnection{Edges: []*KqiCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := kc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := kc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	kc = pager.applyCursors(kc, after, before)
	kc = pager.applyOrder(kc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		kc = kc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		kc = kc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := kc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *KqiCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *KqiCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *KqiCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KqiCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KqiCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KqiCategoryOrderFieldName orders KqiCategory by name.
	KqiCategoryOrderFieldName = &KqiCategoryOrderField{
		field: kqicategory.FieldName,
		toCursor: func(kc *KqiCategory) Cursor {
			return Cursor{
				ID:    kc.ID,
				Value: kc.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KqiCategoryOrderField) String() string {
	var str string
	switch f.field {
	case kqicategory.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KqiCategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KqiCategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KqiCategoryOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KqiCategoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KqiCategoryOrderField", str)
	}
	return nil
}

// KqiCategoryOrderField defines the ordering field of KqiCategory.
type KqiCategoryOrderField struct {
	field    string
	toCursor func(*KqiCategory) Cursor
}

// KqiCategoryOrder defines the ordering of KqiCategory.
type KqiCategoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *KqiCategoryOrderField `json:"field"`
}

// DefaultKqiCategoryOrder is the default ordering of KqiCategory.
var DefaultKqiCategoryOrder = &KqiCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &KqiCategoryOrderField{
		field: kqicategory.FieldID,
		toCursor: func(kc *KqiCategory) Cursor {
			return Cursor{ID: kc.ID}
		},
	},
}

// KqiComparatorEdge is the edge representation of KqiComparator.
type KqiComparatorEdge struct {
	Node   *KqiComparator `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// KqiComparatorConnection is the connection containing edges to KqiComparator.
type KqiComparatorConnection struct {
	Edges      []*KqiComparatorEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// KqiComparatorPaginateOption enables pagination customization.
type KqiComparatorPaginateOption func(*kqiComparatorPager) error

// WithKqiComparatorOrder configures pagination ordering.
func WithKqiComparatorOrder(order *KqiComparatorOrder) KqiComparatorPaginateOption {
	if order == nil {
		order = DefaultKqiComparatorOrder
	}
	o := *order
	return func(pager *kqiComparatorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKqiComparatorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKqiComparatorFilter configures pagination filter.
func WithKqiComparatorFilter(filter func(*KqiComparatorQuery) (*KqiComparatorQuery, error)) KqiComparatorPaginateOption {
	return func(pager *kqiComparatorPager) error {
		if filter == nil {
			return errors.New("KqiComparatorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kqiComparatorPager struct {
	order  *KqiComparatorOrder
	filter func(*KqiComparatorQuery) (*KqiComparatorQuery, error)
}

func newKqiComparatorPager(opts []KqiComparatorPaginateOption) (*kqiComparatorPager, error) {
	pager := &kqiComparatorPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKqiComparatorOrder
	}
	return pager, nil
}

func (p *kqiComparatorPager) applyFilter(query *KqiComparatorQuery) (*KqiComparatorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kqiComparatorPager) toCursor(kc *KqiComparator) Cursor {
	return p.order.Field.toCursor(kc)
}

func (p *kqiComparatorPager) applyCursors(query *KqiComparatorQuery, after, before *Cursor) *KqiComparatorQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKqiComparatorOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kqiComparatorPager) applyOrder(query *KqiComparatorQuery, reverse bool) *KqiComparatorQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKqiComparatorOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKqiComparatorOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to KqiComparator.
func (kc *KqiComparatorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KqiComparatorPaginateOption,
) (*KqiComparatorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKqiComparatorPager(opts)
	if err != nil {
		return nil, err
	}

	if kc, err = pager.applyFilter(kc); err != nil {
		return nil, err
	}

	conn := &KqiComparatorConnection{Edges: []*KqiComparatorEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := kc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := kc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	kc = pager.applyCursors(kc, after, before)
	kc = pager.applyOrder(kc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		kc = kc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		kc = kc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := kc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *KqiComparator
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *KqiComparator {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *KqiComparator {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KqiComparatorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KqiComparatorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// KqiComparatorOrderField defines the ordering field of KqiComparator.
type KqiComparatorOrderField struct {
	field    string
	toCursor func(*KqiComparator) Cursor
}

// KqiComparatorOrder defines the ordering of KqiComparator.
type KqiComparatorOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *KqiComparatorOrderField `json:"field"`
}

// DefaultKqiComparatorOrder is the default ordering of KqiComparator.
var DefaultKqiComparatorOrder = &KqiComparatorOrder{
	Direction: OrderDirectionAsc,
	Field: &KqiComparatorOrderField{
		field: kqicomparator.FieldID,
		toCursor: func(kc *KqiComparator) Cursor {
			return Cursor{ID: kc.ID}
		},
	},
}

// KqiPerspectiveEdge is the edge representation of KqiPerspective.
type KqiPerspectiveEdge struct {
	Node   *KqiPerspective `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// KqiPerspectiveConnection is the connection containing edges to KqiPerspective.
type KqiPerspectiveConnection struct {
	Edges      []*KqiPerspectiveEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// KqiPerspectivePaginateOption enables pagination customization.
type KqiPerspectivePaginateOption func(*kqiPerspectivePager) error

// WithKqiPerspectiveOrder configures pagination ordering.
func WithKqiPerspectiveOrder(order *KqiPerspectiveOrder) KqiPerspectivePaginateOption {
	if order == nil {
		order = DefaultKqiPerspectiveOrder
	}
	o := *order
	return func(pager *kqiPerspectivePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKqiPerspectiveOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKqiPerspectiveFilter configures pagination filter.
func WithKqiPerspectiveFilter(filter func(*KqiPerspectiveQuery) (*KqiPerspectiveQuery, error)) KqiPerspectivePaginateOption {
	return func(pager *kqiPerspectivePager) error {
		if filter == nil {
			return errors.New("KqiPerspectiveQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kqiPerspectivePager struct {
	order  *KqiPerspectiveOrder
	filter func(*KqiPerspectiveQuery) (*KqiPerspectiveQuery, error)
}

func newKqiPerspectivePager(opts []KqiPerspectivePaginateOption) (*kqiPerspectivePager, error) {
	pager := &kqiPerspectivePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKqiPerspectiveOrder
	}
	return pager, nil
}

func (p *kqiPerspectivePager) applyFilter(query *KqiPerspectiveQuery) (*KqiPerspectiveQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kqiPerspectivePager) toCursor(kp *KqiPerspective) Cursor {
	return p.order.Field.toCursor(kp)
}

func (p *kqiPerspectivePager) applyCursors(query *KqiPerspectiveQuery, after, before *Cursor) *KqiPerspectiveQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKqiPerspectiveOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kqiPerspectivePager) applyOrder(query *KqiPerspectiveQuery, reverse bool) *KqiPerspectiveQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKqiPerspectiveOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKqiPerspectiveOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to KqiPerspective.
func (kp *KqiPerspectiveQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KqiPerspectivePaginateOption,
) (*KqiPerspectiveConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKqiPerspectivePager(opts)
	if err != nil {
		return nil, err
	}

	if kp, err = pager.applyFilter(kp); err != nil {
		return nil, err
	}

	conn := &KqiPerspectiveConnection{Edges: []*KqiPerspectiveEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := kp.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := kp.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	kp = pager.applyCursors(kp, after, before)
	kp = pager.applyOrder(kp, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		kp = kp.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		kp = kp.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := kp.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *KqiPerspective
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *KqiPerspective {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *KqiPerspective {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KqiPerspectiveEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KqiPerspectiveEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KqiPerspectiveOrderFieldName orders KqiPerspective by name.
	KqiPerspectiveOrderFieldName = &KqiPerspectiveOrderField{
		field: kqiperspective.FieldName,
		toCursor: func(kp *KqiPerspective) Cursor {
			return Cursor{
				ID:    kp.ID,
				Value: kp.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KqiPerspectiveOrderField) String() string {
	var str string
	switch f.field {
	case kqiperspective.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KqiPerspectiveOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KqiPerspectiveOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KqiPerspectiveOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KqiPerspectiveOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KqiPerspectiveOrderField", str)
	}
	return nil
}

// KqiPerspectiveOrderField defines the ordering field of KqiPerspective.
type KqiPerspectiveOrderField struct {
	field    string
	toCursor func(*KqiPerspective) Cursor
}

// KqiPerspectiveOrder defines the ordering of KqiPerspective.
type KqiPerspectiveOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *KqiPerspectiveOrderField `json:"field"`
}

// DefaultKqiPerspectiveOrder is the default ordering of KqiPerspective.
var DefaultKqiPerspectiveOrder = &KqiPerspectiveOrder{
	Direction: OrderDirectionAsc,
	Field: &KqiPerspectiveOrderField{
		field: kqiperspective.FieldID,
		toCursor: func(kp *KqiPerspective) Cursor {
			return Cursor{ID: kp.ID}
		},
	},
}

// KqiSourceEdge is the edge representation of KqiSource.
type KqiSourceEdge struct {
	Node   *KqiSource `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// KqiSourceConnection is the connection containing edges to KqiSource.
type KqiSourceConnection struct {
	Edges      []*KqiSourceEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// KqiSourcePaginateOption enables pagination customization.
type KqiSourcePaginateOption func(*kqiSourcePager) error

// WithKqiSourceOrder configures pagination ordering.
func WithKqiSourceOrder(order *KqiSourceOrder) KqiSourcePaginateOption {
	if order == nil {
		order = DefaultKqiSourceOrder
	}
	o := *order
	return func(pager *kqiSourcePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKqiSourceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKqiSourceFilter configures pagination filter.
func WithKqiSourceFilter(filter func(*KqiSourceQuery) (*KqiSourceQuery, error)) KqiSourcePaginateOption {
	return func(pager *kqiSourcePager) error {
		if filter == nil {
			return errors.New("KqiSourceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kqiSourcePager struct {
	order  *KqiSourceOrder
	filter func(*KqiSourceQuery) (*KqiSourceQuery, error)
}

func newKqiSourcePager(opts []KqiSourcePaginateOption) (*kqiSourcePager, error) {
	pager := &kqiSourcePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKqiSourceOrder
	}
	return pager, nil
}

func (p *kqiSourcePager) applyFilter(query *KqiSourceQuery) (*KqiSourceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kqiSourcePager) toCursor(ks *KqiSource) Cursor {
	return p.order.Field.toCursor(ks)
}

func (p *kqiSourcePager) applyCursors(query *KqiSourceQuery, after, before *Cursor) *KqiSourceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKqiSourceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kqiSourcePager) applyOrder(query *KqiSourceQuery, reverse bool) *KqiSourceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKqiSourceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKqiSourceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to KqiSource.
func (ks *KqiSourceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KqiSourcePaginateOption,
) (*KqiSourceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKqiSourcePager(opts)
	if err != nil {
		return nil, err
	}

	if ks, err = pager.applyFilter(ks); err != nil {
		return nil, err
	}

	conn := &KqiSourceConnection{Edges: []*KqiSourceEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ks.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ks.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ks = pager.applyCursors(ks, after, before)
	ks = pager.applyOrder(ks, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ks = ks.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ks = ks.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ks.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *KqiSource
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *KqiSource {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *KqiSource {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KqiSourceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KqiSourceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KqiSourceOrderFieldName orders KqiSource by name.
	KqiSourceOrderFieldName = &KqiSourceOrderField{
		field: kqisource.FieldName,
		toCursor: func(ks *KqiSource) Cursor {
			return Cursor{
				ID:    ks.ID,
				Value: ks.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KqiSourceOrderField) String() string {
	var str string
	switch f.field {
	case kqisource.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KqiSourceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KqiSourceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KqiSourceOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KqiSourceOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KqiSourceOrderField", str)
	}
	return nil
}

// KqiSourceOrderField defines the ordering field of KqiSource.
type KqiSourceOrderField struct {
	field    string
	toCursor func(*KqiSource) Cursor
}

// KqiSourceOrder defines the ordering of KqiSource.
type KqiSourceOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *KqiSourceOrderField `json:"field"`
}

// DefaultKqiSourceOrder is the default ordering of KqiSource.
var DefaultKqiSourceOrder = &KqiSourceOrder{
	Direction: OrderDirectionAsc,
	Field: &KqiSourceOrderField{
		field: kqisource.FieldID,
		toCursor: func(ks *KqiSource) Cursor {
			return Cursor{ID: ks.ID}
		},
	},
}

// KqiTargetEdge is the edge representation of KqiTarget.
type KqiTargetEdge struct {
	Node   *KqiTarget `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// KqiTargetConnection is the connection containing edges to KqiTarget.
type KqiTargetConnection struct {
	Edges      []*KqiTargetEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// KqiTargetPaginateOption enables pagination customization.
type KqiTargetPaginateOption func(*kqiTargetPager) error

// WithKqiTargetOrder configures pagination ordering.
func WithKqiTargetOrder(order *KqiTargetOrder) KqiTargetPaginateOption {
	if order == nil {
		order = DefaultKqiTargetOrder
	}
	o := *order
	return func(pager *kqiTargetPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKqiTargetOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKqiTargetFilter configures pagination filter.
func WithKqiTargetFilter(filter func(*KqiTargetQuery) (*KqiTargetQuery, error)) KqiTargetPaginateOption {
	return func(pager *kqiTargetPager) error {
		if filter == nil {
			return errors.New("KqiTargetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kqiTargetPager struct {
	order  *KqiTargetOrder
	filter func(*KqiTargetQuery) (*KqiTargetQuery, error)
}

func newKqiTargetPager(opts []KqiTargetPaginateOption) (*kqiTargetPager, error) {
	pager := &kqiTargetPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKqiTargetOrder
	}
	return pager, nil
}

func (p *kqiTargetPager) applyFilter(query *KqiTargetQuery) (*KqiTargetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kqiTargetPager) toCursor(kt *KqiTarget) Cursor {
	return p.order.Field.toCursor(kt)
}

func (p *kqiTargetPager) applyCursors(query *KqiTargetQuery, after, before *Cursor) *KqiTargetQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKqiTargetOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kqiTargetPager) applyOrder(query *KqiTargetQuery, reverse bool) *KqiTargetQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKqiTargetOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKqiTargetOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to KqiTarget.
func (kt *KqiTargetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KqiTargetPaginateOption,
) (*KqiTargetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKqiTargetPager(opts)
	if err != nil {
		return nil, err
	}

	if kt, err = pager.applyFilter(kt); err != nil {
		return nil, err
	}

	conn := &KqiTargetConnection{Edges: []*KqiTargetEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := kt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := kt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	kt = pager.applyCursors(kt, after, before)
	kt = pager.applyOrder(kt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		kt = kt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		kt = kt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := kt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *KqiTarget
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *KqiTarget {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *KqiTarget {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KqiTargetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KqiTargetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KqiTargetOrderFieldName orders KqiTarget by name.
	KqiTargetOrderFieldName = &KqiTargetOrderField{
		field: kqitarget.FieldName,
		toCursor: func(kt *KqiTarget) Cursor {
			return Cursor{
				ID:    kt.ID,
				Value: kt.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KqiTargetOrderField) String() string {
	var str string
	switch f.field {
	case kqitarget.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KqiTargetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KqiTargetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KqiTargetOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KqiTargetOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KqiTargetOrderField", str)
	}
	return nil
}

// KqiTargetOrderField defines the ordering field of KqiTarget.
type KqiTargetOrderField struct {
	field    string
	toCursor func(*KqiTarget) Cursor
}

// KqiTargetOrder defines the ordering of KqiTarget.
type KqiTargetOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *KqiTargetOrderField `json:"field"`
}

// DefaultKqiTargetOrder is the default ordering of KqiTarget.
var DefaultKqiTargetOrder = &KqiTargetOrder{
	Direction: OrderDirectionAsc,
	Field: &KqiTargetOrderField{
		field: kqitarget.FieldID,
		toCursor: func(kt *KqiTarget) Cursor {
			return Cursor{ID: kt.ID}
		},
	},
}

// KqiTemporalFrequencyEdge is the edge representation of KqiTemporalFrequency.
type KqiTemporalFrequencyEdge struct {
	Node   *KqiTemporalFrequency `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// KqiTemporalFrequencyConnection is the connection containing edges to KqiTemporalFrequency.
type KqiTemporalFrequencyConnection struct {
	Edges      []*KqiTemporalFrequencyEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

// KqiTemporalFrequencyPaginateOption enables pagination customization.
type KqiTemporalFrequencyPaginateOption func(*kqiTemporalFrequencyPager) error

// WithKqiTemporalFrequencyOrder configures pagination ordering.
func WithKqiTemporalFrequencyOrder(order *KqiTemporalFrequencyOrder) KqiTemporalFrequencyPaginateOption {
	if order == nil {
		order = DefaultKqiTemporalFrequencyOrder
	}
	o := *order
	return func(pager *kqiTemporalFrequencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultKqiTemporalFrequencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithKqiTemporalFrequencyFilter configures pagination filter.
func WithKqiTemporalFrequencyFilter(filter func(*KqiTemporalFrequencyQuery) (*KqiTemporalFrequencyQuery, error)) KqiTemporalFrequencyPaginateOption {
	return func(pager *kqiTemporalFrequencyPager) error {
		if filter == nil {
			return errors.New("KqiTemporalFrequencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type kqiTemporalFrequencyPager struct {
	order  *KqiTemporalFrequencyOrder
	filter func(*KqiTemporalFrequencyQuery) (*KqiTemporalFrequencyQuery, error)
}

func newKqiTemporalFrequencyPager(opts []KqiTemporalFrequencyPaginateOption) (*kqiTemporalFrequencyPager, error) {
	pager := &kqiTemporalFrequencyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultKqiTemporalFrequencyOrder
	}
	return pager, nil
}

func (p *kqiTemporalFrequencyPager) applyFilter(query *KqiTemporalFrequencyQuery) (*KqiTemporalFrequencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *kqiTemporalFrequencyPager) toCursor(ktf *KqiTemporalFrequency) Cursor {
	return p.order.Field.toCursor(ktf)
}

func (p *kqiTemporalFrequencyPager) applyCursors(query *KqiTemporalFrequencyQuery, after, before *Cursor) *KqiTemporalFrequencyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultKqiTemporalFrequencyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *kqiTemporalFrequencyPager) applyOrder(query *KqiTemporalFrequencyQuery, reverse bool) *KqiTemporalFrequencyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultKqiTemporalFrequencyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultKqiTemporalFrequencyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to KqiTemporalFrequency.
func (ktf *KqiTemporalFrequencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...KqiTemporalFrequencyPaginateOption,
) (*KqiTemporalFrequencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newKqiTemporalFrequencyPager(opts)
	if err != nil {
		return nil, err
	}

	if ktf, err = pager.applyFilter(ktf); err != nil {
		return nil, err
	}

	conn := &KqiTemporalFrequencyConnection{Edges: []*KqiTemporalFrequencyEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ktf.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ktf.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ktf = pager.applyCursors(ktf, after, before)
	ktf = pager.applyOrder(ktf, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ktf = ktf.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ktf = ktf.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ktf.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *KqiTemporalFrequency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *KqiTemporalFrequency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *KqiTemporalFrequency {
			return nodes[i]
		}
	}

	conn.Edges = make([]*KqiTemporalFrequencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &KqiTemporalFrequencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// KqiTemporalFrequencyOrderFieldName orders KqiTemporalFrequency by name.
	KqiTemporalFrequencyOrderFieldName = &KqiTemporalFrequencyOrderField{
		field: kqitemporalfrequency.FieldName,
		toCursor: func(ktf *KqiTemporalFrequency) Cursor {
			return Cursor{
				ID:    ktf.ID,
				Value: ktf.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f KqiTemporalFrequencyOrderField) String() string {
	var str string
	switch f.field {
	case kqitemporalfrequency.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f KqiTemporalFrequencyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *KqiTemporalFrequencyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("KqiTemporalFrequencyOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *KqiTemporalFrequencyOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid KqiTemporalFrequencyOrderField", str)
	}
	return nil
}

// KqiTemporalFrequencyOrderField defines the ordering field of KqiTemporalFrequency.
type KqiTemporalFrequencyOrderField struct {
	field    string
	toCursor func(*KqiTemporalFrequency) Cursor
}

// KqiTemporalFrequencyOrder defines the ordering of KqiTemporalFrequency.
type KqiTemporalFrequencyOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *KqiTemporalFrequencyOrderField `json:"field"`
}

// DefaultKqiTemporalFrequencyOrder is the default ordering of KqiTemporalFrequency.
var DefaultKqiTemporalFrequencyOrder = &KqiTemporalFrequencyOrder{
	Direction: OrderDirectionAsc,
	Field: &KqiTemporalFrequencyOrderField{
		field: kqitemporalfrequency.FieldID,
		toCursor: func(ktf *KqiTemporalFrequency) Cursor {
			return Cursor{ID: ktf.ID}
		},
	},
}

// LinkEdge is the edge representation of Link.
type LinkEdge struct {
	Node   *Link  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// LinkConnection is the connection containing edges to Link.
type LinkConnection struct {
	Edges      []*LinkEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// LinkPaginateOption enables pagination customization.
type LinkPaginateOption func(*linkPager) error

// WithLinkOrder configures pagination ordering.
func WithLinkOrder(order *LinkOrder) LinkPaginateOption {
	if order == nil {
		order = DefaultLinkOrder
	}
	o := *order
	return func(pager *linkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLinkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLinkFilter configures pagination filter.
func WithLinkFilter(filter func(*LinkQuery) (*LinkQuery, error)) LinkPaginateOption {
	return func(pager *linkPager) error {
		if filter == nil {
			return errors.New("LinkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type linkPager struct {
	order  *LinkOrder
	filter func(*LinkQuery) (*LinkQuery, error)
}

func newLinkPager(opts []LinkPaginateOption) (*linkPager, error) {
	pager := &linkPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLinkOrder
	}
	return pager, nil
}

func (p *linkPager) applyFilter(query *LinkQuery) (*LinkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *linkPager) toCursor(l *Link) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *linkPager) applyCursors(query *LinkQuery, after, before *Cursor) *LinkQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLinkOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *linkPager) applyOrder(query *LinkQuery, reverse bool) *LinkQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLinkOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLinkOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Link.
func (l *LinkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LinkPaginateOption,
) (*LinkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLinkPager(opts)
	if err != nil {
		return nil, err
	}

	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}

	conn := &LinkConnection{Edges: []*LinkEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := l.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := l.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	l = pager.applyCursors(l, after, before)
	l = pager.applyOrder(l, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		l = l.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		l = l.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := l.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Link
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Link {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Link {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LinkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LinkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// LinkOrderField defines the ordering field of Link.
type LinkOrderField struct {
	field    string
	toCursor func(*Link) Cursor
}

// LinkOrder defines the ordering of Link.
type LinkOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *LinkOrderField `json:"field"`
}

// DefaultLinkOrder is the default ordering of Link.
var DefaultLinkOrder = &LinkOrder{
	Direction: OrderDirectionAsc,
	Field: &LinkOrderField{
		field: link.FieldID,
		toCursor: func(l *Link) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// LocationEdge is the edge representation of Location.
type LocationEdge struct {
	Node   *Location `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LocationConnection is the connection containing edges to Location.
type LocationConnection struct {
	Edges      []*LocationEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// LocationPaginateOption enables pagination customization.
type LocationPaginateOption func(*locationPager) error

// WithLocationOrder configures pagination ordering.
func WithLocationOrder(order *LocationOrder) LocationPaginateOption {
	if order == nil {
		order = DefaultLocationOrder
	}
	o := *order
	return func(pager *locationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLocationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLocationFilter configures pagination filter.
func WithLocationFilter(filter func(*LocationQuery) (*LocationQuery, error)) LocationPaginateOption {
	return func(pager *locationPager) error {
		if filter == nil {
			return errors.New("LocationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationPager struct {
	order  *LocationOrder
	filter func(*LocationQuery) (*LocationQuery, error)
}

func newLocationPager(opts []LocationPaginateOption) (*locationPager, error) {
	pager := &locationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLocationOrder
	}
	return pager, nil
}

func (p *locationPager) applyFilter(query *LocationQuery) (*LocationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationPager) toCursor(l *Location) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *locationPager) applyCursors(query *LocationQuery, after, before *Cursor) *LocationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLocationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *locationPager) applyOrder(query *LocationQuery, reverse bool) *LocationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLocationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLocationOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Location.
func (l *LocationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LocationPaginateOption,
) (*LocationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationPager(opts)
	if err != nil {
		return nil, err
	}

	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}

	conn := &LocationConnection{Edges: []*LocationEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := l.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := l.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	l = pager.applyCursors(l, after, before)
	l = pager.applyOrder(l, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		l = l.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		l = l.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := l.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Location
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Location {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Location {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LocationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LocationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// LocationOrderFieldName orders Location by name.
	LocationOrderFieldName = &LocationOrderField{
		field: location.FieldName,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LocationOrderField) String() string {
	var str string
	switch f.field {
	case location.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LocationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LocationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LocationOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *LocationOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid LocationOrderField", str)
	}
	return nil
}

// LocationOrderField defines the ordering field of Location.
type LocationOrderField struct {
	field    string
	toCursor func(*Location) Cursor
}

// LocationOrder defines the ordering of Location.
type LocationOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LocationOrderField `json:"field"`
}

// DefaultLocationOrder is the default ordering of Location.
var DefaultLocationOrder = &LocationOrder{
	Direction: OrderDirectionAsc,
	Field: &LocationOrderField{
		field: location.FieldID,
		toCursor: func(l *Location) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// LocationTypeEdge is the edge representation of LocationType.
type LocationTypeEdge struct {
	Node   *LocationType `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// LocationTypeConnection is the connection containing edges to LocationType.
type LocationTypeConnection struct {
	Edges      []*LocationTypeEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// LocationTypePaginateOption enables pagination customization.
type LocationTypePaginateOption func(*locationTypePager) error

// WithLocationTypeOrder configures pagination ordering.
func WithLocationTypeOrder(order *LocationTypeOrder) LocationTypePaginateOption {
	if order == nil {
		order = DefaultLocationTypeOrder
	}
	o := *order
	return func(pager *locationTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLocationTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLocationTypeFilter configures pagination filter.
func WithLocationTypeFilter(filter func(*LocationTypeQuery) (*LocationTypeQuery, error)) LocationTypePaginateOption {
	return func(pager *locationTypePager) error {
		if filter == nil {
			return errors.New("LocationTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationTypePager struct {
	order  *LocationTypeOrder
	filter func(*LocationTypeQuery) (*LocationTypeQuery, error)
}

func newLocationTypePager(opts []LocationTypePaginateOption) (*locationTypePager, error) {
	pager := &locationTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLocationTypeOrder
	}
	return pager, nil
}

func (p *locationTypePager) applyFilter(query *LocationTypeQuery) (*LocationTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationTypePager) toCursor(lt *LocationType) Cursor {
	return p.order.Field.toCursor(lt)
}

func (p *locationTypePager) applyCursors(query *LocationTypeQuery, after, before *Cursor) *LocationTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLocationTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *locationTypePager) applyOrder(query *LocationTypeQuery, reverse bool) *LocationTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLocationTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLocationTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to LocationType.
func (lt *LocationTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LocationTypePaginateOption,
) (*LocationTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationTypePager(opts)
	if err != nil {
		return nil, err
	}

	if lt, err = pager.applyFilter(lt); err != nil {
		return nil, err
	}

	conn := &LocationTypeConnection{Edges: []*LocationTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := lt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := lt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	lt = pager.applyCursors(lt, after, before)
	lt = pager.applyOrder(lt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		lt = lt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		lt = lt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := lt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *LocationType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LocationType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LocationType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LocationTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LocationTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// LocationTypeOrderField defines the ordering field of LocationType.
type LocationTypeOrderField struct {
	field    string
	toCursor func(*LocationType) Cursor
}

// LocationTypeOrder defines the ordering of LocationType.
type LocationTypeOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *LocationTypeOrderField `json:"field"`
}

// DefaultLocationTypeOrder is the default ordering of LocationType.
var DefaultLocationTypeOrder = &LocationTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &LocationTypeOrderField{
		field: locationtype.FieldID,
		toCursor: func(lt *LocationType) Cursor {
			return Cursor{ID: lt.ID}
		},
	},
}

// NetworkTypeEdge is the edge representation of NetworkType.
type NetworkTypeEdge struct {
	Node   *NetworkType `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// NetworkTypeConnection is the connection containing edges to NetworkType.
type NetworkTypeConnection struct {
	Edges      []*NetworkTypeEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// NetworkTypePaginateOption enables pagination customization.
type NetworkTypePaginateOption func(*networkTypePager) error

// WithNetworkTypeOrder configures pagination ordering.
func WithNetworkTypeOrder(order *NetworkTypeOrder) NetworkTypePaginateOption {
	if order == nil {
		order = DefaultNetworkTypeOrder
	}
	o := *order
	return func(pager *networkTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNetworkTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNetworkTypeFilter configures pagination filter.
func WithNetworkTypeFilter(filter func(*NetworkTypeQuery) (*NetworkTypeQuery, error)) NetworkTypePaginateOption {
	return func(pager *networkTypePager) error {
		if filter == nil {
			return errors.New("NetworkTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type networkTypePager struct {
	order  *NetworkTypeOrder
	filter func(*NetworkTypeQuery) (*NetworkTypeQuery, error)
}

func newNetworkTypePager(opts []NetworkTypePaginateOption) (*networkTypePager, error) {
	pager := &networkTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNetworkTypeOrder
	}
	return pager, nil
}

func (p *networkTypePager) applyFilter(query *NetworkTypeQuery) (*NetworkTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *networkTypePager) toCursor(nt *NetworkType) Cursor {
	return p.order.Field.toCursor(nt)
}

func (p *networkTypePager) applyCursors(query *NetworkTypeQuery, after, before *Cursor) *NetworkTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultNetworkTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *networkTypePager) applyOrder(query *NetworkTypeQuery, reverse bool) *NetworkTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultNetworkTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultNetworkTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to NetworkType.
func (nt *NetworkTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NetworkTypePaginateOption,
) (*NetworkTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNetworkTypePager(opts)
	if err != nil {
		return nil, err
	}

	if nt, err = pager.applyFilter(nt); err != nil {
		return nil, err
	}

	conn := &NetworkTypeConnection{Edges: []*NetworkTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := nt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := nt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	nt = pager.applyCursors(nt, after, before)
	nt = pager.applyOrder(nt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		nt = nt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		nt = nt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := nt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *NetworkType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NetworkType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NetworkType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*NetworkTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &NetworkTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// NetworkTypeOrderFieldName orders NetworkType by name.
	NetworkTypeOrderFieldName = &NetworkTypeOrderField{
		field: networktype.FieldName,
		toCursor: func(nt *NetworkType) Cursor {
			return Cursor{
				ID:    nt.ID,
				Value: nt.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NetworkTypeOrderField) String() string {
	var str string
	switch f.field {
	case networktype.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NetworkTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NetworkTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NetworkTypeOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *NetworkTypeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NetworkTypeOrderField", str)
	}
	return nil
}

// NetworkTypeOrderField defines the ordering field of NetworkType.
type NetworkTypeOrderField struct {
	field    string
	toCursor func(*NetworkType) Cursor
}

// NetworkTypeOrder defines the ordering of NetworkType.
type NetworkTypeOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *NetworkTypeOrderField `json:"field"`
}

// DefaultNetworkTypeOrder is the default ordering of NetworkType.
var DefaultNetworkTypeOrder = &NetworkTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &NetworkTypeOrderField{
		field: networktype.FieldID,
		toCursor: func(nt *NetworkType) Cursor {
			return Cursor{ID: nt.ID}
		},
	},
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order *OrganizationOrder) OrganizationPaginateOption {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	o := *order
	return func(pager *organizationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	order  *OrganizationOrder
	filter func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption) (*organizationPager, error) {
	pager := &organizationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationOrder
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) *OrganizationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultOrganizationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *organizationPager) applyOrder(query *OrganizationQuery, reverse bool) *OrganizationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultOrganizationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultOrganizationOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts)
	if err != nil {
		return nil, err
	}

	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}

	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := o.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := o.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	o = pager.applyCursors(o, after, before)
	o = pager.applyOrder(o, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		o = o.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		o = o.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := o.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}

	conn.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// OrganizationOrderFieldName orders Organization by name.
	OrganizationOrderFieldName = &OrganizationOrderField{
		field: organization.FieldName,
		toCursor: func(o *Organization) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrganizationOrderField) String() string {
	var str string
	switch f.field {
	case organization.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrganizationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrganizationOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *OrganizationOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	field    string
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: OrderDirectionAsc,
	Field: &OrganizationOrderField{
		field: organization.FieldID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ParameterCatalogEdge is the edge representation of ParameterCatalog.
type ParameterCatalogEdge struct {
	Node   *ParameterCatalog `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ParameterCatalogConnection is the connection containing edges to ParameterCatalog.
type ParameterCatalogConnection struct {
	Edges      []*ParameterCatalogEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// ParameterCatalogPaginateOption enables pagination customization.
type ParameterCatalogPaginateOption func(*parameterCatalogPager) error

// WithParameterCatalogOrder configures pagination ordering.
func WithParameterCatalogOrder(order *ParameterCatalogOrder) ParameterCatalogPaginateOption {
	if order == nil {
		order = DefaultParameterCatalogOrder
	}
	o := *order
	return func(pager *parameterCatalogPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultParameterCatalogOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithParameterCatalogFilter configures pagination filter.
func WithParameterCatalogFilter(filter func(*ParameterCatalogQuery) (*ParameterCatalogQuery, error)) ParameterCatalogPaginateOption {
	return func(pager *parameterCatalogPager) error {
		if filter == nil {
			return errors.New("ParameterCatalogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type parameterCatalogPager struct {
	order  *ParameterCatalogOrder
	filter func(*ParameterCatalogQuery) (*ParameterCatalogQuery, error)
}

func newParameterCatalogPager(opts []ParameterCatalogPaginateOption) (*parameterCatalogPager, error) {
	pager := &parameterCatalogPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultParameterCatalogOrder
	}
	return pager, nil
}

func (p *parameterCatalogPager) applyFilter(query *ParameterCatalogQuery) (*ParameterCatalogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *parameterCatalogPager) toCursor(pc *ParameterCatalog) Cursor {
	return p.order.Field.toCursor(pc)
}

func (p *parameterCatalogPager) applyCursors(query *ParameterCatalogQuery, after, before *Cursor) *ParameterCatalogQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultParameterCatalogOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *parameterCatalogPager) applyOrder(query *ParameterCatalogQuery, reverse bool) *ParameterCatalogQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultParameterCatalogOrder.Field {
		query = query.Order(direction.orderFunc(DefaultParameterCatalogOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ParameterCatalog.
func (pc *ParameterCatalogQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ParameterCatalogPaginateOption,
) (*ParameterCatalogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newParameterCatalogPager(opts)
	if err != nil {
		return nil, err
	}

	if pc, err = pager.applyFilter(pc); err != nil {
		return nil, err
	}

	conn := &ParameterCatalogConnection{Edges: []*ParameterCatalogEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pc = pager.applyCursors(pc, after, before)
	pc = pager.applyOrder(pc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pc = pc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pc = pc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ParameterCatalog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ParameterCatalog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ParameterCatalog {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ParameterCatalogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ParameterCatalogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ParameterCatalogOrderField defines the ordering field of ParameterCatalog.
type ParameterCatalogOrderField struct {
	field    string
	toCursor func(*ParameterCatalog) Cursor
}

// ParameterCatalogOrder defines the ordering of ParameterCatalog.
type ParameterCatalogOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ParameterCatalogOrderField `json:"field"`
}

// DefaultParameterCatalogOrder is the default ordering of ParameterCatalog.
var DefaultParameterCatalogOrder = &ParameterCatalogOrder{
	Direction: OrderDirectionAsc,
	Field: &ParameterCatalogOrderField{
		field: parametercatalog.FieldID,
		toCursor: func(pc *ParameterCatalog) Cursor {
			return Cursor{ID: pc.ID}
		},
	},
}

// PermissionsPolicyEdge is the edge representation of PermissionsPolicy.
type PermissionsPolicyEdge struct {
	Node   *PermissionsPolicy `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// PermissionsPolicyConnection is the connection containing edges to PermissionsPolicy.
type PermissionsPolicyConnection struct {
	Edges      []*PermissionsPolicyEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// PermissionsPolicyPaginateOption enables pagination customization.
type PermissionsPolicyPaginateOption func(*permissionsPolicyPager) error

// WithPermissionsPolicyOrder configures pagination ordering.
func WithPermissionsPolicyOrder(order *PermissionsPolicyOrder) PermissionsPolicyPaginateOption {
	if order == nil {
		order = DefaultPermissionsPolicyOrder
	}
	o := *order
	return func(pager *permissionsPolicyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPermissionsPolicyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPermissionsPolicyFilter configures pagination filter.
func WithPermissionsPolicyFilter(filter func(*PermissionsPolicyQuery) (*PermissionsPolicyQuery, error)) PermissionsPolicyPaginateOption {
	return func(pager *permissionsPolicyPager) error {
		if filter == nil {
			return errors.New("PermissionsPolicyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type permissionsPolicyPager struct {
	order  *PermissionsPolicyOrder
	filter func(*PermissionsPolicyQuery) (*PermissionsPolicyQuery, error)
}

func newPermissionsPolicyPager(opts []PermissionsPolicyPaginateOption) (*permissionsPolicyPager, error) {
	pager := &permissionsPolicyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPermissionsPolicyOrder
	}
	return pager, nil
}

func (p *permissionsPolicyPager) applyFilter(query *PermissionsPolicyQuery) (*PermissionsPolicyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *permissionsPolicyPager) toCursor(pp *PermissionsPolicy) Cursor {
	return p.order.Field.toCursor(pp)
}

func (p *permissionsPolicyPager) applyCursors(query *PermissionsPolicyQuery, after, before *Cursor) *PermissionsPolicyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPermissionsPolicyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *permissionsPolicyPager) applyOrder(query *PermissionsPolicyQuery, reverse bool) *PermissionsPolicyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPermissionsPolicyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPermissionsPolicyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to PermissionsPolicy.
func (pp *PermissionsPolicyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PermissionsPolicyPaginateOption,
) (*PermissionsPolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPermissionsPolicyPager(opts)
	if err != nil {
		return nil, err
	}

	if pp, err = pager.applyFilter(pp); err != nil {
		return nil, err
	}

	conn := &PermissionsPolicyConnection{Edges: []*PermissionsPolicyEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pp.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pp.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pp = pager.applyCursors(pp, after, before)
	pp = pager.applyOrder(pp, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pp = pp.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pp = pp.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pp.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *PermissionsPolicy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PermissionsPolicy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PermissionsPolicy {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PermissionsPolicyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PermissionsPolicyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// PermissionsPolicyOrderField defines the ordering field of PermissionsPolicy.
type PermissionsPolicyOrderField struct {
	field    string
	toCursor func(*PermissionsPolicy) Cursor
}

// PermissionsPolicyOrder defines the ordering of PermissionsPolicy.
type PermissionsPolicyOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *PermissionsPolicyOrderField `json:"field"`
}

// DefaultPermissionsPolicyOrder is the default ordering of PermissionsPolicy.
var DefaultPermissionsPolicyOrder = &PermissionsPolicyOrder{
	Direction: OrderDirectionAsc,
	Field: &PermissionsPolicyOrderField{
		field: permissionspolicy.FieldID,
		toCursor: func(pp *PermissionsPolicy) Cursor {
			return Cursor{ID: pp.ID}
		},
	},
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order *ProjectOrder) ProjectPaginateOption {
	if order == nil {
		order = DefaultProjectOrder
	}
	o := *order
	return func(pager *projectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	order  *ProjectOrder
	filter func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption) (*projectPager, error) {
	pager := &projectPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectOrder
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) *ProjectQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProjectOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *projectPager) applyOrder(query *ProjectQuery, reverse bool) *ProjectQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProjectOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProjectOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts)
	if err != nil {
		return nil, err
	}

	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}

	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pr = pr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ProjectOrderFieldCreateTime orders Project by create_time.
	ProjectOrderFieldCreateTime = &ProjectOrderField{
		field: project.FieldCreateTime,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreateTime,
			}
		},
	}
	// ProjectOrderFieldUpdateTime orders Project by update_time.
	ProjectOrderFieldUpdateTime = &ProjectOrderField{
		field: project.FieldUpdateTime,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdateTime,
			}
		},
	}
	// ProjectOrderFieldName orders Project by name.
	ProjectOrderFieldName = &ProjectOrderField{
		field: project.FieldName,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProjectOrderFieldPriority orders Project by priority.
	ProjectOrderFieldPriority = &ProjectOrderField{
		field: project.FieldPriority,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Priority,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectOrderField) String() string {
	var str string
	switch f.field {
	case project.FieldCreateTime:
		str = "CREATED_AT"
	case project.FieldUpdateTime:
		str = "UPDATED_AT"
	case project.FieldName:
		str = "NAME"
	case project.FieldPriority:
		str = "PRIORITY"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ProjectOrderFieldCreateTime
	case "UPDATED_AT":
		*f = *ProjectOrderFieldUpdateTime
	case "NAME":
		*f = *ProjectOrderFieldName
	case "PRIORITY":
		*f = *ProjectOrderFieldPriority
	default:
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	field    string
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: OrderDirectionAsc,
	Field: &ProjectOrderField{
		field: project.FieldID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ProjectTemplateEdge is the edge representation of ProjectTemplate.
type ProjectTemplateEdge struct {
	Node   *ProjectTemplate `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ProjectTemplateConnection is the connection containing edges to ProjectTemplate.
type ProjectTemplateConnection struct {
	Edges      []*ProjectTemplateEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// ProjectTemplatePaginateOption enables pagination customization.
type ProjectTemplatePaginateOption func(*projectTemplatePager) error

// WithProjectTemplateOrder configures pagination ordering.
func WithProjectTemplateOrder(order *ProjectTemplateOrder) ProjectTemplatePaginateOption {
	if order == nil {
		order = DefaultProjectTemplateOrder
	}
	o := *order
	return func(pager *projectTemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectTemplateFilter configures pagination filter.
func WithProjectTemplateFilter(filter func(*ProjectTemplateQuery) (*ProjectTemplateQuery, error)) ProjectTemplatePaginateOption {
	return func(pager *projectTemplatePager) error {
		if filter == nil {
			return errors.New("ProjectTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectTemplatePager struct {
	order  *ProjectTemplateOrder
	filter func(*ProjectTemplateQuery) (*ProjectTemplateQuery, error)
}

func newProjectTemplatePager(opts []ProjectTemplatePaginateOption) (*projectTemplatePager, error) {
	pager := &projectTemplatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectTemplateOrder
	}
	return pager, nil
}

func (p *projectTemplatePager) applyFilter(query *ProjectTemplateQuery) (*ProjectTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectTemplatePager) toCursor(pt *ProjectTemplate) Cursor {
	return p.order.Field.toCursor(pt)
}

func (p *projectTemplatePager) applyCursors(query *ProjectTemplateQuery, after, before *Cursor) *ProjectTemplateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProjectTemplateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *projectTemplatePager) applyOrder(query *ProjectTemplateQuery, reverse bool) *ProjectTemplateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProjectTemplateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProjectTemplateOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProjectTemplate.
func (pt *ProjectTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectTemplatePaginateOption,
) (*ProjectTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectTemplatePager(opts)
	if err != nil {
		return nil, err
	}

	if pt, err = pager.applyFilter(pt); err != nil {
		return nil, err
	}

	conn := &ProjectTemplateConnection{Edges: []*ProjectTemplateEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pt = pager.applyCursors(pt, after, before)
	pt = pager.applyOrder(pt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pt = pt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pt = pt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProjectTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProjectTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProjectTemplate {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProjectTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProjectTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProjectTemplateOrderField defines the ordering field of ProjectTemplate.
type ProjectTemplateOrderField struct {
	field    string
	toCursor func(*ProjectTemplate) Cursor
}

// ProjectTemplateOrder defines the ordering of ProjectTemplate.
type ProjectTemplateOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ProjectTemplateOrderField `json:"field"`
}

// DefaultProjectTemplateOrder is the default ordering of ProjectTemplate.
var DefaultProjectTemplateOrder = &ProjectTemplateOrder{
	Direction: OrderDirectionAsc,
	Field: &ProjectTemplateOrderField{
		field: projecttemplate.FieldID,
		toCursor: func(pt *ProjectTemplate) Cursor {
			return Cursor{ID: pt.ID}
		},
	},
}

// ProjectTypeEdge is the edge representation of ProjectType.
type ProjectTypeEdge struct {
	Node   *ProjectType `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ProjectTypeConnection is the connection containing edges to ProjectType.
type ProjectTypeConnection struct {
	Edges      []*ProjectTypeEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// ProjectTypePaginateOption enables pagination customization.
type ProjectTypePaginateOption func(*projectTypePager) error

// WithProjectTypeOrder configures pagination ordering.
func WithProjectTypeOrder(order *ProjectTypeOrder) ProjectTypePaginateOption {
	if order == nil {
		order = DefaultProjectTypeOrder
	}
	o := *order
	return func(pager *projectTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectTypeFilter configures pagination filter.
func WithProjectTypeFilter(filter func(*ProjectTypeQuery) (*ProjectTypeQuery, error)) ProjectTypePaginateOption {
	return func(pager *projectTypePager) error {
		if filter == nil {
			return errors.New("ProjectTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectTypePager struct {
	order  *ProjectTypeOrder
	filter func(*ProjectTypeQuery) (*ProjectTypeQuery, error)
}

func newProjectTypePager(opts []ProjectTypePaginateOption) (*projectTypePager, error) {
	pager := &projectTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectTypeOrder
	}
	return pager, nil
}

func (p *projectTypePager) applyFilter(query *ProjectTypeQuery) (*ProjectTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectTypePager) toCursor(pt *ProjectType) Cursor {
	return p.order.Field.toCursor(pt)
}

func (p *projectTypePager) applyCursors(query *ProjectTypeQuery, after, before *Cursor) *ProjectTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProjectTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *projectTypePager) applyOrder(query *ProjectTypeQuery, reverse bool) *ProjectTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProjectTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProjectTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProjectType.
func (pt *ProjectTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectTypePaginateOption,
) (*ProjectTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectTypePager(opts)
	if err != nil {
		return nil, err
	}

	if pt, err = pager.applyFilter(pt); err != nil {
		return nil, err
	}

	conn := &ProjectTypeConnection{Edges: []*ProjectTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pt = pager.applyCursors(pt, after, before)
	pt = pager.applyOrder(pt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pt = pt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pt = pt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProjectType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProjectType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProjectType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProjectTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProjectTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProjectTypeOrderField defines the ordering field of ProjectType.
type ProjectTypeOrderField struct {
	field    string
	toCursor func(*ProjectType) Cursor
}

// ProjectTypeOrder defines the ordering of ProjectType.
type ProjectTypeOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ProjectTypeOrderField `json:"field"`
}

// DefaultProjectTypeOrder is the default ordering of ProjectType.
var DefaultProjectTypeOrder = &ProjectTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &ProjectTypeOrderField{
		field: projecttype.FieldID,
		toCursor: func(pt *ProjectType) Cursor {
			return Cursor{ID: pt.ID}
		},
	},
}

// PropertyEdge is the edge representation of Property.
type PropertyEdge struct {
	Node   *Property `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// PropertyConnection is the connection containing edges to Property.
type PropertyConnection struct {
	Edges      []*PropertyEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// PropertyPaginateOption enables pagination customization.
type PropertyPaginateOption func(*propertyPager) error

// WithPropertyOrder configures pagination ordering.
func WithPropertyOrder(order *PropertyOrder) PropertyPaginateOption {
	if order == nil {
		order = DefaultPropertyOrder
	}
	o := *order
	return func(pager *propertyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPropertyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPropertyFilter configures pagination filter.
func WithPropertyFilter(filter func(*PropertyQuery) (*PropertyQuery, error)) PropertyPaginateOption {
	return func(pager *propertyPager) error {
		if filter == nil {
			return errors.New("PropertyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type propertyPager struct {
	order  *PropertyOrder
	filter func(*PropertyQuery) (*PropertyQuery, error)
}

func newPropertyPager(opts []PropertyPaginateOption) (*propertyPager, error) {
	pager := &propertyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPropertyOrder
	}
	return pager, nil
}

func (p *propertyPager) applyFilter(query *PropertyQuery) (*PropertyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *propertyPager) toCursor(pr *Property) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *propertyPager) applyCursors(query *PropertyQuery, after, before *Cursor) *PropertyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPropertyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *propertyPager) applyOrder(query *PropertyQuery, reverse bool) *PropertyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPropertyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPropertyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Property.
func (pr *PropertyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PropertyPaginateOption,
) (*PropertyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPropertyPager(opts)
	if err != nil {
		return nil, err
	}

	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}

	conn := &PropertyConnection{Edges: []*PropertyEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pr = pr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Property
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Property {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Property {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PropertyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PropertyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// PropertyOrderField defines the ordering field of Property.
type PropertyOrderField struct {
	field    string
	toCursor func(*Property) Cursor
}

// PropertyOrder defines the ordering of Property.
type PropertyOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *PropertyOrderField `json:"field"`
}

// DefaultPropertyOrder is the default ordering of Property.
var DefaultPropertyOrder = &PropertyOrder{
	Direction: OrderDirectionAsc,
	Field: &PropertyOrderField{
		field: property.FieldID,
		toCursor: func(pr *Property) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// PropertyCategoryEdge is the edge representation of PropertyCategory.
type PropertyCategoryEdge struct {
	Node   *PropertyCategory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// PropertyCategoryConnection is the connection containing edges to PropertyCategory.
type PropertyCategoryConnection struct {
	Edges      []*PropertyCategoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// PropertyCategoryPaginateOption enables pagination customization.
type PropertyCategoryPaginateOption func(*propertyCategoryPager) error

// WithPropertyCategoryOrder configures pagination ordering.
func WithPropertyCategoryOrder(order *PropertyCategoryOrder) PropertyCategoryPaginateOption {
	if order == nil {
		order = DefaultPropertyCategoryOrder
	}
	o := *order
	return func(pager *propertyCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPropertyCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPropertyCategoryFilter configures pagination filter.
func WithPropertyCategoryFilter(filter func(*PropertyCategoryQuery) (*PropertyCategoryQuery, error)) PropertyCategoryPaginateOption {
	return func(pager *propertyCategoryPager) error {
		if filter == nil {
			return errors.New("PropertyCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type propertyCategoryPager struct {
	order  *PropertyCategoryOrder
	filter func(*PropertyCategoryQuery) (*PropertyCategoryQuery, error)
}

func newPropertyCategoryPager(opts []PropertyCategoryPaginateOption) (*propertyCategoryPager, error) {
	pager := &propertyCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPropertyCategoryOrder
	}
	return pager, nil
}

func (p *propertyCategoryPager) applyFilter(query *PropertyCategoryQuery) (*PropertyCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *propertyCategoryPager) toCursor(pc *PropertyCategory) Cursor {
	return p.order.Field.toCursor(pc)
}

func (p *propertyCategoryPager) applyCursors(query *PropertyCategoryQuery, after, before *Cursor) *PropertyCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPropertyCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *propertyCategoryPager) applyOrder(query *PropertyCategoryQuery, reverse bool) *PropertyCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPropertyCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPropertyCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to PropertyCategory.
func (pc *PropertyCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PropertyCategoryPaginateOption,
) (*PropertyCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPropertyCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if pc, err = pager.applyFilter(pc); err != nil {
		return nil, err
	}

	conn := &PropertyCategoryConnection{Edges: []*PropertyCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pc = pager.applyCursors(pc, after, before)
	pc = pager.applyOrder(pc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pc = pc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pc = pc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *PropertyCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PropertyCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PropertyCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PropertyCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PropertyCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// PropertyCategoryOrderFieldName orders PropertyCategory by name.
	PropertyCategoryOrderFieldName = &PropertyCategoryOrderField{
		field: propertycategory.FieldName,
		toCursor: func(pc *PropertyCategory) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.Name,
			}
		},
	}
	// PropertyCategoryOrderFieldIndex orders PropertyCategory by index.
	PropertyCategoryOrderFieldIndex = &PropertyCategoryOrderField{
		field: propertycategory.FieldIndex,
		toCursor: func(pc *PropertyCategory) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.Index,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PropertyCategoryOrderField) String() string {
	var str string
	switch f.field {
	case propertycategory.FieldName:
		str = "NAME"
	case propertycategory.FieldIndex:
		str = "INDEX"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PropertyCategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PropertyCategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PropertyCategoryOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *PropertyCategoryOrderFieldName
	case "INDEX":
		*f = *PropertyCategoryOrderFieldIndex
	default:
		return fmt.Errorf("%s is not a valid PropertyCategoryOrderField", str)
	}
	return nil
}

// PropertyCategoryOrderField defines the ordering field of PropertyCategory.
type PropertyCategoryOrderField struct {
	field    string
	toCursor func(*PropertyCategory) Cursor
}

// PropertyCategoryOrder defines the ordering of PropertyCategory.
type PropertyCategoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *PropertyCategoryOrderField `json:"field"`
}

// DefaultPropertyCategoryOrder is the default ordering of PropertyCategory.
var DefaultPropertyCategoryOrder = &PropertyCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &PropertyCategoryOrderField{
		field: propertycategory.FieldID,
		toCursor: func(pc *PropertyCategory) Cursor {
			return Cursor{ID: pc.ID}
		},
	},
}

// PropertyTypeEdge is the edge representation of PropertyType.
type PropertyTypeEdge struct {
	Node   *PropertyType `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// PropertyTypeConnection is the connection containing edges to PropertyType.
type PropertyTypeConnection struct {
	Edges      []*PropertyTypeEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// PropertyTypePaginateOption enables pagination customization.
type PropertyTypePaginateOption func(*propertyTypePager) error

// WithPropertyTypeOrder configures pagination ordering.
func WithPropertyTypeOrder(order *PropertyTypeOrder) PropertyTypePaginateOption {
	if order == nil {
		order = DefaultPropertyTypeOrder
	}
	o := *order
	return func(pager *propertyTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPropertyTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPropertyTypeFilter configures pagination filter.
func WithPropertyTypeFilter(filter func(*PropertyTypeQuery) (*PropertyTypeQuery, error)) PropertyTypePaginateOption {
	return func(pager *propertyTypePager) error {
		if filter == nil {
			return errors.New("PropertyTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type propertyTypePager struct {
	order  *PropertyTypeOrder
	filter func(*PropertyTypeQuery) (*PropertyTypeQuery, error)
}

func newPropertyTypePager(opts []PropertyTypePaginateOption) (*propertyTypePager, error) {
	pager := &propertyTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPropertyTypeOrder
	}
	return pager, nil
}

func (p *propertyTypePager) applyFilter(query *PropertyTypeQuery) (*PropertyTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *propertyTypePager) toCursor(pt *PropertyType) Cursor {
	return p.order.Field.toCursor(pt)
}

func (p *propertyTypePager) applyCursors(query *PropertyTypeQuery, after, before *Cursor) *PropertyTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPropertyTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *propertyTypePager) applyOrder(query *PropertyTypeQuery, reverse bool) *PropertyTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPropertyTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPropertyTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to PropertyType.
func (pt *PropertyTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PropertyTypePaginateOption,
) (*PropertyTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPropertyTypePager(opts)
	if err != nil {
		return nil, err
	}

	if pt, err = pager.applyFilter(pt); err != nil {
		return nil, err
	}

	conn := &PropertyTypeConnection{Edges: []*PropertyTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pt = pager.applyCursors(pt, after, before)
	pt = pager.applyOrder(pt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pt = pt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pt = pt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *PropertyType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PropertyType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PropertyType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PropertyTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PropertyTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// PropertyTypeOrderField defines the ordering field of PropertyType.
type PropertyTypeOrderField struct {
	field    string
	toCursor func(*PropertyType) Cursor
}

// PropertyTypeOrder defines the ordering of PropertyType.
type PropertyTypeOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *PropertyTypeOrderField `json:"field"`
}

// DefaultPropertyTypeOrder is the default ordering of PropertyType.
var DefaultPropertyTypeOrder = &PropertyTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &PropertyTypeOrderField{
		field: propertytype.FieldID,
		toCursor: func(pt *PropertyType) Cursor {
			return Cursor{ID: pt.ID}
		},
	},
}

// RecommendationsEdge is the edge representation of Recommendations.
type RecommendationsEdge struct {
	Node   *Recommendations `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// RecommendationsConnection is the connection containing edges to Recommendations.
type RecommendationsConnection struct {
	Edges      []*RecommendationsEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// RecommendationsPaginateOption enables pagination customization.
type RecommendationsPaginateOption func(*recommendationsPager) error

// WithRecommendationsOrder configures pagination ordering.
func WithRecommendationsOrder(order *RecommendationsOrder) RecommendationsPaginateOption {
	if order == nil {
		order = DefaultRecommendationsOrder
	}
	o := *order
	return func(pager *recommendationsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRecommendationsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRecommendationsFilter configures pagination filter.
func WithRecommendationsFilter(filter func(*RecommendationsQuery) (*RecommendationsQuery, error)) RecommendationsPaginateOption {
	return func(pager *recommendationsPager) error {
		if filter == nil {
			return errors.New("RecommendationsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type recommendationsPager struct {
	order  *RecommendationsOrder
	filter func(*RecommendationsQuery) (*RecommendationsQuery, error)
}

func newRecommendationsPager(opts []RecommendationsPaginateOption) (*recommendationsPager, error) {
	pager := &recommendationsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRecommendationsOrder
	}
	return pager, nil
}

func (p *recommendationsPager) applyFilter(query *RecommendationsQuery) (*RecommendationsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *recommendationsPager) toCursor(r *Recommendations) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *recommendationsPager) applyCursors(query *RecommendationsQuery, after, before *Cursor) *RecommendationsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRecommendationsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *recommendationsPager) applyOrder(query *RecommendationsQuery, reverse bool) *RecommendationsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRecommendationsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRecommendationsOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Recommendations.
func (r *RecommendationsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RecommendationsPaginateOption,
) (*RecommendationsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRecommendationsPager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RecommendationsConnection{Edges: []*RecommendationsEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Recommendations
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Recommendations {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Recommendations {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RecommendationsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RecommendationsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RecommendationsOrderFieldExternalId orders Recommendations by externalId.
	RecommendationsOrderFieldExternalId = &RecommendationsOrderField{
		field: recommendations.FieldExternalId,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.ExternalId,
			}
		},
	}
	// RecommendationsOrderFieldResource orders Recommendations by resource.
	RecommendationsOrderFieldResource = &RecommendationsOrderField{
		field: recommendations.FieldResource,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Resource,
			}
		},
	}
	// RecommendationsOrderFieldAlarmType orders Recommendations by alarmType.
	RecommendationsOrderFieldAlarmType = &RecommendationsOrderField{
		field: recommendations.FieldAlarmType,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.AlarmType,
			}
		},
	}
	// RecommendationsOrderFieldShortDescription orders Recommendations by shortDescription.
	RecommendationsOrderFieldShortDescription = &RecommendationsOrderField{
		field: recommendations.FieldShortDescription,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.ShortDescription,
			}
		},
	}
	// RecommendationsOrderFieldLongDescription orders Recommendations by longDescription.
	RecommendationsOrderFieldLongDescription = &RecommendationsOrderField{
		field: recommendations.FieldLongDescription,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.LongDescription,
			}
		},
	}
	// RecommendationsOrderFieldCommand orders Recommendations by command.
	RecommendationsOrderFieldCommand = &RecommendationsOrderField{
		field: recommendations.FieldCommand,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Command,
			}
		},
	}
	// RecommendationsOrderFieldPriority orders Recommendations by priority.
	RecommendationsOrderFieldPriority = &RecommendationsOrderField{
		field: recommendations.FieldPriority,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Priority,
			}
		},
	}
	// RecommendationsOrderFieldStatus orders Recommendations by status.
	RecommendationsOrderFieldStatus = &RecommendationsOrderField{
		field: recommendations.FieldStatus,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Status,
			}
		},
	}
	// RecommendationsOrderFieldUsed orders Recommendations by used.
	RecommendationsOrderFieldUsed = &RecommendationsOrderField{
		field: recommendations.FieldUsed,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Used,
			}
		},
	}
	// RecommendationsOrderFieldRunbook orders Recommendations by runbook.
	RecommendationsOrderFieldRunbook = &RecommendationsOrderField{
		field: recommendations.FieldRunbook,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Runbook,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RecommendationsOrderField) String() string {
	var str string
	switch f.field {
	case recommendations.FieldExternalId:
		str = "EXTERNALID"
	case recommendations.FieldResource:
		str = "RESOURCE"
	case recommendations.FieldAlarmType:
		str = "ALARMTYPE"
	case recommendations.FieldShortDescription:
		str = "SHORTDESCRIPTION"
	case recommendations.FieldLongDescription:
		str = "LONGDESCRIPTION"
	case recommendations.FieldCommand:
		str = "COMMAND"
	case recommendations.FieldPriority:
		str = "PRIORITY"
	case recommendations.FieldStatus:
		str = "STATUS"
	case recommendations.FieldUsed:
		str = "USED"
	case recommendations.FieldRunbook:
		str = "RUNBOOK"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RecommendationsOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RecommendationsOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RecommendationsOrderField %T must be a string", v)
	}
	switch str {
	case "EXTERNALID":
		*f = *RecommendationsOrderFieldExternalId
	case "RESOURCE":
		*f = *RecommendationsOrderFieldResource
	case "ALARMTYPE":
		*f = *RecommendationsOrderFieldAlarmType
	case "SHORTDESCRIPTION":
		*f = *RecommendationsOrderFieldShortDescription
	case "LONGDESCRIPTION":
		*f = *RecommendationsOrderFieldLongDescription
	case "COMMAND":
		*f = *RecommendationsOrderFieldCommand
	case "PRIORITY":
		*f = *RecommendationsOrderFieldPriority
	case "STATUS":
		*f = *RecommendationsOrderFieldStatus
	case "USED":
		*f = *RecommendationsOrderFieldUsed
	case "RUNBOOK":
		*f = *RecommendationsOrderFieldRunbook
	default:
		return fmt.Errorf("%s is not a valid RecommendationsOrderField", str)
	}
	return nil
}

// RecommendationsOrderField defines the ordering field of Recommendations.
type RecommendationsOrderField struct {
	field    string
	toCursor func(*Recommendations) Cursor
}

// RecommendationsOrder defines the ordering of Recommendations.
type RecommendationsOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *RecommendationsOrderField `json:"field"`
}

// DefaultRecommendationsOrder is the default ordering of Recommendations.
var DefaultRecommendationsOrder = &RecommendationsOrder{
	Direction: OrderDirectionAsc,
	Field: &RecommendationsOrderField{
		field: recommendations.FieldID,
		toCursor: func(r *Recommendations) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// RecommendationsCategoryEdge is the edge representation of RecommendationsCategory.
type RecommendationsCategoryEdge struct {
	Node   *RecommendationsCategory `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// RecommendationsCategoryConnection is the connection containing edges to RecommendationsCategory.
type RecommendationsCategoryConnection struct {
	Edges      []*RecommendationsCategoryEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

// RecommendationsCategoryPaginateOption enables pagination customization.
type RecommendationsCategoryPaginateOption func(*recommendationsCategoryPager) error

// WithRecommendationsCategoryOrder configures pagination ordering.
func WithRecommendationsCategoryOrder(order *RecommendationsCategoryOrder) RecommendationsCategoryPaginateOption {
	if order == nil {
		order = DefaultRecommendationsCategoryOrder
	}
	o := *order
	return func(pager *recommendationsCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRecommendationsCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRecommendationsCategoryFilter configures pagination filter.
func WithRecommendationsCategoryFilter(filter func(*RecommendationsCategoryQuery) (*RecommendationsCategoryQuery, error)) RecommendationsCategoryPaginateOption {
	return func(pager *recommendationsCategoryPager) error {
		if filter == nil {
			return errors.New("RecommendationsCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type recommendationsCategoryPager struct {
	order  *RecommendationsCategoryOrder
	filter func(*RecommendationsCategoryQuery) (*RecommendationsCategoryQuery, error)
}

func newRecommendationsCategoryPager(opts []RecommendationsCategoryPaginateOption) (*recommendationsCategoryPager, error) {
	pager := &recommendationsCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRecommendationsCategoryOrder
	}
	return pager, nil
}

func (p *recommendationsCategoryPager) applyFilter(query *RecommendationsCategoryQuery) (*RecommendationsCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *recommendationsCategoryPager) toCursor(rc *RecommendationsCategory) Cursor {
	return p.order.Field.toCursor(rc)
}

func (p *recommendationsCategoryPager) applyCursors(query *RecommendationsCategoryQuery, after, before *Cursor) *RecommendationsCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRecommendationsCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *recommendationsCategoryPager) applyOrder(query *RecommendationsCategoryQuery, reverse bool) *RecommendationsCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRecommendationsCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRecommendationsCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to RecommendationsCategory.
func (rc *RecommendationsCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RecommendationsCategoryPaginateOption,
) (*RecommendationsCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRecommendationsCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if rc, err = pager.applyFilter(rc); err != nil {
		return nil, err
	}

	conn := &RecommendationsCategoryConnection{Edges: []*RecommendationsCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := rc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rc = pager.applyCursors(rc, after, before)
	rc = pager.applyOrder(rc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rc = rc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rc = rc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *RecommendationsCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RecommendationsCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RecommendationsCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RecommendationsCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RecommendationsCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RecommendationsCategoryOrderFieldName orders RecommendationsCategory by name.
	RecommendationsCategoryOrderFieldName = &RecommendationsCategoryOrderField{
		field: recommendationscategory.FieldName,
		toCursor: func(rc *RecommendationsCategory) Cursor {
			return Cursor{
				ID:    rc.ID,
				Value: rc.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RecommendationsCategoryOrderField) String() string {
	var str string
	switch f.field {
	case recommendationscategory.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RecommendationsCategoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RecommendationsCategoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RecommendationsCategoryOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *RecommendationsCategoryOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid RecommendationsCategoryOrderField", str)
	}
	return nil
}

// RecommendationsCategoryOrderField defines the ordering field of RecommendationsCategory.
type RecommendationsCategoryOrderField struct {
	field    string
	toCursor func(*RecommendationsCategory) Cursor
}

// RecommendationsCategoryOrder defines the ordering of RecommendationsCategory.
type RecommendationsCategoryOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *RecommendationsCategoryOrderField `json:"field"`
}

// DefaultRecommendationsCategoryOrder is the default ordering of RecommendationsCategory.
var DefaultRecommendationsCategoryOrder = &RecommendationsCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &RecommendationsCategoryOrderField{
		field: recommendationscategory.FieldID,
		toCursor: func(rc *RecommendationsCategory) Cursor {
			return Cursor{ID: rc.ID}
		},
	},
}

// RecommendationsSourcesEdge is the edge representation of RecommendationsSources.
type RecommendationsSourcesEdge struct {
	Node   *RecommendationsSources `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// RecommendationsSourcesConnection is the connection containing edges to RecommendationsSources.
type RecommendationsSourcesConnection struct {
	Edges      []*RecommendationsSourcesEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

// RecommendationsSourcesPaginateOption enables pagination customization.
type RecommendationsSourcesPaginateOption func(*recommendationsSourcesPager) error

// WithRecommendationsSourcesOrder configures pagination ordering.
func WithRecommendationsSourcesOrder(order *RecommendationsSourcesOrder) RecommendationsSourcesPaginateOption {
	if order == nil {
		order = DefaultRecommendationsSourcesOrder
	}
	o := *order
	return func(pager *recommendationsSourcesPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRecommendationsSourcesOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRecommendationsSourcesFilter configures pagination filter.
func WithRecommendationsSourcesFilter(filter func(*RecommendationsSourcesQuery) (*RecommendationsSourcesQuery, error)) RecommendationsSourcesPaginateOption {
	return func(pager *recommendationsSourcesPager) error {
		if filter == nil {
			return errors.New("RecommendationsSourcesQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type recommendationsSourcesPager struct {
	order  *RecommendationsSourcesOrder
	filter func(*RecommendationsSourcesQuery) (*RecommendationsSourcesQuery, error)
}

func newRecommendationsSourcesPager(opts []RecommendationsSourcesPaginateOption) (*recommendationsSourcesPager, error) {
	pager := &recommendationsSourcesPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRecommendationsSourcesOrder
	}
	return pager, nil
}

func (p *recommendationsSourcesPager) applyFilter(query *RecommendationsSourcesQuery) (*RecommendationsSourcesQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *recommendationsSourcesPager) toCursor(rs *RecommendationsSources) Cursor {
	return p.order.Field.toCursor(rs)
}

func (p *recommendationsSourcesPager) applyCursors(query *RecommendationsSourcesQuery, after, before *Cursor) *RecommendationsSourcesQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRecommendationsSourcesOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *recommendationsSourcesPager) applyOrder(query *RecommendationsSourcesQuery, reverse bool) *RecommendationsSourcesQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRecommendationsSourcesOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRecommendationsSourcesOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to RecommendationsSources.
func (rs *RecommendationsSourcesQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RecommendationsSourcesPaginateOption,
) (*RecommendationsSourcesConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRecommendationsSourcesPager(opts)
	if err != nil {
		return nil, err
	}

	if rs, err = pager.applyFilter(rs); err != nil {
		return nil, err
	}

	conn := &RecommendationsSourcesConnection{Edges: []*RecommendationsSourcesEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rs.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := rs.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rs = pager.applyCursors(rs, after, before)
	rs = pager.applyOrder(rs, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rs = rs.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rs = rs.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rs.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *RecommendationsSources
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RecommendationsSources {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RecommendationsSources {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RecommendationsSourcesEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RecommendationsSourcesEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RecommendationsSourcesOrderFieldName orders RecommendationsSources by name.
	RecommendationsSourcesOrderFieldName = &RecommendationsSourcesOrderField{
		field: recommendationssources.FieldName,
		toCursor: func(rs *RecommendationsSources) Cursor {
			return Cursor{
				ID:    rs.ID,
				Value: rs.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RecommendationsSourcesOrderField) String() string {
	var str string
	switch f.field {
	case recommendationssources.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RecommendationsSourcesOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RecommendationsSourcesOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RecommendationsSourcesOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *RecommendationsSourcesOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid RecommendationsSourcesOrderField", str)
	}
	return nil
}

// RecommendationsSourcesOrderField defines the ordering field of RecommendationsSources.
type RecommendationsSourcesOrderField struct {
	field    string
	toCursor func(*RecommendationsSources) Cursor
}

// RecommendationsSourcesOrder defines the ordering of RecommendationsSources.
type RecommendationsSourcesOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *RecommendationsSourcesOrderField `json:"field"`
}

// DefaultRecommendationsSourcesOrder is the default ordering of RecommendationsSources.
var DefaultRecommendationsSourcesOrder = &RecommendationsSourcesOrder{
	Direction: OrderDirectionAsc,
	Field: &RecommendationsSourcesOrderField{
		field: recommendationssources.FieldID,
		toCursor: func(rs *RecommendationsSources) Cursor {
			return Cursor{ID: rs.ID}
		},
	},
}

// ReportFilterEdge is the edge representation of ReportFilter.
type ReportFilterEdge struct {
	Node   *ReportFilter `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ReportFilterConnection is the connection containing edges to ReportFilter.
type ReportFilterConnection struct {
	Edges      []*ReportFilterEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// ReportFilterPaginateOption enables pagination customization.
type ReportFilterPaginateOption func(*reportFilterPager) error

// WithReportFilterOrder configures pagination ordering.
func WithReportFilterOrder(order *ReportFilterOrder) ReportFilterPaginateOption {
	if order == nil {
		order = DefaultReportFilterOrder
	}
	o := *order
	return func(pager *reportFilterPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReportFilterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReportFilterFilter configures pagination filter.
func WithReportFilterFilter(filter func(*ReportFilterQuery) (*ReportFilterQuery, error)) ReportFilterPaginateOption {
	return func(pager *reportFilterPager) error {
		if filter == nil {
			return errors.New("ReportFilterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type reportFilterPager struct {
	order  *ReportFilterOrder
	filter func(*ReportFilterQuery) (*ReportFilterQuery, error)
}

func newReportFilterPager(opts []ReportFilterPaginateOption) (*reportFilterPager, error) {
	pager := &reportFilterPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReportFilterOrder
	}
	return pager, nil
}

func (p *reportFilterPager) applyFilter(query *ReportFilterQuery) (*ReportFilterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *reportFilterPager) toCursor(rf *ReportFilter) Cursor {
	return p.order.Field.toCursor(rf)
}

func (p *reportFilterPager) applyCursors(query *ReportFilterQuery, after, before *Cursor) *ReportFilterQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReportFilterOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *reportFilterPager) applyOrder(query *ReportFilterQuery, reverse bool) *ReportFilterQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReportFilterOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReportFilterOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReportFilter.
func (rf *ReportFilterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReportFilterPaginateOption,
) (*ReportFilterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReportFilterPager(opts)
	if err != nil {
		return nil, err
	}

	if rf, err = pager.applyFilter(rf); err != nil {
		return nil, err
	}

	conn := &ReportFilterConnection{Edges: []*ReportFilterEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rf.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := rf.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rf = pager.applyCursors(rf, after, before)
	rf = pager.applyOrder(rf, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rf = rf.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rf = rf.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rf.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReportFilter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReportFilter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReportFilter {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReportFilterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReportFilterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ReportFilterOrderField defines the ordering field of ReportFilter.
type ReportFilterOrderField struct {
	field    string
	toCursor func(*ReportFilter) Cursor
}

// ReportFilterOrder defines the ordering of ReportFilter.
type ReportFilterOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ReportFilterOrderField `json:"field"`
}

// DefaultReportFilterOrder is the default ordering of ReportFilter.
var DefaultReportFilterOrder = &ReportFilterOrder{
	Direction: OrderDirectionAsc,
	Field: &ReportFilterOrderField{
		field: reportfilter.FieldID,
		toCursor: func(rf *ReportFilter) Cursor {
			return Cursor{ID: rf.ID}
		},
	},
}

// RuleEdge is the edge representation of Rule.
type RuleEdge struct {
	Node   *Rule  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RuleConnection is the connection containing edges to Rule.
type RuleConnection struct {
	Edges      []*RuleEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// RulePaginateOption enables pagination customization.
type RulePaginateOption func(*rulePager) error

// WithRuleOrder configures pagination ordering.
func WithRuleOrder(order *RuleOrder) RulePaginateOption {
	if order == nil {
		order = DefaultRuleOrder
	}
	o := *order
	return func(pager *rulePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRuleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRuleFilter configures pagination filter.
func WithRuleFilter(filter func(*RuleQuery) (*RuleQuery, error)) RulePaginateOption {
	return func(pager *rulePager) error {
		if filter == nil {
			return errors.New("RuleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type rulePager struct {
	order  *RuleOrder
	filter func(*RuleQuery) (*RuleQuery, error)
}

func newRulePager(opts []RulePaginateOption) (*rulePager, error) {
	pager := &rulePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRuleOrder
	}
	return pager, nil
}

func (p *rulePager) applyFilter(query *RuleQuery) (*RuleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *rulePager) toCursor(r *Rule) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *rulePager) applyCursors(query *RuleQuery, after, before *Cursor) *RuleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRuleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *rulePager) applyOrder(query *RuleQuery, reverse bool) *RuleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRuleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRuleOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Rule.
func (r *RuleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RulePaginateOption,
) (*RuleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRulePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RuleConnection{Edges: []*RuleEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Rule
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Rule {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Rule {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RuleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RuleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// RuleOrderField defines the ordering field of Rule.
type RuleOrderField struct {
	field    string
	toCursor func(*Rule) Cursor
}

// RuleOrder defines the ordering of Rule.
type RuleOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RuleOrderField `json:"field"`
}

// DefaultRuleOrder is the default ordering of Rule.
var DefaultRuleOrder = &RuleOrder{
	Direction: OrderDirectionAsc,
	Field: &RuleOrderField{
		field: rule.FieldID,
		toCursor: func(r *Rule) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// RuleLimitEdge is the edge representation of RuleLimit.
type RuleLimitEdge struct {
	Node   *RuleLimit `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// RuleLimitConnection is the connection containing edges to RuleLimit.
type RuleLimitConnection struct {
	Edges      []*RuleLimitEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// RuleLimitPaginateOption enables pagination customization.
type RuleLimitPaginateOption func(*ruleLimitPager) error

// WithRuleLimitOrder configures pagination ordering.
func WithRuleLimitOrder(order *RuleLimitOrder) RuleLimitPaginateOption {
	if order == nil {
		order = DefaultRuleLimitOrder
	}
	o := *order
	return func(pager *ruleLimitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRuleLimitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRuleLimitFilter configures pagination filter.
func WithRuleLimitFilter(filter func(*RuleLimitQuery) (*RuleLimitQuery, error)) RuleLimitPaginateOption {
	return func(pager *ruleLimitPager) error {
		if filter == nil {
			return errors.New("RuleLimitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ruleLimitPager struct {
	order  *RuleLimitOrder
	filter func(*RuleLimitQuery) (*RuleLimitQuery, error)
}

func newRuleLimitPager(opts []RuleLimitPaginateOption) (*ruleLimitPager, error) {
	pager := &ruleLimitPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRuleLimitOrder
	}
	return pager, nil
}

func (p *ruleLimitPager) applyFilter(query *RuleLimitQuery) (*RuleLimitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ruleLimitPager) toCursor(rl *RuleLimit) Cursor {
	return p.order.Field.toCursor(rl)
}

func (p *ruleLimitPager) applyCursors(query *RuleLimitQuery, after, before *Cursor) *RuleLimitQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRuleLimitOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *ruleLimitPager) applyOrder(query *RuleLimitQuery, reverse bool) *RuleLimitQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRuleLimitOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRuleLimitOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to RuleLimit.
func (rl *RuleLimitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RuleLimitPaginateOption,
) (*RuleLimitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRuleLimitPager(opts)
	if err != nil {
		return nil, err
	}

	if rl, err = pager.applyFilter(rl); err != nil {
		return nil, err
	}

	conn := &RuleLimitConnection{Edges: []*RuleLimitEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := rl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rl = pager.applyCursors(rl, after, before)
	rl = pager.applyOrder(rl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rl = rl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rl = rl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *RuleLimit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RuleLimit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RuleLimit {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RuleLimitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RuleLimitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// RuleLimitOrderField defines the ordering field of RuleLimit.
type RuleLimitOrderField struct {
	field    string
	toCursor func(*RuleLimit) Cursor
}

// RuleLimitOrder defines the ordering of RuleLimit.
type RuleLimitOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *RuleLimitOrderField `json:"field"`
}

// DefaultRuleLimitOrder is the default ordering of RuleLimit.
var DefaultRuleLimitOrder = &RuleLimitOrder{
	Direction: OrderDirectionAsc,
	Field: &RuleLimitOrderField{
		field: rulelimit.FieldID,
		toCursor: func(rl *RuleLimit) Cursor {
			return Cursor{ID: rl.ID}
		},
	},
}

// RuleTypeEdge is the edge representation of RuleType.
type RuleTypeEdge struct {
	Node   *RuleType `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// RuleTypeConnection is the connection containing edges to RuleType.
type RuleTypeConnection struct {
	Edges      []*RuleTypeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// RuleTypePaginateOption enables pagination customization.
type RuleTypePaginateOption func(*ruleTypePager) error

// WithRuleTypeOrder configures pagination ordering.
func WithRuleTypeOrder(order *RuleTypeOrder) RuleTypePaginateOption {
	if order == nil {
		order = DefaultRuleTypeOrder
	}
	o := *order
	return func(pager *ruleTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRuleTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRuleTypeFilter configures pagination filter.
func WithRuleTypeFilter(filter func(*RuleTypeQuery) (*RuleTypeQuery, error)) RuleTypePaginateOption {
	return func(pager *ruleTypePager) error {
		if filter == nil {
			return errors.New("RuleTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ruleTypePager struct {
	order  *RuleTypeOrder
	filter func(*RuleTypeQuery) (*RuleTypeQuery, error)
}

func newRuleTypePager(opts []RuleTypePaginateOption) (*ruleTypePager, error) {
	pager := &ruleTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRuleTypeOrder
	}
	return pager, nil
}

func (p *ruleTypePager) applyFilter(query *RuleTypeQuery) (*RuleTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ruleTypePager) toCursor(rt *RuleType) Cursor {
	return p.order.Field.toCursor(rt)
}

func (p *ruleTypePager) applyCursors(query *RuleTypeQuery, after, before *Cursor) *RuleTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRuleTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *ruleTypePager) applyOrder(query *RuleTypeQuery, reverse bool) *RuleTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRuleTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRuleTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to RuleType.
func (rt *RuleTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RuleTypePaginateOption,
) (*RuleTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRuleTypePager(opts)
	if err != nil {
		return nil, err
	}

	if rt, err = pager.applyFilter(rt); err != nil {
		return nil, err
	}

	conn := &RuleTypeConnection{Edges: []*RuleTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := rt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rt = pager.applyCursors(rt, after, before)
	rt = pager.applyOrder(rt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rt = rt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rt = rt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *RuleType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RuleType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RuleType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RuleTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RuleTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RuleTypeOrderFieldName orders RuleType by name.
	RuleTypeOrderFieldName = &RuleTypeOrderField{
		field: ruletype.FieldName,
		toCursor: func(rt *RuleType) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RuleTypeOrderField) String() string {
	var str string
	switch f.field {
	case ruletype.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RuleTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RuleTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RuleTypeOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *RuleTypeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid RuleTypeOrderField", str)
	}
	return nil
}

// RuleTypeOrderField defines the ordering field of RuleType.
type RuleTypeOrderField struct {
	field    string
	toCursor func(*RuleType) Cursor
}

// RuleTypeOrder defines the ordering of RuleType.
type RuleTypeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *RuleTypeOrderField `json:"field"`
}

// DefaultRuleTypeOrder is the default ordering of RuleType.
var DefaultRuleTypeOrder = &RuleTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &RuleTypeOrderField{
		field: ruletype.FieldID,
		toCursor: func(rt *RuleType) Cursor {
			return Cursor{ID: rt.ID}
		},
	},
}

// ServiceEdge is the edge representation of Service.
type ServiceEdge struct {
	Node   *Service `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ServiceConnection is the connection containing edges to Service.
type ServiceConnection struct {
	Edges      []*ServiceEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ServicePaginateOption enables pagination customization.
type ServicePaginateOption func(*servicePager) error

// WithServiceOrder configures pagination ordering.
func WithServiceOrder(order *ServiceOrder) ServicePaginateOption {
	if order == nil {
		order = DefaultServiceOrder
	}
	o := *order
	return func(pager *servicePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceFilter configures pagination filter.
func WithServiceFilter(filter func(*ServiceQuery) (*ServiceQuery, error)) ServicePaginateOption {
	return func(pager *servicePager) error {
		if filter == nil {
			return errors.New("ServiceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type servicePager struct {
	order  *ServiceOrder
	filter func(*ServiceQuery) (*ServiceQuery, error)
}

func newServicePager(opts []ServicePaginateOption) (*servicePager, error) {
	pager := &servicePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceOrder
	}
	return pager, nil
}

func (p *servicePager) applyFilter(query *ServiceQuery) (*ServiceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *servicePager) toCursor(s *Service) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *servicePager) applyCursors(query *ServiceQuery, after, before *Cursor) *ServiceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultServiceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *servicePager) applyOrder(query *ServiceQuery, reverse bool) *ServiceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultServiceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultServiceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Service.
func (s *ServiceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServicePaginateOption,
) (*ServiceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServicePager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &ServiceConnection{Edges: []*ServiceEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Service
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Service {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Service {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ServiceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ServiceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ServiceOrderField defines the ordering field of Service.
type ServiceOrderField struct {
	field    string
	toCursor func(*Service) Cursor
}

// ServiceOrder defines the ordering of Service.
type ServiceOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ServiceOrderField `json:"field"`
}

// DefaultServiceOrder is the default ordering of Service.
var DefaultServiceOrder = &ServiceOrder{
	Direction: OrderDirectionAsc,
	Field: &ServiceOrderField{
		field: service.FieldID,
		toCursor: func(s *Service) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ServiceEndpointEdge is the edge representation of ServiceEndpoint.
type ServiceEndpointEdge struct {
	Node   *ServiceEndpoint `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ServiceEndpointConnection is the connection containing edges to ServiceEndpoint.
type ServiceEndpointConnection struct {
	Edges      []*ServiceEndpointEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// ServiceEndpointPaginateOption enables pagination customization.
type ServiceEndpointPaginateOption func(*serviceEndpointPager) error

// WithServiceEndpointOrder configures pagination ordering.
func WithServiceEndpointOrder(order *ServiceEndpointOrder) ServiceEndpointPaginateOption {
	if order == nil {
		order = DefaultServiceEndpointOrder
	}
	o := *order
	return func(pager *serviceEndpointPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceEndpointOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceEndpointFilter configures pagination filter.
func WithServiceEndpointFilter(filter func(*ServiceEndpointQuery) (*ServiceEndpointQuery, error)) ServiceEndpointPaginateOption {
	return func(pager *serviceEndpointPager) error {
		if filter == nil {
			return errors.New("ServiceEndpointQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serviceEndpointPager struct {
	order  *ServiceEndpointOrder
	filter func(*ServiceEndpointQuery) (*ServiceEndpointQuery, error)
}

func newServiceEndpointPager(opts []ServiceEndpointPaginateOption) (*serviceEndpointPager, error) {
	pager := &serviceEndpointPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceEndpointOrder
	}
	return pager, nil
}

func (p *serviceEndpointPager) applyFilter(query *ServiceEndpointQuery) (*ServiceEndpointQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serviceEndpointPager) toCursor(se *ServiceEndpoint) Cursor {
	return p.order.Field.toCursor(se)
}

func (p *serviceEndpointPager) applyCursors(query *ServiceEndpointQuery, after, before *Cursor) *ServiceEndpointQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultServiceEndpointOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *serviceEndpointPager) applyOrder(query *ServiceEndpointQuery, reverse bool) *ServiceEndpointQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultServiceEndpointOrder.Field {
		query = query.Order(direction.orderFunc(DefaultServiceEndpointOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ServiceEndpoint.
func (se *ServiceEndpointQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceEndpointPaginateOption,
) (*ServiceEndpointConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceEndpointPager(opts)
	if err != nil {
		return nil, err
	}

	if se, err = pager.applyFilter(se); err != nil {
		return nil, err
	}

	conn := &ServiceEndpointConnection{Edges: []*ServiceEndpointEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := se.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := se.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	se = pager.applyCursors(se, after, before)
	se = pager.applyOrder(se, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		se = se.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		se = se.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := se.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ServiceEndpoint
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceEndpoint {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceEndpoint {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ServiceEndpointEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ServiceEndpointEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ServiceEndpointOrderField defines the ordering field of ServiceEndpoint.
type ServiceEndpointOrderField struct {
	field    string
	toCursor func(*ServiceEndpoint) Cursor
}

// ServiceEndpointOrder defines the ordering of ServiceEndpoint.
type ServiceEndpointOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ServiceEndpointOrderField `json:"field"`
}

// DefaultServiceEndpointOrder is the default ordering of ServiceEndpoint.
var DefaultServiceEndpointOrder = &ServiceEndpointOrder{
	Direction: OrderDirectionAsc,
	Field: &ServiceEndpointOrderField{
		field: serviceendpoint.FieldID,
		toCursor: func(se *ServiceEndpoint) Cursor {
			return Cursor{ID: se.ID}
		},
	},
}

// ServiceEndpointDefinitionEdge is the edge representation of ServiceEndpointDefinition.
type ServiceEndpointDefinitionEdge struct {
	Node   *ServiceEndpointDefinition `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// ServiceEndpointDefinitionConnection is the connection containing edges to ServiceEndpointDefinition.
type ServiceEndpointDefinitionConnection struct {
	Edges      []*ServiceEndpointDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

// ServiceEndpointDefinitionPaginateOption enables pagination customization.
type ServiceEndpointDefinitionPaginateOption func(*serviceEndpointDefinitionPager) error

// WithServiceEndpointDefinitionOrder configures pagination ordering.
func WithServiceEndpointDefinitionOrder(order *ServiceEndpointDefinitionOrder) ServiceEndpointDefinitionPaginateOption {
	if order == nil {
		order = DefaultServiceEndpointDefinitionOrder
	}
	o := *order
	return func(pager *serviceEndpointDefinitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceEndpointDefinitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceEndpointDefinitionFilter configures pagination filter.
func WithServiceEndpointDefinitionFilter(filter func(*ServiceEndpointDefinitionQuery) (*ServiceEndpointDefinitionQuery, error)) ServiceEndpointDefinitionPaginateOption {
	return func(pager *serviceEndpointDefinitionPager) error {
		if filter == nil {
			return errors.New("ServiceEndpointDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serviceEndpointDefinitionPager struct {
	order  *ServiceEndpointDefinitionOrder
	filter func(*ServiceEndpointDefinitionQuery) (*ServiceEndpointDefinitionQuery, error)
}

func newServiceEndpointDefinitionPager(opts []ServiceEndpointDefinitionPaginateOption) (*serviceEndpointDefinitionPager, error) {
	pager := &serviceEndpointDefinitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceEndpointDefinitionOrder
	}
	return pager, nil
}

func (p *serviceEndpointDefinitionPager) applyFilter(query *ServiceEndpointDefinitionQuery) (*ServiceEndpointDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serviceEndpointDefinitionPager) toCursor(sed *ServiceEndpointDefinition) Cursor {
	return p.order.Field.toCursor(sed)
}

func (p *serviceEndpointDefinitionPager) applyCursors(query *ServiceEndpointDefinitionQuery, after, before *Cursor) *ServiceEndpointDefinitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultServiceEndpointDefinitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *serviceEndpointDefinitionPager) applyOrder(query *ServiceEndpointDefinitionQuery, reverse bool) *ServiceEndpointDefinitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultServiceEndpointDefinitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultServiceEndpointDefinitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ServiceEndpointDefinition.
func (sed *ServiceEndpointDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceEndpointDefinitionPaginateOption,
) (*ServiceEndpointDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceEndpointDefinitionPager(opts)
	if err != nil {
		return nil, err
	}

	if sed, err = pager.applyFilter(sed); err != nil {
		return nil, err
	}

	conn := &ServiceEndpointDefinitionConnection{Edges: []*ServiceEndpointDefinitionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := sed.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := sed.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	sed = pager.applyCursors(sed, after, before)
	sed = pager.applyOrder(sed, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		sed = sed.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		sed = sed.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := sed.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ServiceEndpointDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceEndpointDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceEndpointDefinition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ServiceEndpointDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ServiceEndpointDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ServiceEndpointDefinitionOrderField defines the ordering field of ServiceEndpointDefinition.
type ServiceEndpointDefinitionOrderField struct {
	field    string
	toCursor func(*ServiceEndpointDefinition) Cursor
}

// ServiceEndpointDefinitionOrder defines the ordering of ServiceEndpointDefinition.
type ServiceEndpointDefinitionOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *ServiceEndpointDefinitionOrderField `json:"field"`
}

// DefaultServiceEndpointDefinitionOrder is the default ordering of ServiceEndpointDefinition.
var DefaultServiceEndpointDefinitionOrder = &ServiceEndpointDefinitionOrder{
	Direction: OrderDirectionAsc,
	Field: &ServiceEndpointDefinitionOrderField{
		field: serviceendpointdefinition.FieldID,
		toCursor: func(sed *ServiceEndpointDefinition) Cursor {
			return Cursor{ID: sed.ID}
		},
	},
}

// ServiceTypeEdge is the edge representation of ServiceType.
type ServiceTypeEdge struct {
	Node   *ServiceType `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ServiceTypeConnection is the connection containing edges to ServiceType.
type ServiceTypeConnection struct {
	Edges      []*ServiceTypeEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// ServiceTypePaginateOption enables pagination customization.
type ServiceTypePaginateOption func(*serviceTypePager) error

// WithServiceTypeOrder configures pagination ordering.
func WithServiceTypeOrder(order *ServiceTypeOrder) ServiceTypePaginateOption {
	if order == nil {
		order = DefaultServiceTypeOrder
	}
	o := *order
	return func(pager *serviceTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceTypeFilter configures pagination filter.
func WithServiceTypeFilter(filter func(*ServiceTypeQuery) (*ServiceTypeQuery, error)) ServiceTypePaginateOption {
	return func(pager *serviceTypePager) error {
		if filter == nil {
			return errors.New("ServiceTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serviceTypePager struct {
	order  *ServiceTypeOrder
	filter func(*ServiceTypeQuery) (*ServiceTypeQuery, error)
}

func newServiceTypePager(opts []ServiceTypePaginateOption) (*serviceTypePager, error) {
	pager := &serviceTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceTypeOrder
	}
	return pager, nil
}

func (p *serviceTypePager) applyFilter(query *ServiceTypeQuery) (*ServiceTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serviceTypePager) toCursor(st *ServiceType) Cursor {
	return p.order.Field.toCursor(st)
}

func (p *serviceTypePager) applyCursors(query *ServiceTypeQuery, after, before *Cursor) *ServiceTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultServiceTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *serviceTypePager) applyOrder(query *ServiceTypeQuery, reverse bool) *ServiceTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultServiceTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultServiceTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ServiceType.
func (st *ServiceTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceTypePaginateOption,
) (*ServiceTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceTypePager(opts)
	if err != nil {
		return nil, err
	}

	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}

	conn := &ServiceTypeConnection{Edges: []*ServiceTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := st.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := st.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	st = pager.applyCursors(st, after, before)
	st = pager.applyOrder(st, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		st = st.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		st = st.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := st.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ServiceType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ServiceTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ServiceTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ServiceTypeOrderField defines the ordering field of ServiceType.
type ServiceTypeOrderField struct {
	field    string
	toCursor func(*ServiceType) Cursor
}

// ServiceTypeOrder defines the ordering of ServiceType.
type ServiceTypeOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ServiceTypeOrderField `json:"field"`
}

// DefaultServiceTypeOrder is the default ordering of ServiceType.
var DefaultServiceTypeOrder = &ServiceTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &ServiceTypeOrderField{
		field: servicetype.FieldID,
		toCursor: func(st *ServiceType) Cursor {
			return Cursor{ID: st.ID}
		},
	},
}

// SurveyEdge is the edge representation of Survey.
type SurveyEdge struct {
	Node   *Survey `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// SurveyConnection is the connection containing edges to Survey.
type SurveyConnection struct {
	Edges      []*SurveyEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// SurveyPaginateOption enables pagination customization.
type SurveyPaginateOption func(*surveyPager) error

// WithSurveyOrder configures pagination ordering.
func WithSurveyOrder(order *SurveyOrder) SurveyPaginateOption {
	if order == nil {
		order = DefaultSurveyOrder
	}
	o := *order
	return func(pager *surveyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyFilter configures pagination filter.
func WithSurveyFilter(filter func(*SurveyQuery) (*SurveyQuery, error)) SurveyPaginateOption {
	return func(pager *surveyPager) error {
		if filter == nil {
			return errors.New("SurveyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyPager struct {
	order  *SurveyOrder
	filter func(*SurveyQuery) (*SurveyQuery, error)
}

func newSurveyPager(opts []SurveyPaginateOption) (*surveyPager, error) {
	pager := &surveyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyOrder
	}
	return pager, nil
}

func (p *surveyPager) applyFilter(query *SurveyQuery) (*SurveyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyPager) toCursor(s *Survey) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *surveyPager) applyCursors(query *SurveyQuery, after, before *Cursor) *SurveyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSurveyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *surveyPager) applyOrder(query *SurveyQuery, reverse bool) *SurveyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSurveyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSurveyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Survey.
func (s *SurveyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyPaginateOption,
) (*SurveyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &SurveyConnection{Edges: []*SurveyEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Survey
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Survey {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Survey {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SurveyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SurveyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SurveyOrderField defines the ordering field of Survey.
type SurveyOrderField struct {
	field    string
	toCursor func(*Survey) Cursor
}

// SurveyOrder defines the ordering of Survey.
type SurveyOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *SurveyOrderField `json:"field"`
}

// DefaultSurveyOrder is the default ordering of Survey.
var DefaultSurveyOrder = &SurveyOrder{
	Direction: OrderDirectionAsc,
	Field: &SurveyOrderField{
		field: survey.FieldID,
		toCursor: func(s *Survey) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// SurveyCellScanEdge is the edge representation of SurveyCellScan.
type SurveyCellScanEdge struct {
	Node   *SurveyCellScan `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// SurveyCellScanConnection is the connection containing edges to SurveyCellScan.
type SurveyCellScanConnection struct {
	Edges      []*SurveyCellScanEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// SurveyCellScanPaginateOption enables pagination customization.
type SurveyCellScanPaginateOption func(*surveyCellScanPager) error

// WithSurveyCellScanOrder configures pagination ordering.
func WithSurveyCellScanOrder(order *SurveyCellScanOrder) SurveyCellScanPaginateOption {
	if order == nil {
		order = DefaultSurveyCellScanOrder
	}
	o := *order
	return func(pager *surveyCellScanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyCellScanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyCellScanFilter configures pagination filter.
func WithSurveyCellScanFilter(filter func(*SurveyCellScanQuery) (*SurveyCellScanQuery, error)) SurveyCellScanPaginateOption {
	return func(pager *surveyCellScanPager) error {
		if filter == nil {
			return errors.New("SurveyCellScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyCellScanPager struct {
	order  *SurveyCellScanOrder
	filter func(*SurveyCellScanQuery) (*SurveyCellScanQuery, error)
}

func newSurveyCellScanPager(opts []SurveyCellScanPaginateOption) (*surveyCellScanPager, error) {
	pager := &surveyCellScanPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyCellScanOrder
	}
	return pager, nil
}

func (p *surveyCellScanPager) applyFilter(query *SurveyCellScanQuery) (*SurveyCellScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyCellScanPager) toCursor(scs *SurveyCellScan) Cursor {
	return p.order.Field.toCursor(scs)
}

func (p *surveyCellScanPager) applyCursors(query *SurveyCellScanQuery, after, before *Cursor) *SurveyCellScanQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSurveyCellScanOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *surveyCellScanPager) applyOrder(query *SurveyCellScanQuery, reverse bool) *SurveyCellScanQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSurveyCellScanOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSurveyCellScanOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to SurveyCellScan.
func (scs *SurveyCellScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyCellScanPaginateOption,
) (*SurveyCellScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyCellScanPager(opts)
	if err != nil {
		return nil, err
	}

	if scs, err = pager.applyFilter(scs); err != nil {
		return nil, err
	}

	conn := &SurveyCellScanConnection{Edges: []*SurveyCellScanEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := scs.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := scs.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	scs = pager.applyCursors(scs, after, before)
	scs = pager.applyOrder(scs, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		scs = scs.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		scs = scs.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := scs.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *SurveyCellScan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SurveyCellScan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SurveyCellScan {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SurveyCellScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SurveyCellScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SurveyCellScanOrderField defines the ordering field of SurveyCellScan.
type SurveyCellScanOrderField struct {
	field    string
	toCursor func(*SurveyCellScan) Cursor
}

// SurveyCellScanOrder defines the ordering of SurveyCellScan.
type SurveyCellScanOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *SurveyCellScanOrderField `json:"field"`
}

// DefaultSurveyCellScanOrder is the default ordering of SurveyCellScan.
var DefaultSurveyCellScanOrder = &SurveyCellScanOrder{
	Direction: OrderDirectionAsc,
	Field: &SurveyCellScanOrderField{
		field: surveycellscan.FieldID,
		toCursor: func(scs *SurveyCellScan) Cursor {
			return Cursor{ID: scs.ID}
		},
	},
}

// SurveyQuestionEdge is the edge representation of SurveyQuestion.
type SurveyQuestionEdge struct {
	Node   *SurveyQuestion `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// SurveyQuestionConnection is the connection containing edges to SurveyQuestion.
type SurveyQuestionConnection struct {
	Edges      []*SurveyQuestionEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// SurveyQuestionPaginateOption enables pagination customization.
type SurveyQuestionPaginateOption func(*surveyQuestionPager) error

// WithSurveyQuestionOrder configures pagination ordering.
func WithSurveyQuestionOrder(order *SurveyQuestionOrder) SurveyQuestionPaginateOption {
	if order == nil {
		order = DefaultSurveyQuestionOrder
	}
	o := *order
	return func(pager *surveyQuestionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyQuestionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyQuestionFilter configures pagination filter.
func WithSurveyQuestionFilter(filter func(*SurveyQuestionQuery) (*SurveyQuestionQuery, error)) SurveyQuestionPaginateOption {
	return func(pager *surveyQuestionPager) error {
		if filter == nil {
			return errors.New("SurveyQuestionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyQuestionPager struct {
	order  *SurveyQuestionOrder
	filter func(*SurveyQuestionQuery) (*SurveyQuestionQuery, error)
}

func newSurveyQuestionPager(opts []SurveyQuestionPaginateOption) (*surveyQuestionPager, error) {
	pager := &surveyQuestionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyQuestionOrder
	}
	return pager, nil
}

func (p *surveyQuestionPager) applyFilter(query *SurveyQuestionQuery) (*SurveyQuestionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyQuestionPager) toCursor(sq *SurveyQuestion) Cursor {
	return p.order.Field.toCursor(sq)
}

func (p *surveyQuestionPager) applyCursors(query *SurveyQuestionQuery, after, before *Cursor) *SurveyQuestionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSurveyQuestionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *surveyQuestionPager) applyOrder(query *SurveyQuestionQuery, reverse bool) *SurveyQuestionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSurveyQuestionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSurveyQuestionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to SurveyQuestion.
func (sq *SurveyQuestionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyQuestionPaginateOption,
) (*SurveyQuestionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyQuestionPager(opts)
	if err != nil {
		return nil, err
	}

	if sq, err = pager.applyFilter(sq); err != nil {
		return nil, err
	}

	conn := &SurveyQuestionConnection{Edges: []*SurveyQuestionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := sq.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := sq.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	sq = pager.applyCursors(sq, after, before)
	sq = pager.applyOrder(sq, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		sq = sq.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		sq = sq.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := sq.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *SurveyQuestion
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SurveyQuestion {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SurveyQuestion {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SurveyQuestionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SurveyQuestionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SurveyQuestionOrderField defines the ordering field of SurveyQuestion.
type SurveyQuestionOrderField struct {
	field    string
	toCursor func(*SurveyQuestion) Cursor
}

// SurveyQuestionOrder defines the ordering of SurveyQuestion.
type SurveyQuestionOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *SurveyQuestionOrderField `json:"field"`
}

// DefaultSurveyQuestionOrder is the default ordering of SurveyQuestion.
var DefaultSurveyQuestionOrder = &SurveyQuestionOrder{
	Direction: OrderDirectionAsc,
	Field: &SurveyQuestionOrderField{
		field: surveyquestion.FieldID,
		toCursor: func(sq *SurveyQuestion) Cursor {
			return Cursor{ID: sq.ID}
		},
	},
}

// SurveyTemplateCategoryEdge is the edge representation of SurveyTemplateCategory.
type SurveyTemplateCategoryEdge struct {
	Node   *SurveyTemplateCategory `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// SurveyTemplateCategoryConnection is the connection containing edges to SurveyTemplateCategory.
type SurveyTemplateCategoryConnection struct {
	Edges      []*SurveyTemplateCategoryEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

// SurveyTemplateCategoryPaginateOption enables pagination customization.
type SurveyTemplateCategoryPaginateOption func(*surveyTemplateCategoryPager) error

// WithSurveyTemplateCategoryOrder configures pagination ordering.
func WithSurveyTemplateCategoryOrder(order *SurveyTemplateCategoryOrder) SurveyTemplateCategoryPaginateOption {
	if order == nil {
		order = DefaultSurveyTemplateCategoryOrder
	}
	o := *order
	return func(pager *surveyTemplateCategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyTemplateCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyTemplateCategoryFilter configures pagination filter.
func WithSurveyTemplateCategoryFilter(filter func(*SurveyTemplateCategoryQuery) (*SurveyTemplateCategoryQuery, error)) SurveyTemplateCategoryPaginateOption {
	return func(pager *surveyTemplateCategoryPager) error {
		if filter == nil {
			return errors.New("SurveyTemplateCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyTemplateCategoryPager struct {
	order  *SurveyTemplateCategoryOrder
	filter func(*SurveyTemplateCategoryQuery) (*SurveyTemplateCategoryQuery, error)
}

func newSurveyTemplateCategoryPager(opts []SurveyTemplateCategoryPaginateOption) (*surveyTemplateCategoryPager, error) {
	pager := &surveyTemplateCategoryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyTemplateCategoryOrder
	}
	return pager, nil
}

func (p *surveyTemplateCategoryPager) applyFilter(query *SurveyTemplateCategoryQuery) (*SurveyTemplateCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyTemplateCategoryPager) toCursor(stc *SurveyTemplateCategory) Cursor {
	return p.order.Field.toCursor(stc)
}

func (p *surveyTemplateCategoryPager) applyCursors(query *SurveyTemplateCategoryQuery, after, before *Cursor) *SurveyTemplateCategoryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSurveyTemplateCategoryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *surveyTemplateCategoryPager) applyOrder(query *SurveyTemplateCategoryQuery, reverse bool) *SurveyTemplateCategoryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSurveyTemplateCategoryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSurveyTemplateCategoryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to SurveyTemplateCategory.
func (stc *SurveyTemplateCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyTemplateCategoryPaginateOption,
) (*SurveyTemplateCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyTemplateCategoryPager(opts)
	if err != nil {
		return nil, err
	}

	if stc, err = pager.applyFilter(stc); err != nil {
		return nil, err
	}

	conn := &SurveyTemplateCategoryConnection{Edges: []*SurveyTemplateCategoryEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := stc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := stc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	stc = pager.applyCursors(stc, after, before)
	stc = pager.applyOrder(stc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		stc = stc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		stc = stc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := stc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *SurveyTemplateCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SurveyTemplateCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SurveyTemplateCategory {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SurveyTemplateCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SurveyTemplateCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SurveyTemplateCategoryOrderField defines the ordering field of SurveyTemplateCategory.
type SurveyTemplateCategoryOrderField struct {
	field    string
	toCursor func(*SurveyTemplateCategory) Cursor
}

// SurveyTemplateCategoryOrder defines the ordering of SurveyTemplateCategory.
type SurveyTemplateCategoryOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *SurveyTemplateCategoryOrderField `json:"field"`
}

// DefaultSurveyTemplateCategoryOrder is the default ordering of SurveyTemplateCategory.
var DefaultSurveyTemplateCategoryOrder = &SurveyTemplateCategoryOrder{
	Direction: OrderDirectionAsc,
	Field: &SurveyTemplateCategoryOrderField{
		field: surveytemplatecategory.FieldID,
		toCursor: func(stc *SurveyTemplateCategory) Cursor {
			return Cursor{ID: stc.ID}
		},
	},
}

// SurveyTemplateQuestionEdge is the edge representation of SurveyTemplateQuestion.
type SurveyTemplateQuestionEdge struct {
	Node   *SurveyTemplateQuestion `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// SurveyTemplateQuestionConnection is the connection containing edges to SurveyTemplateQuestion.
type SurveyTemplateQuestionConnection struct {
	Edges      []*SurveyTemplateQuestionEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

// SurveyTemplateQuestionPaginateOption enables pagination customization.
type SurveyTemplateQuestionPaginateOption func(*surveyTemplateQuestionPager) error

// WithSurveyTemplateQuestionOrder configures pagination ordering.
func WithSurveyTemplateQuestionOrder(order *SurveyTemplateQuestionOrder) SurveyTemplateQuestionPaginateOption {
	if order == nil {
		order = DefaultSurveyTemplateQuestionOrder
	}
	o := *order
	return func(pager *surveyTemplateQuestionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyTemplateQuestionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyTemplateQuestionFilter configures pagination filter.
func WithSurveyTemplateQuestionFilter(filter func(*SurveyTemplateQuestionQuery) (*SurveyTemplateQuestionQuery, error)) SurveyTemplateQuestionPaginateOption {
	return func(pager *surveyTemplateQuestionPager) error {
		if filter == nil {
			return errors.New("SurveyTemplateQuestionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyTemplateQuestionPager struct {
	order  *SurveyTemplateQuestionOrder
	filter func(*SurveyTemplateQuestionQuery) (*SurveyTemplateQuestionQuery, error)
}

func newSurveyTemplateQuestionPager(opts []SurveyTemplateQuestionPaginateOption) (*surveyTemplateQuestionPager, error) {
	pager := &surveyTemplateQuestionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyTemplateQuestionOrder
	}
	return pager, nil
}

func (p *surveyTemplateQuestionPager) applyFilter(query *SurveyTemplateQuestionQuery) (*SurveyTemplateQuestionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyTemplateQuestionPager) toCursor(stq *SurveyTemplateQuestion) Cursor {
	return p.order.Field.toCursor(stq)
}

func (p *surveyTemplateQuestionPager) applyCursors(query *SurveyTemplateQuestionQuery, after, before *Cursor) *SurveyTemplateQuestionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSurveyTemplateQuestionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *surveyTemplateQuestionPager) applyOrder(query *SurveyTemplateQuestionQuery, reverse bool) *SurveyTemplateQuestionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSurveyTemplateQuestionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSurveyTemplateQuestionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to SurveyTemplateQuestion.
func (stq *SurveyTemplateQuestionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyTemplateQuestionPaginateOption,
) (*SurveyTemplateQuestionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyTemplateQuestionPager(opts)
	if err != nil {
		return nil, err
	}

	if stq, err = pager.applyFilter(stq); err != nil {
		return nil, err
	}

	conn := &SurveyTemplateQuestionConnection{Edges: []*SurveyTemplateQuestionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := stq.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := stq.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	stq = pager.applyCursors(stq, after, before)
	stq = pager.applyOrder(stq, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		stq = stq.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		stq = stq.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := stq.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *SurveyTemplateQuestion
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SurveyTemplateQuestion {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SurveyTemplateQuestion {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SurveyTemplateQuestionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SurveyTemplateQuestionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SurveyTemplateQuestionOrderField defines the ordering field of SurveyTemplateQuestion.
type SurveyTemplateQuestionOrderField struct {
	field    string
	toCursor func(*SurveyTemplateQuestion) Cursor
}

// SurveyTemplateQuestionOrder defines the ordering of SurveyTemplateQuestion.
type SurveyTemplateQuestionOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *SurveyTemplateQuestionOrderField `json:"field"`
}

// DefaultSurveyTemplateQuestionOrder is the default ordering of SurveyTemplateQuestion.
var DefaultSurveyTemplateQuestionOrder = &SurveyTemplateQuestionOrder{
	Direction: OrderDirectionAsc,
	Field: &SurveyTemplateQuestionOrderField{
		field: surveytemplatequestion.FieldID,
		toCursor: func(stq *SurveyTemplateQuestion) Cursor {
			return Cursor{ID: stq.ID}
		},
	},
}

// SurveyWiFiScanEdge is the edge representation of SurveyWiFiScan.
type SurveyWiFiScanEdge struct {
	Node   *SurveyWiFiScan `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// SurveyWiFiScanConnection is the connection containing edges to SurveyWiFiScan.
type SurveyWiFiScanConnection struct {
	Edges      []*SurveyWiFiScanEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// SurveyWiFiScanPaginateOption enables pagination customization.
type SurveyWiFiScanPaginateOption func(*surveyWiFiScanPager) error

// WithSurveyWiFiScanOrder configures pagination ordering.
func WithSurveyWiFiScanOrder(order *SurveyWiFiScanOrder) SurveyWiFiScanPaginateOption {
	if order == nil {
		order = DefaultSurveyWiFiScanOrder
	}
	o := *order
	return func(pager *surveyWiFiScanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyWiFiScanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyWiFiScanFilter configures pagination filter.
func WithSurveyWiFiScanFilter(filter func(*SurveyWiFiScanQuery) (*SurveyWiFiScanQuery, error)) SurveyWiFiScanPaginateOption {
	return func(pager *surveyWiFiScanPager) error {
		if filter == nil {
			return errors.New("SurveyWiFiScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyWiFiScanPager struct {
	order  *SurveyWiFiScanOrder
	filter func(*SurveyWiFiScanQuery) (*SurveyWiFiScanQuery, error)
}

func newSurveyWiFiScanPager(opts []SurveyWiFiScanPaginateOption) (*surveyWiFiScanPager, error) {
	pager := &surveyWiFiScanPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyWiFiScanOrder
	}
	return pager, nil
}

func (p *surveyWiFiScanPager) applyFilter(query *SurveyWiFiScanQuery) (*SurveyWiFiScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyWiFiScanPager) toCursor(swfs *SurveyWiFiScan) Cursor {
	return p.order.Field.toCursor(swfs)
}

func (p *surveyWiFiScanPager) applyCursors(query *SurveyWiFiScanQuery, after, before *Cursor) *SurveyWiFiScanQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSurveyWiFiScanOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *surveyWiFiScanPager) applyOrder(query *SurveyWiFiScanQuery, reverse bool) *SurveyWiFiScanQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSurveyWiFiScanOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSurveyWiFiScanOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to SurveyWiFiScan.
func (swfs *SurveyWiFiScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyWiFiScanPaginateOption,
) (*SurveyWiFiScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyWiFiScanPager(opts)
	if err != nil {
		return nil, err
	}

	if swfs, err = pager.applyFilter(swfs); err != nil {
		return nil, err
	}

	conn := &SurveyWiFiScanConnection{Edges: []*SurveyWiFiScanEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := swfs.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := swfs.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	swfs = pager.applyCursors(swfs, after, before)
	swfs = pager.applyOrder(swfs, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		swfs = swfs.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		swfs = swfs.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := swfs.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *SurveyWiFiScan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SurveyWiFiScan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SurveyWiFiScan {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SurveyWiFiScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SurveyWiFiScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SurveyWiFiScanOrderField defines the ordering field of SurveyWiFiScan.
type SurveyWiFiScanOrderField struct {
	field    string
	toCursor func(*SurveyWiFiScan) Cursor
}

// SurveyWiFiScanOrder defines the ordering of SurveyWiFiScan.
type SurveyWiFiScanOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *SurveyWiFiScanOrderField `json:"field"`
}

// DefaultSurveyWiFiScanOrder is the default ordering of SurveyWiFiScan.
var DefaultSurveyWiFiScanOrder = &SurveyWiFiScanOrder{
	Direction: OrderDirectionAsc,
	Field: &SurveyWiFiScanOrderField{
		field: surveywifiscan.FieldID,
		toCursor: func(swfs *SurveyWiFiScan) Cursor {
			return Cursor{ID: swfs.ID}
		},
	},
}

// TechEdge is the edge representation of Tech.
type TechEdge struct {
	Node   *Tech  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TechConnection is the connection containing edges to Tech.
type TechConnection struct {
	Edges      []*TechEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// TechPaginateOption enables pagination customization.
type TechPaginateOption func(*techPager) error

// WithTechOrder configures pagination ordering.
func WithTechOrder(order *TechOrder) TechPaginateOption {
	if order == nil {
		order = DefaultTechOrder
	}
	o := *order
	return func(pager *techPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTechOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTechFilter configures pagination filter.
func WithTechFilter(filter func(*TechQuery) (*TechQuery, error)) TechPaginateOption {
	return func(pager *techPager) error {
		if filter == nil {
			return errors.New("TechQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type techPager struct {
	order  *TechOrder
	filter func(*TechQuery) (*TechQuery, error)
}

func newTechPager(opts []TechPaginateOption) (*techPager, error) {
	pager := &techPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTechOrder
	}
	return pager, nil
}

func (p *techPager) applyFilter(query *TechQuery) (*TechQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *techPager) toCursor(t *Tech) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *techPager) applyCursors(query *TechQuery, after, before *Cursor) *TechQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTechOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *techPager) applyOrder(query *TechQuery, reverse bool) *TechQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTechOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTechOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Tech.
func (t *TechQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TechPaginateOption,
) (*TechConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTechPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TechConnection{Edges: []*TechEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Tech
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tech {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tech {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TechEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TechEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TechOrderFieldName orders Tech by name.
	TechOrderFieldName = &TechOrderField{
		field: tech.FieldName,
		toCursor: func(t *Tech) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TechOrderField) String() string {
	var str string
	switch f.field {
	case tech.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TechOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TechOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TechOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *TechOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TechOrderField", str)
	}
	return nil
}

// TechOrderField defines the ordering field of Tech.
type TechOrderField struct {
	field    string
	toCursor func(*Tech) Cursor
}

// TechOrder defines the ordering of Tech.
type TechOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TechOrderField `json:"field"`
}

// DefaultTechOrder is the default ordering of Tech.
var DefaultTechOrder = &TechOrder{
	Direction: OrderDirectionAsc,
	Field: &TechOrderField{
		field: tech.FieldID,
		toCursor: func(t *Tech) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ThresholdEdge is the edge representation of Threshold.
type ThresholdEdge struct {
	Node   *Threshold `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ThresholdConnection is the connection containing edges to Threshold.
type ThresholdConnection struct {
	Edges      []*ThresholdEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// ThresholdPaginateOption enables pagination customization.
type ThresholdPaginateOption func(*thresholdPager) error

// WithThresholdOrder configures pagination ordering.
func WithThresholdOrder(order *ThresholdOrder) ThresholdPaginateOption {
	if order == nil {
		order = DefaultThresholdOrder
	}
	o := *order
	return func(pager *thresholdPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultThresholdOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithThresholdFilter configures pagination filter.
func WithThresholdFilter(filter func(*ThresholdQuery) (*ThresholdQuery, error)) ThresholdPaginateOption {
	return func(pager *thresholdPager) error {
		if filter == nil {
			return errors.New("ThresholdQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type thresholdPager struct {
	order  *ThresholdOrder
	filter func(*ThresholdQuery) (*ThresholdQuery, error)
}

func newThresholdPager(opts []ThresholdPaginateOption) (*thresholdPager, error) {
	pager := &thresholdPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultThresholdOrder
	}
	return pager, nil
}

func (p *thresholdPager) applyFilter(query *ThresholdQuery) (*ThresholdQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *thresholdPager) toCursor(t *Threshold) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *thresholdPager) applyCursors(query *ThresholdQuery, after, before *Cursor) *ThresholdQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultThresholdOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *thresholdPager) applyOrder(query *ThresholdQuery, reverse bool) *ThresholdQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultThresholdOrder.Field {
		query = query.Order(direction.orderFunc(DefaultThresholdOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Threshold.
func (t *ThresholdQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ThresholdPaginateOption,
) (*ThresholdConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newThresholdPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &ThresholdConnection{Edges: []*ThresholdEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Threshold
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Threshold {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Threshold {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ThresholdEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ThresholdEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ThresholdOrderFieldName orders Threshold by name.
	ThresholdOrderFieldName = &ThresholdOrderField{
		field: threshold.FieldName,
		toCursor: func(t *Threshold) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ThresholdOrderField) String() string {
	var str string
	switch f.field {
	case threshold.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ThresholdOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ThresholdOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ThresholdOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ThresholdOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ThresholdOrderField", str)
	}
	return nil
}

// ThresholdOrderField defines the ordering field of Threshold.
type ThresholdOrderField struct {
	field    string
	toCursor func(*Threshold) Cursor
}

// ThresholdOrder defines the ordering of Threshold.
type ThresholdOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ThresholdOrderField `json:"field"`
}

// DefaultThresholdOrder is the default ordering of Threshold.
var DefaultThresholdOrder = &ThresholdOrder{
	Direction: OrderDirectionAsc,
	Field: &ThresholdOrderField{
		field: threshold.FieldID,
		toCursor: func(t *Threshold) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}

	conn := &UserConnection{Edges: []*UserEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := u.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := u.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		u = u.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		u = u.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := u.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// UsersGroupEdge is the edge representation of UsersGroup.
type UsersGroupEdge struct {
	Node   *UsersGroup `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// UsersGroupConnection is the connection containing edges to UsersGroup.
type UsersGroupConnection struct {
	Edges      []*UsersGroupEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// UsersGroupPaginateOption enables pagination customization.
type UsersGroupPaginateOption func(*usersGroupPager) error

// WithUsersGroupOrder configures pagination ordering.
func WithUsersGroupOrder(order *UsersGroupOrder) UsersGroupPaginateOption {
	if order == nil {
		order = DefaultUsersGroupOrder
	}
	o := *order
	return func(pager *usersGroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUsersGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUsersGroupFilter configures pagination filter.
func WithUsersGroupFilter(filter func(*UsersGroupQuery) (*UsersGroupQuery, error)) UsersGroupPaginateOption {
	return func(pager *usersGroupPager) error {
		if filter == nil {
			return errors.New("UsersGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersGroupPager struct {
	order  *UsersGroupOrder
	filter func(*UsersGroupQuery) (*UsersGroupQuery, error)
}

func newUsersGroupPager(opts []UsersGroupPaginateOption) (*usersGroupPager, error) {
	pager := &usersGroupPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUsersGroupOrder
	}
	return pager, nil
}

func (p *usersGroupPager) applyFilter(query *UsersGroupQuery) (*UsersGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersGroupPager) toCursor(ug *UsersGroup) Cursor {
	return p.order.Field.toCursor(ug)
}

func (p *usersGroupPager) applyCursors(query *UsersGroupQuery, after, before *Cursor) *UsersGroupQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUsersGroupOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *usersGroupPager) applyOrder(query *UsersGroupQuery, reverse bool) *UsersGroupQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUsersGroupOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUsersGroupOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UsersGroup.
func (ug *UsersGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UsersGroupPaginateOption,
) (*UsersGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUsersGroupPager(opts)
	if err != nil {
		return nil, err
	}

	if ug, err = pager.applyFilter(ug); err != nil {
		return nil, err
	}

	conn := &UsersGroupConnection{Edges: []*UsersGroupEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ug.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ug.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ug = pager.applyCursors(ug, after, before)
	ug = pager.applyOrder(ug, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ug = ug.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ug = ug.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ug.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UsersGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UsersGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UsersGroup {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UsersGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UsersGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UsersGroupOrderField defines the ordering field of UsersGroup.
type UsersGroupOrderField struct {
	field    string
	toCursor func(*UsersGroup) Cursor
}

// UsersGroupOrder defines the ordering of UsersGroup.
type UsersGroupOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *UsersGroupOrderField `json:"field"`
}

// DefaultUsersGroupOrder is the default ordering of UsersGroup.
var DefaultUsersGroupOrder = &UsersGroupOrder{
	Direction: OrderDirectionAsc,
	Field: &UsersGroupOrderField{
		field: usersgroup.FieldID,
		toCursor: func(ug *UsersGroup) Cursor {
			return Cursor{ID: ug.ID}
		},
	},
}

// VendorEdge is the edge representation of Vendor.
type VendorEdge struct {
	Node   *Vendor `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// VendorConnection is the connection containing edges to Vendor.
type VendorConnection struct {
	Edges      []*VendorEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// VendorPaginateOption enables pagination customization.
type VendorPaginateOption func(*vendorPager) error

// WithVendorOrder configures pagination ordering.
func WithVendorOrder(order *VendorOrder) VendorPaginateOption {
	if order == nil {
		order = DefaultVendorOrder
	}
	o := *order
	return func(pager *vendorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVendorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVendorFilter configures pagination filter.
func WithVendorFilter(filter func(*VendorQuery) (*VendorQuery, error)) VendorPaginateOption {
	return func(pager *vendorPager) error {
		if filter == nil {
			return errors.New("VendorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vendorPager struct {
	order  *VendorOrder
	filter func(*VendorQuery) (*VendorQuery, error)
}

func newVendorPager(opts []VendorPaginateOption) (*vendorPager, error) {
	pager := &vendorPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVendorOrder
	}
	return pager, nil
}

func (p *vendorPager) applyFilter(query *VendorQuery) (*VendorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vendorPager) toCursor(v *Vendor) Cursor {
	return p.order.Field.toCursor(v)
}

func (p *vendorPager) applyCursors(query *VendorQuery, after, before *Cursor) *VendorQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVendorOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vendorPager) applyOrder(query *VendorQuery, reverse bool) *VendorQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVendorOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVendorOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Vendor.
func (v *VendorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VendorPaginateOption,
) (*VendorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVendorPager(opts)
	if err != nil {
		return nil, err
	}

	if v, err = pager.applyFilter(v); err != nil {
		return nil, err
	}

	conn := &VendorConnection{Edges: []*VendorEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := v.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := v.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	v = pager.applyCursors(v, after, before)
	v = pager.applyOrder(v, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		v = v.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		v = v.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := v.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Vendor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vendor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vendor {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VendorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VendorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VendorOrderFieldName orders Vendor by name.
	VendorOrderFieldName = &VendorOrderField{
		field: vendor.FieldName,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VendorOrderField) String() string {
	var str string
	switch f.field {
	case vendor.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VendorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VendorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VendorOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *VendorOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid VendorOrderField", str)
	}
	return nil
}

// VendorOrderField defines the ordering field of Vendor.
type VendorOrderField struct {
	field    string
	toCursor func(*Vendor) Cursor
}

// VendorOrder defines the ordering of Vendor.
type VendorOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *VendorOrderField `json:"field"`
}

// DefaultVendorOrder is the default ordering of Vendor.
var DefaultVendorOrder = &VendorOrder{
	Direction: OrderDirectionAsc,
	Field: &VendorOrderField{
		field: vendor.FieldID,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{ID: v.ID}
		},
	},
}

// WorkOrderEdge is the edge representation of WorkOrder.
type WorkOrderEdge struct {
	Node   *WorkOrder `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// WorkOrderConnection is the connection containing edges to WorkOrder.
type WorkOrderConnection struct {
	Edges      []*WorkOrderEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// WorkOrderPaginateOption enables pagination customization.
type WorkOrderPaginateOption func(*workOrderPager) error

// WithWorkOrderOrder configures pagination ordering.
func WithWorkOrderOrder(order *WorkOrderOrder) WorkOrderPaginateOption {
	if order == nil {
		order = DefaultWorkOrderOrder
	}
	o := *order
	return func(pager *workOrderPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkOrderOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkOrderFilter configures pagination filter.
func WithWorkOrderFilter(filter func(*WorkOrderQuery) (*WorkOrderQuery, error)) WorkOrderPaginateOption {
	return func(pager *workOrderPager) error {
		if filter == nil {
			return errors.New("WorkOrderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workOrderPager struct {
	order  *WorkOrderOrder
	filter func(*WorkOrderQuery) (*WorkOrderQuery, error)
}

func newWorkOrderPager(opts []WorkOrderPaginateOption) (*workOrderPager, error) {
	pager := &workOrderPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkOrderOrder
	}
	return pager, nil
}

func (p *workOrderPager) applyFilter(query *WorkOrderQuery) (*WorkOrderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workOrderPager) toCursor(wo *WorkOrder) Cursor {
	return p.order.Field.toCursor(wo)
}

func (p *workOrderPager) applyCursors(query *WorkOrderQuery, after, before *Cursor) *WorkOrderQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkOrderOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workOrderPager) applyOrder(query *WorkOrderQuery, reverse bool) *WorkOrderQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkOrderOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkOrderOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to WorkOrder.
func (wo *WorkOrderQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkOrderPaginateOption,
) (*WorkOrderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkOrderPager(opts)
	if err != nil {
		return nil, err
	}

	if wo, err = pager.applyFilter(wo); err != nil {
		return nil, err
	}

	conn := &WorkOrderConnection{Edges: []*WorkOrderEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := wo.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := wo.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	wo = pager.applyCursors(wo, after, before)
	wo = pager.applyOrder(wo, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		wo = wo.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		wo = wo.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := wo.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *WorkOrder
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkOrder {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkOrder {
			return nodes[i]
		}
	}

	conn.Edges = make([]*WorkOrderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &WorkOrderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// WorkOrderOrderFieldUpdateTime orders WorkOrder by update_time.
	WorkOrderOrderFieldUpdateTime = &WorkOrderOrderField{
		field: workorder.FieldUpdateTime,
		toCursor: func(wo *WorkOrder) Cursor {
			return Cursor{
				ID:    wo.ID,
				Value: wo.UpdateTime,
			}
		},
	}
	// WorkOrderOrderFieldName orders WorkOrder by name.
	WorkOrderOrderFieldName = &WorkOrderOrderField{
		field: workorder.FieldName,
		toCursor: func(wo *WorkOrder) Cursor {
			return Cursor{
				ID:    wo.ID,
				Value: wo.Name,
			}
		},
	}
	// WorkOrderOrderFieldCreationDate orders WorkOrder by creation_date.
	WorkOrderOrderFieldCreationDate = &WorkOrderOrderField{
		field: workorder.FieldCreationDate,
		toCursor: func(wo *WorkOrder) Cursor {
			return Cursor{
				ID:    wo.ID,
				Value: wo.CreationDate,
			}
		},
	}
	// WorkOrderOrderFieldCloseDate orders WorkOrder by close_date.
	WorkOrderOrderFieldCloseDate = &WorkOrderOrderField{
		field: workorder.FieldCloseDate,
		toCursor: func(wo *WorkOrder) Cursor {
			return Cursor{
				ID:    wo.ID,
				Value: wo.CloseDate,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WorkOrderOrderField) String() string {
	var str string
	switch f.field {
	case workorder.FieldUpdateTime:
		str = "UPDATED_AT"
	case workorder.FieldName:
		str = "NAME"
	case workorder.FieldCreationDate:
		str = "CREATED_AT"
	case workorder.FieldCloseDate:
		str = "CLOSED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WorkOrderOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WorkOrderOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WorkOrderOrderField %T must be a string", v)
	}
	switch str {
	case "UPDATED_AT":
		*f = *WorkOrderOrderFieldUpdateTime
	case "NAME":
		*f = *WorkOrderOrderFieldName
	case "CREATED_AT":
		*f = *WorkOrderOrderFieldCreationDate
	case "CLOSED_AT":
		*f = *WorkOrderOrderFieldCloseDate
	default:
		return fmt.Errorf("%s is not a valid WorkOrderOrderField", str)
	}
	return nil
}

// WorkOrderOrderField defines the ordering field of WorkOrder.
type WorkOrderOrderField struct {
	field    string
	toCursor func(*WorkOrder) Cursor
}

// WorkOrderOrder defines the ordering of WorkOrder.
type WorkOrderOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *WorkOrderOrderField `json:"field"`
}

// DefaultWorkOrderOrder is the default ordering of WorkOrder.
var DefaultWorkOrderOrder = &WorkOrderOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkOrderOrderField{
		field: workorder.FieldID,
		toCursor: func(wo *WorkOrder) Cursor {
			return Cursor{ID: wo.ID}
		},
	},
}

// WorkOrderDefinitionEdge is the edge representation of WorkOrderDefinition.
type WorkOrderDefinitionEdge struct {
	Node   *WorkOrderDefinition `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// WorkOrderDefinitionConnection is the connection containing edges to WorkOrderDefinition.
type WorkOrderDefinitionConnection struct {
	Edges      []*WorkOrderDefinitionEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

// WorkOrderDefinitionPaginateOption enables pagination customization.
type WorkOrderDefinitionPaginateOption func(*workOrderDefinitionPager) error

// WithWorkOrderDefinitionOrder configures pagination ordering.
func WithWorkOrderDefinitionOrder(order *WorkOrderDefinitionOrder) WorkOrderDefinitionPaginateOption {
	if order == nil {
		order = DefaultWorkOrderDefinitionOrder
	}
	o := *order
	return func(pager *workOrderDefinitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkOrderDefinitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkOrderDefinitionFilter configures pagination filter.
func WithWorkOrderDefinitionFilter(filter func(*WorkOrderDefinitionQuery) (*WorkOrderDefinitionQuery, error)) WorkOrderDefinitionPaginateOption {
	return func(pager *workOrderDefinitionPager) error {
		if filter == nil {
			return errors.New("WorkOrderDefinitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workOrderDefinitionPager struct {
	order  *WorkOrderDefinitionOrder
	filter func(*WorkOrderDefinitionQuery) (*WorkOrderDefinitionQuery, error)
}

func newWorkOrderDefinitionPager(opts []WorkOrderDefinitionPaginateOption) (*workOrderDefinitionPager, error) {
	pager := &workOrderDefinitionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkOrderDefinitionOrder
	}
	return pager, nil
}

func (p *workOrderDefinitionPager) applyFilter(query *WorkOrderDefinitionQuery) (*WorkOrderDefinitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workOrderDefinitionPager) toCursor(wod *WorkOrderDefinition) Cursor {
	return p.order.Field.toCursor(wod)
}

func (p *workOrderDefinitionPager) applyCursors(query *WorkOrderDefinitionQuery, after, before *Cursor) *WorkOrderDefinitionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkOrderDefinitionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workOrderDefinitionPager) applyOrder(query *WorkOrderDefinitionQuery, reverse bool) *WorkOrderDefinitionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkOrderDefinitionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkOrderDefinitionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to WorkOrderDefinition.
func (wod *WorkOrderDefinitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkOrderDefinitionPaginateOption,
) (*WorkOrderDefinitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkOrderDefinitionPager(opts)
	if err != nil {
		return nil, err
	}

	if wod, err = pager.applyFilter(wod); err != nil {
		return nil, err
	}

	conn := &WorkOrderDefinitionConnection{Edges: []*WorkOrderDefinitionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := wod.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := wod.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	wod = pager.applyCursors(wod, after, before)
	wod = pager.applyOrder(wod, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		wod = wod.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		wod = wod.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := wod.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *WorkOrderDefinition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkOrderDefinition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkOrderDefinition {
			return nodes[i]
		}
	}

	conn.Edges = make([]*WorkOrderDefinitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &WorkOrderDefinitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// WorkOrderDefinitionOrderField defines the ordering field of WorkOrderDefinition.
type WorkOrderDefinitionOrderField struct {
	field    string
	toCursor func(*WorkOrderDefinition) Cursor
}

// WorkOrderDefinitionOrder defines the ordering of WorkOrderDefinition.
type WorkOrderDefinitionOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *WorkOrderDefinitionOrderField `json:"field"`
}

// DefaultWorkOrderDefinitionOrder is the default ordering of WorkOrderDefinition.
var DefaultWorkOrderDefinitionOrder = &WorkOrderDefinitionOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkOrderDefinitionOrderField{
		field: workorderdefinition.FieldID,
		toCursor: func(wod *WorkOrderDefinition) Cursor {
			return Cursor{ID: wod.ID}
		},
	},
}

// WorkOrderTemplateEdge is the edge representation of WorkOrderTemplate.
type WorkOrderTemplateEdge struct {
	Node   *WorkOrderTemplate `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// WorkOrderTemplateConnection is the connection containing edges to WorkOrderTemplate.
type WorkOrderTemplateConnection struct {
	Edges      []*WorkOrderTemplateEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// WorkOrderTemplatePaginateOption enables pagination customization.
type WorkOrderTemplatePaginateOption func(*workOrderTemplatePager) error

// WithWorkOrderTemplateOrder configures pagination ordering.
func WithWorkOrderTemplateOrder(order *WorkOrderTemplateOrder) WorkOrderTemplatePaginateOption {
	if order == nil {
		order = DefaultWorkOrderTemplateOrder
	}
	o := *order
	return func(pager *workOrderTemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkOrderTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkOrderTemplateFilter configures pagination filter.
func WithWorkOrderTemplateFilter(filter func(*WorkOrderTemplateQuery) (*WorkOrderTemplateQuery, error)) WorkOrderTemplatePaginateOption {
	return func(pager *workOrderTemplatePager) error {
		if filter == nil {
			return errors.New("WorkOrderTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workOrderTemplatePager struct {
	order  *WorkOrderTemplateOrder
	filter func(*WorkOrderTemplateQuery) (*WorkOrderTemplateQuery, error)
}

func newWorkOrderTemplatePager(opts []WorkOrderTemplatePaginateOption) (*workOrderTemplatePager, error) {
	pager := &workOrderTemplatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkOrderTemplateOrder
	}
	return pager, nil
}

func (p *workOrderTemplatePager) applyFilter(query *WorkOrderTemplateQuery) (*WorkOrderTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workOrderTemplatePager) toCursor(wot *WorkOrderTemplate) Cursor {
	return p.order.Field.toCursor(wot)
}

func (p *workOrderTemplatePager) applyCursors(query *WorkOrderTemplateQuery, after, before *Cursor) *WorkOrderTemplateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkOrderTemplateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workOrderTemplatePager) applyOrder(query *WorkOrderTemplateQuery, reverse bool) *WorkOrderTemplateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkOrderTemplateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkOrderTemplateOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to WorkOrderTemplate.
func (wot *WorkOrderTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkOrderTemplatePaginateOption,
) (*WorkOrderTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkOrderTemplatePager(opts)
	if err != nil {
		return nil, err
	}

	if wot, err = pager.applyFilter(wot); err != nil {
		return nil, err
	}

	conn := &WorkOrderTemplateConnection{Edges: []*WorkOrderTemplateEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := wot.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := wot.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	wot = pager.applyCursors(wot, after, before)
	wot = pager.applyOrder(wot, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		wot = wot.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		wot = wot.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := wot.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *WorkOrderTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkOrderTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkOrderTemplate {
			return nodes[i]
		}
	}

	conn.Edges = make([]*WorkOrderTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &WorkOrderTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// WorkOrderTemplateOrderField defines the ordering field of WorkOrderTemplate.
type WorkOrderTemplateOrderField struct {
	field    string
	toCursor func(*WorkOrderTemplate) Cursor
}

// WorkOrderTemplateOrder defines the ordering of WorkOrderTemplate.
type WorkOrderTemplateOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *WorkOrderTemplateOrderField `json:"field"`
}

// DefaultWorkOrderTemplateOrder is the default ordering of WorkOrderTemplate.
var DefaultWorkOrderTemplateOrder = &WorkOrderTemplateOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkOrderTemplateOrderField{
		field: workordertemplate.FieldID,
		toCursor: func(wot *WorkOrderTemplate) Cursor {
			return Cursor{ID: wot.ID}
		},
	},
}

// WorkOrderTypeEdge is the edge representation of WorkOrderType.
type WorkOrderTypeEdge struct {
	Node   *WorkOrderType `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// WorkOrderTypeConnection is the connection containing edges to WorkOrderType.
type WorkOrderTypeConnection struct {
	Edges      []*WorkOrderTypeEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// WorkOrderTypePaginateOption enables pagination customization.
type WorkOrderTypePaginateOption func(*workOrderTypePager) error

// WithWorkOrderTypeOrder configures pagination ordering.
func WithWorkOrderTypeOrder(order *WorkOrderTypeOrder) WorkOrderTypePaginateOption {
	if order == nil {
		order = DefaultWorkOrderTypeOrder
	}
	o := *order
	return func(pager *workOrderTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkOrderTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkOrderTypeFilter configures pagination filter.
func WithWorkOrderTypeFilter(filter func(*WorkOrderTypeQuery) (*WorkOrderTypeQuery, error)) WorkOrderTypePaginateOption {
	return func(pager *workOrderTypePager) error {
		if filter == nil {
			return errors.New("WorkOrderTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workOrderTypePager struct {
	order  *WorkOrderTypeOrder
	filter func(*WorkOrderTypeQuery) (*WorkOrderTypeQuery, error)
}

func newWorkOrderTypePager(opts []WorkOrderTypePaginateOption) (*workOrderTypePager, error) {
	pager := &workOrderTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkOrderTypeOrder
	}
	return pager, nil
}

func (p *workOrderTypePager) applyFilter(query *WorkOrderTypeQuery) (*WorkOrderTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workOrderTypePager) toCursor(wot *WorkOrderType) Cursor {
	return p.order.Field.toCursor(wot)
}

func (p *workOrderTypePager) applyCursors(query *WorkOrderTypeQuery, after, before *Cursor) *WorkOrderTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkOrderTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workOrderTypePager) applyOrder(query *WorkOrderTypeQuery, reverse bool) *WorkOrderTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkOrderTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkOrderTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to WorkOrderType.
func (wot *WorkOrderTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkOrderTypePaginateOption,
) (*WorkOrderTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkOrderTypePager(opts)
	if err != nil {
		return nil, err
	}

	if wot, err = pager.applyFilter(wot); err != nil {
		return nil, err
	}

	conn := &WorkOrderTypeConnection{Edges: []*WorkOrderTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := wot.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := wot.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	wot = pager.applyCursors(wot, after, before)
	wot = pager.applyOrder(wot, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		wot = wot.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		wot = wot.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := wot.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *WorkOrderType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkOrderType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkOrderType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*WorkOrderTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &WorkOrderTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// WorkOrderTypeOrderField defines the ordering field of WorkOrderType.
type WorkOrderTypeOrderField struct {
	field    string
	toCursor func(*WorkOrderType) Cursor
}

// WorkOrderTypeOrder defines the ordering of WorkOrderType.
type WorkOrderTypeOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *WorkOrderTypeOrderField `json:"field"`
}

// DefaultWorkOrderTypeOrder is the default ordering of WorkOrderType.
var DefaultWorkOrderTypeOrder = &WorkOrderTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkOrderTypeOrderField{
		field: workordertype.FieldID,
		toCursor: func(wot *WorkOrderType) Cursor {
			return Cursor{ID: wot.ID}
		},
	},
}

// WorkerTypeEdge is the edge representation of WorkerType.
type WorkerTypeEdge struct {
	Node   *WorkerType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// WorkerTypeConnection is the connection containing edges to WorkerType.
type WorkerTypeConnection struct {
	Edges      []*WorkerTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// WorkerTypePaginateOption enables pagination customization.
type WorkerTypePaginateOption func(*workerTypePager) error

// WithWorkerTypeOrder configures pagination ordering.
func WithWorkerTypeOrder(order *WorkerTypeOrder) WorkerTypePaginateOption {
	if order == nil {
		order = DefaultWorkerTypeOrder
	}
	o := *order
	return func(pager *workerTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkerTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkerTypeFilter configures pagination filter.
func WithWorkerTypeFilter(filter func(*WorkerTypeQuery) (*WorkerTypeQuery, error)) WorkerTypePaginateOption {
	return func(pager *workerTypePager) error {
		if filter == nil {
			return errors.New("WorkerTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workerTypePager struct {
	order  *WorkerTypeOrder
	filter func(*WorkerTypeQuery) (*WorkerTypeQuery, error)
}

func newWorkerTypePager(opts []WorkerTypePaginateOption) (*workerTypePager, error) {
	pager := &workerTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkerTypeOrder
	}
	return pager, nil
}

func (p *workerTypePager) applyFilter(query *WorkerTypeQuery) (*WorkerTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workerTypePager) toCursor(wt *WorkerType) Cursor {
	return p.order.Field.toCursor(wt)
}

func (p *workerTypePager) applyCursors(query *WorkerTypeQuery, after, before *Cursor) *WorkerTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkerTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workerTypePager) applyOrder(query *WorkerTypeQuery, reverse bool) *WorkerTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkerTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkerTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to WorkerType.
func (wt *WorkerTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkerTypePaginateOption,
) (*WorkerTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkerTypePager(opts)
	if err != nil {
		return nil, err
	}

	if wt, err = pager.applyFilter(wt); err != nil {
		return nil, err
	}

	conn := &WorkerTypeConnection{Edges: []*WorkerTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := wt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := wt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	wt = pager.applyCursors(wt, after, before)
	wt = pager.applyOrder(wt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		wt = wt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		wt = wt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := wt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *WorkerType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkerType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkerType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*WorkerTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &WorkerTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// WorkerTypeOrderField defines the ordering field of WorkerType.
type WorkerTypeOrderField struct {
	field    string
	toCursor func(*WorkerType) Cursor
}

// WorkerTypeOrder defines the ordering of WorkerType.
type WorkerTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *WorkerTypeOrderField `json:"field"`
}

// DefaultWorkerTypeOrder is the default ordering of WorkerType.
var DefaultWorkerTypeOrder = &WorkerTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkerTypeOrderField{
		field: workertype.FieldID,
		toCursor: func(wt *WorkerType) Cursor {
			return Cursor{ID: wt.ID}
		},
	},
}
