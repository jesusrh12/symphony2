// Copyright (c) 2004-present Facebook All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by entc, DO NOT EDIT.

package recommendations

import (
	"time"

	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/symphony/pkg/ent/predicate"
)

// ID filters vertices based on their identifier.
func ID(id int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// UpdateTime applies equality check predicate on the "update_time" field. It's identical to UpdateTimeEQ.
func UpdateTime(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// ExternalId applies equality check predicate on the "externalId" field. It's identical to ExternalIdEQ.
func ExternalId(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExternalId), v))
	})
}

// Resource applies equality check predicate on the "resource" field. It's identical to ResourceEQ.
func Resource(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResource), v))
	})
}

// AlarmType applies equality check predicate on the "alarmType" field. It's identical to AlarmTypeEQ.
func AlarmType(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAlarmType), v))
	})
}

// ShortDescription applies equality check predicate on the "shortDescription" field. It's identical to ShortDescriptionEQ.
func ShortDescription(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldShortDescription), v))
	})
}

// LongDescription applies equality check predicate on the "longDescription" field. It's identical to LongDescriptionEQ.
func LongDescription(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLongDescription), v))
	})
}

// Command applies equality check predicate on the "command" field. It's identical to CommandEQ.
func Command(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCommand), v))
	})
}

// Priority applies equality check predicate on the "priority" field. It's identical to PriorityEQ.
func Priority(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPriority), v))
	})
}

// Status applies equality check predicate on the "status" field. It's identical to StatusEQ.
func Status(v bool) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// Used applies equality check predicate on the "used" field. It's identical to UsedEQ.
func Used(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUsed), v))
	})
}

// Runbook applies equality check predicate on the "runbook" field. It's identical to RunbookEQ.
func Runbook(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRunbook), v))
	})
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateTime), v))
	})
}

// UpdateTimeEQ applies the EQ predicate on the "update_time" field.
func UpdateTimeEQ(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeNEQ applies the NEQ predicate on the "update_time" field.
func UpdateTimeNEQ(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeIn applies the In predicate on the "update_time" field.
func UpdateTimeIn(vs ...time.Time) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeNotIn applies the NotIn predicate on the "update_time" field.
func UpdateTimeNotIn(vs ...time.Time) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeGT applies the GT predicate on the "update_time" field.
func UpdateTimeGT(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeGTE applies the GTE predicate on the "update_time" field.
func UpdateTimeGTE(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLT applies the LT predicate on the "update_time" field.
func UpdateTimeLT(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLTE applies the LTE predicate on the "update_time" field.
func UpdateTimeLTE(v time.Time) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateTime), v))
	})
}

// ExternalIdEQ applies the EQ predicate on the "externalId" field.
func ExternalIdEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExternalId), v))
	})
}

// ExternalIdNEQ applies the NEQ predicate on the "externalId" field.
func ExternalIdNEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExternalId), v))
	})
}

// ExternalIdIn applies the In predicate on the "externalId" field.
func ExternalIdIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExternalId), v...))
	})
}

// ExternalIdNotIn applies the NotIn predicate on the "externalId" field.
func ExternalIdNotIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExternalId), v...))
	})
}

// ExternalIdGT applies the GT predicate on the "externalId" field.
func ExternalIdGT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExternalId), v))
	})
}

// ExternalIdGTE applies the GTE predicate on the "externalId" field.
func ExternalIdGTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExternalId), v))
	})
}

// ExternalIdLT applies the LT predicate on the "externalId" field.
func ExternalIdLT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExternalId), v))
	})
}

// ExternalIdLTE applies the LTE predicate on the "externalId" field.
func ExternalIdLTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExternalId), v))
	})
}

// ExternalIdContains applies the Contains predicate on the "externalId" field.
func ExternalIdContains(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldExternalId), v))
	})
}

// ExternalIdHasPrefix applies the HasPrefix predicate on the "externalId" field.
func ExternalIdHasPrefix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldExternalId), v))
	})
}

// ExternalIdHasSuffix applies the HasSuffix predicate on the "externalId" field.
func ExternalIdHasSuffix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldExternalId), v))
	})
}

// ExternalIdEqualFold applies the EqualFold predicate on the "externalId" field.
func ExternalIdEqualFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldExternalId), v))
	})
}

// ExternalIdContainsFold applies the ContainsFold predicate on the "externalId" field.
func ExternalIdContainsFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldExternalId), v))
	})
}

// ResourceEQ applies the EQ predicate on the "resource" field.
func ResourceEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResource), v))
	})
}

// ResourceNEQ applies the NEQ predicate on the "resource" field.
func ResourceNEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldResource), v))
	})
}

// ResourceIn applies the In predicate on the "resource" field.
func ResourceIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldResource), v...))
	})
}

// ResourceNotIn applies the NotIn predicate on the "resource" field.
func ResourceNotIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldResource), v...))
	})
}

// ResourceGT applies the GT predicate on the "resource" field.
func ResourceGT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldResource), v))
	})
}

// ResourceGTE applies the GTE predicate on the "resource" field.
func ResourceGTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldResource), v))
	})
}

// ResourceLT applies the LT predicate on the "resource" field.
func ResourceLT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldResource), v))
	})
}

// ResourceLTE applies the LTE predicate on the "resource" field.
func ResourceLTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldResource), v))
	})
}

// ResourceContains applies the Contains predicate on the "resource" field.
func ResourceContains(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldResource), v))
	})
}

// ResourceHasPrefix applies the HasPrefix predicate on the "resource" field.
func ResourceHasPrefix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldResource), v))
	})
}

// ResourceHasSuffix applies the HasSuffix predicate on the "resource" field.
func ResourceHasSuffix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldResource), v))
	})
}

// ResourceEqualFold applies the EqualFold predicate on the "resource" field.
func ResourceEqualFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldResource), v))
	})
}

// ResourceContainsFold applies the ContainsFold predicate on the "resource" field.
func ResourceContainsFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldResource), v))
	})
}

// AlarmTypeEQ applies the EQ predicate on the "alarmType" field.
func AlarmTypeEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeNEQ applies the NEQ predicate on the "alarmType" field.
func AlarmTypeNEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeIn applies the In predicate on the "alarmType" field.
func AlarmTypeIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAlarmType), v...))
	})
}

// AlarmTypeNotIn applies the NotIn predicate on the "alarmType" field.
func AlarmTypeNotIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAlarmType), v...))
	})
}

// AlarmTypeGT applies the GT predicate on the "alarmType" field.
func AlarmTypeGT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeGTE applies the GTE predicate on the "alarmType" field.
func AlarmTypeGTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeLT applies the LT predicate on the "alarmType" field.
func AlarmTypeLT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeLTE applies the LTE predicate on the "alarmType" field.
func AlarmTypeLTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeContains applies the Contains predicate on the "alarmType" field.
func AlarmTypeContains(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeHasPrefix applies the HasPrefix predicate on the "alarmType" field.
func AlarmTypeHasPrefix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeHasSuffix applies the HasSuffix predicate on the "alarmType" field.
func AlarmTypeHasSuffix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeEqualFold applies the EqualFold predicate on the "alarmType" field.
func AlarmTypeEqualFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAlarmType), v))
	})
}

// AlarmTypeContainsFold applies the ContainsFold predicate on the "alarmType" field.
func AlarmTypeContainsFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAlarmType), v))
	})
}

// ShortDescriptionEQ applies the EQ predicate on the "shortDescription" field.
func ShortDescriptionEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionNEQ applies the NEQ predicate on the "shortDescription" field.
func ShortDescriptionNEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionIn applies the In predicate on the "shortDescription" field.
func ShortDescriptionIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldShortDescription), v...))
	})
}

// ShortDescriptionNotIn applies the NotIn predicate on the "shortDescription" field.
func ShortDescriptionNotIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldShortDescription), v...))
	})
}

// ShortDescriptionGT applies the GT predicate on the "shortDescription" field.
func ShortDescriptionGT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionGTE applies the GTE predicate on the "shortDescription" field.
func ShortDescriptionGTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionLT applies the LT predicate on the "shortDescription" field.
func ShortDescriptionLT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionLTE applies the LTE predicate on the "shortDescription" field.
func ShortDescriptionLTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionContains applies the Contains predicate on the "shortDescription" field.
func ShortDescriptionContains(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionHasPrefix applies the HasPrefix predicate on the "shortDescription" field.
func ShortDescriptionHasPrefix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionHasSuffix applies the HasSuffix predicate on the "shortDescription" field.
func ShortDescriptionHasSuffix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionEqualFold applies the EqualFold predicate on the "shortDescription" field.
func ShortDescriptionEqualFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldShortDescription), v))
	})
}

// ShortDescriptionContainsFold applies the ContainsFold predicate on the "shortDescription" field.
func ShortDescriptionContainsFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldShortDescription), v))
	})
}

// LongDescriptionEQ applies the EQ predicate on the "longDescription" field.
func LongDescriptionEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionNEQ applies the NEQ predicate on the "longDescription" field.
func LongDescriptionNEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionIn applies the In predicate on the "longDescription" field.
func LongDescriptionIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLongDescription), v...))
	})
}

// LongDescriptionNotIn applies the NotIn predicate on the "longDescription" field.
func LongDescriptionNotIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLongDescription), v...))
	})
}

// LongDescriptionGT applies the GT predicate on the "longDescription" field.
func LongDescriptionGT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionGTE applies the GTE predicate on the "longDescription" field.
func LongDescriptionGTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionLT applies the LT predicate on the "longDescription" field.
func LongDescriptionLT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionLTE applies the LTE predicate on the "longDescription" field.
func LongDescriptionLTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionContains applies the Contains predicate on the "longDescription" field.
func LongDescriptionContains(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionHasPrefix applies the HasPrefix predicate on the "longDescription" field.
func LongDescriptionHasPrefix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionHasSuffix applies the HasSuffix predicate on the "longDescription" field.
func LongDescriptionHasSuffix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionEqualFold applies the EqualFold predicate on the "longDescription" field.
func LongDescriptionEqualFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLongDescription), v))
	})
}

// LongDescriptionContainsFold applies the ContainsFold predicate on the "longDescription" field.
func LongDescriptionContainsFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLongDescription), v))
	})
}

// CommandEQ applies the EQ predicate on the "command" field.
func CommandEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCommand), v))
	})
}

// CommandNEQ applies the NEQ predicate on the "command" field.
func CommandNEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCommand), v))
	})
}

// CommandIn applies the In predicate on the "command" field.
func CommandIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCommand), v...))
	})
}

// CommandNotIn applies the NotIn predicate on the "command" field.
func CommandNotIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCommand), v...))
	})
}

// CommandGT applies the GT predicate on the "command" field.
func CommandGT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCommand), v))
	})
}

// CommandGTE applies the GTE predicate on the "command" field.
func CommandGTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCommand), v))
	})
}

// CommandLT applies the LT predicate on the "command" field.
func CommandLT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCommand), v))
	})
}

// CommandLTE applies the LTE predicate on the "command" field.
func CommandLTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCommand), v))
	})
}

// CommandContains applies the Contains predicate on the "command" field.
func CommandContains(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCommand), v))
	})
}

// CommandHasPrefix applies the HasPrefix predicate on the "command" field.
func CommandHasPrefix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCommand), v))
	})
}

// CommandHasSuffix applies the HasSuffix predicate on the "command" field.
func CommandHasSuffix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCommand), v))
	})
}

// CommandIsNil applies the IsNil predicate on the "command" field.
func CommandIsNil() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCommand)))
	})
}

// CommandNotNil applies the NotNil predicate on the "command" field.
func CommandNotNil() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCommand)))
	})
}

// CommandEqualFold applies the EqualFold predicate on the "command" field.
func CommandEqualFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCommand), v))
	})
}

// CommandContainsFold applies the ContainsFold predicate on the "command" field.
func CommandContainsFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCommand), v))
	})
}

// PriorityEQ applies the EQ predicate on the "priority" field.
func PriorityEQ(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPriority), v))
	})
}

// PriorityNEQ applies the NEQ predicate on the "priority" field.
func PriorityNEQ(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPriority), v))
	})
}

// PriorityIn applies the In predicate on the "priority" field.
func PriorityIn(vs ...int) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPriority), v...))
	})
}

// PriorityNotIn applies the NotIn predicate on the "priority" field.
func PriorityNotIn(vs ...int) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPriority), v...))
	})
}

// PriorityGT applies the GT predicate on the "priority" field.
func PriorityGT(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPriority), v))
	})
}

// PriorityGTE applies the GTE predicate on the "priority" field.
func PriorityGTE(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPriority), v))
	})
}

// PriorityLT applies the LT predicate on the "priority" field.
func PriorityLT(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPriority), v))
	})
}

// PriorityLTE applies the LTE predicate on the "priority" field.
func PriorityLTE(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPriority), v))
	})
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v bool) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v bool) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// UsedEQ applies the EQ predicate on the "used" field.
func UsedEQ(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUsed), v))
	})
}

// UsedNEQ applies the NEQ predicate on the "used" field.
func UsedNEQ(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUsed), v))
	})
}

// UsedIn applies the In predicate on the "used" field.
func UsedIn(vs ...int) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUsed), v...))
	})
}

// UsedNotIn applies the NotIn predicate on the "used" field.
func UsedNotIn(vs ...int) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUsed), v...))
	})
}

// UsedGT applies the GT predicate on the "used" field.
func UsedGT(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUsed), v))
	})
}

// UsedGTE applies the GTE predicate on the "used" field.
func UsedGTE(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUsed), v))
	})
}

// UsedLT applies the LT predicate on the "used" field.
func UsedLT(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUsed), v))
	})
}

// UsedLTE applies the LTE predicate on the "used" field.
func UsedLTE(v int) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUsed), v))
	})
}

// UsedIsNil applies the IsNil predicate on the "used" field.
func UsedIsNil() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUsed)))
	})
}

// UsedNotNil applies the NotNil predicate on the "used" field.
func UsedNotNil() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUsed)))
	})
}

// RunbookEQ applies the EQ predicate on the "runbook" field.
func RunbookEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRunbook), v))
	})
}

// RunbookNEQ applies the NEQ predicate on the "runbook" field.
func RunbookNEQ(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRunbook), v))
	})
}

// RunbookIn applies the In predicate on the "runbook" field.
func RunbookIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRunbook), v...))
	})
}

// RunbookNotIn applies the NotIn predicate on the "runbook" field.
func RunbookNotIn(vs ...string) predicate.Recommendations {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Recommendations(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRunbook), v...))
	})
}

// RunbookGT applies the GT predicate on the "runbook" field.
func RunbookGT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRunbook), v))
	})
}

// RunbookGTE applies the GTE predicate on the "runbook" field.
func RunbookGTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRunbook), v))
	})
}

// RunbookLT applies the LT predicate on the "runbook" field.
func RunbookLT(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRunbook), v))
	})
}

// RunbookLTE applies the LTE predicate on the "runbook" field.
func RunbookLTE(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRunbook), v))
	})
}

// RunbookContains applies the Contains predicate on the "runbook" field.
func RunbookContains(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRunbook), v))
	})
}

// RunbookHasPrefix applies the HasPrefix predicate on the "runbook" field.
func RunbookHasPrefix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRunbook), v))
	})
}

// RunbookHasSuffix applies the HasSuffix predicate on the "runbook" field.
func RunbookHasSuffix(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRunbook), v))
	})
}

// RunbookIsNil applies the IsNil predicate on the "runbook" field.
func RunbookIsNil() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRunbook)))
	})
}

// RunbookNotNil applies the NotNil predicate on the "runbook" field.
func RunbookNotNil() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRunbook)))
	})
}

// RunbookEqualFold applies the EqualFold predicate on the "runbook" field.
func RunbookEqualFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRunbook), v))
	})
}

// RunbookContainsFold applies the ContainsFold predicate on the "runbook" field.
func RunbookContainsFold(v string) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRunbook), v))
	})
}

// HasRecomendationSources applies the HasEdge predicate on the "recomendation_sources" edge.
func HasRecomendationSources() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RecomendationSourcesTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, RecomendationSourcesTable, RecomendationSourcesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasRecomendationSourcesWith applies the HasEdge predicate on the "recomendation_sources" edge with a given conditions (other predicates).
func HasRecomendationSourcesWith(preds ...predicate.RecommendationsSources) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RecomendationSourcesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, RecomendationSourcesTable, RecomendationSourcesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasRecomendationCategory applies the HasEdge predicate on the "recomendation_category" edge.
func HasRecomendationCategory() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RecomendationCategoryTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, RecomendationCategoryTable, RecomendationCategoryColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasRecomendationCategoryWith applies the HasEdge predicate on the "recomendation_category" edge with a given conditions (other predicates).
func HasRecomendationCategoryWith(preds ...predicate.RecommendationsCategory) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RecomendationCategoryInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, RecomendationCategoryTable, RecomendationCategoryColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUserCreate applies the HasEdge predicate on the "UserCreate" edge.
func HasUserCreate() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserCreateTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, UserCreateTable, UserCreateColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserCreateWith applies the HasEdge predicate on the "UserCreate" edge with a given conditions (other predicates).
func HasUserCreateWith(preds ...predicate.User) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserCreateInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, UserCreateTable, UserCreateColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUserApprobed applies the HasEdge predicate on the "UserApprobed" edge.
func HasUserApprobed() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserApprobedTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, UserApprobedTable, UserApprobedColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserApprobedWith applies the HasEdge predicate on the "UserApprobed" edge with a given conditions (other predicates).
func HasUserApprobedWith(preds ...predicate.User) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserApprobedInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, UserApprobedTable, UserApprobedColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasVendorsRecomendations applies the HasEdge predicate on the "vendors_recomendations" edge.
func HasVendorsRecomendations() predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(VendorsRecomendationsTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, VendorsRecomendationsTable, VendorsRecomendationsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasVendorsRecomendationsWith applies the HasEdge predicate on the "vendors_recomendations" edge with a given conditions (other predicates).
func HasVendorsRecomendationsWith(preds ...predicate.Vendor) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(VendorsRecomendationsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, VendorsRecomendationsTable, VendorsRecomendationsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...predicate.Recommendations) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...predicate.Recommendations) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Recommendations) predicate.Recommendations {
	return predicate.Recommendations(func(s *sql.Selector) {
		p(s.Not())
	})
}
