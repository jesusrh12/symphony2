// Copyright (c) 2004-present Facebook All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
	"github.com/facebook/ent/schema/field"
	"github.com/facebookincubator/symphony/pkg/ent/block"
	"github.com/facebookincubator/symphony/pkg/ent/entrypoint"
	"github.com/facebookincubator/symphony/pkg/ent/exitpoint"
	"github.com/facebookincubator/symphony/pkg/ent/predicate"
	"github.com/facebookincubator/symphony/pkg/flowengine/flowschema"
)

// EntryPointUpdate is the builder for updating EntryPoint entities.
type EntryPointUpdate struct {
	config
	hooks    []Hook
	mutation *EntryPointMutation
}

// Where adds a new predicate for the builder.
func (epu *EntryPointUpdate) Where(ps ...predicate.EntryPoint) *EntryPointUpdate {
	epu.mutation.predicates = append(epu.mutation.predicates, ps...)
	return epu
}

// SetRole sets the role field.
func (epu *EntryPointUpdate) SetRole(fpr flowschema.EntryPointRole) *EntryPointUpdate {
	epu.mutation.SetRole(fpr)
	return epu
}

// SetCid sets the cid field.
func (epu *EntryPointUpdate) SetCid(s string) *EntryPointUpdate {
	epu.mutation.SetCid(s)
	return epu
}

// SetNillableCid sets the cid field if the given value is not nil.
func (epu *EntryPointUpdate) SetNillableCid(s *string) *EntryPointUpdate {
	if s != nil {
		epu.SetCid(*s)
	}
	return epu
}

// ClearCid clears the value of cid.
func (epu *EntryPointUpdate) ClearCid() *EntryPointUpdate {
	epu.mutation.ClearCid()
	return epu
}

// AddPrevExitPointIDs adds the prev_exit_points edge to ExitPoint by ids.
func (epu *EntryPointUpdate) AddPrevExitPointIDs(ids ...int) *EntryPointUpdate {
	epu.mutation.AddPrevExitPointIDs(ids...)
	return epu
}

// AddPrevExitPoints adds the prev_exit_points edges to ExitPoint.
func (epu *EntryPointUpdate) AddPrevExitPoints(e ...*ExitPoint) *EntryPointUpdate {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epu.AddPrevExitPointIDs(ids...)
}

// SetParentBlockID sets the parent_block edge to Block by id.
func (epu *EntryPointUpdate) SetParentBlockID(id int) *EntryPointUpdate {
	epu.mutation.SetParentBlockID(id)
	return epu
}

// SetParentBlock sets the parent_block edge to Block.
func (epu *EntryPointUpdate) SetParentBlock(b *Block) *EntryPointUpdate {
	return epu.SetParentBlockID(b.ID)
}

// Mutation returns the EntryPointMutation object of the builder.
func (epu *EntryPointUpdate) Mutation() *EntryPointMutation {
	return epu.mutation
}

// ClearPrevExitPoints clears all "prev_exit_points" edges to type ExitPoint.
func (epu *EntryPointUpdate) ClearPrevExitPoints() *EntryPointUpdate {
	epu.mutation.ClearPrevExitPoints()
	return epu
}

// RemovePrevExitPointIDs removes the prev_exit_points edge to ExitPoint by ids.
func (epu *EntryPointUpdate) RemovePrevExitPointIDs(ids ...int) *EntryPointUpdate {
	epu.mutation.RemovePrevExitPointIDs(ids...)
	return epu
}

// RemovePrevExitPoints removes prev_exit_points edges to ExitPoint.
func (epu *EntryPointUpdate) RemovePrevExitPoints(e ...*ExitPoint) *EntryPointUpdate {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epu.RemovePrevExitPointIDs(ids...)
}

// ClearParentBlock clears the "parent_block" edge to type Block.
func (epu *EntryPointUpdate) ClearParentBlock() *EntryPointUpdate {
	epu.mutation.ClearParentBlock()
	return epu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (epu *EntryPointUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	epu.defaults()
	if len(epu.hooks) == 0 {
		if err = epu.check(); err != nil {
			return 0, err
		}
		affected, err = epu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*EntryPointMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = epu.check(); err != nil {
				return 0, err
			}
			epu.mutation = mutation
			affected, err = epu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(epu.hooks) - 1; i >= 0; i-- {
			mut = epu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, epu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (epu *EntryPointUpdate) SaveX(ctx context.Context) int {
	affected, err := epu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (epu *EntryPointUpdate) Exec(ctx context.Context) error {
	_, err := epu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (epu *EntryPointUpdate) ExecX(ctx context.Context) {
	if err := epu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (epu *EntryPointUpdate) defaults() {
	if _, ok := epu.mutation.UpdateTime(); !ok {
		v := entrypoint.UpdateDefaultUpdateTime()
		epu.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (epu *EntryPointUpdate) check() error {
	if v, ok := epu.mutation.Role(); ok {
		if err := entrypoint.RoleValidator(v); err != nil {
			return &ValidationError{Name: "role", err: fmt.Errorf("ent: validator failed for field \"role\": %w", err)}
		}
	}
	if _, ok := epu.mutation.ParentBlockID(); epu.mutation.ParentBlockCleared() && !ok {
		return errors.New("ent: clearing a required unique edge \"parent_block\"")
	}
	return nil
}

func (epu *EntryPointUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   entrypoint.Table,
			Columns: entrypoint.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: entrypoint.FieldID,
			},
		},
	}
	if ps := epu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := epu.mutation.UpdateTime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: entrypoint.FieldUpdateTime,
		})
	}
	if value, ok := epu.mutation.Role(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: entrypoint.FieldRole,
		})
	}
	if value, ok := epu.mutation.Cid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: entrypoint.FieldCid,
		})
	}
	if epu.mutation.CidCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: entrypoint.FieldCid,
		})
	}
	if epu.mutation.PrevExitPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   entrypoint.PrevExitPointsTable,
			Columns: entrypoint.PrevExitPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: exitpoint.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epu.mutation.RemovedPrevExitPointsIDs(); len(nodes) > 0 && !epu.mutation.PrevExitPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   entrypoint.PrevExitPointsTable,
			Columns: entrypoint.PrevExitPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: exitpoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epu.mutation.PrevExitPointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   entrypoint.PrevExitPointsTable,
			Columns: entrypoint.PrevExitPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: exitpoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if epu.mutation.ParentBlockCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   entrypoint.ParentBlockTable,
			Columns: []string{entrypoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epu.mutation.ParentBlockIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   entrypoint.ParentBlockTable,
			Columns: []string{entrypoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, epu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{entrypoint.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// EntryPointUpdateOne is the builder for updating a single EntryPoint entity.
type EntryPointUpdateOne struct {
	config
	hooks    []Hook
	mutation *EntryPointMutation
}

// SetRole sets the role field.
func (epuo *EntryPointUpdateOne) SetRole(fpr flowschema.EntryPointRole) *EntryPointUpdateOne {
	epuo.mutation.SetRole(fpr)
	return epuo
}

// SetCid sets the cid field.
func (epuo *EntryPointUpdateOne) SetCid(s string) *EntryPointUpdateOne {
	epuo.mutation.SetCid(s)
	return epuo
}

// SetNillableCid sets the cid field if the given value is not nil.
func (epuo *EntryPointUpdateOne) SetNillableCid(s *string) *EntryPointUpdateOne {
	if s != nil {
		epuo.SetCid(*s)
	}
	return epuo
}

// ClearCid clears the value of cid.
func (epuo *EntryPointUpdateOne) ClearCid() *EntryPointUpdateOne {
	epuo.mutation.ClearCid()
	return epuo
}

// AddPrevExitPointIDs adds the prev_exit_points edge to ExitPoint by ids.
func (epuo *EntryPointUpdateOne) AddPrevExitPointIDs(ids ...int) *EntryPointUpdateOne {
	epuo.mutation.AddPrevExitPointIDs(ids...)
	return epuo
}

// AddPrevExitPoints adds the prev_exit_points edges to ExitPoint.
func (epuo *EntryPointUpdateOne) AddPrevExitPoints(e ...*ExitPoint) *EntryPointUpdateOne {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epuo.AddPrevExitPointIDs(ids...)
}

// SetParentBlockID sets the parent_block edge to Block by id.
func (epuo *EntryPointUpdateOne) SetParentBlockID(id int) *EntryPointUpdateOne {
	epuo.mutation.SetParentBlockID(id)
	return epuo
}

// SetParentBlock sets the parent_block edge to Block.
func (epuo *EntryPointUpdateOne) SetParentBlock(b *Block) *EntryPointUpdateOne {
	return epuo.SetParentBlockID(b.ID)
}

// Mutation returns the EntryPointMutation object of the builder.
func (epuo *EntryPointUpdateOne) Mutation() *EntryPointMutation {
	return epuo.mutation
}

// ClearPrevExitPoints clears all "prev_exit_points" edges to type ExitPoint.
func (epuo *EntryPointUpdateOne) ClearPrevExitPoints() *EntryPointUpdateOne {
	epuo.mutation.ClearPrevExitPoints()
	return epuo
}

// RemovePrevExitPointIDs removes the prev_exit_points edge to ExitPoint by ids.
func (epuo *EntryPointUpdateOne) RemovePrevExitPointIDs(ids ...int) *EntryPointUpdateOne {
	epuo.mutation.RemovePrevExitPointIDs(ids...)
	return epuo
}

// RemovePrevExitPoints removes prev_exit_points edges to ExitPoint.
func (epuo *EntryPointUpdateOne) RemovePrevExitPoints(e ...*ExitPoint) *EntryPointUpdateOne {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return epuo.RemovePrevExitPointIDs(ids...)
}

// ClearParentBlock clears the "parent_block" edge to type Block.
func (epuo *EntryPointUpdateOne) ClearParentBlock() *EntryPointUpdateOne {
	epuo.mutation.ClearParentBlock()
	return epuo
}

// Save executes the query and returns the updated entity.
func (epuo *EntryPointUpdateOne) Save(ctx context.Context) (*EntryPoint, error) {
	var (
		err  error
		node *EntryPoint
	)
	epuo.defaults()
	if len(epuo.hooks) == 0 {
		if err = epuo.check(); err != nil {
			return nil, err
		}
		node, err = epuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*EntryPointMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = epuo.check(); err != nil {
				return nil, err
			}
			epuo.mutation = mutation
			node, err = epuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(epuo.hooks) - 1; i >= 0; i-- {
			mut = epuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, epuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (epuo *EntryPointUpdateOne) SaveX(ctx context.Context) *EntryPoint {
	node, err := epuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (epuo *EntryPointUpdateOne) Exec(ctx context.Context) error {
	_, err := epuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (epuo *EntryPointUpdateOne) ExecX(ctx context.Context) {
	if err := epuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (epuo *EntryPointUpdateOne) defaults() {
	if _, ok := epuo.mutation.UpdateTime(); !ok {
		v := entrypoint.UpdateDefaultUpdateTime()
		epuo.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (epuo *EntryPointUpdateOne) check() error {
	if v, ok := epuo.mutation.Role(); ok {
		if err := entrypoint.RoleValidator(v); err != nil {
			return &ValidationError{Name: "role", err: fmt.Errorf("ent: validator failed for field \"role\": %w", err)}
		}
	}
	if _, ok := epuo.mutation.ParentBlockID(); epuo.mutation.ParentBlockCleared() && !ok {
		return errors.New("ent: clearing a required unique edge \"parent_block\"")
	}
	return nil
}

func (epuo *EntryPointUpdateOne) sqlSave(ctx context.Context) (_node *EntryPoint, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   entrypoint.Table,
			Columns: entrypoint.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: entrypoint.FieldID,
			},
		},
	}
	id, ok := epuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing EntryPoint.ID for update")}
	}
	_spec.Node.ID.Value = id
	if value, ok := epuo.mutation.UpdateTime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: entrypoint.FieldUpdateTime,
		})
	}
	if value, ok := epuo.mutation.Role(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: entrypoint.FieldRole,
		})
	}
	if value, ok := epuo.mutation.Cid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: entrypoint.FieldCid,
		})
	}
	if epuo.mutation.CidCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: entrypoint.FieldCid,
		})
	}
	if epuo.mutation.PrevExitPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   entrypoint.PrevExitPointsTable,
			Columns: entrypoint.PrevExitPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: exitpoint.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epuo.mutation.RemovedPrevExitPointsIDs(); len(nodes) > 0 && !epuo.mutation.PrevExitPointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   entrypoint.PrevExitPointsTable,
			Columns: entrypoint.PrevExitPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: exitpoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epuo.mutation.PrevExitPointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   entrypoint.PrevExitPointsTable,
			Columns: entrypoint.PrevExitPointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: exitpoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if epuo.mutation.ParentBlockCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   entrypoint.ParentBlockTable,
			Columns: []string{entrypoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := epuo.mutation.ParentBlockIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   entrypoint.ParentBlockTable,
			Columns: []string{entrypoint.ParentBlockColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: block.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &EntryPoint{config: epuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues()
	if err = sqlgraph.UpdateNode(ctx, epuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{entrypoint.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
